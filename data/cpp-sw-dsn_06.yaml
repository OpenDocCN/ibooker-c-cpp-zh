- en: Chapter 6\. The Adapter, Observer, and CRTP Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。适配器、观察者和 CRTP 设计模式
- en: 'In this chapter, we turn our attention to three must-know design patterns:
    the two GoF design patterns, Adapter and *Observer*, and the *Curiously Recurring
    Template Pattern (CRTP)* design pattern.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关注三种必须了解的设计模式：两种 GoF 设计模式，适配器和*观察者*，以及*奇异递归模板模式（CRTP）*设计模式。
- en: 'In [“Guideline 24: Use Adapters to Standardize Interfaces”](#use_adapters_to_standardize_interfaces),
    we talk about making incompatible things fit together by adapting interfaces.
    To achieve this, I will show you the Adapter design pattern and its application
    in both inheritance hierarchies and generic programming. You will also get an
    overview of different kinds of Adapters, including object, class, and function
    Adapters.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“指南 24：使用适配器标准化接口”](#use_adapters_to_standardize_interfaces) 中，我们讨论通过适配器将不兼容的事物整合在一起的方法。为了实现这一点，我将向您展示适配器设计模式及其在继承层次结构和泛型编程中的应用。您还将获得各种适配器的概述，包括对象适配器、类适配器和函数适配器。
- en: 'In [“Guideline 25: Apply Observers as an Abstract Notification Mechanism”](#apply_observers_as_an_abstract_notification_mechanism),
    we will deal with how to observe state change and how to get notified about it.
    In this context, I will introduce you to the Observer design pattern, one of the
    most famous and most commonly used design patterns. We will talk about the classic,
    GoF-style Observer, and also how to implement the Observer in modern C++.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“指南 25：将观察者应用作抽象通知机制”](#apply_observers_as_an_abstract_notification_mechanism)
    中，我们将讨论如何观察状态变化以及如何收到通知。在这个背景下，我将向您介绍观察者设计模式，这是最著名和最常用的设计模式之一。我们将讨论经典的 GoF 风格的观察者，以及如何在现代
    C++ 中实现观察者模式。
- en: 'In [“Guideline 26: Use CRTP to Introduce Static Type Categories”](#use_crtp_to_introduce_static_type_categories),
    we will turn our attention to the CRTP. I will show you how to use CRTP to define
    a compile-time relationship between a family of related types and how to properly
    implement a CRTP base class.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“指南 26：使用 CRTP 引入静态类型类别”](#use_crtp_to_introduce_static_type_categories)
    中，我们将转向 CRTP。我将向您展示如何使用 CRTP 定义一组相关类型之间的编译时关系，以及如何正确实现 CRTP 基类。
- en: 'In [“Guideline 27: Use CRTP for Static Mixin Classes”](#use_crtp_for_static_mixin_classes),
    I will continue the CRTP story by showing you how CRTP can be used to create compile-time
    mixin classes. We will also see the difference between semantic inheritance, where
    it is used to create an abstraction, and technical inheritance, where it is used
    as an implementation detail for technical elegance and convenience only.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“指南 27：使用 CRTP 创建静态混合类”](#use_crtp_for_static_mixin_classes) 中，我将继续讲解 CRTP，向您展示如何使用
    CRTP 创建编译时混合类。我们还将看到语义继承与技术继承的区别，语义继承用于创建抽象，而技术继承仅用于技术上的优雅和便利性的实现细节。
- en: 'Guideline 24: Use Adapters to Standardize Interfaces'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南 24：使用适配器标准化接口
- en: 'Let’s assume that you have implemented the `Document` example from [“Guideline
    3: Separate Interfaces to Avoid Artificial Coupling”](ch01.xhtml#separate_interfaces_to_avoid_artificial_coupling),
    and that, because you properly adhere to the Interface Segregation Principle (ISP),
    you’re reasonably happy with the way it works:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经根据 [“指南 3：分离接口以避免人为耦合”](ch01.xhtml#separate_interfaces_to_avoid_artificial_coupling)
    实现了 `Document` 示例，并且因为您正确遵循了接口隔离原则（ISP），您对其工作方式感到满意：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, one day you’re required to introduce the Pages document format.^([1](ch06.xhtml#idm45043101334880))
    Of course, it is similar to the Word document that you already have in place,
    but unfortunately, you’re not familiar with the details of the Pages format. To
    make things worse, you don’t have a lot of time to get familiar with the format,
    because you have way too many other things to do. Luckily, you know about a quite
    reasonable, open source implementation for that format: the `OpenPages` class:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一天，您需要介绍 Pages 文档格式。^([1](ch06.xhtml#idm45043101334880)) 当然，它类似于您已经使用的 Word
    文档，但不幸的是，您并不熟悉 Pages 格式的细节。更糟糕的是，您没有太多时间去熟悉这种格式，因为您有太多其他事情要做。幸运的是，您了解到有一个相当合理的开源实现：`OpenPages`
    类：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On the bright side, this class provides about everything you need for your
    purposes: a `convertToBytes()` member function to serialize the content of the
    document, and the free `exportToJSONFormat()` function to convert the Pages document
    into the JSON format. Unfortunately, it does not fit your interface expectations:
    instead of the `convertToBytes()` member function, you expect a `serialize()`
    member function. And instead of the free `exportToJSONFormat()` function, you
    expect the `exportToJSON()` member function. Ultimately, of course, the third-party
    class does not inherit from your `Document` base class, which means that you can’t
    easily incorporate the class into your existing hierarchy. However, there is a
    solution to this problem: a seamless integration using the Adapter design pattern.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 光明面是，这个类提供了您所需的几乎所有内容：一个 `convertToBytes()` 成员函数来序列化文档的内容，以及一个免费的 `exportToJSONFormat()`
    函数来将 Pages 文档转换为 JSON 格式。不幸的是，它不符合您的接口期望：您期望一个 `serialize()` 成员函数而不是 `convertToBytes()`
    成员函数。而且您期望一个 `exportToJSON()` 成员函数而不是免费的 `exportToJSONFormat()` 函数。当然，最终，第三方类没有从您的
    `Document` 基类继承，这意味着您无法轻松地将该类整合到您现有的层次结构中。然而，这个问题是有解决方案的：使用适配器设计模式进行无缝集成。
- en: The Adapter Design Pattern Explained
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释适配器设计模式
- en: The Adapter design pattern is another one of the classic GoF design patterns.
    It’s focused on standardizing interfaces and helping nonintrusively add functionality
    into an existing inheritance hierarchy.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式是另一个经典 GoF 设计模式之一。它专注于标准化接口，帮助在现有的继承层次结构中非侵入地添加功能。
- en: The Adapter Design Pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: 'Intent: “Convert the interface of a class into another interface clients expect.
    Adapter lets classes work together that couldn’t otherwise because of incompatible
    interfaces.”^([2](ch06.xhtml#idm45043101092960))'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 意图：“将一个类的接口转换成客户期望的另一个接口。适配器模式使得因接口不兼容而不能在一起工作的类能够在一起工作。”^([2](ch06.xhtml#idm45043101092960))
- en: '[Figure 6-1](#fig_adapter_document) shows the UML diagram for your Adapter
    scenario: you already have the `Document` base class in place (we ignore the `JSONExportable`
    and `Serializable` interfaces for a second) and have already implemented a couple
    of different kinds of documents (for instance, with the `Word` class). The new
    addition to this hierarchy is the `Pages` class.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](#fig_adapter_document) 展示了适配器场景的 UML 图：您已经准备好了 `Document` 基类（我们暂时忽略
    `JSONExportable` 和 `Serializable` 接口），并且已经实现了几种不同类型的文档（例如使用 `Word` 类）。这个层次结构的新添加是
    `Pages` 类。'
- en: '![cpsd 0601](assets/cpsd_0601.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![cpsd 0601](assets/cpsd_0601.png)'
- en: Figure 6-1\. The UML representation of the Adapter design pattern
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 适配器设计模式的 UML 表示
- en: 'The `Pages` class acts as a wrapper to the third-party `OpenPages` class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages` 类作为第三方 `OpenPages` 类的包装器：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Pages` implements the `Document` interface by forwarding the calls to the
    corresponding `OpenPages` functions: a call to `exportToJSON()` is forwarded to
    the free `exportToJSONFormat()` function ([![1](assets/1.png)](#code_g24_1)),
    and the call to `serialize()` is forwarded to the `convertToBytes()` member function
    ([![2](assets/2.png)](#code_g24_2)).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages` 通过将调用转发到相应的 `OpenPages` 函数来实现 `Document` 接口：调用 `exportToJSON()` 被转发到自由的
    `exportToJSONFormat()` 函数（[![1](assets/1.png)](#code_g24_1)），而调用 `serialize()`
    被转发到 `convertToBytes()` 成员函数（[![2](assets/2.png)](#code_g24_2)）。'
- en: 'With the `Pages` class, you can easily integrate the third-party implementation
    into your existing hierarchy. *Very* easily indeed: you can integrate it without
    having to modify it in any way. This nonintrusive nature of the Adapter design
    pattern is what you should consider one of the greatest strengths of the Adapter
    design pattern: anyone can add an Adapter to adapt an interface to another, existing
    interface.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Pages` 类，您可以轻松地将第三方实现集成到您现有的层次结构中。非常容易：您可以在不修改任何内容的情况下进行集成。适配器设计模式的这种非侵入性本质是您应该考虑的适配器设计模式的最大优势之一：任何人都可以添加一个适配器来将一个接口适配到另一个现有的接口。
- en: 'In this context, the `Pages` class serves as an abstraction from the actual
    implementation details in the `OpenPages` class. Therefore, the Adapter design
    pattern separates the concerns of the interface from the implementation details.
    This nicely fulfills the Single-Responsibility Principle (SRP) and blends well
    with the intention of the Open-Closed Principle (OCP) (see [“Guideline 2: Design
    for Change”](ch01.xhtml#design_for_change) and [“Guideline 5: Design for Extension”](ch01.xhtml#design_for_extension)).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情境下，`Pages` 类作为 `OpenPages` 类中实际实现细节的一个抽象。因此，适配器设计模式将接口的关注点与实现细节分离开来。这样做很好地满足了单一责任原则（SRP），并且与开闭原则（OCP）的意图融合得很好（参见[“指南2：设计以便改变”](ch01.xhtml#design_for_change)
    和 [“指南5：设计以便扩展”](ch01.xhtml#design_for_extension)）。
- en: In a way, the `Pages` Adapter works as an indirection and maps from one set
    of functions to another one. Note that it is not strictly necessary to map from
    one function to exactly one other function. On the contrary, you have complete
    flexibility on how to map the expected set of functions onto the available set
    of functions. Thus, Adapter does not necessarily represent a 1-to-1 relationship,
    but can also support a 1-to-*N* relationship.^([3](ch06.xhtml#idm45043100929584))
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种角度来说，`Pages` 适配器作为一种间接方式工作，并将一组函数映射到另一组函数。请注意，并不严格要求将一个函数映射到确切的另一个函数。相反，你完全可以灵活地将预期的函数集映射到可用的函数集上。因此，适配器不一定代表一对一的关系，而是可以支持一对多的关系。^([3](ch06.xhtml#idm45043100929584))
- en: Object Adapters Versus Class Adapters
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象适配器与类适配器的比较。
- en: The `Pages` class is an example of a so-called *object adapter*. This term refers
    to the fact that you store an instance of the wrapped type. Alternatively, given
    that the wrapped type is part of an inheritance hierarchy, you could store a pointer
    to the base class of this hierarchy. This would allow you to use the object adapter
    for all types that are part of the hierarchy, giving the object adapter a considerable
    boost in flexibility.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages` 类是所谓的*对象适配器*的一个例子。这个术语指的是你存储包装类型的一个实例。或者，考虑到包装类型是继承层次结构的一部分，你可以存储该层次结构的基类指针。这将允许你对层次结构中的所有类型使用对象适配器，从而显著提升对象适配器的灵活性。'
- en: 'In contrast, there is also the option to implement a so-called *class adapter*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，还有实现所谓的*类适配器*的选项：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of storing an instance of the adapted type, you would inherit from
    it (if possible, nonpublicly) and implement the expected interface accordingly
    ([![3](assets/3.png)](#code_g24_3)). However, as discussed in [“Guideline 20:
    Favor Composition over Inheritance”](ch05.xhtml#favor_composition_over_inheritance),
    it is preferable to build on composition. In general, object adapters prove to
    be much more flexible than class adapters and thus should be your favorite. There
    are only a few reasons why you would prefer a class adapter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是存储适配类型的实例，你可以继承它（如果可能的话，非公开地）并相应地实现预期的接口（[![3](assets/3.png)](#code_g24_3)）。然而，正如在[“指南20：更喜欢组合而非继承”](ch05.xhtml#favor_composition_over_inheritance)中讨论的那样，最好建立在组合之上。一般来说，对象适配器比类适配器更为灵活，因此应该是你的首选。只有少数情况下，你会更倾向于选择类适配器：
- en: If you have to override a virtual function.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你必须覆盖一个虚函数。
- en: If you need access to a `protected` member function.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要访问一个`protected`成员函数。
- en: If you require the adapted type to be constructed *before* another base class.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你要求适配类型在另一个基类之前构造。
- en: If you need to share a common virtual base class or override the construction
    of a virtual base class.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要共享一个共同的虚基类或者覆盖虚基类的构造。
- en: If you can draw *significant* advantage from the [*Empty Base Optimization (EBO)*](https://oreil.ly/7wLyW).^([4](ch06.xhtml#idm45043100781216))
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以从[*空基类优化 (EBO)*](https://oreil.ly/7wLyW)中获得显著优势。^([4](ch06.xhtml#idm45043100781216))
- en: Otherwise, and this applies to most cases, you should prefer an object adapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对大多数情况而言，你应该优先选择对象适配器。
- en: '“I like this design pattern—it’s powerful. However, I just remembered that
    you recommended using the name of the design pattern in the code to communicate
    intent. Shouldn’t the class be called `PagesAdapter`?” You make an excellent point.
    And I’m happy that you remember [“Guideline 14: Use a Design Pattern’s Name to
    Communicate Intent”](ch03.xhtml#use_a_design_patterns_name_to_communicate_intent),
    in which I indeed argued that the name of the pattern helps to understand the
    code. I admit that in this case, I’m open to both naming conventions. While I
    do see the advantages of the name `PagesAdapter`, as this immediately communicates
    that you built on the Adapter design pattern, I don’t consider it a necessity
    to communicate the fact that this class represents an adapter. To me, the Adapter
    feels like an implementation detail in this situation: I do not need to know that
    the `Pages` class doesn’t implement all the details itself, but uses the `OpenPages`
    class for that. That’s why I said to “consider using the name.” You should decide
    on a case-by-case basis.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '“我喜欢这个设计模式——它很强大。然而，我刚想起你推荐在代码中使用设计模式的名称来传达意图。难道这个类不应该叫做 `PagesAdapter` 吗？”
    你提出了一个很好的观点。我很高兴你记得[“Guideline 14: Use a Design Pattern’s Name to Communicate
    Intent”](ch03.xhtml#use_a_design_patterns_name_to_communicate_intent)，在这里我确实主张设计模式的名称有助于理解代码。我承认在这种情况下，我对两种命名约定都持开放态度。虽然我确实看到了
    `PagesAdapter` 这个名称的优点，因为它立即传达了你基于适配器设计模式的构建，但我不认为在这种情况下传达这个类代表一个适配器是必要的。对我来说，适配器在这种情况下感觉像是一个实现细节：我不需要知道
    `Pages` 类并没有自己实现所有细节，而是使用 `OpenPages` 类来实现。这就是为什么我建议“考虑使用名称”。你应该根据具体情况来决定。'
- en: Examples from the Standard Library
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中的例子
- en: 'One useful application of the Adapter design pattern is to standardize the
    interface of different kinds of containers. Let’s assume the following `Stack`
    base class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式的一个有用应用是标准化不同类型容器的接口。假设有以下 `Stack` 基类：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `Stack` class provides the necessary interface to access the top element
    of the stack ([![4](assets/4.png)](#code_g24_4)), check if the stack is empty
    ([![5](assets/5.png)](#code_g24_5)), query the size of the stack ([![6](assets/6.png)](#code_g24_6)),
    push an element onto the stack ([![7](assets/7.png)](#code_g24_7)), and remove
    the top element of the stack ([![8](assets/8.png)](#code_g24_8)). This base class
    can now be used to implement different Adapters for various data structures, such
    as `std::vector`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Stack` 类提供了访问堆栈顶部元素的必要接口 ([![4](assets/4.png)](#code_g24_4)), 检查堆栈是否为空 ([![5](assets/5.png)](#code_g24_5)),
    查询堆栈大小 ([![6](assets/6.png)](#code_g24_6)), 将元素推入堆栈 ([![7](assets/7.png)](#code_g24_7)),
    以及移除堆栈顶部元素 ([![8](assets/8.png)](#code_g24_8))。现在可以使用这个基类来实现不同的适配器，用于各种数据结构，比如
    `std::vector`：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You worry, “Do you seriously suggest implementing a stack by an abstract base
    class? Aren’t you worried about the performance implications? For every use of
    a member function, you have to pay with a virtual function call!” No, of course
    I don’t suggest that. Obviously, you are correct, and I completely agree with
    you: from a C++ perspective, this kind of container feels strange and very inefficient.
    Because of efficiency, we usually realize the same idea via class templates. This
    is the approach taken by the C++ Standard Library in the form of the three STL
    classes called [Container adaptors](https://oreil.ly/RMYzu): [`std::stack`](https://oreil.ly/y4cr6),
    [`std::queue`](https://oreil.ly/LvVNn), and [`std::priority_queue`](https://oreil.ly/nTBM8):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会担心，“你真的建议通过抽象基类来实现堆栈吗？你不担心性能问题吗？每次使用成员函数都要付出虚函数调用的代价！” 当然，我并不建议这样做。显然，你是正确的，我完全同意你的观点：从
    C++ 的角度来看，这种容器的设计感觉很奇怪，而且效率非常低下。出于效率考虑，我们通常会通过类模板来实现相同的想法。这也是 C++ 标准库采用的方法，例如三个
    STL 类称为[容器适配器](https://oreil.ly/RMYzu)：[`std::stack`](https://oreil.ly/y4cr6),
    [`std::queue`](https://oreil.ly/LvVNn), 和 [`std::priority_queue`](https://oreil.ly/nTBM8)：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These three class templates adapt the interface of a given `Container` type
    to a special purpose. For instance, the purpose of the `std::stack` class template
    is to adapt the interface of a container to the stack operations `top()`, `empty()`,
    `size()`, `push()`, `emplace()`, `pop()`, and `swap()`.^([5](ch06.xhtml#idm45043100261104))
    By default, you’re able to use the three available sequence containers: `std::vector`,
    `std::list`, and `std::deque`. For any other container type, you are able to specialize
    the `std::stack` class template.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类模板将给定的 `Container` 类型的接口适配到特定目的。例如，`std::stack` 类模板的目的是将容器的接口适配到栈操作 `top()`、`empty()`、`size()`、`push()`、`emplace()`、`pop()`
    和 `swap()`。^([5](ch06.xhtml#idm45043100261104)) 默认情况下，您可以使用三种可用的序列容器：`std::vector`、`std::list`
    和 `std::deque`。对于任何其他容器类型，您可以专门化 `std::stack` 类模板。
- en: '“This feels *so* much more familiar,” you say, visibly relieved. Again, I absolutely
    agree. I also consider the Standard Library approach the more suitable solution
    for the purpose of containers. But it’s still interesting to compare the two approaches.
    While there are many technical differences between the `Stack` base class and
    the `std::stack` class template, the purpose and semantics of these two approaches
    are remarkably similar: both provide the ability to adapt any data structure to
    a given stack interface. And both serve as a variation point, allowing you to
    nonintrusively add new Adapters without having to modify existing code.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “这感觉*非常*熟悉”，你说道，显然松了一口气。我完全同意。我认为标准库的方法更适合容器的目的。但是比较这两种方法仍然很有趣。虽然 `Stack` 基类和
    `std::stack` 类模板之间有许多技术上的不同，但这两种方法的目的和语义非常相似：两者都提供了将任何数据结构适配到给定栈接口的能力。而且两者都作为变异点，允许您在不必修改现有代码的情况下非侵入式地添加新的适配器。
- en: Comparison Between Adapter and Strategy
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器与策略的比较
- en: '“The three STL classes seem to fulfill the intent of Adapters, but isn’t this
    the same way of configuring behavior as in the Strategy design pattern? Isn’t
    this similar to `std::unique_ptr` and its deleter?” you ask. And yes, you’re correct.
    From a structural point of view, the Strategy and Adapter design patterns are
    very similar. However, as explained in [“Guideline 11: Understand the Purpose
    of Design Patterns”](ch03.xhtml#understand_the_purpose_of_design_patterns), the
    structure of design patterns may be similar or even the same, but the intent is
    different. In this context, the `Container` parameter specifies not just a single
    aspect of the behavior, but most of the behavior or even all of it. The class
    templates merely act as a wrapper around the functionality of the given type—they
    mainly adapt the interface. So the primary focus of an Adapter is to standardize
    interfaces and integrate incompatible functionality into an existing set of conventions;
    while on the other hand, the primary focus of the Strategy design pattern is to
    enable the configuration of behavior from the outside, building on and providing
    an expected interface. Also, for an Adapter there is no need to reconfigure the
    behavior at any time.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '“STL 的这三个类似乎实现了适配器的意图，但这不是和策略设计模式中配置行为的方式相同吗？这和 `std::unique_ptr` 及其删除器有相似之处？”
    你问道。是的，你说得对。从结构上看，策略模式和适配器设计模式非常相似。然而，正如在 [“指南 11: 理解设计模式的目的”](ch03.xhtml#understand_the_purpose_of_design_patterns)
    中所解释的，设计模式的结构可能相似甚至相同，但其意图是不同的。在这种情况下，`Container` 参数不仅仅指定行为的单个方面，而是大多数甚至全部行为。类模板主要充当给定类型功能的包装器——它们主要是适配接口。因此，适配器的主要焦点是标准化接口并将不兼容的功能集成到现有的约定集中；而另一方面，策略设计模式的主要焦点是允许从外部配置行为，构建并提供预期的接口。此外，适配器不需要在任何时候重新配置行为。'
- en: Function Adapters
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数适配器
- en: Additional examples for the Adapter design pattern are the Standard Library’s
    free functions [`begin()`](https://oreil.ly/ZP74K) and [`end()`](https://oreil.ly/qFeMX).
    “Are you serious?” you ask, surprised. “You claim that free functions serve as
    an example of the Adapter design pattern? Isn’t this a job for classes?” Well,
    not necessarily. The purpose of the free `begin()` and `end()` functions is to
    adapt the iterator interface of any type to the expected STL iterator interface.
    Thus, it maps from an available set of functions to an expected set of functions
    and serves the same purpose as any other Adapter. The major difference is that
    in contrast to object adapters or class adapters, which are based on either inheritance
    (runtime polymorphism) or templates (compile-time polymorphism), `begin()` and
    `end()` draw their power from function overloading, which is the second major
    compile-time polymorphism mechanism in C++. Still, some form of abstraction is
    at play.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式的另一个示例是标准库的自由函数[`begin()`](https://oreil.ly/ZP74K)和[`end()`](https://oreil.ly/qFeMX)。“你是认真的吗？”你问道，感到惊讶。“你说自由函数作为适配器设计模式的一个例子？这不是类的工作吗？”嗯，并非完全如此。自由函数`begin()`和`end()`的目的是将任何类型的迭代器接口适配到预期的STL迭代器接口。因此，它将可用函数集映射到预期函数集，并起到与任何其他适配器相同的作用。其主要区别在于，与基于继承（运行时多态性）或模板（编译时多态性）的对象适配器或类适配器不同，`begin()`和`end()`依靠函数重载获得其能力，这是C++中第二个主要的编译时多态机制。尽管如此，某种形式的抽象仍在发挥作用。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that all kinds of abstractions represent a set of requirements and
    thus have to adhere to the Liskov Substitution Principle (LSP). This is also true
    for overload sets; see [“Guideline 8: Understand the Semantic Requirements of
    Overload Sets”](ch02.xhtml#understand_the_semantic_requirements_of_overload_sets).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有种类的抽象都代表一组要求，因此必须遵守里氏替换原则（LSP）。这对于重载集合也是如此；参见[“指导原则8：理解重载集的语义要求”](ch02.xhtml#understand_the_semantic_requirements_of_overload_sets)。
- en: 'Consider the following function template:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数模板：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `traverseRange()` function, we iterate through all the elements contained
    in the given range with a range-based `for` loop. The traversal happens via iterators
    that the compiler acquires with the free `begin()` and `end()` functions. Hence,
    the preceding `for` loop is equivalent to the following form of `for`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`traverseRange()`函数中，我们通过基于范围的`for`循环遍历给定范围内包含的所有元素。遍历通过编译器使用的自由函数`begin()`和`end()`获取的迭代器进行。因此，前述的`for`循环等同于以下形式的`for`：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Obviously, the range-based `for` loop is much more convenient to use. However,
    underneath the surface, the compiler generates code based on the free `begin()`
    and `end()` functions. Note the two `using` declarations in their beginning: the
    purpose is to enable [*Argument-Dependent Lookup (ADL)*](https://oreil.ly/VKcsl)
    for the given type of range. ADL is the mechanism that makes sure the “correct”
    `begin()` and `end()` functions are called, even if they are overloads that reside
    in a user-specific namespace. This means that you have the opportunity to overload
    `begin()` and `end()` for any type and map the expected interface to a different,
    special-purpose set of functions.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，基于范围的`for`循环更加方便使用。但在表面下，编译器生成基于自由函数`begin()`和`end()`的代码。请注意它们开头的两个`using`声明：其目的是为了为给定范围的类型启用[*Argument-Dependent
    Lookup (ADL)*](https://oreil.ly/VKcsl)。ADL是一种机制，确保调用“正确”的`begin()`和`end()`函数，即使它们是存在于用户特定命名空间中的重载。这意味着您有机会为任何类型重载`begin()`和`end()`，并将预期接口映射到不同的特定函数集。
- en: 'This kind of *function adapter* was called a *shim* by Matthew Wilson in 2004.^([6](ch06.xhtml#idm45043099971744))
    One valuable property of this technique is that it’s completely nonintrusive:
    it is possible to add a free function to any type, even to types that you could
    never adapt, such as types provided by third-party libraries. Hence, any generic
    code written in terms of shims gives you the enormous power to adapt virtually
    any type to the expected interface. Thus, you can imagine that shims or function
    adapters are the backbone of generic programming.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*函数适配器*在2004年被Matthew Wilson称为*shim*^([6](ch06.xhtml#idm45043099971744))。这种技术的一个宝贵特性是它完全不侵入：可以向任何类型添加自由函数，甚至是无法适配的类型，例如第三方库提供的类型。因此，任何以shims或函数适配器为术语编写的通用代码都为您提供了适应几乎任何类型到预期接口的巨大能力。因此，您可以想象shims或函数适配器是通用编程的支柱。
- en: Analyzing the Shortcomings of the Adapter Design Pattern
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析适配器设计模式的缺点
- en: Despite the value of the Adapter design pattern, there is one issue with this
    design pattern that I should explicitly point out. Consider the following example,
    which I adopted from Eric Freeman and Elisabeth Robson:^([7](ch06.xhtml#idm45043099966256))
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管**适配器设计模式**的价值很高，但有一个问题我必须明确指出。考虑以下例子，我从埃里克·弗里曼和伊丽莎白·罗布森那里采用的：^([7](ch06.xhtml#idm45043099966256))
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We start with the abstract `Duck` class, which introduces the two pure virtual
    functions `quack()` and `fly()`. Indeed, this appears to be a pretty expected
    and natural interface for a `Duck` class and of course raises some expectations:
    ducks make a very characteristic sound and can fly pretty well. This interface
    is implemented by many possible kinds of `Duck`, such as the `MallardDuck` class.
    Now, for some reason we also have to deal with turkeys:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从抽象的`Duck`（鸭子）类开始，引入了两个纯虚函数`quack()`和`fly()`。事实上，这看起来是一个非常预期和自然的`Duck`类接口，并且当然会引发一些期望：鸭子发出非常特征性的声音并且能够飞得很好。这个接口被许多可能的`Duck`类实现，比如`MallardDuck`（绿头鸭）类。现在，出于某种原因，我们也不得不处理火鸡：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Turkeys are represented by the abstract `Turkey` class, which of course is
    implemented by many different kinds of specific `Turkey`s, like the `WildTurkey`.
    To make things worse, for some reason ducks and turkeys are expected be used together.^([8](ch06.xhtml#idm45043099762144))
    One possible way to make this work is to pretend that a turkey is a duck. After
    all, a turkey is pretty similar to a duck. Well, OK, it doesn’t quack, but it
    can gobble (the typical turkey sound), and it can also fly (not for a long distance,
    but yes, it can fly). So you could adapt turkeys to ducks with the `TurkeyAdapter`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 火鸡由抽象的`Turkey`类表示，当然，这个类被许多不同种类的具体`Turkey`（火鸡）实现，比如`WildTurkey`（野火鸡）。更糟糕的是，出于某种原因，鸭子和火鸡被期望一起使用。一个可能的解决方案是假装火鸡是鸭子。毕竟，火鸡与鸭子非常相似。好吧，它不会嘎嘎叫，但它可以咯咯叫（典型的火鸡声音），而且它也能飞（虽然飞行距离不远，但确实可以飞）。因此，你可以用`TurkeyAdapter`（火鸡适配器）来适配火鸡到鸭子：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While this is an amusing interpretation of [duck typing](https://oreil.ly/3rGpx),
    this example nicely demonstrates that it’s way too easy to integrate something
    alien into an existing hierarchy. A `Turkey` is simply not a `Duck`, even if we
    want it to be. I would argue that likely both the `quack()` and the `fly()` function
    violate the LSP. Neither functions really does what I would expect it to (at least
    I’m pretty sure that I want a quacking, not gobbling, critter and that I want
    something that can really fly like a duck). Of course, it depends on the specific
    context, but undeniably, the Adapter design pattern makes it very easy to combine
    things that do not belong together. Thus, it’s very important that you consider
    the expected behavior and check for LSP violations when applying this design pattern:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是对[鸭子类型](https://oreil.ly/3rGpx)的一个有趣解释，这个例子很好地展示了将外来事物集成到现有层次结构中的过于简单。一只`Turkey`（火鸡）根本不是`Duck`（鸭子），即使我们希望它是。我认为`quack()`和`fly()`函数可能都违反了LSP。这两个函数都不是我期望的（至少我相当确定我想要的是呱呱叫而不是咯咯叫的生物，以及我想要的是真正像鸭子一样能飞的东西）。当然，这取决于具体的上下文，但不可否认的是，适配器设计模式确实使得将不相容的事物组合在一起变得非常容易。因此，在应用此设计模式时，考虑期望的行为并检查LSP违规非常重要：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In summary, the Adapter design pattern can be considered one of the most valuable
    design patterns for combining different pieces of functionality and making them
    work together. I promise that it will prove to be a valuable tool in your daily
    work. Still, do not abuse the power of Adapter in some heroic effort to combine
    apples and oranges (or even oranges and grapefruits: they are similar but not
    the same). Always be aware of LSP expectations.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，适配器设计模式可以被认为是结合不同功能片段并使它们协同工作的最有价值的设计模式之一。我保证它将在你的日常工作中证明是一个宝贵的工具。但是，请不要滥用适配器的力量，试图将苹果和橙子（甚至橙子和葡萄柚）结合在一起。始终注意LSP的期望。
- en: 'Guideline 25: Apply Observers as an Abstract Notification Mechanism'
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准则 25：将观察者应用为抽象通知机制
- en: 'Chances are good that you’ve heard about observers before. “Oh, yes, of course
    I have—isn’t this what the so-called social media platforms are doing with us?”
    you ask. Well, not exactly what I was going for, but yes, I believe we could call
    these platforms observers. And yes, there is also a pattern to what they do, even
    though it is not a design pattern. But I’m actually thinking about one of the
    most popular GoF design patterns, the Observer design pattern. Even if you are
    not familiar with the idea yet, you very likely have some experience with helpful
    observers from real life. For instance, you may have noticed that in some messenger
    apps the sender of a text message is immediately informed once you’ve read a new
    text message. That means that the message is displayed as “read” instead of just
    “delivered.” This little service is essentially the work of a real-life Observer:
    as soon as the status of the new message changes, the sender is notified, providing
    the opportunity to respond to the state change.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你很有可能之前就听说过观察者了。“哦，是的，当然听过——这不就是所谓的社交媒体平台对我们所做的事情吗？”你问道。嗯，并不完全是我想要的，但是是的，我相信我们可以称这些平台为观察者。而且，确实有它们所做的事情的模式，尽管不是设计模式。但我实际上是在谈论一个最流行的GoF设计模式之一，观察者设计模式。即使你对这个想法不熟悉，你很可能在现实生活中有一些有用的观察者的经验。例如，你可能注意到，在一些即时通讯应用程序中，当你阅读新消息时，消息的发送者会立即收到通知。这意味着消息显示为“已读”，而不仅仅是“已发送”。这项小服务本质上就是现实生活中观察者的工作：一旦新消息的状态发生变化，发送者就会收到通知，从而有机会对状态变化作出响应。
- en: The Observer Design Pattern Explained
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者设计模式解析
- en: 'In many software situations it’s desirable to get feedback as soon as some
    state change occurs: a new job is added to a task queue, a setting is changed
    in some configuration object, a result is ready to be picked up, etc. But at the
    same time, it would be highly undesirable to introduce explicit dependencies between
    the subject (the observed entity that changes) and its observers (the callbacks
    that are notified based on a state change). On the contrary, the subject should
    be oblivious to the potentially many different kinds of observers. And that’s
    for the simple reason that any direct dependency would make the software harder
    to change and harder to extend. This decoupling between the subject and its potentially
    many observers is the intent of the Observer design pattern.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多软件情况下，当某些状态发生变化时，及时获得反馈是非常可取的：例如，将作业添加到任务队列中，更改配置对象中的设置，准备好可以获取结果等等。但与此同时，引入主题（变化的观察实体）与其观察者（基于状态变化通知的回调）之间的显式依赖是非常不可取的。相反，主题应该对潜在的许多不同类型的观察者毫不知情。这样做的简单原因是任何直接的依赖关系都会使软件更难以改变和扩展。这种主题与其潜在的许多观察者之间的解耦是观察者设计模式的意图。
- en: The Observer Design Pattern
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者设计模式
- en: 'Intent: “Define a one-to-many dependency between objects so that when one object
    changes state, all its dependents are notified and updated automatically.”^([9](ch06.xhtml#idm45043099265856))'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 意图：“定义对象之间的一对多依赖关系，以便当一个对象改变状态时，所有依赖它的对象都会自动收到通知并更新。”^([9](ch06.xhtml#idm45043099265856))
- en: As with all design patterns, the Observer design pattern identifies one aspect
    as a *variation point* (an aspect that changes or is expected to change) and extracts
    it in the form of an abstraction. It thus helps to decouple software entities.
    In the case of the Observer, the need to introduce new observers—the need to extend
    a one-to-many dependency—is recognized to be the variation point. As [Figure 6-2](#fig_observer_original)
    illustrates, this variation point is realized in the form of the `Observer` base
    class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有设计模式一样，观察者设计模式将一个*变化点*（即变化或预期变化的方面）标识出来，并以抽象形式提取出来。因此，它有助于解耦软件实体。在观察者的情况下，识别到需要引入新观察者——需要扩展一对多的依赖——被认为是变化点。正如[图6-2](#fig_observer_original)所示，这个变化点在`Observer`基类的形式下得以实现。
- en: '![](assets/cpsd_0602.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![assets/cpsd_0602.png](assets/cpsd_0602.png)'
- en: Figure 6-2\. The UML representation of the Observer design pattern
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2\. 观察者设计模式的UML表示
- en: The `Observer` class represents the abstraction for all possible implementations
    of observers. These observers are attached to a specific subject, represented
    by the `ConcreteSubject` class. To reduce the coupling between observers and their
    subjects, or to simply reduce code duplication by providing all common services
    to `attach()` and `detach()` to different observers, the `Subject` abstraction
    can be used. This `Subject` might also `notify()` all attached observers about
    a state change and trigger their corresponding `update()` functionality.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer`类代表了所有可能的观察者实现的抽象。这些观察者附加到特定的主题，由`ConcreteSubject`类表示。为了减少观察者与其主题之间的耦合，或者简单地通过为不同的观察者提供所有共同服务来减少代码重复，可以使用`Subject`抽象。这个`Subject`也可能通知所有附加的观察者关于状态变化，并触发它们相应的`update()`功能。'
- en: '“Isn’t the introduction of the `Observer` base class another example of the
    SRP?” you ask. And yes, you’re 100% correct: extracting the `Observer` class,
    extracting a variation point, is the SRP in action (see [“Guideline 2: Design
    for Change”](ch01.xhtml#design_for_change)). Again, the SRP acts as an enabler
    for the OCP (see [“Guideline 5: Design for Extension”](ch01.xhtml#design_for_extension)):
    by introducing the `Observer` abstraction, anyone is able to add new kinds of
    observers (e.g., `ConcreteObserver`) without the need to modify existing code.
    If you pay attention to the ownership of the `Observer` base class and make sure
    that the `Observer` class lives in the high level of your architecture, then you
    also fulfill the Dependency Inversion Principle (DIP).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “Observer”基类的引入是SRP的另一个例子，你可能会问。是的，你完全正确：抽取`Observer`类，提取一个变化点，就是SRP的实践（参见[“指导原则2：为变化设计”](ch01.xhtml#design_for_change)）。再次强调，SRP作为OCP的一个推动因素（参见[“指导原则5：为扩展设计”](ch01.xhtml#design_for_extension)）：通过引入`Observer`抽象，任何人都能够添加新类型的观察者（例如`ConcreteObserver`），而无需修改现有代码。如果你关注`Observer`基类的所有权，并确保`Observer`类存在于架构的高层级，则也符合依赖反转原则（DIP）。
- en: A Classic Observer Implementation
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典Observer模式实现
- en: '“Great, I get it! It’s nice to see these design principles in action again,
    but I would like to see a concrete Observer example.” I understand. So let’s take
    a look at a concrete implementation. However, I should clearly state the limitations
    of the following example before we start to look at the code. You might already
    be familiar with `Observer`, and therefore you might be looking for help and deeper
    advice on many of the tricky implementation details of Observer: how to deal with
    the order of attaching and detaching observers, attaching an observer multiple
    times, and especially using observers in a concurrent environment. I should honestly
    state up front that it is not my intention to provide answers to these questions.
    That discussion would be like opening a can of worms, quickly sucking us into
    the realm of implementation details. No, although you may be disappointed, my
    intention is to mostly stay on the level of software design.^([10](ch06.xhtml#idm45043099207840))'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: “太好了，我明白了！再次看到这些设计原则在实践中的应用真是太棒了，但我想看一个具体的Observer示例。”我理解。那么让我们来看一个具体的实现。不过，在我们开始查看代码之前，我应该明确说明以下示例的局限性。你可能已经熟悉了`Observer`，因此你可能正在寻求帮助，并希望深入了解许多Observer的棘手实现细节：如何处理附加和分离观察者的顺序，多次附加观察者，特别是在并发环境中使用观察者。我应该诚实地提前声明，我并不打算提供这些问题的答案。那样的讨论会像打开潘多拉盒子，迅速把我们吸引到实现细节的领域。不，尽管你可能会感到失望，但我的意图大部分是留在软件设计的层面上。^([10](ch06.xhtml#idm45043099207840))
- en: 'Like for the previous design patterns, we start with a classic implementation
    of the Observer design pattern. The central element is the `Observer` base class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的设计模式一样，我们从Observer设计模式的经典实现开始。其核心元素是`Observer`基类：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The most important implementation detail of this class is the pure virtual
    `update()` function ([![1](assets/1.png)](#code_g25_1)), which is called whenever
    the observer is notified of some state change.^([11](ch06.xhtml#idm45043099160560))
    There are three alternatives for how to define the `update()` function, which
    provide a reasonable implementation and design flexibility. The first alternative
    is to push the updated state via one or even several `update()` functions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的最重要的实现细节是纯虚拟的`update()`函数（[![1](assets/1.png)](#code_g25_1)），每当观察者被通知到某个状态变化时就会调用它。有三种定义`update()`函数的替代方法，它们提供了合理的实现和设计灵活性。第一种替代方法是通过一个或多个`update()`函数推送更新的状态：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This form of observer is commonly called a *push observer*. In this form, the
    observer is given all necessary information by the subject and therefore is not
    required to pull any information from the subject on its own. This can reduce
    the coupling to the subject significantly and create the opportunity to reuse
    the `Observer` class for several subjects. Additionally, there is the option to
    use a separate overload for each kind of state change. In the preceding code snippet,
    there are two `update()` functions, one for each of two possible state changes.
    And since it’s always clear which state changed, the observer is not required
    to “search” for any state change, which proves to be efficient.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观察者形式通常被称为*推送观察者*。在这种形式中，观察者由主体提供所有必要的信息，因此不需要自行从主体拉取任何信息。这可以显著减少与主体的耦合，并创造重用`Observer`类的机会。此外，还可以选择为每种状态变化使用单独的重载。在前面的代码片段中，有两个`update()`函数，分别用于两种可能的状态变化。由于状态变化始终明确，因此观察者无需“搜索”任何状态变化，这证明是高效的。
- en: '“Excuse me,” you say, “but isn’t this a violation of the ISP? Shouldn’t we
    separate concerns by separating the `update()` functions into several base classes?”
    This is a great question! Obviously, you’re watching out for artificial coupling.
    Very good! And you are correct: we could separate an `Observer` with several `update()`
    functions into smaller `Observer` classes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: “对不起”，你说，“但这不是违反ISP吗？我们不应该通过将`update()`函数分成几个基类来分离关注点吗？” 这是一个很好的问题！显然，您正在关注人为耦合。非常好！而且您是正确的：我们可以将具有多个`update()`函数的观察者分离成较小的`Observer`类：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In theory, this approach could help reduce the coupling to a particular subject
    and more easily reuse observers for different subjects. It might also help because
    different observers might be interested in different state changes, and therefore
    it might be a violation of the ISP to artificially couple all possible state changes.
    And of course this might result in an efficiency gain if a lot of unnecessary
    state change notifications can be avoided.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这种方法可以帮助减少对特定主题的耦合，并更容易地为不同的主题重用观察者。它可能还有助于不同的观察者可能对不同的状态变化感兴趣，因此人为耦合所有可能的状态变化可能会违反ISP。当然，如果能够避免大量不必要的状态变化通知，这可能会带来效率提升。
- en: Unfortunately, a particular subject is not likely to distinguish among different
    kinds of observers. First, because this would require it to store different kinds
    of pointers (which is inconvenient to handle for the subject), and second, because
    it is possible that different state changes are linked in a certain way. In that
    case, the subject will expect that observers are interested in *all* possible
    state changes. From that perspective it can be reasonable to combine several `update()`
    functions into one base class. Either way, it’s very likely that a concrete observer
    will have to deal with all kinds of state changes. I know, it can be a nuisance
    to have to deal with several `update()` functions, even if only a small fraction
    of them are interesting. But still, make sure that you’re not accidentally violating
    the Liskov Substitution Principle by not adhering to some expected behavior (if
    there is any).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，特定的主题不太可能区分不同类型的观察者。首先，这需要它存储不同类型的指针（对于主题来说是不方便的），其次，不同的状态变化可能以某种方式相互关联。在这种情况下，主题将期望观察者对*所有*可能的状态变化感兴趣。从这个角度来看，将几个`update()`函数合并到一个基类中可能是合理的。无论如何，很可能一个具体的观察者将不得不处理所有类型的状态变化。我知道，即使只有很少一部分是有趣的，也必须处理几个`update()`函数，这可能会让人感到困扰。但是，请确保您不会因为不遵守某些预期行为（如果有的话）而意外违反里氏替换原则。
- en: There are several more potential downsides of a push observer. First, the observers
    are *always* given *all* the information, whether they need it or not. Thus, this
    push style works well only if the observers need the information most of the time.
    Otherwise, a lot of effort is lost on unnecessary notifications. Second, pushing
    creates a dependency on the number and kind of arguments that are passed to the
    observer. Any change to these arguments requires a lot of subsequent changes in
    the deriving observer classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 推送观察者还有几个潜在的缺点。首先，观察者*总是*被*所有*信息传递，无论他们是否需要。因此，如果观察者大部分时间都需要信息，这种推送样式才有效。否则，大量的工作会浪费在不必要的通知上。其次，推送会创建对传递给观察者的参数数量和种类的依赖性。对这些参数的任何更改都需要在派生观察者类中进行大量的后续更改。
- en: Some of these downsides are resolved by the second `Observer` alternative. It’s
    possible to only pass a reference to the subject to the observer:^([12](ch06.xhtml#idm45043098985312))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些缺点通过第二个`Observer`的替代方案得以解决。只需将主题的引用传递给观察者即可：^([12](ch06.xhtml#idm45043098985312))
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Due to the lack of specific information passed to the observer, the classes
    deriving from the `Observer` base class are required to pull the new information
    from the subject on their own. For this reason, this form of observer is commonly
    called a *pull observer*. The advantage is the reduced dependency on the number
    and kinds of arguments. Deriving observers are free to query for any information,
    not just the changed state. On the other hand, this design creates a strong, direct
    dependency between the classes deriving from `Observer` and the subject. Hence,
    any change to the subject easily reflects on the observers. Additionally, observers
    might have to “search” for the state change if multiple details have changed.
    This might prove to be unnecessarily inefficient.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于观察者未传递特定信息，派生自`Observer`基类的类必须自行从主题拉取新信息。因此，这种形式的观察者通常被称为“拉取观察者”。优点是对参数数量和类型的依赖性减少。派生观察者可以自由查询任何信息，而不仅限于已更改的状态。另一方面，此设计在`Observer`派生类与主题之间创建了强烈直接的依赖性。因此，对主题的任何更改都很容易反映在观察者身上。此外，如果多个细节发生了变化，观察者可能需要“搜索”状态变化，这可能会被证明是不必要的低效率。
- en: 'If you consider only a single piece of information as the changing state, the
    performance disadvantage might not pose a limitation for you. Still, please remember
    that software changes: a subject may grow, and with it the desire to notify about
    different kinds of changes. Adapting the observers in the process would result
    in a lot of additional work. From that point of view, the *push observer* appears
    to be a better choice.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只将单个信息片段视为变化状态，性能劣势可能不会对你构成限制。但请记住软件会变化：主题可能增长，因此希望通知不同类型的变化。在此过程中调整观察者将导致大量额外工作。从这个角度来看，“推送观察者”似乎是一个更好的选择。
- en: 'Luckily, there is a third alternative, which removes a lot of the previous
    disadvantages and thus becomes our approach of choice: in addition to passing
    a reference to the subject, we pass a tag to provide information about which property
    of a subject has changed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还有第三种选择，消除了许多先前的缺点，因此成为我们的首选方法：除了传递主题的引用外，还传递一个标签，提供有关主题哪个属性已更改的信息：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The tag may help an observer to decide on its own whether some state change
    is interesting or not. It’s commonly represented by some subject-specific enumeration
    type, which lists all possible state changes. This, unfortunately, increases the
    coupling of the `Observer` class to a specific subject.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该标签可能帮助观察者自行决定某些状态变化是否有趣。通常由特定于主题的枚举类型表示，列出所有可能的状态变化。不幸的是，这会增加`Observer`类与特定主题之间的耦合。
- en: “Wouldn’t it be possible to remove the dependency on a specific `Subject` by
    implementing the `Observer` base class as a class template? Take a look at the
    following code snippet:”
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: “通过将`Observer`基类实现为一个类模板，能否删除对特定`Subject`的依赖？看一下以下代码片段：”
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is a great suggestion. By defining the `Observer` class in the form of
    a class template ([![2](assets/2.png)](#code_g25_2)), we can easily lift the `Observer`
    to a higher architectural level. In this form, the class does not depend on any
    specific subject and thus may be reused by many different subjects that want to
    define a one-to-many relationship. However, you should not expect too much of
    this improvement: the effect is limited to the `Observer` class. Concrete subjects
    will expect concrete instantiations of this observer class, and in consequence,
    concrete implementations of `Observer` will still strongly depend on the subject.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的建议。通过将`Observer`类定义为一个类模板的形式（[![2](assets/2.png)](#code_g25_2)），我们可以轻松地将`Observer`提升到更高的架构层次。在这种形式下，该类不依赖于任何特定的主题，因此可以被许多不同希望定义一对多关系的主题重复使用。然而，你不应期望这种改进能起到太大作用：效果仅限于`Observer`类。具体的主题将期望具体的这个观察者类的实例化，因此`Observer`的具体实现仍然会强烈依赖于主题。
- en: To better understand why that is, let’s take a look at a possible subject implementation.
    After your initial comment about social media, I suggest that we implement an
    Observer for persons. Well, OK, this example may be morally questionable, but
    it will serve its purpose, so let’s go with that. At least we know who is to blame
    for this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解其中的原因，让我们看一下可能的主题实现。在您对社交媒体的初步评论之后，我建议我们为人员实现一个观察者。好吧，好吧，这个例子可能在道德上有问题，但它会达到它的目的，所以让我们这么做吧。至少我们知道谁该为此负责。
- en: 'The following `Person` class represents an observed person:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`Person`类表示一个被观察的人：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, a `Person` is merely an aggregation of the three data members:
    `forename_`, `surname_`, and `address_` ([![3](assets/3.png)](#code_g25_3)) (I
    know, this is a rather simple representation of a person.) In addition, a person
    holds the `std::set` of registered observers ([![4](assets/4.png)](#code_g25_4)).
    Please note that the observers are registered by pointers to instances of `PersonObserver`
    ([![5](assets/5.png)](#code_g25_5)). This is interesting for two reasons: first,
    this demonstrates the purpose of the templated `Observer` class: the `Person`
    class instantiates its own kind of observer from the class template. And second,
    pointers prove to be very useful in this context, since the address of an object
    is unique. Thus, it is common to use the address as a unique identifier for an
    observer.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Person`仅仅是三个数据成员的聚合：`forename_`、`surname_`和`address_`（[![3](assets/3.png)](#code_g25_3))（我知道，这只是一个人的一个相当简单的表示）。此外，一个人持有已注册观察者的`std::set`（[![4](assets/4.png)](#code_g25_4))。请注意，观察者是通过指向`PersonObserver`实例的指针来注册的（[![5](assets/5.png)](#code_g25_5))。出于两个原因这是有趣的：首先，这展示了模板化`Observer`类的目的：`Person`类从类模板实例化其自己的观察者类型。其次，指针在这种情况下证明非常有用，因为对象的地址是唯一的。因此，常见的做法是使用地址作为观察者的唯一标识符。
- en: '“Shouldn’t this be `std::unique_ptr` or `std::shared_ptr`?” you ask. No, not
    in this situation. The pointers merely serve as handles to the registered observers;
    they should not own the observers. Therefore, any owning smart pointer would be
    the wrong tool in this situation. The only reasonable choice would be `std::weak_ptr`,
    which would allow you to check for dangling pointers. However, `std::weak_ptr`
    is not a good candidate for a key for `std::set` (not even with a custom comparator).
    Although there are ways to still use `std::weak_ptr`, I will stick to raw pointers.
    But don’t worry, this doesn’t mean we are abandoning the benefits of modern C++.
    No, using a raw pointer is perfectly valid in this situation. This is also expressed
    in C++ [Core Guideline F.7](https://oreil.ly/xS6w6):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “这里应该用`std::unique_ptr`还是`std::shared_ptr`？”你问道。不，在这种情况下不需要。这些指针仅仅作为已注册观察者的句柄；它们不应该拥有这些观察者。因此，在这种情况下，任何拥有性智能指针都是错误的选择。唯一合理的选择将是`std::weak_ptr`，它允许您检查悬空指针。然而，`std::weak_ptr`并不是`std::set`的一个好选择（即使使用自定义比较器）。尽管仍有方法可以使用`std::weak_ptr`，我将坚持使用裸指针。但不要担心，这并不意味着我们放弃了现代C++的好处。不，在这种情况下使用裸指针是完全有效的。这也在C++
    [核心指南 F.7](https://oreil.ly/xS6w6)中表达了：
- en: For the general use, take `T*` or `T&` arguments rather than smart pointers.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于一般使用，取`T*`或`T&`作为参数，而不是智能指针。
- en: 'Whenever you’re interested in getting a notification for a state change of
    a person, you can register an observer via the `attach()` member function ([![6](assets/6.png)](#code_g25_6)).
    And whenever you’re no longer interested in getting notifications, you can deregister
    an observer via the `detach()` member function ([![7](assets/7.png)](#code_g25_7)).
    These two functions are an essential ingredient of the Observer design pattern
    and a clear indication of the application of the design pattern:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您对获取人的状态变化通知感兴趣时，您可以通过`attach()`成员函数注册一个观察者（[![6](assets/6.png)](#code_g25_6))。每当您不再对获取通知感兴趣时，您可以通过`detach()`成员函数注销一个观察者（[![7](assets/7.png)](#code_g25_7))。这两个函数是观察者设计模式的一个重要组成部分，也清楚地表明了设计模式的应用：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You have complete freedom to implement the `attach()` and `detach()` functions
    as you see fit. In this example, we allow an observer to be registered only a
    single time with a `std::set`. If you try to register an observer a second time,
    the function returns `false`. The same thing happens if you try to deregister
    an observer that is not registered. Note that the decision to not allow multiple
    registrations is my choice for this example. In other scenarios, it might be desirable
    or even necessary to accept duplicate registrations. Either way, the behavior
    and interface of the subject should of course be consistent in all cases.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你完全可以自由地实现`attach()`和`detach()`函数。在这个例子中，我们允许一个观察者在`std::set`中只注册一次。如果尝试第二次注册观察者，函数会返回`false`。如果尝试取消注册一个未注册的观察者也会发生同样的事情。请注意，不允许多次注册的决定是我在这个例子中的选择。在其他情况下，允许重复注册可能是可取的，甚至是必要的。无论如何，主题的行为和接口在所有情况下都应该是一致的。
- en: 'Another core function of the Observer design pattern is the `notify()` member
    function ([![8](assets/8.png)](#code_g25_8)). Whenever some state change occurs,
    this function is called to notify all registered observers about the change:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式的另一个核心功能是`notify()`成员函数（[![8](assets/8.png)](#code_g25_8)）。每当发生状态变化时，此函数被调用以通知所有注册的观察者。
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '“Why is the implementation of the `notify()` function so complicated? Wouldn’t
    a range-based `for` loop be completely sufficient?” You are correct; I should
    explain what’s happening here. The given formulation makes sure `detach()` operations
    can be detected during the iteration. This may happen, for instance, if an observer
    decides to detach itself during the call to the `update()` function. But I do
    not claim that this formulation is perfect: unfortunately it is not able to cope
    with `attach()` operations. And don’t even start to ask about concurrency! So
    this is just one example why the implementation details of observer can be so
    tricky.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “为什么`notify()`函数的实现这么复杂？难道使用基于范围的`for`循环就不够吗？”你说得对；我应该解释一下这里发生了什么。给定的表述确保在迭代期间可以检测到`detach()`操作。例如，在调用`update()`函数期间，观察者决定分离时就会发生这种情况。但我并不认为这种表述是完美的：不幸的是，它无法处理`attach()`操作。至于并发问题，更是不能接触！因此，这只是说明为什么观察者模式的实现细节会如此棘手的一个例子。
- en: 'The `notify()` function is called in all three setter functions ([![9](assets/9.png)](#code_g25_9)).
    Note that in all three functions, we always pass a different tag to indicate which
    property has changed. This tag may be used by classes deriving from the `Observer`
    base class to determine the nature of the change:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify()`函数在所有三个setter函数中被调用（[![9](assets/9.png)](#code_g25_9)）。请注意，在所有三个函数中，我们始终传递不同的标签来指示发生了哪种属性的更改。派生自`Observer`基类的类可以使用此标签来确定变化的性质。'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With these mechanics in place, you are now able to write new kinds of fully
    OCP-conforming observers. For instance, you could decide to implement a `NameObserver`
    and an `AddressObserver`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些机制，你现在可以编写符合完全OCP的新型观察者了。例如，你可以决定实现`NameObserver`和`AddressObserver`：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Equipped with these two observers, you are now notified whenever either the
    name or address of a person changes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个观察者，现在无论人的姓名还是地址发生变化时，您都会收到通知了。
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After these many implementation details, let’s take a step back and look at
    the bigger picture again. [Figure 6-3](#fig_observer_dependency_graph) shows the
    dependency graph for this Observer example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这么多实现细节之后，让我们再退一步，再次审视更大的图景。[图6-3](#fig_observer_dependency_graph)展示了这个观察者示例的依赖图。
- en: '![](assets/cpsd_0603.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cpsd_0603.png)'
- en: Figure 6-3\. Dependency graph for the Observer design pattern
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3。观察者设计模式的依赖图
- en: Due to the decision to implement the `Observer` class in the form of a class
    template, the `Observer` class resides on the highest level of our architecture.
    This enables you to reuse the `Observer` class for multiple purposes, for instance,
    for the `Person` class. The `Person` class declares its own `Observer<Person,Person::StateChange>`
    type and by that injects the code into its own architectural level. Concrete person
    observers, e.g., `NameObserver` and `AddressObserver`, can subsequently build
    on this declaration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于决定以类模板形式实现`Observer`类，所以`Observer`类位于我们架构的最高层。这使得你可以为多个目的重用`Observer`类，例如`Person`类。`Person`类声明了自己的`Observer<Person,
    Person::StateChange>`类型，并通过这种方式将代码注入到自己的架构层次中。具体的人员观察者，例如`NameObserver`和`AddressObserver`，随后可以基于这个声明进行构建。
- en: An Observer Implementation Based on Value Semantics
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于值语义的观察者实现
- en: '“I understand why you’ve started with a classic implementation, but since you
    have made the point about favoring value semantics, how would the observer look
    in a value semantics world?” That is an excellent question, since this a very
    reasonable next step. As explained in [“Guideline 22: Prefer Value Semantics over
    Reference Semantics”](ch05.xhtml#prefer_value_semantics_to_reference_semantics),
    there are a lot of good reasons to avoid the realm of reference semantics. However,
    we won’t entirely stray from the classic implementation: to register and deregister
    observers, we will always be in need of some unique identifier for observers,
    and the unique address of an observer is just the easiest and most convenient
    way to tackle that problem. Therefore, we’ll stick to using a pointer to refer
    to a registered observer. However, `std::function` is an elegant way to avoid
    the inheritance hierarchy—`std::function`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: “我理解你为什么从经典实现开始，但是既然你提到了偏爱值语义，那么在值语义世界中观察者会是什么样子呢？” 这是一个很好的问题，因为这是一个非常合理的下一步。正如在
    [“指南 22：偏爱值语义而非引用语义”](ch05.xhtml#prefer_value_semantics_to_reference_semantics)
    中解释的那样，有很多充分的理由避免引用语义的领域。然而，我们不会完全偏离经典实现：为了注册和注销观察者，我们始终需要一些唯一的标识符来标识观察者，而观察者的唯一地址只是解决这个问题最简单和最方便的方法。因此，我们将继续使用指针来引用注册的观察者。然而，`std::function`
    是避免继承层次结构的一种优雅方式 — `std::function`：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead of implementing the `Observer` class as a base class, and thus requiring
    deriving classes to inherit and implement the `update()` function in a very specific
    way, we separate concerns and instead build on composition (see [“Guideline 20:
    Favor Composition over Inheritance”](ch05.xhtml#favor_composition_over_inheritance)).
    The `Observer` class first provides a type alias called `OnUpdate` for the `std::function`
    type for the expected signature of our `update()` function ([![10](assets/10.png)](#code_g25_10)).
    Via the constructor, you are passed an instance of `std::function` ([![11](assets/11.png)](#code_g25_11)),
    and you move it into your data member `onUpdate_` ([![12](assets/12.png)](#code_g25_12)).
    The job of the `update()` function is now to forward the call, including the arguments,
    to `onUpdate_` ([![13](assets/13.png)](#code_g25_13)).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将 `Observer` 类实现为基类，从而要求派生类以非常特定的方式继承并实现 `update()` 函数，我们将关注点分离，而是建立在组合之上（参见
    [“指南 20：偏爱组合而非继承”](ch05.xhtml#favor_composition_over_inheritance)）。`Observer`
    类首先为我们 `update()` 函数期望签名的 `std::function` 类型提供了一个类型别名称为 `OnUpdate`（[![10](assets/10.png)](#code_g25_10)）。通过构造函数，您将得到一个
    `std::function` 实例（[![11](assets/11.png)](#code_g25_11)），并将其移动到您的数据成员 `onUpdate_`
    中（[![12](assets/12.png)](#code_g25_12)）。现在，`update()` 函数的工作是将调用转发到 `onUpdate_`，包括参数在内（[![13](assets/13.png)](#code_g25_13)）。
- en: 'The flexibility gained with `std::function` is easily demonstrated with an
    updated `main()` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::function` 获得的灵活性可以很容易地通过更新后的 `main()` 函数来演示：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Thanks to choosing a less intrusive approach and to decoupling with `std::function`,
    the choice of how to implement the `update()` function is completely up to the
    observer’s implementer (stateless, stateful, etc.). For the `nameObserver`, we
    build on the free function `propertyChanged()`, which itself is strongly decoupled
    because it’s not bound to a class and might be reused on several occasions. The
    `addressObserver`, on the other hand, chooses a lambda instead, which could possibly
    capture some state. Either way, the only convention that these two have to follow
    is to fulfill the required signature of the required `std::function` type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择了较少侵入性的方法，并与 `std::function` 解耦，如何实现 `update()` 函数完全由观察者的实现者决定（无状态的、有状态的等）。对于
    `nameObserver`，我们依赖于自由函数 `propertyChanged()`，它本身解耦性强，因为它不绑定到一个类，并且可以在多个场合重复使用。另一方面，`addressObserver`
    选择了一个可能捕获一些状态的 lambda 表达式。无论哪种方式，这两者唯一需要遵循的约定是满足所需 `std::function` 类型的必要签名。
- en: '“Why do we still need the `Observer` class? Couldn’t we just directly use `std::function`?”
    Yes, it most certainly looks that way. From a functionality point of view, the
    `Observer` class doesn’t add anything by itself. However, as `std::function` is
    a true child of value semantics, we tend to copy or move `std::function` objects.
    But this is not desirable in this situation: especially if you use a stateful
    observer, you don’t want a copy of your observer to be called. And although technically
    possible, it is not particularly common to pass around pointers to `std::function`.
    Therefore, the `Observer` class may still be of value in the form of an Adapter
    for `std::function` (see [“Guideline 24: Use Adapters to Standardize Interfaces”](#use_adapters_to_standardize_interfaces)).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “为什么我们仍然需要`Observer`类？我们不能直接使用`std::function`吗？” 是的，看起来确实是这样。从功能角度来看，`Observer`类本身并没有增加任何东西。然而，由于`std::function`是值语义的真正子集，我们倾向于复制或移动`std::function`对象。但在这种情况下这是不可取的：特别是如果您使用有状态的观察者，您不希望调用观察者的副本。虽然技术上可能，但通常不会传递指向`std::function`的指针。因此，在`std::function`的适配器形式下，`Observer`类仍可能具有价值（参见[“指南24：使用适配器标准化接口”](#use_adapters_to_standardize_interfaces)）。
- en: Analyzing the Shortcomings of the Observer Design Pattern
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析观察者设计模式的缺陷
- en: “This is not quite the value semantics solution I was expecting, but I still
    like it!” Well, I’m glad you feel this way. Indeed, the value semantics advantages,
    in combination with the benefits of the Observer design pattern (i.e., decoupling
    an event from the action taken for that event and the ability to easily add new
    kinds of observers), work really, really well. Unfortunately, there is no perfect
    design, and every design also comes with disadvantages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: “这并不完全是我期望的值语义解决方案，但我仍然喜欢它！” 嗯，我很高兴你有这种感觉。实际上，值语义的优势与观察者设计模式的好处（即，将事件与执行该事件的操作分离，以及轻松添加新类型的观察者的能力）结合起来，效果非常好。不幸的是，没有完美的设计，每种设计也都伴随着缺点。
- en: First, I should explicitly spell out that the demonstrated `std::function` approach
    works well only for a *pull observer* with a single `update()` function. Since
    `std::function` can cope with only a single callable, any approach that would
    require multiple `update()` functions cannot be handled by a single `std::function`.
    Therefore, `std::function` is usually not the way to go for a *push observer*
    with multiple `update()` functions, or the potential for a growing number of `update()`
    functions (remember, code tends to change!). However, it is possible to generalize
    the approach of `std::function`. If the need arises, the design pattern of choice
    is Type Erasure (see [Chapter 8](ch08.xhtml#type_erasure)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我应明确说明，演示的`std::function`方法仅适用于具有单个`update()`函数的*拉模式观察者*。由于`std::function`只能处理单个可调用对象，任何需要多个`update()`函数的方法都无法通过单个`std::function`处理。因此，`std::function`通常不适用于具有多个`update()`函数或可能增加`update()`函数数量的*推模式观察者*（请记住，代码倾向于变化！）。但可以推广`std::function`的方法。如果需要，首选的设计模式是类型擦除（参见[第8章](ch08.xhtml#type_erasure)）。
- en: 'A second (minor) disadvantage, as you have seen, is that there is no pure value-based
    implementation. While we might be able to implement the `update()` functionality
    in terms of `std::function` to gain flexibility, we still use a raw pointer to
    attach and detach Observers. And that is easy to explain: the advantages of using
    a pointer as a unique identifier are just too good to dismiss. Additionally, for
    a stateful Observer, we don’t want to deal with the copy of an entity. Still,
    this of course requires us to check for `nullptr` (which takes additional effort),
    and we always have to pay for the indirection that the pointer represents.^([13](ch06.xhtml#idm45043096802160))
    I personally would rate this as only a minor point because of the many advantages
    of this approach.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个（较小的）缺点，如您所见，是没有纯粹基于值的实现。尽管我们可能能够通过`std::function`实现`update()`功能以获得灵活性，但我们仍然使用原始指针来附加和分离观察者。这很容易解释：使用指针作为唯一标识符的优点实在是太好了，不容忽视。此外，对于有状态的观察者，我们不希望处理实体的副本。当然，这需要我们检查`nullptr`（这需要额外的工作量），而且我们始终需要支付指针所代表的间接引用的开销。^([13](ch06.xhtml#idm45043096802160))
    我个人认为这只是一个小问题，因为这种方法有许多优点。
- en: 'A far bigger disadvantage is the potential implementation issues with *Observers*:
    the order of registration and deregistration may matter a lot, in particular if
    an observer is allowed to register multiple times. Also, in a multithreaded environment,
    the thread-safe registration and deregistration of observers and handling of events
    are highly nontrivial topics. For instance, an untrusted observer can freeze a
    server during a callback if it behaves inappropriately, and implementing timeouts
    for arbitrary computations is *very* nontrivial. However, this topic is far outside
    the scope of this book.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更大的缺点是 *观察者* 的潜在实现问题：注册和注销的顺序可能非常重要，特别是如果允许一个观察者多次注册。此外，在多线程环境中，观察者的线程安全注册和注销以及事件处理是非常不平凡的问题。例如，如果一个不受信任的观察者在回调期间表现不当，它可能会冻结服务器，而为任意计算实现超时则是非常非平凡的。然而，这个主题远远超出了本书的范围。
- en: 'What is in the scope of this book, however, is the alleged danger that the
    overuse of observers can quickly and easily lead to a complex network of interconnections.
    Indeed, if you are not careful, you can accidentally introduce an infinite loop
    of callbacks! For that reason, developers are sometimes concerned about using
    Observers and are afraid that a single notification may result in a huge, global
    response due to these interconnections. While this danger exists, of course, a
    proper design should not be severely affected by this: if you have a proper architecture
    and if you have properly implemented your observers, then any sequence of notifications
    should always run along a directed, acyclic graph (DAG) toward the lower levels
    of your architecture. And that, of course, is the beauty of good software design.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书所涉及的范围是观察者的过度使用可能很容易导致复杂的互联网网络。事实上，如果你不小心，你可能会意外地引入回调的无限循环！因此，开发者有时会对使用观察者感到担忧，并担心单个通知可能会由于这些互联网连接而导致巨大的全局响应。当然，如果你有一个适当的架构，并且正确地实现了你的观察者，那么任何通知序列应始终沿着你的架构向下运行一个有向无环图（DAG）。当然，这正是良好软件设计的美丽所在。
- en: In summary, with the intent of providing a solution for notification of state
    change, the Observer design pattern proves to be one of the most famous and most
    commonly used design patterns. Aside from the potentially tricky implementation
    details, it is definitely one of the design patterns that should be in every developer’s
    toolbox.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，观察者设计模式的目的是提供一种解决状态变化通知的方案，它被证明是最著名和最常用的设计模式之一。除了可能棘手的实现细节外，它绝对是每个开发者工具箱中应该有的设计模式之一。
- en: 'Guideline 26: Use CRTP to Introduce Static Type Categories'
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南 26：使用 CRTP 引入静态类型类别
- en: 'C++ really has a lot to offer. It comes with lots of features, many syntactic
    curiosities, and a large number of amazing, utterly unpronounceable and (for the
    uninitiated) plainly cryptic acronyms: RAII, ADL, CTAD, SFINAE, NTTP, IFNDR, and
    SIOF. Oh, what fun! One of these cryptic acronyms is CRTP, short for the *Curiously
    Recurring Template Pattern*.^([14](ch06.xhtml#idm45043096784000)) If you’re’ scratching
    your head because the name doesn’t make any sense to you, don’t worry: as is so
    often in C++, the name was chosen randomly, but has stuck and has never been reconsidered
    or changed. The pattern was named by James Coplien in the February 1995 issue
    of the *C++ Report* after realizing that, curiously, this pattern was recurring
    in many different C++ codebases.^([15](ch06.xhtml#idm45043096781776)) And curiously,
    this pattern, although building on inheritance and (potentially) serving as an
    abstraction, does not exhibit the usual performance drawbacks of many other classic
    design patterns. For that reason, CRTP is definitely worth a look, as it may become
    a valuable, or should I say *curious*, addition to your design pattern toolbox.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 真的有很多东西要提供。它带来了许多功能，许多句法上的奇特之处，以及大量令人惊讶、完全无法发音和（对于未经过初始化的人）明显神秘的首字母缩写：RAII、ADL、CTAD、SFINAE、NTTP、IFNDR
    和 SIOF。哦，这多有趣啊！其中一个神秘的首字母缩写就是 CRTP，即 *Curiously Recurring Template Pattern*。[^14](ch06.xhtml#idm45043096784000)
    如果你因为名字对你来说毫无意义而摸不着头脑，不要担心：就像在 C++ 中经常发生的那样，这个名字是随意选择的，但却被固守并从未被重新考虑或更改过。这个模式是由詹姆斯·科普利恩在
    *C++ Report* 1995 年 2 月号上命名的，他意识到，奇怪的是，这个模式在许多不同的 C++ 代码库中反复出现。[^15](ch06.xhtml#idm45043096781776)
    令人好奇的是，尽管这种模式建立在继承之上（潜在地）作为一种抽象，但它并不表现出许多其他经典设计模式通常具有的性能缺陷。因此，CRTP 绝对值得一看，因为它可能成为你设计模式工具箱中一个有价值的，或者说是
    *奇特* 的补充。
- en: A Motivation for CRTP
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRTP 的动机
- en: Performance is very important in C++. So important in fact, that in several
    contexts the performance overhead of using virtual functions is considered outright
    unacceptable. Therefore, in performance-sensitive contexts, such as certain parts
    of computer games or high-frequency trading, no virtual functions are used. The
    same is true for high-performance computing (HPC). In HPC, any kind of conditional
    or indirection, and this includes virtual functions, is banned from the most performance-critical
    parts, such as the innermost loops of compute kernels. Using them would incur
    too much of a performance overhead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 性能在C++中非常重要。事实上，在几种情境中，使用虚函数的性能开销被认为是完全不能接受的。因此，在对性能要求极高的情境下，比如某些电脑游戏或高频交易的部分场景中，不使用虚函数。同样适用于高性能计算（HPC）。在HPC中，任何形式的条件判断或间接引用，包括虚函数，在性能最关键的部分，如计算核心的最内层循环中，都是被禁止的。使用它们会带来过多的性能开销。
- en: 'To give an example of how and why this matters, let’s consider the following
    `DynamicVector` class template from a linear algebra (LA) library:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明这个问题的重要性和原因，让我们考虑来自线性代数（LA）库的以下`DynamicVector`类模板：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Despite the name, `DynamicVector` does not represent a container but a numerical
    vector for the purpose of LA computations. The `Dynamic` part of the name implies
    that it allocates its elements of type `T` dynamically, in this example, in the
    form of `std::vector` ([![1](assets/1.png)](#code_g26_1)). For that reason, it
    is suited for large LA problems (definitely in the range of several million elements).
    Although this class may be loaded with many numerical operations, from an interface
    point of view you might indeed be tempted to call it a container: it provides
    the usual nested types (`value_type`, `iterator`, and `const_iterator`) ([![2](assets/2.png)](#code_g26_2)),
    a `size()` function to query the current number of elements ([![3](assets/3.png)](#code_g26_3)),
    subscript operators to access individual elements by index (one for non-`const`
    and one for `const` vectors) ([![4](assets/4.png)](#code_g26_4)), and `begin()`
    and `end()` functions to iterate over the elements ([![5](assets/5.png)](#code_g26_5)).
    Apart from the member functions, it also provides an output operator ([![6](assets/6.png)](#code_g26_6))
    and, to show at least one LA operation, a function to compute the vector’s [Euclidean
    norm](https://oreil.ly/x2a47) (often also called the *L2 norm*, because it approximates
    the L2 norm for discrete vectors) ([![7](assets/7.png)](#code_g26_7)).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字是`DynamicVector`，但它并不表示一个容器，而是用于LA计算的数值向量。名字中的`Dynamic`部分暗示它以动态方式分配其类型为`T`的元素，例如在这个例子中，以`std::vector`的形式（[![1](assets/1.png)](#code_g26_1)）。因此，它适用于大型LA问题（绝对是数百万个元素的范围）。尽管这个类可能加载了许多数值操作，从接口的角度来看，您确实可能会倾向于将其称为容器：它提供了常见的嵌套类型（`value_type`、`iterator`和`const_iterator`）（[![2](assets/2.png)](#code_g26_2)），一个`size()`函数来查询当前元素的数量（[![3](assets/3.png)](#code_g26_3)），通过索引访问单个元素的下标操作符（一个用于非`const`向量，一个用于`const`向量）（[![4](assets/4.png)](#code_g26_4)），以及`begin()`和`end()`函数来迭代元素（[![5](assets/5.png)](#code_g26_5)）。除了成员函数外，它还提供了一个输出运算符（[![6](assets/6.png)](#code_g26_6)），并且，为了展示至少一个LA操作，提供了一个计算向量的[欧几里得范数](https://oreil.ly/x2a47)的函数（通常也称为*L2范数*，因为它近似于离散向量的L2范数）（[![7](assets/7.png)](#code_g26_7)）。
- en: 'The `DynamicVector` is not the only vector class, though. In our LA library,
    you will also find the following `StaticVector` class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`DynamicVector`并不是唯一的向量类。在我们的线性代数库中，您还会找到以下`StaticVector`类：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '“Isn’t this almost the same as the `DynamicVector` class?” you wonder. Yes,
    these two classes are very similar indeed. The `StaticVector` class provides the
    same interface as the `DynamicVector`, such as the nested types `value_type`,
    `iterator`, and `const_iterator` ([![8](assets/8.png)](#code_g26_8)); the `size()`
    member function ([![9](assets/9.png)](#code_g26_9)); the subscript operators ([![10](assets/10.png)](#code_g26_10));
    and the `begin()` and `end()` functions ([![11](assets/11.png)](#code_g26_11)).
    It also comes with an output operator ([![12](assets/12.png)](#code_g26_12)) and
    a free `l2norm()` function ([![13](assets/13.png)](#code_g26_13)). However, there
    is an important, performance-related difference between the two vector classes:
    as the `Static` in the name suggests, the `StaticVector` does not allocate its
    elements dynamically. Instead, it uses an in-class buffer to store its elements,
    for instance, with a `std::array` ([![14](assets/14.png)](#code_g26_14)). Thus,
    in contrast to `DynamicVector`, the entire functionality of `StaticVector` is
    optimized for a small, fixed number of elements, such as 2D or 3D vectors.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “这与`DynamicVector`类几乎相同，不是吗？”你想知道。是的，这两个类确实非常相似。`StaticVector`类提供与`DynamicVector`相同的接口，例如嵌套类型`value_type`、`iterator`和`const_iterator`（[![8](assets/8.png)](#code_g26_8))；`size()`成员函数（[![9](assets/9.png)](#code_g26_9))；下标运算符（[![10](assets/10.png)](#code_g26_10))；以及`begin()`和`end()`函数（[![11](assets/11.png)](#code_g26_11))。它还带有一个输出运算符（[![12](assets/12.png)](#code_g26_12))和一个自由的`l2norm()`函数（[![13](assets/13.png)](#code_g26_13))。然而，这两个向量类之间有一个重要的性能差异：正如名称中的`Static`所示，`StaticVector`不会动态分配其元素。相反，它使用一个内部缓冲区来存储其元素，例如，使用`std::array`（[![14](assets/14.png)](#code_g26_14))。因此，与`DynamicVector`相比，`StaticVector`的整个功能都针对少量固定数量的元素进行了优化，比如二维或三维向量。
- en: '“OK, I understand that this is important for performance, but there’s still
    a lot of code duplication, right?” Again, you are correct. If you take a close
    look at the associated output operator of the two vector classes, you will find
    that the implementation of these two functions is identical. This is deeply undesirable:
    if anything changes, for instance, the way vectors are formatted (and remember:
    change is *the one* constant in software development and needs to be expected;
    see [“Guideline 2: Design for Change”](ch01.xhtml#design_for_change)), then you
    would have to make the change in many places, not just one. This is a violation
    of the Don’t Repeat Yourself (DRY) principle: it’s easy to forget or miss updating
    one of the many places, thus introducing an inconsistency or even a bug.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: “好的，我明白这对性能很重要，但还是有很多代码重复，对吧？”再次，你是正确的。如果你仔细查看这两个向量类的相关输出运算符，你会发现这两个函数的实现是相同的。这是非常不可取的：如果有任何变化，例如向量格式的改变（记住：变化是软件开发中唯一的常量，并且需要预料到；参见[“指南
    2：为变更设计”](ch01.xhtml#design_for_change)），那么你将不得不在许多地方进行更改，而不仅仅是一个地方。这是违反了“不要重复自己”（DRY）原则：很容易忘记或者遗漏更新其中一个地方，从而引入不一致性甚至错误。
- en: “But isn’t this duplication easily resolved with a slightly more general function
    template? For example, I can imagine the following output operator for all kinds
    of dense vectors:”
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: “但是通过稍微更通用的函数模板难道不可以轻松解决这种重复吗？例如，我可以想象为各种密集向量编写以下输出运算符：”
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Although this seems like an adequate solution, I wouldn’t accept this code
    in a pull request. This function template is indeed more general, but I would
    definitely not call it “slightly” more general; what you are suggesting is the
    most general output operator one could possibly write. Yes, the name of the function
    template may suggest that it’s written for only dense vectors (including `DynamicVector`
    and `StaticVector`), but this function template will in fact accept any type:
    `DynamicVector`, `StaticVector`, `std::vector`, `std::string`, and fundamental
    types such as `int` and `double`. It simply fails to specify any requirement or
    any kind of constraint. For that reason it violates [Core Guideline T.10](https://oreil.ly/bVjjh):^([16](ch06.xhtml#idm45043095642896))'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这似乎是一个足够的解决方案，但我不会在拉取请求中接受这段代码。这个函数模板确实更加通用，但我绝对不会称其为“稍微”更通用；你建议的是可能写出的最通用的输出运算符。是的，函数模板的名称可能表明它仅适用于密集向量（包括`DynamicVector`和`StaticVector`），但实际上这个函数模板将接受任何类型：`DynamicVector`、`StaticVector`、`std::vector`、`std::string`，以及诸如`int`和`double`等基本类型。它只是未能指定任何要求或任何类型的约束。因此，它违反了[核心指南
    T.10](https://oreil.ly/bVjjh)：^([16](ch06.xhtml#idm45043095642896))
- en: Specify concepts for all template arguments.
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为所有模板参数指定概念。
- en: 'While this output operator will work for all dense vectors and sequence containers,
    you would get a compilation error for all types that do not provide the expected
    interface. Or even worse, you might subtly violate the implicit requirements and
    expectations, and with that the LSP (see [“Guideline 6: Adhere to the Expected
    Behavior of Abstractions”](ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions)).
    Of course, you wouldn’t do this consciously, but likely accidentally: this output
    operator is a perfect match for any type and might be used even though you don’t
    expect it. Therefore, this function template would be a very unfortunate addition
    to the output operator overload set. What we need is a totally new set of types,
    a new type category.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然这个输出运算符将适用于所有密集向量和序列容器，但对于不提供预期接口的所有类型，您将获得编译错误。或者更糟糕的是，您可能会微妙地违反隐含的要求和期望，从而违反LSP（见[“Guideline
    6: Adhere to the Expected Behavior of Abstractions”](ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions)）。当然，这不是有意的，而是可能是意外的：这个输出运算符对任何类型都是完美匹配，可能会在您不期望的情况下使用。因此，这个函数模板将是输出运算符重载集合中非常不幸的一个补充。我们需要的是一组全新的类型，一个新的类型类别。'
- en: “Isn’t this what base classes are for? Couldn’t we just formulate a `DenseVector`
    base class that defines the expected interface for all dense vectors? Consider
    the following sketch of a `DenseVector` base class:”
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “这不是基类的用途吗？我们难道不能简单地制定一个`DenseVector`基类，为所有密集向量定义预期接口吗？考虑下面的`DenseVector`基类草图：”
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '“This should work, right? I’m just not sure how to declare the `begin()` and
    `end()` functions, as I don’t know how to abstract from different iterator types,
    such as `std::vector<T>::iterator` and `std::array<T>::iterator`.” I also have
    a feeling that this could be a problem, and I admit that I also do not have a
    quick solution for that. But there is something far more concerning: with this
    base class, we would turn all our member functions into virtual member functions.
    That would include the `begin()` and `end()` functions but, most importantly,
    the two subscript operators. The consequences would be significant: with every
    access to an element of the vector, we would now have to call a virtual function.
    Every single access! Therefore, with this base class, we could wave goodbye to
    high performance.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: “这应该可行，对吧？我只是不确定如何声明`begin()`和`end()`函数，因为我不知道如何从不同的迭代器类型（例如`std::vector<T>::iterator`和`std::array<T>::iterator`）抽象出来。”
    我也有种感觉这可能是个问题，我承认我对此也没有快速解决方案。但有一件事更令人担忧：使用这个基类，我们会把所有成员函数都变成虚成员函数。这将包括`begin()`和`end()`函数，但更重要的是两个下标运算符。后果将是显著的：现在每次访问向量的元素时，我们都必须调用一个虚函数。每次访问都是如此！因此，使用这个基类，我们可以告别高性能。
- en: Still, the general idea of building an abstraction with a base class is good.
    We just have to do it differently. This is where we should take a closer look
    at the CRTP.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总体上，使用基类建立抽象的想法是好的。我们只需要以不同的方式做。这就是我们应该更仔细研究CRTP的地方。
- en: The CRTP Design Pattern Explained
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释CRTP设计模式
- en: The CRTP design pattern builds on the common idea of creating an abstraction
    using a base class. But instead of establishing a runtime relationship between
    base and derived classes via virtual functions, it creates a compile-time relationship.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: CRTP设计模式建立在使用基类创建抽象的常见思想之上。但它不是通过虚函数在基类和派生类之间建立运行时关系，而是创建编译时关系。
- en: The CRTP Design Pattern
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRTP设计模式
- en: 'Intent: “Define a compile-time abstraction for a family of related types.”'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 意图：“为一系列相关类型定义编译时抽象。”
- en: 'The compile-time relationship between the `DenseVector` base class and the
    `DynamicVector` derived class is created by upgrading the base class to a class
    template:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将`DenseVector`基类升级为类模板，创建了与`DynamicVector`派生类之间的编译时关系：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The curious detail about CRTP is that the new template parameter of the `DenseVector`
    base class represents the type of the associated derived class ([![15](assets/15.png)](#code_g26_15)).
    Derived classes, for instance, the `DynamicVector`, are expected to provide their
    own type to instantiate the base class ([![16](assets/16.png)](#code_g26_16)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CRTP的有趣细节是，`DenseVector`基类的新模板参数代表了关联派生类的类型（[![15](assets/15.png)](#code_g26_15)）。例如，派生类如`DynamicVector`期望提供其自己的类型来实例化基类（[![16](assets/16.png)](#code_g26_16)）。
- en: “Wow, wait a second—is that even possible?” you ask. It is. To instantiate a
    template, you do not need the complete definition of a type. It is sufficient
    to use an incomplete type. Such an incomplete type is available after the compiler
    has seen the `class DynamicVector` declaration. In essence, this piece of syntax
    works as a forward declaration. Therefore, the `DynamicVector` class can indeed
    use itself as a template argument to the `DenseVector` base class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: “哇，等等，这真的可能吗？” 你问道。是的。要实例化一个模板，你并不需要完整的类型定义。使用不完整类型就足够了。这样的不完整类型在编译器看到`class
    DynamicVector`声明之后就可用了。从本质上讲，这段语法像是前向声明一样起作用。因此，`DynamicVector`类确实可以将自身用作`DenseVector`基类的模板参数。
- en: 'Of course, you can name the template parameter of the base class however you’d
    like (e.g., simply `T`), but as discussed in [“Guideline 14: Use a Design Pattern’s
    Name to Communicate Intent”](ch03.xhtml#use_a_design_patterns_name_to_communicate_intent),
    it helps to communicate intent by using the name of the design pattern or names
    commonly used for a pattern. For that reason, you could name the parameter `CRTP`,
    which nicely communicates the pattern but unfortunately only to the initiated.
    Everyone else will be puzzled by the acronym. Therefore, the template parameter
    is often called `Derived`, which perfectly expresses its purpose and communicates
    its intent: it represents the type of the derived class.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，你可以随意命名基类的模板参数（例如，简单地`T`），但正如在[“Guideline 14: Use a Design Pattern’s Name
    to Communicate Intent”](ch03.xhtml#use_a_design_patterns_name_to_communicate_intent)中讨论的那样，使用设计模式的名称或通常用于模式的名称有助于传达意图。因此，你可以将参数命名为`CRTP`，这样很好地传达了模式，但遗憾的是只有理解的人才能明白。其他人会对这个缩写感到困惑。因此，模板参数通常被称为`Derived`，这完美地表达了它的目的并传达了它的意图：它代表了派生类的类型。'
- en: 'Via this template parameter, the base class is now aware of the actual type
    of the derived type. While it still represents an abstraction and the common interface
    for all dense vectors, it is now able to access and call the concrete implementation
    in the derived type. This happens, for instance, in the `size()` member function
    ([![17](assets/17.png)](#code_g26_17)): the `DenseVector` uses a `static_cast`
    to convert itself into a reference to the derived class and calls the `size()`
    function on that. What at first glance may look like a recursive function call
    (calling the `size()` function within the `size()` function) is in fact a call
    of the `size()` member function in the derived class ([![18](assets/18.png)](#code_g26_18)).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个模板参数，基类现在可以意识到派生类型的实际类型。虽然它仍然代表一种抽象和所有稠密向量的共同接口，但它现在能够访问并调用派生类型中的具体实现。例如，在`size()`成员函数中（[![17](assets/17.png)](#code_g26_17)）：`DenseVector`使用`static_cast`将自身转换为派生类的引用，并在其上调用`size()`函数。乍一看可能像是递归函数调用（在`size()`函数内部调用`size()`函数），实际上是在派生类中调用`size()`成员函数（[![18](assets/18.png)](#code_g26_18)）。
- en: “So this is the compile-time relationship you were taking about. The base class
    represents an abstraction from concrete derived types and implementation details
    but still knows exactly where the implementation details are. So we really do
    not need any virtual function.” Correct. With CRTP, we are now able to implement
    a common interface and forward every call to the derived class by simply performing
    a `static_cast`. And there is no performance penalty for doing this. In fact,
    the base class function is very likely to be inlined, and if the `DenseVector`
    is the only or first base class, the `static_cast` will not even result in a single
    assembly instruction. It merely tells the compiler to treat the object as an object
    of the derived type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: “这就是你所说的编译时关系吗？基类代表具体派生类型和实现细节的抽象，但仍然清楚地知道实现细节在哪里。所以我们确实不需要任何虚函数。” 正确。通过CRTP，我们现在能够实现一个共同的接口，并通过简单的`static_cast`将每个调用转发到派生类。这样做没有性能惩罚。事实上，基类函数很可能被内联，如果`DenseVector`是唯一或第一个基类，`static_cast`甚至不会导致单个汇编指令。它仅仅告诉编译器将对象视为派生类型的对象。
- en: 'To provide a clean CRTP base class, we should update a couple of details, though:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供一个干净的CRTP基类，我们应该更新一些细节，尽管如此：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since we want to avoid any virtual functions, we’re also not interested in
    a virtual destructor. Therefore, we implement the destructor as a nonvirtual function
    in the `protected` section of the class ([![19](assets/19.png)](#code_g26_19)).
    This perfectly adheres to [Core Guideline C.35](https://oreil.ly/RxGfR):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望避免任何虚函数，我们对虚析构函数也不感兴趣。因此，我们在类的`protected`部分实现了非虚析构函数 ([![19](assets/19.png)](#code_g26_19))。这完全符合[Core
    Guideline C.35](https://oreil.ly/RxGfR)的要求：
- en: A base class destructor should be either public and virtual, or protected and
    non-virtual.
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基类的析构函数应该是公共的且虚拟的，或者是受保护的且非虚拟的。
- en: Keep in mind, though, that this definition of the destructor keeps the compiler
    from generating the two move operations. Since a CRTP base class is usually empty
    with nothing to move, this is not a problem; but still, always be mindful about
    the [Rule of 5](https://oreil.ly/fzS3f).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请记住，这个析构函数的定义阻止编译器生成两个移动操作。由于CRTP基类通常为空且没有任何内容可移动，这不是问题；但仍然要始终注意[Rule of 5](https://oreil.ly/fzS3f)。
- en: We should also avoid using a `static_cast` in every single member function of
    the base class. Although it would be correct, any cast should be considered suspicious,
    and casts should be minimized.^([17](ch06.xhtml#idm45043095164048)) For that reason,
    we add the two `derived()` member functions, which perform the cast and can be
    used in the other member functions ([![20](assets/20.png)](#code_g26_20)). This
    resulting code not only looks cleaner and adheres to the *DRY* principle, but
    it also looks far less suspicious.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也应该避免在基类的每一个成员函数中使用`static_cast`。虽然这样做是正确的，但是任何强制转换都应该被视为可疑的，而且应该尽量减少强制转换。^([17](ch06.xhtml#idm45043095164048))
    因此，我们添加了两个`derived()`成员函数，用于执行转换并可以在其他成员函数中使用 ([![20](assets/20.png)](#code_g26_20))。这样一来，生成的代码不仅更清晰，符合*DRY*原则，而且看起来更不可疑。
- en: 'Equipped with the `derived()` functions, we can now go ahead and define the
    subscript operators and the `begin()` and `end()` functions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 借助于`derived()`函数，我们现在可以继续定义下标操作符和`begin()`以及`end()`函数：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, these functions are not as straightforward as the `size()` member
    function. In particular, the return types prove to be a little harder to specify,
    as these types depend on the implementation of the `Derived` class. “Well, that
    shouldn’t be too hard,” you say. “This is why the derived types provide a couple
    of nested types, such as `value_type`, `iterator`, and `const_iterator`, right?”
    Indeed, it appears to be intuitive to just ask nicely:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些函数并不像`size()`成员函数那样直截了当。特别是，返回类型的确定稍微复杂一些，因为这些类型依赖于`Derived`类的实现。“好吧，这应该不会太难，”你说道。“这就是为什么派生类型提供了一些嵌套类型，比如`value_type`、`iterator`和`const_iterator`，对吧？”确实，看起来很直观，只需友好地询问：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We query for the `value_type`, `iterator`, and `const_iterator` types in the
    derived class (don’t forget the `typename` keyword) and use these to specify our
    return types ([![21](assets/21.png)](#code_g26_21)). Easy, right? You can almost
    bet that it’s not that easy. If you try this, the Clang compiler will complain
    with a seriously weird and baffling error message:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类中查询`value_type`、`iterator`和`const_iterator`类型（别忘了`typename`关键字），并使用它们来指定我们的返回类型
    ([![21](assets/21.png)](#code_g26_21))。简单，对吧？你几乎可以打赌，事情并没有那么简单。如果你尝试这样做，Clang编译器将会投诉一个非常奇怪和令人困惑的错误信息：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '“No `value_type` in `DynamicVector<int>`—strange.” The first idea that crosses
    your mind is that you messed up. It must be a typo. Of course! So you go back
    to your code and check the spelling. However, it turns out that everything seems
    to be OK. There is no typo. You check the `DynamicVector` class again: there it
    is, the nested `value_type` member. And everything is `public`, too. The error
    message just doesn’t make any sense. You reexamine everything, and again, and
    half an hour later you conclude, “The compiler has a bug!”'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: “`DynamicVector<int>`中没有`value_type`——奇怪。”你脑海中闪过的第一个想法是你搞砸了。肯定是打字错误。当然！于是你回到代码，检查拼写。然而，事实证明一切似乎都没问题。没有拼写错误。你再次检查`DynamicVector`类：嵌套的`value_type`成员在那里。而且一切都是`public`的。这个错误信息简直毫无意义。你重新审视一切，再次，半个小时后你得出结论，“编译器有bug！”
- en: No, it isn’t a bug in the compiler. Not in Clang or any other compiler. GCC
    provides a different, still slightly puzzling, but a perhaps little more illuminating
    error message:^([18](ch06.xhtml#idm45043094873184))
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是编译器的错误。不是Clang或任何其他编译器的错误。GCC提供了一个不同的，稍微更具启发性但可能仍然有点令人费解的错误信息:^([18](ch06.xhtml#idm45043094873184))
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The Clang compiler is correct: there is no `value_type` in the `DynamicVector`
    class. Not yet! When you query for the nested types, the definition of the `DynamicVector`
    class hasn’t been seen, and `DynamicVector` is still an incomplete type. That’s
    because the compiler will instantiate the `DenseVector` base class before the
    definition of the `DynamicVector` class. After all, syntactically, the base class
    is specified before the body of the class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Clang编译器是正确的：在`DynamicVector`类中不存在`value_type`。还没有！当你查询嵌套类型时，`DynamicVector`类的定义还没有被看到，而`DynamicVector`仍然是一个不完整的类型。这是因为编译器会在`DynamicVector`类的定义之前实例化`DenseVector`基类。毕竟，从语法上来说，基类是在类的主体之前指定的：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In consequence, there is no way that you can use the nested types of the derived
    class for the return types of the CRTP class. In fact, you can’t use anything
    as long as the derived class is an incomplete type. “But why can I call the member
    functions of the derived class? Shouldn’t this result in the same problem?” Luckily,
    this works (otherwise the CRTP pattern would not work at all). But it only works
    because of a special property of class templates: member functions are only instantiated
    on demand, meaning when they are actually called. Since an actual call usually
    happens only after the definition of the derived class is available, there is
    no problem with a missing definition. At that point, the derived class is not
    an incomplete type anymore.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你无法使用派生类的嵌套类型作为CRTP类的返回类型。实际上，在派生类是不完整类型的情况下，你不能使用任何东西。“但为什么我可以调用派生类的成员函数？这不应该导致相同的问题吗？”幸运的是，这是有效的（否则CRTP模式根本无法工作）。但它之所以有效，仅因为类模板的一个特殊属性：成员函数只有在需要时才会被实例化，也就是在实际调用它们时。由于实际调用通常发生在派生类定义可用之后，因此缺少定义时并不存在问题。在那时，派生类就不再是不完整类型了。
- en: '“OK, I get it. But how do we specify the return types of the subscript operators
    and `begin()` and `end()` functions?” The most convenient way to handle this is
    to use return type deduction. This is a perfect opportunity to use the `decltype(auto)`
    return type:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: “好的，我明白了。但是我们如何指定下标运算符、`begin()`和`end()`函数的返回类型？”处理这个问题最方便的方法是使用返回类型推导。这是使用`decltype(auto)`返回类型的一个绝佳机会：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: “Wouldn’t it be enough to just use `auto`? For instance, we could define the
    return types like this:”
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: “只使用`auto`不就足够了吗？例如，我们可以像这样定义返回类型：”
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It would be enough for this example, yes. However, as I keep emphasizing, code
    changes. Eventually, there may be another, deriving vector class that does not
    store its values and returns references to its values but produces values and
    returns by value. And yes, this is easily conceivable: consider, for instance,
    a `ZeroVector` class, which represents the [zero element](https://oreil.ly/DS9FB)
    for vectors. Such a vector would not store all of its elements, as this would
    be wasteful, but would likely be implemented as an empty class, which returns
    a zero by value every time an element is accessed. In that case, an `auto&` return
    type would be incorrect. Yes, the compiler would (hopefully) warn you about that.
    But you could avoid the entire problem by just returning *exactly* what the deriving
    class returns. And that kind of return type is represented by the `decltype(auto)`
    return.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子来说，这是足够的，是的。然而，正如我一直强调的，代码会变化。最终，可能会有另一个派生的向量类，它不存储其值并返回其值的引用，而是生成值并通过值返回。是的，这很容易想象：比如考虑一个`ZeroVector`类，它代表向量的[零元素](https://oreil.ly/DS9FB)。这样的向量不会存储所有元素，因为这样做很浪费，而可能被实现为一个空类，每次访问元素时都通过值返回零。在这种情况下，使用`auto&`返回类型将是不正确的。是的，编译器会（希望）警告你这个问题。但是你可以通过返回*确切*与派生类返回相同的内容来避免整个问题。这种返回类型正是`decltype(auto)`返回类型所表示的。
- en: Analyzing the Shortcomings of the CRTP Design Pattern
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析CRTP设计模式的缺点
- en: '“Wow, this CRTP design pattern sounds amazing. So seriously, apart from these
    slightly-more-complex-than-usual implementation details, isn’t this the solution
    to all performance issues with virtual functions? And isn’t this the key, the
    holy grail for all inheritance-related problems?” I can understand the enthusiasm!
    At first sight, CRTP most definitely looks like the ultimate solution for all
    kinds of inheritance hierarchies. Unfortunately, that is an illusion. Remember:
    every design pattern comes with benefits but unfortunately also with drawbacks.
    And there are several pretty limiting drawbacks to the CRTP design pattern.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: “哇，这个 CRTP 设计模式听起来太棒了。所以说，除了这些比通常稍微复杂的实现细节外，这难道不是解决所有虚函数性能问题的方案吗？这不是所有继承相关问题的圣杯吗？”
    我能理解这种热情！乍一看，CRTP 确实看起来像是所有继承层次结构问题的终极解决方案。不幸的是，这是一种幻觉。请记住：每种设计模式都有其好处，但不幸的是也有其局限性。而
    CRTP 设计模式有几个相当限制性的缺点。
- en: 'The first, and one of the most restricting, drawbacks is the lack of a common
    base class. I will repeat this to emphasize the gravity of the repercussions:
    there is *no* common base class! Effectively, every single derived class has a
    different base class. For example, the `DynamicVector<T>` class has the `DenseVector<Dynamic​Vector<T>>`
    base class. The `StaticVector<T,Size>` class has the `Dense​Vector​<StaticVector<T,Size>>`
    base class (see [Figure 6-4](#fig_crtp_dependency_graph)). Thus, whenever a common
    base class is required, a common abstraction that can be used, for instance, to
    store different types in a collection, the CRTP design pattern is *not* the right
    choice.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，也是最为限制的缺点之一是缺乏一个公共基类。我会重复这一点以强调其重要性：*没有* 共同的基类！实际上，每个派生类都有一个不同的基类。例如，`DynamicVector<T>`
    类具有 `DenseVector<Dynamic​Vector<T>>` 基类。`StaticVector<T,Size>` 类具有 `Dense​Vector​<StaticVector<T,Size>>`
    基类（参见 [图 6-4](#fig_crtp_dependency_graph)）。因此，每当需要一个公共基类时，例如用于存储集合中的不同类型的公共抽象，CRTP
    设计模式 *不* 是正确的选择。
- en: '![](assets/cpsd_0604.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cpsd_0604.png)'
- en: Figure 6-4\. Dependency graph for the CRTP design pattern
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. CRTP 设计模式的依赖图
- en: '“Oh, wow, I see that this could be a real limitation. But couldn’t we just
    make the CRTP base class derive from a common base class?” you argue. No, not
    really, because this would require us to introduce virtual functions again. “OK,
    I see. What about simulating a common base class using `std::variant`?” Yes, that’s
    an option. However, please remember that `std::variant` is a representation of
    the *Visitor* design pattern (see [“Guideline 16: Use Visitor to Extend Operations”](ch04.xhtml#use_visitors_to_extend_operations)).
    And since `std::variant` needs to know about all its potential alternatives, this
    will limit your freedom to add new types. So you see, even though you might not
    like it, CRTP really is *not* a replacement for every inheritance hierarchy.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '“哦，哇，我看到这可能是一个真正的限制。但我们难道不可以让 CRTP 基类从一个公共基类继承吗？” 你提出了反驳。不行，不行，因为这将要求我们再次引入虚函数。“好的，我明白了。那用
    `std::variant` 模拟一个公共基类怎么样？” 是的，这是一个选择。但请记住，`std::variant` 是 *Visitor* 设计模式的一种表示（参见
    [“准则 16: 使用 Visitor 扩展操作”](ch04.xhtml#use_visitors_to_extend_operations)）。而且由于
    `std::variant` 需要知道其所有潜在的替代方案，这将限制您添加新类型的自由。所以你看，尽管你可能不喜欢，CRTP 真的 *不* 是每个继承层次结构的替代品。'
- en: 'The second, also potentially very limiting drawback is that everything that
    comes in touch with a CRTP base class becomes a template itself. That is particularly
    true for all functions that work with such a base class. Consider, for instance,
    the upgraded output operator and the `l2norm()` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，同样可能非常限制的缺点是，一旦与 CRTP 基类接触的一切都变成了模板本身。这对所有与这样的基类一起工作的函数特别适用。例如，考虑升级后的输出运算符和
    `l2norm()` 函数：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These two functions should work with all classes deriving from the `DenseVector`
    CRTP class. And of course they should not depend on the concrete types of the
    derived classes. Therefore, these two functions must be function templates: the
    `Derived` type must be deduced. While in the context of a linear algebra library
    this is usually not an issue because almost all functionality is implemented in
    terms of templates anyway, this may be a big downside in other contexts. It might
    be highly undesirable to turn lots of code into templates and move the definitions
    into header files, effectively sacrificing the encapsulation of source files.
    Yes, this may be a severe drawback indeed!'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数应该适用于所有从 `DenseVector` CRTP 类派生的类。当然，它们不应依赖于派生类的具体类型。因此，这两个函数必须是函数模板：必须推导出
    `Derived` 类型。虽然在线性代数库的上下文中，这通常不是问题，因为几乎所有功能都以模板实现，但在其他上下文中可能会有很大的缺点。大量将代码转换为模板并将定义移动到头文件中，实际上是牺牲了源文件的封装性。是的，这可能确实是一个严重的缺点！
- en: 'Third, CRTP is an intrusive design pattern. Deriving classes have to explicitly
    opt in by inheriting from the CRTP base class. While this may be a nonissue in
    our own code, you cannot easily add a base class to foreign code. In such a situation,
    you would have to resort to the Adapter design pattern (see [“Guideline 24: Use
    Adapters to Standardize Interfaces”](#use_adapters_to_standardize_interfaces)).
    Thus, CRTP does not provide the flexibility of nonintrusive design patterns (e.g.,
    the Visitor design pattern implemented with `std::variant`, the Adapter design
    pattern, and so on).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '第三，CRTP 是一种侵入式的设计模式。派生类必须明确选择通过继承 CRTP 基类来参与其中。虽然在我们自己的代码中可能不是问题，但在外部代码中，你不能轻易地添加一个基类。在这种情况下，你将不得不使用适配器设计模式（参见
    [“Guideline 24: Use Adapters to Standardize Interfaces”](#use_adapters_to_standardize_interfaces)）。因此，CRTP
    不具备非侵入式设计模式的灵活性（例如，使用 `std::variant` 实现的访问者设计模式，适配器设计模式等）。'
- en: Last but not least, CRTP does not provide runtime polymorphism, only compile-time
    polymorphism. Therefore, the pattern makes sense only if some kind of static type
    abstraction is required. If not, it is again not a replacement for all inheritance
    hierarchies.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，CRTP 不提供运行时多态性，只提供编译时多态性。因此，该模式仅在需要某种静态类型抽象时才有意义。如果不需要，它再次不能替代所有继承层次结构。
- en: 'The Future of CRTP: A Comparison Between CRTP and C++20 Concepts'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRTP 的未来：CRTP 与 C++20 概念的比较
- en: '“I understand, you’re right. CRTP is pure compile-time polymorphism. However,
    this makes me wonder: wouldn’t it be possible to build on C++20 concepts instead
    of CRTP? Consider the following code. We could use a concept to define the requirements
    for a set of types, and restrict functions and operators to only those types that
    provide the expected interface:”^([19](ch06.xhtml#idm45043094124512))'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: “我明白了，你说得对。CRTP 是纯粹的编译时多态性。然而，这让我想知道：我们是否可以依赖 C++20 概念而不是 CRTP？考虑以下代码。我们可以使用概念来定义一组类型的要求，并将函数和操作符限定为仅接受提供所期望接口的类型：”^([19](ch06.xhtml#idm45043094124512))
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You are absolutely correct. I agree, this is a very reasonable alternative.
    Indeed, C++20 concepts are pretty similar to CRTP but represent an easier, nonintrusive
    alternative. Especially by being nonintrusive, if you have access to C++20 concepts
    and it is possible to define the static set of types by a concept, you should
    prefer the concept over the CRTP.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你完全正确。我同意，这是一个非常合理的替代方案。确实，C++20 概念与 CRTP 非常相似，但代表了一种更简单、非侵入式的选择。特别是通过非侵入性，如果你可以使用
    C++20 概念并且可以通过概念定义静态类型集合，你应该优先选择概念而非 CRTP。
- en: 'Still, I’m not entirely happy with this solution. While this formulation of
    the output operator effectively constrains the function template to only those
    types that provide the expected interface, it does not completely restrict the
    function template to our set of dense vector types. It’s still possible to pass
    `std::vector` and `std::string` (`std::string` already has an output operator
    in the `std` namespace). Therefore, this concept is not specific enough. But if
    you run into this situation, don’t worry: there is a solution using a tag class:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我对这个解决方案并不完全满意。虽然这种输出操作符的表述有效地限制了函数模板仅接受那些提供所期望接口的类型，但它并未完全将函数模板限定为我们的稠密向量类型集合。仍然可以传递
    `std::vector` 和 `std::string`（`std::string` 在 `std` 命名空间中已经有了输出操作符）。因此，这个概念还不够具体。但如果你遇到这种情况，不要担心：使用标签类有解决方案：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'By inheriting (preferably nonpublicly) from the `DenseVectorTag` class ([![22](assets/22.png)](#code_g26_22)),
    classes like `DynamicVector` can identify as being part of a certain set of types
    ([![23](assets/23.png)](#code_g26_23)). Function and operator templates can therefore
    be effectively limited to accept only those types that explicitly opt in to the
    set of types. Unfortunately, there’s a catch: this approach is no longer nonintrusive.
    To overcome this limitation, we introduce a compile-time indirection by a customizable
    type trait class. In other words, we apply the SRP and separate concerns:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 `DenseVectorTag` 类（最好是非公开方式）继承，像 `DynamicVector` 这样的类可以识别为某一类类型的一部分（[![23](assets/23.png)](#code_g26_23)）。因此，函数和操作符模板可以有效地限制为仅接受那些明确选择加入类型集合的类型。不幸的是，这种方法不再是非侵入式的。为了克服这一限制，我们引入了通过可定制的类型特性类进行编译时间接的方法。换句话说，我们应用
    SRP 原则并分离关注点：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `IsDenseVector` class template, along with its corresponding variable template,
    indicates whether a given type is part of the set of dense vector types ([![24](assets/24.png)](#code_g26_24)
    and [![25](assets/25.png)](#code_g26_25)). Instead of directly querying a given
    type, the `DenseVector` concept would ask indirectly via the `IsDenseVector` type
    trait ([![26](assets/26.png)](#code_g26_26)). This opens up the opportunity for
    classes to either intrusively derive from the `DenseVectorTag` ([![27](assets/27.png)](#code_g26_27))
    or to nonintrusively specialize the `IsDenseVector` type trait ([![28](assets/28.png)](#code_g26_28)).
    In this form, the concepts approach truly supersedes the classic CRTP approach.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsDenseVector` 类模板及其对应的变量模板，指示给定类型是否属于稠密向量类型集合（[![24](assets/24.png)](#code_g26_24)
    和 [![25](assets/25.png)](#code_g26_25)）。而不是直接查询给定类型，`DenseVector` 概念会通过 `IsDenseVector`
    类型特性间接询问（[![26](assets/26.png)](#code_g26_26)）。这为类提供了两种选择：要么通过侵入式继承自 `DenseVectorTag`（[![27](assets/27.png)](#code_g26_27)），要么通过非侵入式方式专门化
    `IsDenseVector` 类型特性（[![28](assets/28.png)](#code_g26_28)）。这种形式下，概念方法真正超越了经典的
    CRTP 方法。'
- en: In summary, CRTP is an amazing design pattern for defining a compile-time relationship
    between a family of related types. Most interestingly, it resolves all performance
    issues that you may have with inheritance hierarchies. However, CRTP comes with
    a couple of potentially limiting drawbacks, such as the lack of a common base
    class, the quick spreading of template code, and the restriction to compile-time
    polymorphism. With C++20, consider replacing CRTP with concepts, which provide
    an easier and nonintrusive alternative. However, if you do not have access to
    C++20 concepts and if CRTP fits, it will prove immensely valuable to you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，CRTP 是一个了不起的设计模式，用于定义一组相关类型之间的编译时关系。最有趣的是，它解决了继承层次结构可能带来的所有性能问题。然而，CRTP
    也带来了一些潜在的限制性缺点，例如缺乏共同的基类、模板代码的快速传播以及限制于编译时多态性。使用 C++20，考虑将 CRTP 替换为概念，这提供了一个更简单且非侵入式的替代方案。但是，如果你没有使用
    C++20 概念的机会，并且 CRTP 适合你的情况，它将为你证明其极大的价值。
- en: 'Guideline 27: Use CRTP for Static Mixin Classes'
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南 27：使用 CRTP 实现静态 Mixin 类
- en: 'In [“Guideline 26: Use CRTP to Introduce Static Type Categories”](#use_crtp_to_introduce_static_type_categories),
    I introduced you to the CRTP design pattern. I may also have given you the impression
    that CRTP is old hat, made obsolete by the advent of C++20 concepts. Well, interestingly
    it is not. At least not entirely. That’s because I haven’t told you the complete
    story yet. CRTP may still be of value: just not as a design pattern but as an
    *implementation pattern*. So let’s take a detour into the realm of implementation
    patterns and let me explain.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“指南 26：使用 CRTP 引入静态类型类别”](#use_crtp_to_introduce_static_type_categories)
    中，我向你介绍了 CRTP 设计模式。我可能也给你留下了一个印象，即 CRTP 是老掉牙的，已经被 C++20 概念取代。然而有趣的是，并非完全如此。这是因为我还没有完全告诉你全部情况。CRTP
    仍然可能有价值：只是不再作为设计模式，而是作为*实现模式*。因此，让我们先进入实现模式的领域，让我解释一下。
- en: A Strong Type Motivation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强类型的动机
- en: Consider the following `StrongType` class template, which represents a wrapper
    around any other type for the purpose of creating a unique, named type:^([20](ch06.xhtml#idm45043093413808))
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的 `StrongType` 类模板，它代表了任何其他类型的包装，用于创建一个独特的、命名的类型：^([20](ch06.xhtml#idm45043093413808))
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This class can, for instance, be used to define the types `Meter`, `Kilometer`,
    and `Surname`:^([21](ch06.xhtml#idm45043093286096))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个类可以用来定义 `Meter`、`Kilometer` 和 `Surname` 类型：^([21](ch06.xhtml#idm45043093286096))
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The use of alias templates for `Meter` and `Kilometer` enables you to choose,
    for instance, `long` or `double` to represent a distance. However, although these
    types are built on fundamental types or Standard Library types, such as `std::string`
    in the case of `Surname`, they represent distinct types (strong types) with semantic
    meaning that cannot be (accidentally) combined in arithmetic operations, for example,
    addition:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用别名模板来表示`Meter`和`Kilometer`可以使您选择`long`或`double`来表示距离。然而，尽管这些类型建立在基本类型或标准库类型上（例如`Surname`的情况下是`std::string`），它们代表具有语义意义的不同类型（强类型），不会（意外地）在算术操作中结合，例如加法：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Although both `Meter` and `Kilometer` are represented via `long`, it isn’t
    possible to directly add `Meter` and `Kilometer` together ([![1](assets/1.png)](#code_g27_1)).
    This is great: it doesn’t leave any opening for accidental bugs to crawl in. It’s
    also not possible to add two `Surname`s, although `std::string` provides an addition
    operator for string concatenation ([![2](assets/2.png)](#code_g27_2)). But this
    is also great: the strong type effectively restricts undesired operations of the
    underlying type. Unfortunately, this “feature” also prevents the addition of two
    `Meter` instances ([![3](assets/3.png)](#code_g27_3)). This operation would be
    desirable, though: it is intuitive, natural, and since the result of the operation
    would again be of type `Meter`, physically accurate. To make this work, we could
    implement an addition operator for the `Meter` type. However, obviously, this
    would not remain the only addition operator. We would also need one for all the
    other strong types, such as `Kilometer`, `Mile`, `Foot`, etc. Since all of these
    implementations would look the same, this would be a violation of the DRY principle.
    Therefore, it appears to be reasonable to extend the `StrongType` class template
    with an addition operator:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Meter`和`Kilometer`都用`long`表示，但不能直接将它们加在一起（[![1](assets/1.png)](#code_g27_1)）。这很好：它不留下任何意外错误的可能。对于字符串连接，虽然`std::string`提供了加法操作符，但两个`Surname`也不能相加（[![2](assets/2.png)](#code_g27_2)）。但这也是好事：强类型有效地限制了底层类型的不必要操作。不幸的是，这种“特性”也阻止了两个`Meter`实例的相加（[![3](assets/3.png)](#code_g27_3)）。尽管如此，这个操作是可取的：它直观自然，并且由于操作的结果再次是`Meter`类型，因此在物理上是准确的。为了使其工作，我们可以为`Meter`类型实现加法操作符。然而显然，这不会是唯一的加法操作符。我们还需要为所有其他强类型实现一个加法操作符，如`Kilometer`、`Mile`、`Foot`等。由于所有这些实现看起来都一样，这违反了DRY原则。因此，将`StrongType`类模板扩展为加法操作符似乎是合理的：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Whereas due to the formulation of this addition operator it is not possible
    to add two different instantiations of `StrongType` together (e.g., `Meter` and
    `Kilometer`), it would enable the addition of two instances of the same instantiation
    of `StrongType`. “Oh, but I see a problem: while it would now be possible to add
    two `Meter`s or two `Kilometer`s, it would also be possible to add two `Surname`s.
    We don’t want that!” You are correct: this would be undesirable. What we need
    instead is a deliberate addition of operations to specific instantiations of `StrongType`.
    This is where CRTP comes into play.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个加法操作符的制定，不能将两个不同实例化的`StrongType`（例如`Meter`和`Kilometer`）相加，但可以对相同实例化的两个实例进行加法。"哦，但我看到一个问题：虽然现在可以添加两个`Meter`或两个`Kilometer`，但也可以添加两个`Surname`。我们不希望这样！”
    您是正确的：这是不可取的。我们需要的是对特定实例化的`StrongType`进行有意义的操作添加。这就是CRTP发挥作用的地方。
- en: Using CRTP as an Implementation Pattern
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CRTP作为实现模式
- en: 'Instead of directly equipping the `StrongType` class template with operations,
    we provide the operations via *mixin* classes: base classes that “inject” the
    desired operations. These mixin classes are implemented in terms of the CRTP.
    Consider, for instance, the `Addable` class template, which represents the addition
    operation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相比直接在`StrongType`类模板中添加操作，我们通过*mixin*类来提供操作：这些基类“注入”所需的操作。这些mixin类是通过CRTP实现的。例如，考虑`Addable`类模板，它表示加法操作：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The name of the template parameters gives it away: `Addable` is a CRTP base
    class. `Addable` provides only two functions, implemented as [hidden friends](https://oreil.ly/QmrTG):
    an addition assignment operator ([![4](assets/4.png)](#code_g27_4)) and an addition
    operator ([![5](assets/5.png)](#code_g27_5)). Both operators are defined for the
    specified `Derived` type and are injected into the surrounding namespace.^([22](ch06.xhtml#idm45043092685280))
    Thus, any class deriving from this CRTP base class will “inherit” two free addition
    operators:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数的名称揭示了它的作用：`Addable`是一个CRTP基类。`Addable`仅提供两个函数，作为[hidden friends](https://oreil.ly/QmrTG)实现：一个加法赋值运算符（参见[![4](assets/4.png)](#code_g27_4)）和一个加法运算符（参见[![5](assets/5.png)](#code_g27_5)）。这两个运算符都为指定的`Derived`类型定义，并注入到周围的命名空间中。^([22](ch06.xhtml#idm45043092685280))
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: “I understand the purpose of the mixin class, but in this form, *all* instantiations
    of `StrongType` would inherit an addition operator, even the ones where an addition
    is not required, right?” Yes, indeed. Therefore, we aren’t finished yet. What
    we want to do is to selectively add the mixin class to those `StrongType` instantiations
    that need the operation. Our solution of choice is to provide the mixins in the
    form of optional template arguments. For that purpose, we extend the `StrongType`
    class template by a pack of variadic template template parameters:^([23](ch06.xhtml#idm45043092620528))
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: “我理解混合类的用途，但在这种形式下，*所有*`StrongType`的实例化都会继承加法运算符，即使在不需要加法的情况下也是如此，对吧？” 是的，确实如此。因此，我们还没有完成。我们想要的是仅向那些需要该操作的`StrongType`实例化中选择性地添加混合类。我们的选择解决方案是提供可选的模板参数形式的混合类。为此，我们通过一组可变模板模板参数扩展了`StrongType`类模板：^([23](ch06.xhtml#idm45043092620528))
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This extension enables us to individually specify, for each single strong type,
    which skills are desired. Consider, for instance, the two additional skills `Printable`
    and `Swappable`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展使我们能够为每个单独的强类型单独指定所需的技能。例如，考虑两个额外的技能`Printable`和`Swappable`：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Together with the `Addable` skill, we can now assemble strong types equipped
    with the required and desired skills:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Addable`技能一起，我们现在可以组装具备所需和期望技能的强类型：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Both `Meter` and `Kilometer` can be added, printed, and swapped (see [![6](assets/6.png)](#code_g27_6)
    and [![7](assets/7.png)](#code_g27_7)), while `Surname` is printable and swappable,
    but not addable (i.e., does not receive the `Addable` mixin and therefore does
    not derive from it) ([![8](assets/8.png)](#code_g27_8)).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meter`和`Kilometer`都可以相加、打印和交换（参见[![6](assets/6.png)](#code_g27_6)和[![7](assets/7.png)](#code_g27_7)），而`Surname`可以打印和交换，但不能相加（即不接收`Addable`混合，因此不继承自它）（参见[![8](assets/8.png)](#code_g27_8)）。'
- en: “That’s great. I understand the purpose of the CRTP mixin class in this context.
    But how is this CRTP example different from previous examples?” Very good question.
    You’re right, the implementation details are very similar. But there are a couple
    of distinctive differences. Note that the CRTP base class doesn’t provide a `virtual`
    or `protected` destructor. Hence, in contrast to previous examples, it is not
    designed as a polymorphic base class. Also note that in this example it is sufficient,
    and even preferable, to use the CRTP base class as a `private` base class, not
    a `public` one ([![9](assets/9.png)](#code_g27_9)).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: “太好了。我理解了在这种上下文中CRTP混合类的目的。但是这个CRTP示例与先前的示例有何不同？” 非常好的问题。你说得对，实现细节非常相似。但是有几个显著的区别。请注意，CRTP基类不提供虚拟或受保护的析构函数。因此，与先前的示例相比，在这个例子中将CRTP基类用作私有基类足以甚至更可取。
    （参见[![9](assets/9.png)](#code_g27_9)）
- en: Thus, in this context, the CRTP base class does not represent an abstraction
    but only an implementation detail. Therefore, the CRTP does not fulfill the properties
    of a design pattern, and it does not act as a design pattern. It’s still a pattern,
    no question there, but it merely acts as an implementation pattern in this case.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，CRTP基类并不代表一种抽象，而仅仅是一种实现细节。因此，CRTP不满足设计模式的属性，也不起到设计模式的作用。它仍然是一种模式，毫无疑问，但在这种情况下仅充当实现模式。
- en: 'The major difference in the implementation of the CRTP examples is the way
    we use inheritance. For the CRTP design pattern, we use inheritance as an abstraction
    according to the LSP: the base class represents the requirements, and thus the
    available and expected behavior of the derived class. User code directly accesses
    the operations via pointers or references to the base class, which in turn requires
    us to provide a `virtual` or `protected` destructor. When implemented this way,
    CRTP becomes a true element of software design—a design pattern.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在CRTP示例的实现中，主要差异在于我们使用继承的方式。对于CRTP设计模式，我们根据LSP使用继承作为抽象：基类代表了要求以及派生类可用和预期的行为。用户代码直接通过指针或引用访问操作，这反过来要求我们提供`virtual`或`protected`析构函数。以这种方式实现时，CRTP成为软件设计的真正元素——一种设计模式。
- en: 'In contrast, for the CRTP implementation pattern, we use inheritance for technical
    elegance and convenience. The base class becomes an implementation detail and
    does not have to be known or used by calling code. Therefore, it doesn’t need
    a `virtual` or `protected` destructor. When implemented this way, CRTP stays on
    the level of the implementation details and therefore is an implementation pattern.
    In this form, however, CRTP does not compete with C++20 concepts. On the contrary:
    in this form CRTP is unchallenged, as it represents a unique technique to provide
    static mixin functionality. For that reason, CRTP is still in use today and represents
    a valuable addition to every C++ developer’s toolbox.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，对于CRTP实现模式，我们使用继承来实现技术上的优雅和方便。基类成为实现细节，不需要被调用代码知道或使用。因此，它不需要`virtual`或`protected`析构函数。当以这种方式实现时，CRTP保持在实现细节的层面上，因此是一种实现模式。然而，以这种形式实现的CRTP不与C++20概念竞争。相反，在这种形式下，CRTP无可匹敌，因为它代表了提供静态mixin功能的独特技术。因此，CRTP至今仍然被使用，并且是每个C++开发者工具箱中的宝贵补充。
- en: In summary, CRTP is not obsolete, but its value has changed. In C++20, CRTP
    is replaced by concepts and therefore is stepping down as a design pattern. However,
    it continues to be valuable as an implementation pattern for mixin classes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，CRTP并非过时，但其价值已经发生了变化。在C++20中，CRTP被概念取代，因此作为一种设计模式逐渐退出。然而，它继续作为mixin类的实现模式非常有价值。
- en: ^([1](ch06.xhtml#idm45043101334880-marker)) The Pages format is Apple’s equivalent
    to Microsoft’s Word format.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#idm45043101334880-marker)) Pages格式是苹果公司对应微软Word格式的等效产品。
- en: '^([2](ch06.xhtml#idm45043101092960-marker)) Erich Gamma et al., *Design Patterns:
    Elements of Reusable Object-Oriented Software*.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.xhtml#idm45043101092960-marker)) Erich Gamma等人，《设计模式：可复用面向对象软件的基础》。
- en: ^([3](ch06.xhtml#idm45043100929584-marker)) If you’re an expert on design patterns,
    you might realize that a 1-to-*N* Adapter has a certain similarity to the Facade
    design pattern. See the GoF book for more details.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.xhtml#idm45043100929584-marker)) 如果你是设计模式的专家，你可能会意识到1对*N*适配器与Facade设计模式有一定的相似性。详细信息请参阅GoF书籍。
- en: ^([4](ch06.xhtml#idm45043100781216-marker)) In C++20, you achieve a similar
    effect by applying the [`[[no_unique_address]]`](https://oreil.ly/H41V8) attribute
    to a data member. If the data member is empty, it might not occupy any storage
    on its own.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.xhtml#idm45043100781216-marker)) 在C++20中，通过将[`[[no_unique_address]]`](https://oreil.ly/H41V8)属性应用于数据成员，可以实现类似的效果。如果数据成员为空，它可能不会单独占用任何存储空间。
- en: ^([5](ch06.xhtml#idm45043100261104-marker)) In this context, it’s particularly
    interesting to note that `std::stack` doesn’t allow you to traverse the elements
    via iterators. As usual for a stack, you’re allowed to access only the topmost
    element.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.xhtml#idm45043100261104-marker)) 在这种情况下，特别有趣的是注意到`std::stack`不允许通过迭代器遍历元素。与堆栈一样，你只能访问顶部元素。
- en: '^([6](ch06.xhtml#idm45043099971744-marker)) Matthew Wilson, *Imperfect C++:
    Practical Solutions for Real-Life Programming* (Addison-Wesley, 2004).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '^([6](ch06.xhtml#idm45043099971744-marker)) Matthew Wilson，《Imperfect C++:
    Practical Solutions for Real-Life Programming》（Addison-Wesley，2004年）。'
- en: '^([7](ch06.xhtml#idm45043099966256-marker)) Eric Freeman and Elisabeth Robson,
    [*Head First Design Patterns: Building Extensible and Maintainable Object-Oriented
    Software*](https://learning.oreilly.com/library/view/head-first-design/9781492077992/)
    (O’Reilly, 2021).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '^([7](ch06.xhtml#idm45043099966256-marker)) Eric Freeman和Elisabeth Robson，《Head
    First Design Patterns: Building Extensible and Maintainable Object-Oriented Software》（O’Reilly，2021年）。'
- en: ^([8](ch06.xhtml#idm45043099762144-marker)) Of course, you know better than
    to try this at home, but let’s assume this is one of those strange, Monday-morning
    management decisions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch06.xhtml#idm45043099762144-marker)) 当然，你知道不能在家里尝试这个，但让我们假设这是一种那些奇怪的、星期一早晨的管理决策之一。
- en: '^([9](ch06.xhtml#idm45043099265856-marker)) Erich Gamma et al., *Design Patterns:
    Elements of Reusable Object-Oriented Software*.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch06.xhtml#idm45043099265856-marker)) Erich Gamma等人，《设计模式：可复用面向对象软件的元素》。
- en: ^([10](ch06.xhtml#idm45043099207840-marker)) Despite the fact that I don’t venture
    into the thicket of Observer implementation details, I can still give you a few
    references on how to implement Observers. A good overview on many of the implementation
    aspects is Victor Ciura’s CppCon 2021 talk [“Spooky Action at a Distance”](https://oreil.ly/9TcK6).
    A very detailed discussion on how to deal with the concurrency issues of the `Observer`
    pattern can be found in Tony Van Eerd’s C++Now 2016 talk [“Thread-Safe Observer
    Pattern—You’re Doing It Wrong”](https://oreil.ly/KKU47).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch06.xhtml#idm45043099207840-marker)) 尽管我不深入研究观察者模式的实现细节，但我仍然可以为你提供一些关于如何实现观察者的参考资料。关于许多实现方面的良好概述可以在Victor
    Ciura的CppCon 2021演讲[“Spooky Action at a Distance”](https://oreil.ly/9TcK6)中找到。关于如何处理`Observer`模式的并发问题的非常详细的讨论可以在Tony
    Van Eerd的C++Now 2016演讲[“Thread-Safe Observer Pattern—You’re Doing It Wrong”](https://oreil.ly/KKU47)中找到。
- en: ^([11](ch06.xhtml#idm45043099160560-marker)) If you’re aware of the [Non-Virtual
    Interface (NVI)](https://oreil.ly/mqwgp) idiom or the Template Method design pattern,
    then please feel free to move this virtual function into the `private` section
    of the class and provide a public, nonvirtual wrapper function for it. You can
    find more information about NVI in Herb Sutter’s [Guru of the Week blog](http://www.gotw.ca)
    or in the article [“Virtuality”](https://oreil.ly/GSdnB) from the *C++ Users Journal*,
    19(9), September 2001.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch06.xhtml#idm45043099160560-marker)) 如果你熟悉[非虚拟接口（NVI）](https://oreil.ly/mqwgp)惯用语或模板方法设计模式，那么请随意将这个虚函数移动到类的`private`部分，并为它提供一个公共的、非虚拟的包装函数。你可以在Herb
    Sutter的[Guru of the Week blog](http://www.gotw.ca)中或者*C++ Users Journal*第19卷第9期（2001年9月）的文章["Virtuality"](https://oreil.ly/GSdnB)中找到关于NVI的更多信息。
- en: ^([12](ch06.xhtml#idm45043098985312-marker)) Alternatively, the observer could
    also remember the subject on its own.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch06.xhtml#idm45043098985312-marker)) 或者，观察者也可以自己记住主题。
- en: ^([13](ch06.xhtml#idm45043096802160-marker)) You can also choose to build on
    `gsl::not_null<T>` from the [Guideline Support Library (GSL)](https://oreil.ly/cx0Jd).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch06.xhtml#idm45043096802160-marker)) 您还可以选择使用来自[指南支持库（GSL）](https://oreil.ly/cx0Jd)的`gsl::not_null<T>`。
- en: '^([14](ch06.xhtml#idm45043096784000-marker)) If you’re wondering what those
    others stand for: RAII: Resource Acquisition Is Initialization (which is argued
    to be the most valuable idea of C++, but at the same time is officially the worst
    acronym; it literally does not make any sense); ADL: Argument Dependent Lookup;
    CTAD: Class Template Argument Deduction; SFINAE: Substitution Failure Is Not An
    Error; NTTP: Non-Type Template Parameter; IFNDR: Ill-Formed, No Diagnostic Required;
    SIOF: Static Initialization Order Fiasco. For an overview of (almost) all C++
    acronyms, see [Arthur O’Dwyer’s blog](https://oreil.ly/36Gnd).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch06.xhtml#idm45043096784000-marker)) 如果你想知道这些缩写代表什么：RAII：资源获取即初始化（被认为是C++中最有价值的理念，但同时也是官方最糟糕的首字母缩略词；它实际上毫无意义）；ADL：参数相关查找；CTAD：类模板参数推断；SFINAE：替换失败不是错误；NTTP：非类型模板参数；IFNDR：格式错误，无需诊断；SIOF：静态初始化顺序混乱。有关（几乎）所有C++缩写的概述，请参见[Arthur
    O’Dwyer的博客](https://oreil.ly/36Gnd)。
- en: '^([15](ch06.xhtml#idm45043096781776-marker)) Ah, the [*C++ Report*](https://oreil.ly/HJIKc)—such
    glorious times! However, you may be one of the poor souls who never had an opportunity
    to read an original *C++ Report*. If so, you should know that it was a bimonthly
    computer magazine published by the SIGS Publications Group between 1989 and 2002\.
    The original *C++ Report* is hard to come by these days, but many of its articles
    have been collected in the book edited by Stanley Lippmann *C++ Gems: Programming
    Pearls from the C++ Report* (Cambridge University Press). This book includes James
    Coplien’s article “Curiously Recurring Template Patterns.”'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '^([15](ch06.xhtml#idm45043096781776-marker)) 啊，[*C++ Report*](https://oreil.ly/HJIKc)——那些辉煌的岁月！然而，你可能是那些从未有机会阅读原始*C++
    Report*的可怜人之一。如果是这样的话，你应该知道，它是由SIGS Publications Group在1989年至2002年间出版的一个双月刊计算机杂志。原始的*C++
    Report*如今很难找到，但其中许多文章已经被收录在由Stanley Lippmann编辑的书籍*C++ Gems: Programming Pearls
    from the C++ Report*（剑桥大学出版社）中。这本书包括了James Coplien的文章“Curiously Recurring Template
    Patterns”。'
- en: '^([16](ch06.xhtml#idm45043095642896-marker)) If you can’t use C++20 concepts
    yet, `std::enable_if` provides an alternative formulation. Refer to [Core Guideline
    T.48](https://oreil.ly/K2ljM): “If your compiler does not support concepts, fake
    them with `enable_if`.” See also your preferred C++ templates reference.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch06.xhtml#idm45043095642896-marker)) 如果你还不能使用 C++20 概念，`std::enable_if`
    提供了一个替代方案。请参阅[核心指南 T.48](https://oreil.ly/K2ljM)：“如果你的编译器不支持概念，请用 `enable_if`
    模拟它们。”同时也查阅你喜欢的 C++ 模板参考资料。
- en: '^([17](ch06.xhtml#idm45043095164048-marker)) Consider any kind of cast (`static_cast`,
    `reinterpret_cast`, `const_cast`, `dynamic_cast`, and especially the old C-style
    casts) as adult features: you take full responsibility of your actions and the
    compiler will obey. Therefore, it is seriously advisable to reduce calls to cast
    operators (see also [Core Guideline ES.48](https://oreil.ly/ZEE0P): “Avoid casts”).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch06.xhtml#idm45043095164048-marker)) 将任何类型的转换（`static_cast`、`reinterpret_cast`、`const_cast`、`dynamic_cast`，特别是旧式的
    C 风格转换）视为成年特性：你需对自己的行为负全责，而编译器则会遵循。因此，强烈建议减少对转换操作符的调用（另请参阅[核心指南 ES.48](https://oreil.ly/ZEE0P)：“避免使用转换”）。
- en: ^([18](ch06.xhtml#idm45043094873184-marker)) This is a great example to demonstrate
    that it pays off to be able to compile your codebase with several major compilers
    (Clang, GCC, MSVC, etc.). Different error messages might help you find the source
    of the problem. Using only one compiler should be considered a risk!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch06.xhtml#idm45043094873184-marker)) 这是一个很好的例子，展示了能够在几个主要编译器（如Clang、GCC、MSVC等）上编译代码库是值得的。不同的错误消息可能帮助你找到问题的源头。只使用一个编译器应被视为一种风险！
- en: ^([19](ch06.xhtml#idm45043094124512-marker)) If you aren’t familiar with the
    idea or syntax of C++20 concepts yet, you can get a quick and painless introduction
    in Sándor Dargó’s *C++ Concepts*, published at [Leanpub](https://leanpub.com/cppconcepts).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch06.xhtml#idm45043094124512-marker)) 如果你对 C++20 概念的思想或语法不熟悉，你可以在 Sándor
    Dargó 的*C++ Concepts*中快速无痛地入门，该书由[Leanpub](https://leanpub.com/cppconcepts)出版。
- en: '^([20](ch06.xhtml#idm45043093413808-marker)) This implementation of a `StrongType`
    is inspired by Jonathan Boccara’s [Fluent C++ blog](https://oreil.ly/Tqafn) and
    the associated [NamedType library](https://oreil.ly/F5JO6). There are several
    more strong type libraries available, though: alternatively you can use Jonathan
    Müller’s [*type_safe* library](https://oreil.ly/Bju8Z), Björn Fahller’s [*strong_type*
    library](https://oreil.ly/bxJrf), or Anthony William’s [*strong_typedef* library](https://oreil.ly/q58u6).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch06.xhtml#idm45043093413808-marker)) 这种`StrongType`的实现灵感来源于Jonathan
    Boccara的[Fluent C++ 博客](https://oreil.ly/Tqafn)和相关的[NamedType 库](https://oreil.ly/F5JO6)。还有几个更多的强类型库可供选择：你也可以使用Jonathan
    Müller的[*type_safe* 库](https://oreil.ly/Bju8Z)、Björn Fahller的[*strong_type* 库](https://oreil.ly/bxJrf)，或者Anthony
    William的[*strong_typedef* 库](https://oreil.ly/q58u6)。
- en: ^([21](ch06.xhtml#idm45043093286096-marker)) The only technical oddity is the
    declaration of a tag class right in the template parameter list. Yes, this works,
    and definitely helps create a unique type for the purpose of instantiating distinct
    strong types.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch06.xhtml#idm45043093286096-marker)) 技术上唯一的奇特之处是在模板参数列表中声明标签类。是的，这样做是有效的，并且绝对有助于为实例化不同强类型创建独特的类型。
- en: ^([22](ch06.xhtml#idm45043092685280-marker)) Many years ago, more specifically
    at the end of the ’90s, this kind of namespace injection was called the *Barton-Nackman
    trick*, named after John J. Barton and Lee R. Nackman. In the March 1995 issue
    of the *C++ Report*, they used namespace injection as a workaround for the limitation
    that function templates could not be overloaded at the time. Surprisingly, today
    this technique has experienced a renaissance as the *hidden friend idiom*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ^([22](ch06.xhtml#idm45043092685280-marker)) 多年前，更具体地说是在90年代末，这种命名空间注入被称为*Barton-Nackman
    技巧*，以John J. Barton和Lee R. Nackman的名字命名。在1995年3月的*C++ Report*期刊中，他们使用命名空间注入作为当时无法重载函数模板的一种解决方法。令人惊讶的是，今天这种技术已经复兴，成为*隐藏友元惯用法*。
- en: ^([23](ch06.xhtml#idm45043092620528-marker)) In [Jonathan Bocarra’s blog](https://oreil.ly/jefQD),
    these optional, variadic arguments are aptly called *skills*. I very much like
    this, so I adopt this naming convention.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ^([23](ch06.xhtml#idm45043092620528-marker)) 在[Jonathan Bocarra 的博客](https://oreil.ly/jefQD)中，这些可选的、可变参数被恰当地称为*技能*。我非常喜欢这个说法，因此我采纳了这个命名约定。
