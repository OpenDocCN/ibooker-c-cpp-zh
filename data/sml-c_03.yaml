- en: Chapter 3\. Flow of Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。控制流
- en: Now that you have seen the basic format of a statement in C, it’s time to start
    branching out…pun intended. In code, the idea of making decisions and then selecting
    a particular bit of code to run instead of some other bit of code is often referred
    to as *branching* or *conditional branching*. And repetition is often discussed
    in terms of *looping* or *iterating*. Collectively, branching and looping statements
    comprise the *flow of control* in a language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了C语言语句的基本格式，是时候开始展开了……打趣一下。在代码中，做出决策然后选择要运行的特定代码而不是其他代码片段的概念通常称为*分支*或*条件分支*。而重复则经常以*循环*或*迭代*的术语来讨论。总体来说，分支和循环语句组成了语言中的*控制流*。
- en: Some problems can be solved with a simple series of linear steps. Many programs
    that automate various computer tasks work just this way, taking a tedious routine
    and reducing that to a single app you can run whenever you need it. But programs
    can do much more than just process a batch of commands. They can make decisions
    based on the values in a variable or the state of a sensor. They can repeat tasks
    like turn on every LED in a string of lights or process every line in a log file.
    And they can combine the decision-making and repetition in complex, nested ways
    that allow you as the programmer to solve just about any problem you can think
    of. In this chapter we’ll look at how C implements these concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题可以通过一系列简单的线性步骤来解决。许多自动化各种计算机任务的程序就是这样工作的，将一个繁琐的例行程序简化成你需要时可以运行的单个应用程序。但程序可以做的远不止处理一批命令。它们可以根据变量的值或传感器的状态做出决策。它们可以重复任务，例如打开一串灯中的每个LED或处理日志文件中的每一行。它们还可以以复杂、嵌套的方式结合决策和重复，使您作为程序员能够解决几乎任何可以想到的问题。在本章中，我们将探讨C语言如何实现这些概念。
- en: Boolean Values
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: To ask a question in C, you typically compare two (or more) things. C has several
    operators meant for just this task. You can check to see if two things are the
    same. You can check to see if two things are not the same. You can see if some
    value is less than or greater than some other value.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C语言中提出问题，通常需要比较两个（或更多）事物。C语言有几个专门用于此任务的运算符。您可以检查两个事物是否相同。您可以检查两个事物是否不同。您可以查看某个值是否小于或大于另一个值。
- en: 'When you ask questions like “is x the same as y,” you get a yes or no, true
    or false answer. In computer science, these are called Boolean values, after George
    Boole, who worked to formalize a system of logical operations and outcomes. Some
    languages have an actual type for Boolean values and variables, but C mostly uses
    integers: 0 is false/no and 1 is true/yes.^([1](ch03.xhtml#idm45018734452728))'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当您像“x是否与y相同”这样提出问题时，您会得到一个是或否、真或假的答案。在计算机科学中，这些称为布尔值，源自乔治·布尔（George Boole），他致力于形式化逻辑操作和结果的系统。一些语言具有布尔值和变量的实际类型，但C语言主要使用整数：0表示假/否，1表示真/是。^([1](ch03.xhtml#idm45018734452728))
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, any value in C that is not 0 is true. So 1 is true, 2 is true,
    –18 is true, etc. I’ll point out anytime I perform a check that relies on this
    fact. It can be convenient, and you will definitely see it used in the real world,
    but I’ll be concentrating on performing explicit comparisons wherever I can.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，任何非0的值都表示为真。因此，1是真，2是真，-18是真，等等。我会指出每当我执行依赖于这一事实的检查时。这可能很方便，在现实世界中您肯定会看到它被使用，但我会集中精力在尽可能进行显式比较上。
- en: Comparison Operators
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Math, of course, is not the only thing computers are good at. When we get into
    writing more complex programs, we’ll need the ability to make decisions about
    the state of our system. We’ll need to compare variables against desired values
    and safeguard against error conditions. We’ll need to detect the end of lists
    and other data structures. Happily, all of these requirements can be accommodated
    with C’s comparison operators.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数学，当然，并不是计算机擅长的唯一领域。当我们开始编写更复杂的程序时，我们将需要能够对系统状态做出决策。我们需要比较变量与期望值，并防范错误条件。我们需要检测列表的末尾和其他数据结构。幸运的是，所有这些需求都可以通过C语言的比较运算符来实现。
- en: C defines six operators (shown in [Table 3-1](#smallerc-CHP-3-TABLE-comparison-ops))
    that can be used to compare values. We use these operators much like we used the
    mathematical operators from [Table 2-6](ch02.xhtml#smallerc-CHP-2-TABLE-math-ops).
    You have a variable or value or expression on the left, the operator, and a variable
    or value or expression on the right. The difference here is that the result of
    using a comparison operator is always a Boolean `int`, meaning it is always a
    `1` or a `0`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C定义了六个运算符（如表3-1所示），可用于比较值。我们使用这些运算符就像我们使用[表2-6](ch02.xhtml#smallerc-CHP-2-TABLE-math-ops)中的数学运算符一样。你在左边有一个变量、值或表达式，在右边有一个变量、值或表达式。这里的区别是使用比较运算符的结果始终是一个布尔`int`，意味着它总是`1`或`0`。
- en: Table 3-1\. Comparison operators
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-1\. 比较运算符
- en: '| Operator | Comparison |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 比较 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `==` | Is equal to |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 |'
- en: '| `!=` | Is not equal to |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 |'
- en: '| `<` | Is less than |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `>` | Is greater than |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `<=` | Is less than or equal to |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于或等于 |'
- en: '| `>=` | Is greater than or equal to |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于或等于 |'
- en: In C, the comparison operators work on characters, integers, and floating point
    numbers. Some languages support operators that work on more complex bits of data
    like arrays (I’ll cover these in [Chapter 4](ch04.xhtml#smallerc-CHP-4)), records,
    or objects, but C uses functions (covered in [Chapter 5](ch05.xhtml#smallerc-CHP-5))
    to do that type of work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，比较运算符适用于字符、整数和浮点数。一些语言支持可以处理更复杂数据位如数组（我将在[第四章](ch04.xhtml#smallerc-CHP-4)中介绍），记录或对象的运算符，但是C语言使用函数（在[第五章](ch05.xhtml#smallerc-CHP-5)中介绍）来完成这类工作。
- en: When comparing two expressions of the same type, you can use the operators in
    [Table 3-1](#smallerc-CHP-3-TABLE-comparison-ops) without really thinking about
    it. If you compare expressions of different types, say a `float` variable and
    an `int` value, the same notion of implicit casting (see [Figure 2-4](ch02.xhtml#smallerc-CHP-2-FIG-promotions))
    applies and the value with the “lower” type will be promoted before being compared.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较两个相同类型的表达式时，你可以毫不费力地使用表3-1中的运算符（见[表3-1](#smallerc-CHP-3-TABLE-comparison-ops)）。如果你比较不同类型的表达式，比如一个`float`变量和一个`int`值，那么隐式转换的概念（见[图2-4](ch02.xhtml#smallerc-CHP-2-FIG-promotions)）将适用，并且较低的类型值在比较之前会被提升。
- en: 'We’ll put these comparison operators to use shortly in [“Branching”](#smallerc-CHP-3-SECT-2)
    and [“Loop Statements”](#smallerc-CHP-3-SECT-3), but we can take a quick detour
    and show the 0-or-1 results with some simple print statements. Consider [*ch03/booleans.c*](https://oreil.ly/2dSZx):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们马上会在[“分支”](#smallerc-CHP-3-SECT-2)和[“循环语句”](#smallerc-CHP-3-SECT-3)中使用这些比较运算符，但是我们可以快速转到简单的打印语句，展示0或1的结果。考虑[*ch03/booleans.c*](https://oreil.ly/2dSZx)：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Go ahead and compile that file and run it. You should see output similar to
    this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编译该文件并运行它。你应该看到类似于这样的输出：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see here that a “true” comparison results in a `1`, as I noted before.
    Conversely, “false” is a `0` behind the scenes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到“真”比较的结果为`1`时，如我之前所述。相反，“假”在幕后为`0`。
- en: Logical Operators
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Some questions we want to ask in our code cannot be reduced to a single comparison.
    A very popular question, for example, is to ask if a variable is within a range
    of values. We need to know if the variable in question is *both* greater than
    some minimum value *and* also less than some maximum. C does not have the kinds
    of operators that create ranges or that test for membership in such ranges. But
    C does support logical operators (sometimes you’ll hear about Boolean operators)
    to help you build up logic expressions that can be quite complex.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中想要询问的一些问题不能简化为单个比较。一个非常常见的问题，例如，是询问一个变量是否在某些值的范围内。我们需要知道所讨论的变量是否*既*大于某个最小值*又*小于某个最大值。C语言没有创建范围或测试成员资格的运算符。但是C支持逻辑运算符（有时你会听说布尔运算符），以帮助你构建相当复杂的逻辑表达式。
- en: To get started, look at the operators in [Table 3-2](#smallerc-CHP-3-TABLE-boolean-ops).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请查看[表3-2](#smallerc-CHP-3-TABLE-boolean-ops)中的运算符。
- en: Table 3-2\. Boolean operators
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-2\. 布尔运算符
- en: '| Operator | Operation | Notes |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 操作 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ! | Not | Unary operator that produces the logical opposite of its operand
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ! | 非 | 产生其操作数的逻辑相反的一元运算符 |'
- en: '| && | And | Conjunction; both operands must be true to yield true |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| && | 与 | 连接；两个操作数必须都为真才返回真 |'
- en: '| &#124;&#124; | Or | Disjunction; true if at least one operand is true |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 或 | 析取；如果至少一个操作数为真则为真 |'
- en: These operators probably look a little strange and you may not be familiar with
    logical operations, so give yourself some time to play with these symbols. Don’t
    worry if they aren’t comfortable yet. Boolean algebra is not a common grade school
    topic! But you will definitely encounter these operators in code you find online,
    so let’s make sure you understand how they work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符可能看起来有点奇怪，你可能不熟悉逻辑运算，所以给自己一些时间来熟悉这些符号。如果现在还不太舒服也不要担心。布尔代数并不是一个常见的小学课题！但你肯定会在在线代码中遇到这些运算符，所以让我们确保你了解它们的工作原理。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Calling it “logic” or “boolean algebra” is useful when discussing programming
    languages, but you probably do have experience with these concepts from human
    languages (like the English I’m using here): these operators form *conjunctions*.
    The classic “and,” “but,” and “or” from grammar lessons are roughly equivalent
    to the `&&`, `!`, and `||` in C. Putting these Boolean expressions into English
    can even help you grasp their intent. Consider “x > 0 && x < 100.” Go ahead and
    read that expression out loud: “x is greater than zero and x is less than 100.”
    If spelling these expressions out helps, it’s an easy trick to pull out when coming
    across new code.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论编程语言时称之为“逻辑”或“布尔代数”是有用的，但你可能从人类语言（比如我这里使用的英语）中已经有了这些概念的经验：这些运算符形成*连词*。语法课上的经典“and”、“but”和“or”大致相当于C语言中的`&&`、`!`和`||`。将这些布尔表达式翻译成英语甚至可以帮助你理解它们的意图。考虑“x
    > 0 && x < 100”。试着大声朗读这个表达式：“x大于零且x小于100。”如果通过拼写这些表达式有助于理解，那么当遇到新代码时，这是一个简单的技巧。
- en: In logic, these operators can be described best by their outcomes. Those outcomes,
    in turn, are often shown in *truth tables* that enumerate all possible combinations
    of inputs and their results. Luckily, with only two possible values, true and
    false, the combinations are manageable. Each operator gets its own truth table.
    [Table 3-3](#smallerc-CHP-3-TABLE-boolean-op-and) lists the inputs and results
    for the `&&` operator. Let’s start there.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑中，这些运算符的最佳描述是它们的结果。这些结果通常在*真值表*中显示，列举出所有可能的输入组合及其结果。幸运的是，只有两个可能的值，真和假，这些组合是可管理的。每个运算符都有自己的真值表。[表 3-3](#smallerc-CHP-3-TABLE-boolean-op-and)
    列出了`&&`运算符的输入和结果。让我们从这里开始。
- en: Table 3-3\. The `&&` (and) operator
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3\. `&&` （与）运算符
- en: '| a | b | a && b |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| a | b | a && b |'
- en: '| --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| true | true | true |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| true | true | true |'
- en: '| true | false | false |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| true | false | false |'
- en: '| false | true | false |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| false | true | false |'
- en: '| false | false | false |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| false | false | false |'
- en: 'As the table illustrates, this is a fairly restrictive operator. Both inputs
    have to be true for the result to be true. Per the previous tip, it can be useful
    to think in terms of an English conjunction: “We can’t go to the party until both
    Reg *and* Kaori are ready.” If Reg isn’t ready, we have to wait. If Reg is ready,
    but Kaori isn’t, we have to wait. Of course, if neither are ready, we wait.^([2](ch03.xhtml#idm45018734265544))
    It’s only when both are good to go that we can start our trek. For the record,
    Reg and Kaori are both quite prompt individuals. Waiting is rarely an issue. ;)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如表格所示，这是一个相当严格的运算符。两个输入必须同时为真才能得到真。根据之前的提示，在英语连词方面可以很有用：“我们在Reg和Kaori都准备好之前不能去派对。”如果Reg没有准备好，我们必须等待。如果Reg准备好了，但Kaori没有准备好，我们也必须等待。当然，如果两者都没准备好，我们就得等。事实上，Reg和Kaori都是相当守时的人，等待很少成为问题。;)
- en: '[Table 3-4](#smallerc-CHP-3-TABLE-boolean-op-or) shows the results when using
    `||` for the same combination of inputs.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-4](#smallerc-CHP-3-TABLE-boolean-op-or) 显示了使用`||`时相同输入组合的结果。'
- en: Table 3-4\. The `||` (or) operator
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-4\. `||` （或）运算符
- en: '| a | b | a &#124;&#124; b |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| a | b | a &#124;&#124; b |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| true | true | true |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| true | true | true |'
- en: '| true | false | true |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| true | false | true |'
- en: '| false | true | true |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| false | true | true |'
- en: '| false | false | false |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| false | false | false |'
- en: This is a more permissive operator. Back to our party trip metaphor, perhaps
    it falls on a weeknight and we can’t expect both of our friends to drop everything
    and join. For this variation, if *either* Reg *or* Kaori can join, then we will
    have a nice time with a good dinner companion. Similar to the `&&` operator, if
    both can join, then hooray! We still have an enjoyable evening ahead.^([3](ch03.xhtml#idm45018734246248))
    If both inputs are false, though, the overall answer is still false and we’ll
    be stuck on our own.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更宽松的运算符。回到我们的聚会旅行隐喻，也许它在工作日晚上举行，我们不能指望我们的朋友们立刻放下一切加入。对于这种变体，如果*任何一个*Reg*或*Kaori可以加入，那么我们将与一个好的晚餐伴侣共度美好时光。与`&&`运算符类似，如果两者都能加入，那太棒了！我们依然可以度过一个愉快的晚上。^([3](ch03.xhtml#idm45018734246248))
    然而，如果两个输入都为false，总体答案仍然是false，我们将独自一人。
- en: The final operator C supports for building logic expressions is `!`. It is a
    *unary* operator, meaning it operates on only one thing rather than the two that
    go into a *binary* operation like the math or comparison operators require. That
    means its table, [Table 3-5](#smallerc-CHP-3-TABLE-boolean-op-not), is a little
    simpler.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个运算符C用于构建逻辑表达式的支持是`!`。它是一个*一元*运算符，意味着它仅操作一个事物，而不是像数学或比较运算符需要的两个事物那样进行*二元*操作。这意味着它的表格，[表 3-5](#smallerc-CHP-3-TABLE-boolean-op-not)，稍微简单一些。
- en: Table 3-5\. The `!` (not) operator
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-5\. `!`（非）运算符
- en: '| a | !a |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| a | !a |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| true | false |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| true | false |'
- en: '| false | true |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| false | true |'
- en: 'In coding, this “not” operation is often used to guard against errors before
    continuing on. Our final party example: we will arrive at the party on time as
    long as we do *not* run into traffic. This operator creates an opposite result.
    So “traffic is bad” versus “no traffic is good.” The conversion to English is
    not quite as literal, but hopefully still illustrates the point that you can talk
    about the logic being performed.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码中，这个“非”操作经常用于在继续之前防止错误。我们最后的聚会例子：只要我们*不*遇到交通阻碍，我们将准时到达聚会。这个运算符创建了一个相反的结果。所以“交通很糟糕”与“没有交通很好”。将这个转换成英语并不是那么直接，但希望仍然能说明问题，即你可以谈论执行的逻辑。
- en: Branching
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支
- en: Now that we know how to translate logic questions into valid C syntax, how can
    we put those questions to use? We’ll start with the notion of conditional statements,
    or *branches*. We can ask a question and then execute some group of statements
    (or not) depending on the answer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何将逻辑问题翻译成有效的C语法，那么我们如何利用这些问题呢？我们将从条件语句或*分支*的概念开始。我们可以提出一个问题，然后根据答案执行一些语句组（或不执行）。
- en: The if Statement
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: 'The simplest conditional statement is the `if` statement. It has three forms,
    with the simplest being a do-it-or-don’t configuration. The syntax of this statement
    is fairly straightforward. You supply the `if` keyword, a test inside parentheses,
    and then a statement or code *block* (a grouping of one or more statements inside
    curly braces) like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的条件语句是 `if` 语句。它有三种形式，其中最简单的是“做或不做”的配置。这个语句的语法非常简单。你提供 `if` 关键字，括号内的测试，然后是一个语句或代码*块*（用大括号括起来的一个或多个语句的组合），如下所示：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the Boolean expression we use is true, we will execute the statement or block
    following the `if` line. If the expression is false, we will skip the statement
    or block.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的布尔表达式为true，则我们将执行`if`行后面的语句或块。如果表达式为false，则我们将跳过该语句或块。
- en: 'Consider a simple program that asks the user for a numeric input. You might
    want to let the user know about uncommon inputs, in case they made a typo. For
    example, we could allow negative numbers, but maybe they aren’t the usual way
    to go. We still want the program to run, but we alert the user that they might
    get a surprising result. The program in [*ch03/warnings.c*](https://oreil.ly/sP2kJ)
    is a simple example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的程序，询问用户一个数字输入。您可能希望在出现不常见的输入时通知用户，以防他们输入错误。例如，我们可以允许负数，但也许这不是通常的方式。我们仍然希望程序运行，但我们警告用户可能会得到意外的结果。[*ch03/warnings.c*](https://oreil.ly/sP2kJ)
    中的程序是一个简单的示例：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we run this with a few different inputs, you can see the effect of the `if`
    statement. Only the final run shows the warning:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用几个不同的输入运行这个程序，你可以看到 `if` 语句的效果。只有最后一次运行显示了警告：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Try entering the program and then compile and run it yourself. Try changing
    the test to look for other things like even or odd numbers, or numbers inside
    or outside a range.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入程序，然后自行编译和运行它。尝试更改测试以查找其他内容，如偶数或奇数，或在范围内或范围外的数字。
- en: 'We can also use `if` statements to get some more human-friendly responses from
    Boolean values. Instead of printing out simple ones and zeros, we can put the
    tests into an `if` statement and then print out any true response. Here’s our
    updated example; we’ll call it [*ch03/booleans2.c*](https://oreil.ly/neHcZ):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`if`语句从布尔值中获得更人性化的响应。我们可以把测试放入`if`语句中，然后根据真实情况打印出任何真实响应。这里是我们更新的示例；我们将其称为[*ch03/booleans2.c*](https://oreil.ly/neHcZ)：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Give this new program a try and you should get output similar to this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 给这个新程序一个尝试，你应该会得到类似于这样的输出：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Great! Only tests that return true are printing. That is much more readable.
    This type of `if` combined with `printf()` is a common debugging trick. Anytime
    you have an interesting (or worrying) condition, print out a warning and maybe
    include the relevant variables to help you fix the problem.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！只有返回true的测试才会打印。这样更易读。这种带有`printf()`的`if`结合是一种常见的调试技巧。每当你遇到一个有趣（或令人担忧）的条件时，打印一个警告，并可能包含相关的变量以帮助你解决问题。
- en: else
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 否则
- en: 'With a simple `if`, we can see nice output for tests that return true. But
    what if we also want to know when a test is false? That’s what the second form
    of the `if` statement is for; it includes an `else` clause. You always use an
    `else` in conjunction with an `if`. (An `else` on its own is a syntax error and
    the program won’t compile.) The `if/else` statement ends up with two branches:
    one executes if the test is true, the other executes if the test is false. Let’s
    build [*ch03/booleans3.c*](https://oreil.ly/neHcZ) and get either a thumbs-up
    or a thumbs-down answer for every test:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的`if`，我们可以看到返回true的测试的漂亮输出。但是如果我们还想知道测试何时为false怎么办？这就是`if`语句的第二种形式的作用；它包括一个`else`子句。你总是和`if`一起使用`else`。（单独使用`else`是语法错误，程序无法编译。）`if/else`语句最终有两个分支：一个在测试为真时执行，另一个在测试为假时执行。让我们构建[*ch03/booleans3.c*](https://oreil.ly/neHcZ)，为每个测试得到一个大拇指或一个大拇指向下的答案：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And if we run this with the same inputs from before, we’ll see a gratifying
    expansion of answers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用之前相同的输入运行它，我们将看到答案的令人满意的扩展：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Perfect. We have readable answers for every test. Now we don’t have to wonder
    if a test ran and failed or was somehow skipped altogether. We get a useful response
    every time. Try upgrading the *warnings.c* file so that you still get the warning
    if a number is “unusual,” but it also gives the user a friendly message indicating
    their input is in the expected range.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。我们对每个测试都有可读的答案。现在我们不必担心测试是否运行失败或被跳过。每次都能得到有用的响应。试着升级*warnings.c*文件，以便在数字“异常”时仍然收到警告，同时向用户提供友好的消息，表明其输入处于预期范围内。
- en: else if chains
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: else if链
- en: 'We now have some pretty powerful decision statements in our toolkit. We can
    do something or skip it. We can do one thing or an alternative. What if we need
    to decide between three statements? Or four? Or more? One possible pattern for
    this scenario is the third variation of `if`: the `if/else if/else` combination.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的工具包中有一些非常强大的决策语句。我们可以做某事或跳过它。我们可以做一件事或做另一种选择。如果我们需要在三个语句之间做出决定呢？或四个？或更多？这种情况的一种可能模式是第三种`if`的变体：`if/else
    if/else`组合。
- en: 'C allows you to “chain” `if/else` pairs together to achieve a one-of-many branch
    selection. Consider game scores that get rated with one, two, or three stars depending
    on how well you did. You could get that type of answer with this idea of `else
    if` blocks. Here is [*ch03/stars.c*](https://oreil.ly/Fe8q9):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: C语言允许你“链式”使用`if/else`来实现从多个选项中选择一个。考虑游戏得分根据表现分为一星、二星或三星的情况。使用`else if`块可以实现这种类型的答案。这里是[*ch03/stars.c*](https://oreil.ly/Fe8q9)的示例：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here are some example runs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些示例运行：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But maybe our game is special and has four star performances. (Wow!) The file
    [*ch03/stars2.c*](https://oreil.ly/uXLDr) shows how to bring one more `else if`
    clause to the rescue!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许我们的游戏很特别，有四星表现。（哇！）文件[*ch03/stars2.c*](https://oreil.ly/uXLDr)展示了如何使用额外的`else
    if`子句来实现更多选择！
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And a few more examples of the output to verify that our new top score works:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多示例输出，以验证我们的新最高分运行正常：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You could continue those chains ad infinitum. Well, within reason. You’ll eventually
    be limited by memory and beyond a handful of clauses, it becomes difficult to
    follow the flow of such chains. If it feels like you have too many `else/if` blocks
    in one chain, it might be worth spending a little time examining your algorithm
    to see if there are other ways to break down your tests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以无限继续这些链条。嗯，合理范围内的无限。最终你会受到内存限制，超过一些从句之后，跟随这样的链条流程就会变得困难。如果感觉你的`else/if`块太多了，也许花一点时间检查你的算法，看看是否有其他方法来分解你的测试会更值得。
- en: if gotchas
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if gotchas
- en: 'The syntax of those `else/if` chains hints at a detail of C’s syntax I previously
    mentioned briefly. The `if` and `else` chunks do not require the curly braces
    if you have exactly one statement in the clause. For example, our *booleans3.c*
    could be written like this ([*ch03/booleans3_alt.c*](https://oreil.ly/FrXzk)):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`else/if`链的语法提示了我之前简要提到的C语法细节。如果从句中确切地只有一个语句，`if`和`else`块就不需要花括号。例如，我们的*booleans3.c*可以像这样编写（[*ch03/booleans3_alt.c*](https://oreil.ly/FrXzk)）：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will definitely run across code like this online. It saves a little typing
    and can make for more compact code where the tests and the statements are simple.
    You *can* use the curly braces to create a block with a single statement just
    as we did in the original *booleans3.c* code. It works like using extra parentheses
    in mathematic operations: not necessary but useful for readability. It is mostly
    just a matter of style when you have only the one thing to do. Since doing two
    or more things always requires the curly braces, though, I’ll stick to using curly
    braces as a way to future-proof our code. (And as a matter of style, I prefer
    the consistency of seeing the braces.) If we come back later to update some example
    and need to add another print statement, say, we won’t have to remember to add
    the braces; they’ll be there ready and waiting.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在线上你肯定会碰到类似这样的代码。这样做可以节省一点输入，并使测试和语句更加简洁。你*可以*使用花括号来创建一个只有一个语句的块，就像我们在原始的*booleans3.c*代码中所做的那样。这与在数学运算中使用额外的括号类似：虽然不是必需的，但对于可读性是有用的。当你只需执行一个操作时，这主要是一种风格问题。然而，如果要执行两个或更多操作，则始终需要使用花括号，因此我会坚持使用花括号来未来保护我们的代码。（并且在风格上，我更喜欢看到括号的一致性。）如果以后回来更新某些示例并需要添加另一个打印语句，比如说，我们就不必记住添加花括号；它们已经准备好等待使用了。
- en: 'The tests you use in `if` statements can also cause problems if you aren’t
    careful. Remember the comment about C treating a zero as false and any other number
    as true? Some programmers rely on that fact to write very compact tests. Consider
    this snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句中使用的测试也可能会带来问题，如果不小心就会出错。记住关于C语言将零视为假，而任何其他数字视为真的注释？一些程序员依赖于这一事实来编写非常紧凑的测试。考虑以下代码片段：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `if` clause will execute for any positive or negative number, as if we had
    built a real test like `x != 0` or even a fancier logical expression like `(x
    < 0 || x > 0)`. This pattern gets used as a (sometimes lazy) shortcut for asking
    “does this variable have any value at all” where a zero is assumed to be an invalid
    possibility. It’s a fairly common pattern, although I usually prefer to write
    explicit tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`从句将为任何正数或负数执行，就好像我们构建了一个真正的测试，比如`x != 0`或者甚至是一个更复杂的逻辑表达式，比如`(x < 0 || x
    > 0)`。这种模式被用作（有时是懒惰的）检查“这个变量是否有任何值”的捷径，其中零被假定为无效可能性。这是一个相当常见的模式，尽管我通常更喜欢编写明确的测试。'
- en: 'One other big quirk of C using integers as proxies for Boolean values: there
    is a very subtle typo that can cause real trouble. Take a look at this next snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中另一个大问题是使用整数作为布尔值的代理：有一个非常微妙的拼写错误可能会导致真正的麻烦。看看下面的代码片段：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you’re curious, go ahead and create a program to try this gotcha. When you
    run it, you’ll see that you *always* get the “Blackjack! 21” output. What happened?
    Look closely at the test in the `if` statement. What we meant to write was `total
    == 21` using the double equal sign comparison operator. By using the single equal
    sign, we actually *assigned* the value 21 to our `total` variable right there
    inside the `if` test! Assignments in C are expressions just like our mathematic
    calculations. The value of an assignment expression is the same as the new value
    being assigned. The upshot is that this test is akin to `if (21) ...`, which will
    always be true since 21 is not 0\. It is frustratingly easy to make this mistake.
    Just watch out for `if` statements that always seem to execute no matter how you
    change your inputs. That behavior is a hint to reexamine the test you’re using.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，请继续创建一个程序来尝试这个陷阱。当你运行它时，你会看到你总是得到“Blackjack！21”输出。发生了什么？仔细看看`if`语句中的测试条件。我们本意是写成`total
    == 21`，使用双等号比较运算符。但是我们使用了单等号，实际上在`if`测试条件中为我们的`total`变量赋值了21！在C语言中，赋值也是表达式，就像我们的数学计算一样。赋值表达式的值与被赋的新值相同。总之，这个测试类似于`if
    (21) ...`，因为21不是0，所以总是为真。这种情况非常容易出错。只要注意那些似乎无论你如何改变输入都会执行的`if`语句。这种行为提示你重新检查你正在使用的测试条件。
- en: The switch Statement
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: I noted in [“else if chains”](#smallerc-CHP-3-SECT-2.1.2) that the `if/else
    if` chains can become difficult to follow if you have too many tests chained together.
    Sometimes, though, you really do have a bunch of specific cases you need to check,
    say, what shirts are in stock at your favorite online store based on your size.
    If those cases all involve the same variable and all use simple equality (`==`)
    as the test, then you can use the `switch` statement in C as a nice alternative.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[“else if链”](#smallerc-CHP-3-SECT-2.1.2)中指出，如果`if/else if`链中有太多的测试条件链接在一起，会变得难以跟踪。不过，有时确实需要检查一堆特定情况，比如基于你的尺码检查你喜爱的在线商店里有什么衬衫。如果这些情况都涉及同一个变量，并且所有情况都使用简单的等式（`==`）作为测试条件，那么在C语言中可以使用`switch`语句作为一个不错的选择。
- en: 'A `switch` statement takes an expression (the control expression), typically
    a variable or simple calculation, and then systematically compares the value of
    that expression to one or more constant values using `case` labels. If the control
    expression value matches a case, the code following that value starts executing
    and continues until the end of the `switch` statement (which is always a curly
    brace block) or the program hits a `break` command. The [*ch03/medals.c*](https://oreil.ly/LVkuZ)
    file contains a simple example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句接受一个表达式（控制表达式），通常是一个变量或简单计算，然后系统地将该表达式的值与一个或多个常量值使用`case`标签进行比较。如果控制表达式的值与某个`case`匹配，那么从该值后面的代码开始执行，并持续执行到`switch`语句的结束（总是一个大括号块）或程序遇到`break`命令为止。[*ch03/medals.c*](https://oreil.ly/LVkuZ)文件包含了一个简单的例子：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you compile and run the program a few times with the three possible inputs,
    you should see results like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并多次运行这个程序，每次使用三种可能的输入，你应该会看到像这样的结果：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Neat! Exactly what we expected. But what if we comment out those `break` lines?
    Let’s try that now because this illustrates a critical quirk with `switch` that
    can trip up new programmers. Here is our altered program, [*ch03/medals2.c*](https://oreil.ly/MluI4):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！正是我们预期的。但是如果我们将那些`break`行注释掉会怎么样？现在让我们试试，因为这展示了`switch`的一个关键怪癖，可能会让新程序员困惑。这是我们修改过的程序，[*ch03/medals2.c*](https://oreil.ly/MluI4)：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here is the new output using the same series of inputs we used the first
    time:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用第一次使用的相同输入系列的新输出：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Huh. That’s really strange. Once it gets started, the program just keeps executing
    statements in the `switch` even if they are part of separate cases. While that
    might seem like a bad idea, it is meant to be a feature of `switch`, not a bug.
    This design allows you to perform the same action for several values. Consider
    the following snippet that describes any number between 1 and 10 in terms of even,
    odd, and prime:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这真是太奇怪了。一旦开始运行，程序会继续执行`switch`语句中的语句，即使它们属于不同的`case`。虽然这看起来可能不是一个好主意，但这是`switch`的一个特性，而不是一个bug。这种设计允许您为多个值执行相同的操作。考虑下面的片段，描述了1到10之间任意数字的偶数、奇数和质数情况：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can arrange cases in such a way that the `switch` feature of flowing until
    a `break` gives us exactly the right output. While this feature is most often
    used to collect a related series of distinct values (such as our even numbers)
    and then give them the same block to execute, the flow of printing the “prime”
    qualifier and then continuing on to add the “odd” designation is valid and can
    be handy sometimes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将案例安排得如此之巧，以至于流动到`break`开关特性正好给我们提供了完全正确的输出。尽管这种特性通常用于收集一系列相关但不同的值（比如我们的偶数），然后给它们相同的执行块，但打印“主要”限定词然后继续添加“奇数”标识的流程也是有效的，有时候也很方便。
- en: Handling defaults
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理默认值
- en: There is one other feature in `switch` that is similar to the `else` clause
    that can be used with `if` statements. Sometimes you want your `switch` statement
    to handle every possible input. But listing out a few thousand integers or even
    just every letter in the alphabet can be very tedious, to say the least. And usually,
    you don’t have unique actions for all those thousands of options. In these situations,
    you can use the `default` label as your final “case” and it will execute regardless
    of the control expression value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`中还有一个与`if`语句的`else`子句类似的特性。有时候，你希望你的`switch`语句处理每一个可能的输入。但列出几千个整数，甚至只是字母表中的每一个字母，无论如何都会非常乏味。通常情况下，您并不对所有这些成千上万个选项都有独特的动作。在这些情况下，您可以使用`default`标签作为最后的“case”，它将执行控制表达式值的任何情况。'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, `default` can appear anywhere in the list of cases, not just as
    the final option. However, since the `default` case *always* runs when encountered,
    it doesn’t make sense to include subsequent, specific cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`default`可以出现在案例列表的任何位置，而不仅仅是作为最后一个选项。然而，由于在遇到时`default`情况总是运行，包括后续特定案例并没有意义。
- en: 'For example, with our *medals.c* program, what about contestants that didn’t
    make the podium? Try running it again with some number larger than three. What
    do you get? Nothing. No error, no output, nada. Let’s write [*ch03/medals3.c*](https://oreil.ly/l1AHK)
    and use the `default` option to print a message and at least prove we saw the
    input:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用我们的*medals.c*程序，那些没有进入领奖台的参赛者怎么样？尝试再次运行它，使用一些大于三的数字。你得到了什么？什么也没有。没有错误，没有输出，什么都没有。让我们写一个[*ch03/medals3.c*](https://oreil.ly/l1AHK)，并使用`default`选项来打印一个消息，至少证明我们看到了输入：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compile and run this new program and try some values larger than three:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行这个新程序，并尝试一些大于三的值：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lovely! No matter what number greater than three we give, we get some feedback
    to show that we have processed that input. Exactly what we wanted. And we can
    use `default` even with `switch` statements that include the multiple-cases-per-block
    arrangement. Let’s add a “Top 10” level to our medal description program, [*ch03/medals4.c*](https://oreil.ly/lS1tv):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！无论我们输入什么大于三的数字，我们都会得到一些反馈，表明我们已经处理了该输入。正是我们想要的。并且我们甚至可以在包含多个案例每个块安排的`switch`语句中使用`default`。让我们为我们的奖牌描述程序添加一个“Top
    10”级别，[*ch03/medals4.c*](https://oreil.ly/lS1tv)：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'One more compile and then run it with a few inputs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再编译一次，然后用几个输入运行它：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Great. Here’s a quick homework assignment for you. Modify *medals4.c* so that
    if you get 4th or 5th place, you get labeled a “runner up.” Places 6 through 10
    should still be listed as top 10\. (It’s a small change. You can check your answer
    against mine in [*ch03/medals5.c*](https://oreil.ly/W7uci).)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。这里有一个快速的家庭作业给你。修改*medals4.c*，以便如果你获得第四或第五名，你会被标记为“亚军”。第6到10名仍然应列为前十名。（这是一个小改变。你可以查看你的答案和我的答案[*ch03/medals5.c*](https://oreil.ly/W7uci)来对比。）
- en: The Ternary Operator and Conditional Assignment
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三元运算符和条件赋值
- en: One last conditional topic that gets a lot of use in lean code is the notion
    of conditional assignment. C includes a ternary operator, `?:`, that takes three
    operands. It allows you to use one of two values in a very compact syntax. The
    result of this ternary expression is indeed a value like any other expression
    in C, so you can use `?:` anywhere a value is legal.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Lean代码中另一个经常使用的条件主题是条件赋值的概念。C语言包含一个三元运算符，`?:`，它接受三个操作数。它允许您在非常紧凑的语法中使用两个值之一。这个三元表达式的结果确实是C语言中任何其他表达式一样的值，所以您可以在任何值合法的地方使用`?:`。
- en: The syntax of `?:` uses a Boolean expression as the first operand, then the
    question mark, then an expression to evaluate if the boolean is true, then the
    colon, and finally an alternate expression to evaluate if the boolean is false.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`?:`的语法使用布尔表达式作为第一个操作数，然后是问号，然后是要评估的表达式（如果布尔为真），然后是冒号，最后是另一个要评估的表达式（如果布尔为假）。'
- en: A great example of using the ternary operator is grabbing the smaller of two
    values. Consider a simple program processing two bids for some graphic design
    work. Budget is sadly the driving factor, so you need to accept the lowest bid.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算符的一个很好的例子是获取两个值中较小的一个。考虑一个简单的程序，处理两个对某些图形设计工作的竞标。预算遗憾地成为主导因素，所以你需要接受最低的竞标价。
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Very dense! It takes a little practice even just to read these ternary expressions,
    but once you have the hang of it, I think you’ll find it a very handy operator.
    The alternative is a somewhat drawn out `if/else`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 非常密集！即使只是阅读这些三元表达式也需要一些练习，但一旦掌握，我认为你会发现它是一个非常方便的运算符。另一种方法是相对冗长的`if/else`：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Certainly not an awful alternative, but it is definitely more verbose. Plus
    there are times where the ternary approach really simplifies things. Remember
    the first program on Boolean expressions, *booleans.c*, in [“Comparison Operators”](#smallerc-CHP-3-SECT-1.1)?
    We had to live with interpreting a 1 as “true” and a 0 as “false.” We eventually
    printed nice statements in *booleans3.c*, but we had to use that fairly verbose
    `if/else` pattern. With `?:`, however, we can make human-friendly output directly
    in the `printf()` statements. Try [*ch03/booleans4.c*](https://oreil.ly/Hnumr)
    and see what you think:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是一个糟糕的替代方案，但它确实更冗长。而且在使用三元方法简化事情的时候确实有时候。还记得第一个布尔表达式程序，*booleans.c*，在[“比较运算符”](#smallerc-CHP-3-SECT-1.1)中吗？我们必须接受将1解释为“true”和0解释为“false”。最终我们在*booleans3.c*中打印了漂亮的陈述，但我们必须使用相当冗长的`if/else`模式。然而，使用`?:`，我们可以直接在`printf()`语句中生成友好的输出。尝试[*ch03/booleans4.c*](https://oreil.ly/Hnumr)，看看你的感觉：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And here is our updated output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们更新后的输出：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Much better.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: It was a bit of a pain wrapping each of those print calls in an `if/else` block
    in *booleans3.c*. Not just annoying, the shared parts in the printed text can
    get out of sync if you make any changes. If you found a typo at the beginning
    of a line, for example, you would have to make sure you fixed the beginning of
    both the `if` clause `printf()` and again in the `else` clause. It is all too
    easy to forget one or the other.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在*booleans3.c*中将每个打印调用都包裹在`if/else`块中有些麻烦。不仅令人恼火，打印文本中的共享部分如果有任何更改可能会失去同步。例如，如果在一行的开头发现了一个拼写错误，你需要确保在`if`子句的`printf()`开头和`else`子句中再次修复它。很容易忘记其中之一。
- en: Any time you can avoid such duplicated code by using a different conditional
    statement or operator, it’s worth considering. But don’t be overzealous; if your
    `if/else` chain feels readable and produces the right output, that is still a
    fine option.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每当可以通过使用不同的条件语句或操作符避免这种重复代码时，都值得考虑。但不要过于热衷；如果你的`if/else`链感觉可读且能产生正确的输出，那仍然是一个不错的选择。
- en: Loop Statements
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环语句
- en: You can solve some interesting problems with just variables and the input, output,
    and branching statements we have covered so far. But one of the spots where computers
    really shine is when you need to repeat a test or batch of statements. To perform
    repetitions, you can use one of C’s *loop* statements. Your program will execute
    all of the (optional) statements, and at the end of those statements, “loop” back
    to the start and execute them all again. Usually you don’t want that loop to run
    forever, so each loop statement has a condition to check and see when the loop
    should stop.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以只用变量和我们迄今为止涵盖的输入、输出和分支语句解决一些有趣的问题。但计算机真正擅长的一个领域是当你需要重复测试或一批语句时。为了执行重复操作，你可以使用C语言的一种*循环*语句。你的程序将执行所有（可选的）语句，并在这些语句结束时“循环”回到起点并再次执行它们。通常情况下，你不希望该循环永远运行，因此每个循环语句都有一个条件来检查并确定何时应该停止循环。
- en: The for Statement
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for`语句'
- en: One type of repetition that crops up in programming is repeating a block for
    a specific number of times. For example, doing something for each day of the week,
    or processing the first 5 lines of input, or even just counting to 10\. In fact,
    let’s see the `for` loop that counts to 10, shown in [Figure 3-1](#smallerc-CHP-3-FIG-for-loop-annotated)
    where I have marked the parts of the loop. (Feel free to type this in or open
    up the [*ch03/ten.c*](https://oreil.ly/qqDiQ) file.) It can look a little messy
    at first, but over time it’ll become familiar.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中经常遇到的一种重复是为特定次数重复执行某个代码块。例如，每周做某件事情，或者处理输入的前5行，甚至只是简单地数到10。事实上，让我们来看看计数到10的`for`循环，如[图 3-1](#smallerc-CHP-3-FIG-for-loop-annotated)所示，我在循环的各个部分做了标记。（随意输入或打开[*ch03/ten.c*](https://oreil.ly/qqDiQ)文件。）起初可能看起来有点凌乱，但随着时间的推移，它会变得更加熟悉。
- en: '![smac 0301](Images/smac_0301.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![smac 0301](Images/smac_0301.png)'
- en: Figure 3-1\. An annotated `for` loop
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 一个带注释的 `for` 循环
- en: 'Before we look at the details of the loop, here’s the output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看循环的详细信息之前，这里是输出：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![1](Images/1.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![1](Images/1.png)'
- en: (`int i = 1`) This is our loop variable. We use the same declaration and initialization
    syntax as we do for normal variables. This portion of the loop is always executed
    first, and is only executed once when the loop starts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (`int i = 1`) 这是我们的循环变量。我们使用与普通变量相同的声明和初始化语法。循环的这一部分总是首先执行，并且只在循环开始时执行一次。
- en: '![2](Images/2.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![2](Images/2.png)'
- en: (`i <= 10`) Here is the test to see when the loop should stop. The loop will
    run as long as this test returns true. If this condition is false—even the first
    time it is checked—the loop will end.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (`i <= 10`) 这里是测试循环何时结束的条件。只要此测试返回 true，循环就会运行。如果此条件为 false —— 即使是在第一次检查时也是如此
    —— 循环将结束。
- en: '![3](Images/3.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![3](Images/3.png)'
- en: The body of the loop is executed next, assuming the test in ![2](Images/2.png)
    returned true.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来执行循环的主体，假设 ![2](Images/2.png) 中的测试返回 true。
- en: '![4](Images/4.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![4](Images/4.png)'
- en: (`i = i + 1`) After completing the body, this adjustment expression is evaluated.
    This expression typically increments or decrements our loop variable by one. After
    this step, control jumps back to ![2](Images/2.png) to see if the loop should
    continue.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (`i = i + 1`) 完成主体后，会评估这个调整表达式。这个表达式通常会增加或减少我们的循环变量一次。在这一步之后，控制会跳回到 ![2](Images/2.png)，以查看循环是否应该继续。
- en: The initialization, the check for when to end, and the adjustment are all quite
    flexible. You can use whatever name you like and can count up or down by any amount.
    You can even use the `char` type for a variable if you want sequential characters
    for any reason.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化、结束条件的检查和调整都非常灵活。你可以使用任何你喜欢的名称，并且可以以任意数量进行递增或递减。甚至可以使用 `char` 类型的变量，如果你有任何原因需要顺序字符。
- en: 'Let’s try a few more simple `for` loops to practice its syntax and its flow.
    We’ll initialize our loop variable, check to make sure we should start the loop,
    execute the statements in the body, perform the adjustment, and then check to
    see if we should continue. Lather. Rinse. Repeat.^([4](ch03.xhtml#idm45018732222664))
    We’ll try some loops with different adjustments including a decrement that can
    be used to count backward, [*ch03/more_for.c*](https://oreil.ly/jzGZe):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些更简单的 `for` 循环，来练习它的语法和流程。我们将初始化我们的循环变量，检查是否应该开始循环，执行主体中的语句，进行调整，然后检查是否应该继续。重复。我们将尝试一些带有不同调整的循环，包括一个可以用来向后计数的递减，[*ch03/more_for.c*](https://oreil.ly/jzGZe)：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s our output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的输出：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Try tweaking some of the values in the loops and recompile. Can you count backward
    by twos? Can you count to 100? Can you count from 1 to 1,024 by doubling?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整一些循环中的值并重新编译。你能逆向计数两个吗？你能从1数到100吗？你能从1数到1,024并且每次都加倍吗？
- en: Increment shortcuts
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递增快捷方式
- en: 'Incrementing or decrementing a variable like we do in those adjustment expressions
    is such a common task (even outside of loops) that C supports a number of shortcuts
    for that type of change. Consider statements of the following form:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们在这些调整表达式中所做的那样对变量进行递增或递减是一个非常常见的任务（即使在循环之外也是如此），因此 C 支持多种用于这种类型变化的快捷方式。考虑以下形式的语句：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'where `var` is some variable and `op` is one of the arithmetic operators from
    [Table 2-6](ch02.xhtml#smallerc-CHP-2-TABLE-math-ops). If you are using that pattern
    in your code, you can use a compound assignment instead:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `var` 是某个变量，`op` 是来自 [Table 2-6](ch02.xhtml#smallerc-CHP-2-TABLE-math-ops)
    的算术运算符之一。如果你在代码中使用了这种模式，可以使用复合赋值代替：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Going further, any time you are adding or subtracting 1 from a variable, you
    can use an even more succinct variation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步说，每当你对变量加减1时，你可以使用更简洁的变体：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may see a “prefix” version of the increment and decrement shortcuts, i.e.,
    `++i` or `--total`. These variations are legal and have a subtle distinction that
    does not come into play when used in `for` loops like we’re doing.^([5](ch03.xhtml#idm45018732082600))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到“前缀”版本的递增和递减快捷方式，例如 `++i` 或 `--total`。这些变体是合法的，并且在我们使用的 `for` 循环中有微妙的区别，不会起作用。
- en: You don’t have to use these compact options, but they are popular and you will
    certainly encounter them on coding sites like Stack Overflow or in Arduino examples.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定要使用这些简洁的选项，但它们很受欢迎，你在编码网站如Stack Overflow或Arduino示例中肯定会遇到它们。
- en: for gotchas
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于捕捉疏忽的注意事项
- en: Before we tackle the other loop options in C, I want to point out a few details
    about `for` loops that can trip you up.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论C中的其他循环选项之前，我想指出关于`for`循环的一些细节可能会让你犯错。
- en: 'Perhaps the most important element of the `for` loop syntax is the condition
    in the middle of the loop’s setup. You need to make sure that the condition allows
    the loop to *start* as well as the more obviously necessary ability to make the
    loop stop. Consider this loop snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环语法中可能最重要的元素是循环设置中间的条件。你需要确保条件允许循环*开始*以及更明显地需要循环停止的能力。考虑这个循环片段：'
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The ostensible intent of the loop is to count to 10—by stopping when `x` is
    equal to 11\. But the condition must evaluate to true for the loop to run, so
    you can’t just watch for the end.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的明显目的是计数到10——当`x`等于11时停止。但是条件必须为真才能运行循环，所以你不能只是等待结束。
- en: 'You also need to make sure your condition and adjustment expressions are in
    sync. One of my favorite mistakes is to create a loop meant to count down or count
    backward, but I forget to use the decrement operation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要确保你的条件和调整表达式是同步的。我最喜欢的错误之一是创建一个用于倒计数或逆向计数的循环，但我忘记使用递减操作：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I obviously should say `countdown--` in the last segment of this setup, but
    incrementing is so common, it’s almost muscle memory. Take a look at this loop.
    Can you see what is going to happen? Instead of moving toward the stop condition,
    this loop will head away and keep going for quite some time. Sadly, the compiler
    can’t really help us here because this syntax is entirely legal. The error is
    a logic error, so it falls to you as the programmer to catch it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这个设置的最后一部分我应该写`countdown--`，但递增是如此常见，几乎已成为肌肉记忆。看看这个循环。你能看出会发生什么吗？这个循环不会朝着停止条件前进，而是会继续前进相当长的时间。不幸的是，编译器无法真正帮助我们，因为这种语法是完全合法的。错误是一个逻辑错误，因此作为程序员，你需要捕捉它。
- en: 'The other big mistake that can be easy to make has to do with the syntax of
    the `for` loop setup. Notice that the expressions are separated by semicolons,
    not commas:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个容易犯的大错误与`for`循环设置的语法有关。请注意，表达式是由分号而不是逗号分隔的：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That detail is easy to miss and you’ll probably make that mistake at least
    once. Here, the compiler will catch you, though:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那个细节很容易被忽略，你可能会至少犯这个错误一次。在这里，编译器会捉住你，尽管：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Easy to fix, of course, but something to be mindful of as you are learning.
    These types of errors are something you encounter (and then fix!) more often when
    typing up code directly rather than cutting and pasting it from an online source.
    I really do recommend entering some of the program listings in this book by hand
    for just this reason.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然很容易修复，但在学习过程中要注意这一点。这些类型的错误在直接输入代码而不是从在线源粘贴时更容易遇到（然后修复！）。出于这个原因，我真的建议手动输入本书中的一些程序清单。
- en: The while Statement
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while语句
- en: Performing a specific number of iterations is certainly a popular task in computer
    programming. But looping until some more generic condition is met is easily just
    as common. In C, that more generic loop is the `while` loop. It has a simple condition
    as its only real syntactic element. If the condition is true, the body of the
    loop is executed. Jump back up and check the condition…and repeat.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，执行特定次数的迭代无疑是一个流行的任务。但是，循环直到满足某些更一般的条件同样常见。在C中，更通用的循环是`while`循环。它只有一个简单的条件作为其唯一的语法元素。如果条件为真，则执行循环体。跳回去检查条件……并重复。
- en: 'This type of loop is perfect for input where you cannot predict how many pieces
    of information you will need to scan. Let’s try a simple program to calculate
    the average of some numbers. Critically, we will allow the user to enter as many
    (or as few) numbers as they wish. We’ll ask them to enter a *sentinel* value to
    indicate they are done giving us new numbers. A sentinel can be any value that
    stands out from expected values. We use it in our condition so we know when to
    stop. For example, let’s ask the user for numbers between 1 and 100\. We can then
    use 0 as a sentinel. Here is [*ch03/average.c*](https://oreil.ly/KmxH4):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的循环非常适合需要扫描多少信息不可预测的输入。让我们尝试一个简单的程序来计算一些数字的平均值。关键是，我们允许用户输入他们想要的任意数量（或任意少量）的数字。我们将要求他们输入一个*标志*值来指示他们已经完成了给我们新数字的输入。标志可以是任何与预期值不同的值。我们在我们的条件中使用它，所以我们知道何时停止。例如，让我们要求用户输入1到100之间的数字。然后我们可以使用0作为标志。这里是[*ch03/average.c*](https://oreil.ly/KmxH4)：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here are two sample runs with different inputs:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个不同输入的样本运行：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We get things going by asking the user for the first number. We then use that
    response in our `while` statement. If they enter a 0 the first time, we’re done.
    Unlike `for` loops, it is not uncommon for a `while` loop to never execute. There
    are reasonable circumstances where you might need to iterate over an optional
    task, say, turning off all the lights in a smart home. But being optional, sometimes
    that means you don’t do it at all; if the lights are already off, there’s nothing
    to do.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始询问用户第一个数字。然后我们在`while`语句中使用这个响应。如果他们第一次输入了0，我们就完成了。与`for`循环不同，`while`循环可能根本不执行是很常见的。有合理的情况，你可能需要迭代一个可选任务，比如关闭智能家居中的所有灯光。但是因为是可选的，有时这意味着你根本不执行；如果灯光已经关闭，那就什么也不需要做。
- en: Assuming they give us a valid number, though, we start the loop. We add their
    input to a separate variable where we keep the running `total`. (In programming,
    this is sometimes referred to as an *accumulator*.) We also increment a third
    variable, `count`, to keep track of how many numbers the user gives us.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设他们给了我们一个有效的数字，我们就开始循环。我们将他们的输入添加到一个单独的变量中，用于保存运行的总数（在编程中，这有时被称为*累加器*）。我们还递增第三个变量`count`，以跟踪用户给我们的数字数量。
- en: We prompt the user for the next number (or a 0 to quit). We get their input,
    and again that value will be used in the `while` loop’s condition. If the most
    recent grade is valid, add it to the total and repeat.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提示用户输入下一个数字（或者输入0退出）。我们获取他们的输入，并且再次将该值用于`while`循环的条件。如果最近的成绩有效，将其添加到总数并重复。
- en: Once we complete the loop, we print the results. We use an `if/else` statement
    to wrap that final result in a nice, human-friendly sentence. If they entered
    a 0 at the beginning, we note that there is no average to print. Otherwise (`else`)
    we print the average with two decimal places of precision.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成循环，我们就打印结果。我们使用`if/else`语句来将最终结果包装在一个友好的人类句子中。如果他们在开始时输入了0，我们指出没有平均值可打印。否则（`else`），我们以两位小数的精度打印平均值。
- en: The do/while Variation
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`do/while`变体'
- en: 'The last of the loop statements in C is the `do/while` (sometimes referred
    to as just a `do` loop). As you might guess from the name, it is similar to the
    `while` loop, but with one big difference. A `do` loop automatically guarantees
    at least one execution of the loop body. It does this by checking the loop condition
    *after* the body has executed instead of before. This is great where you know
    you need at least one pass. Our grade averaging program is actually a perfect
    example. We have to ask the user for a grade at least once. If they give us a
    0 right away, we’re done and that’s fine. If they give us a valid number, we accumulate
    our total and ask again. Using a `do` loop and a small adjustment to our count
    at the end, we can avoid the duplicate `scanf()` calls in [*ch03/average2.c*](https://oreil.ly/ILhdW):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言中最后一种循环语句是`do/while`（有时简称为`do`循环）。从名称就可以猜到，它与`while`循环类似，但有一个重要的不同。`do`循环自动保证至少执行一次循环体。它在执行循环体后而不是之前检查循环条件。这在你知道至少需要一次循环时非常有用。我们的成绩平均程序实际上是一个完美的例子。我们至少需要一次询问用户的成绩。如果他们一开始给了我们一个0，我们就结束了，这是可以接受的。如果他们给了我们一个有效的数字，我们就累加总数并再次询问。使用`do`循环以及对我们计数的小调整，我们可以避免在[*ch03/average2.c*](https://oreil.ly/ILhdW)中重复调用`scanf()`：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And the output is essentially the same:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 输出基本上是一样的：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Not much of a difference—indeed no difference in the results—but any time you
    can remove lines of code without harming functionality, you’re reducing the chances
    of bugs cropping up. That’s always a good thing!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 没有太大的区别——实际上结果没有任何区别——但是每当你可以删除不影响功能的代码行时，你就在减少出错的机会。这总是件好事！
- en: Nesting
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套
- en: 'Adding loops and conditional statements to your repertoire greatly expands
    the problems you can tackle. But it gets even better: you can nest `if` statements
    inside loops to watch for error conditions, put a `while` inside an `if` to wait
    on a sensor, or use a `for` loop inside another `for` loop to traverse tabular
    data. Remember that all these control statements are still just statements and
    they can be used anywhere other, simpler statements are allowed.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将循环和条件语句添加到你的工具箱中，极大地扩展了你能解决的问题范围。但更好的是：你可以在循环内部嵌套`if`语句以监视错误条件，在`if`内部放置`while`以等待传感器的信号，或者在一个`for`循环内部再次使用`for`循环以遍历表格数据。记住，所有这些控制语句仍然只是语句，它们可以在允许更简单的语句的任何地方使用。
- en: 'Let’s use this nesting ability to improve our averaging program further. We
    know zero is the “done” value, but we said we wanted values between 1 and 100\.
    What happens if the user gives us a negative number? Or a number greater than
    100? If you look closely at the code in *average2.c*, you’ll see we don’t do much
    about it. We don’t exit or throw it out. We can do better if we use an `if/else`
    statement inside our loop as in [*ch03/average3.c*](https://oreil.ly/alYI8):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这种嵌套能力进一步改进我们的平均程序。我们知道零是“完成”值，但我们说我们希望值在1到100之间。如果用户给我们一个负数会发生什么？或者一个大于100的数字？如果你仔细看*average2.c*中的代码，你会发现我们对此没有做太多处理。我们不退出或丢弃它。如果我们在循环内部使用`if/else`语句，就像[*ch03/average3.c*](https://oreil.ly/alYI8)中那样，我们可以做得更好：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Cool. We even fixed the little hiccup with our `count` variable in *average2.c*
    where we had to decrement `count` by 1 since we executed the entire body of the
    `do/while` loop even if the first entry was 0\. Very nice upgrade!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒。我们甚至修复了*average2.c*中`count`变量的小问题，我们必须将`count`减1，因为即使第一个条目为0，我们也执行了整个`do/while`循环的主体。非常好的升级！
- en: 'Let’s test this program with some simple inputs so we can verify that bad values
    were not included in the average:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些简单的输入测试这个程序，以便验证坏值没有包含在平均值中：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can check the math: 82 + 43 + 14 + 97 = 236\. 236 ÷ 4 = 59\. That matches
    our result, so our nested `if/else` is working. Hooray!'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查数学：82 + 43 + 14 + 97 = 236。236 ÷ 4 = 59。这与我们的结果相符，所以我们的嵌套`if/else`是有效的。万岁！
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As you build more complicated programs with nested control statements, you may
    bump into situations where you need to get out of a loop before it would normally
    finish. Happily, the `break` command you saw in the discussion of the `switch`
    statement can be used to immediately exit a loop. Some programmers try to avoid
    this “cheat,” but sometimes I think it actually makes code more readable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您使用嵌套控制语句构建更复杂的程序，您可能会遇到需要在循环通常完成之前退出循环的情况。令人高兴的是，您在`switch`语句讨论中看到的`break`命令可用于立即退出循环。一些程序员试图避免这种“作弊”，但有时我认为这实际上使代码更易读。
- en: A common use case is encountering an error from user input in the middle of
    a loop. Rather than try to add extra logic to your loop condition, you can test
    for the error with an `if` statement and if you did get the error, just `break`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是在循环中遇到来自用户输入的错误。与其尝试向循环条件添加额外的逻辑，不如使用`if`语句测试错误，如果确实出现错误，就`break`。
- en: Nested Loops and Tables
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套循环和表格
- en: 'Let’s try another example. I mentioned using nested `for` loops for tabular
    data. We can use this idea to produce the classic multiplication table from grade
    school in [*ch03/multiplication.c*](https://oreil.ly/mQQbs):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个例子。我提到使用嵌套的`for`循环处理表格数据。我们可以利用这个想法在[*ch03/multiplication.c*](https://oreil.ly/mQQbs)中生成小学经典的乘法表：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That’s pretty small. This is the type of repetitive task that programs can
    solve very efficiently. And the resulting table:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这很小。这是程序可以非常高效解决的重复性任务。而且得到的表格如下：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Very gratifying! And you aren’t limited to just two loops. You could process
    three-dimensional data with three loops, as in this snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 非常令人满意！而且你不仅限于只有两个循环。你可以使用三个循环处理三维数据，就像这个片段中所示：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There is (almost) no end to the complexity you can wrap up in your code to solve
    even the thorniest problems.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有结束你可以在代码中包装的复杂性，以解决即使是最棘手的问题。
- en: Variable Scope
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域
- en: One important thing to remember about nesting statements in C is that the language
    enforces *variable scope* in its blocks. If you create a variable to use with
    a `for` loop, for example, that variable cannot be used *after* the loop has completed.
    This is true of any variable declared inside a block (e.g., inside a pair of curly
    braces) or in the setup of a `for` loop. Once the block ends, the variable is
    no longer accessible. (Sometimes you’ll hear programmers talk about a variable’s
    *visibility*, which is the same idea.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中嵌套语句的一个重要事项是，语言在其块中强制执行*变量作用域*。例如，如果你创建一个用于`for`循环的变量，那么该变量在循环完成*后*就不能再使用。这对于在块内（例如，在一对花括号内）或在`for`循环的设置中声明的任何变量都是适用的。一旦块结束，变量就不再可访问。（有时你会听到程序员谈论变量的*可见性*，这是相同的概念。）
- en: Most times you don’t have to think much about this topic, as you’ll naturally
    tend to use your variables where you declare them and that’s great. But in complex
    code structures, you can lose track of where a variable was declared and that
    can cause problems.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你不必过多考虑这个话题，因为你通常会自然地在声明变量的地方使用它们，这很好。但在复杂的代码结构中，你可能会忘记变量的声明位置，这可能会导致问题。
- en: Let’s upgrade our multiplication table program to ask the user what size of
    table (within reason!) they’d like to produce. We’ll allow any table size from
    1 to 20\. We’ll store the user’s response in a variable that can be used by both
    loops. Try the following program ([*ch03/multiplication2.c*](https://oreil.ly/0z424))
    and pay attention to the comments that highlight some potential problem areas
    where a variable is not visible.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们升级我们的乘法表程序，询问用户想要生成多大的表格（合理范围内！）。我们将允许任何从1到20的表格大小。我们将用户的响应存储在一个变量中，可以供两个循环使用。尝试以下程序（[*ch03/multiplication2.c*](https://oreil.ly/0z424)），并注意突出显示一些潜在问题区域的评论，其中一个变量不可见。
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[![1](Images/1.png)](#co_flow_of_control_CO1-1)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_flow_of_control_CO1-1)'
- en: You can see that our `tableSize` variable is visible in both loops.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的`tableSize`变量在两个循环中都是可见的。
- en: '[![2](Images/2.png)](#co_flow_of_control_CO1-3)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_flow_of_control_CO1-3)'
- en: Clearly, the `row` variable is visible inside the loop drive by the `col` variable.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在由`col`变量驱动的循环内部，`row`变量是可见的。
- en: '[![3](Images/3.png)](#co_flow_of_control_CO1-4)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_flow_of_control_CO1-4)'
- en: But once that inner `for` loop finishes printing the values for a given row,
    the `col` variable goes “out of scope” and cannot be used.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一旦内部的`for`循环完成了给定行的值的打印，`col`变量就会“超出范围”，不能再使用。
- en: 'But what happens if you try to access something that has gone out of scope?
    Well happily, the compiler will usually catch you. For example, if we try printing
    the final value of `col` where we currently print the newline character to end
    the row, we’ll get an error like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你尝试访问已经超出范围的东西会发生什么呢？幸运的是，编译器通常会警告你。例如，如果我们尝试在当前打印换行符结束行时打印`col`的最终值，我们将会得到如下错误：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Making these mistakes is never fatal. You just have to read the error message
    and figure out which bit of code is causing the problem. If you *do* need to use
    a particular variable after a loop or block concludes, you must define that variable
    before the block. For example, we could declare both of our loop variables, `row`
    and `col`, in the same spot where we declare `tableSize` to make all three of
    them visible everywhere inside our `main()` function. Our initialization step
    in our `for` loops won’t declare those variables with their `int` type, but rather
    just assign the starting value, like in [*ch03/multiplication3.c*](https://oreil.ly/yTDBc):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 犯这些错误从来不会致命。你只需阅读错误消息并找出导致问题的代码部分即可。如果你在循环或块结束后确实需要使用特定的变量，你必须在块之前定义该变量。例如，我们可以在与`tableSize`声明相同的位置声明我们的两个循环变量`row`和`col`，以便它们在`main()`函数的任何地方都可见。我们在`for`循环的初始化步骤中不会声明这些变量为`int`类型，而只是赋予起始值，就像在[*ch03/multiplication3.c*](https://oreil.ly/yTDBc)中一样。
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we run our new version with a width of 5, then, here’s our output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以宽度为5运行我们的新版本，这是我们的输出：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So we can see the final values of `row` and `col` that caused the loops to stop.
    Kind of neat, but also kind of prone to causing problems. Using variables with
    a broad or global scope is frowned on because of those potential problems. If
    you have a good reason and need to use a particular variable in different blocks,
    that’s fine, just make sure you declare such variables deliberately and not simply
    to make the program compile.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到导致循环停止的`row`和`col`的最终值。看起来很整洁，但也容易引起问题。因为这些潜在问题，不建议使用具有广泛或全局范围的变量。如果你有充分理由并且需要在不同的块中使用特定的变量，那是可以的，只是确保你有意识地声明这些变量，而不是仅仅为了让程序编译通过。
- en: Exercises
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We’ve seen the structure of several different flow of control statements in
    this chapter. Hopefully, you’ve been trying and tweaking the examples as you’ve
    been reading. But nothing helps you get comfortable with a new language or a new
    statement like using it. Over and over. And over. :) To that end, here are some
    exercises to try if you like before reading on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了几种不同的控制流结构的结构。希望你在阅读过程中已经尝试并调整了这些示例。但没有什么比反复使用新语言或新语句更能帮助你熟悉它了。为此，在继续阅读之前，这里有一些练习供你尝试。
- en: 'Print out a triangle pattern. You can hardcode the size or ask the user, like
    we did with our multiplication table. For example:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出一个三角形模式。你可以硬编码尺寸或者询问用户，就像我们在乘法表中所做的那样。例如：
- en: '[PRE52]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Print out a pyramid pattern where the rows of stars are centered, like this:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出一个金字塔模式的图案，其中星号的行是居中的，就像这样：
- en: '[PRE53]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add row and column labels to our multiplication table, like this:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行和列标签添加到我们的乘法表中，如下所示：
- en: '[PRE54]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Write a number guessing game. For now, just pick a number yourself and store
    it in a variable like `secret`. (We’ll take a look at letting the computer pick
    a random number for us in [Chapter 7](ch07.xhtml#smallerc-CHP-7).) Tell the user
    what the bounds of the range are and as they guess, give them clues about whether
    their guess is lower or higher than the secret. Playing your game might look something
    like this:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个猜数字游戏。目前，只需自己选择一个数字并将其存储在变量如`secret`中即可。（我们将在[第7章](ch07.xhtml#smallerc-CHP-7)中讨论让计算机为我们选择随机数字的方法。）告诉用户范围的界限，并在他们猜测时给予关于他们的猜测是低于还是高于秘密数字的线索。玩游戏可能看起来像这样：
- en: '[PRE55]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Try implementing Euclid’s algorithm for finding the greatest common divisor
    shared by two numbers. In *pseudocode* (English statements arranged like code
    and occasionally using operators like “=”; it’s meant to be a way of describing
    the steps of some program without requiring real code), the algorithm goes like
    this:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试实现欧几里德算法，用于找出两个数的最大公约数。在*伪代码*（英语语句排列如代码，并偶尔使用像“=”这样的操作符；它意味着描述某个程序步骤的一种方式，而不需要真正的代码）中，该算法如下所示：
- en: '[PRE56]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can just set the two values in your program or ask the user to input them.
    To check your program, the greatest common divisor of 3,456 and 1,234 is 2 and
    the greatest common divisor of 432 and 729 is 27.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在程序中设置这两个值，或者要求用户输入它们。要检查你的程序，比如3,456和1,234的最大公约数是2，而432和729的最大公约数是27。
- en: If you want to see how I solved these problems, you can look at the various
    answers in the [*ch03/exercises*](https://oreil.ly/BDw5K) folder. But I encourage
    you to try and solve them yourself before looking at my solutions. There are many,
    many ways to solve each of the exercises, and comparing your own approach to mine
    can help reinforce the syntax and purpose of the statements we’ve covered.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看我是如何解决这些问题的，你可以查看[*ch03/exercises*](https://oreil.ly/BDw5K)文件夹中的各种答案。但我鼓励你在查看我的解决方案之前尝试自己解决它们。每个练习都有许多种解决方法，比较你自己的方法和我的方法可以帮助巩固我们所学过的语句的语法和用途。
- en: Next Steps
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来的步骤
- en: The branching and repetition statements we covered in this chapter are the core
    of a computer program’s ability to solve problems. They make it possible to take
    real-world algorithms and convert them into code. Knowing C’s control statements
    comes with the added benefit of preparing you for other programming languages
    that often borrow some of C’s syntax.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章涵盖的分支和重复语句是计算机程序解决问题能力的核心。它们使得将现实世界的算法转换为代码成为可能。了解C语言的控制语句还带来一个额外的好处，即为其他编程语言做好准备，这些语言通常借用了C语言的一些语法。
- en: 'There is more of that syntax to cover, though. In the next chapter, we’ll look
    at how C handles one of the most popular tools for storing big lists of things:
    the array. With an eye on our goal of writing C code for more limited microcontrollers,
    we’ll also see how C can be used to manipulate the smallest thing in a computer:
    the bit.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多的语法需要覆盖。在下一章中，我们将看看C语言如何处理存储大量东西的最流行工具之一：数组。并且，我们将了解C如何用于操作计算机中最小的东西：位。
- en: ^([1](ch03.xhtml#idm45018734452728-marker)) C99 introduced a new type, `_Bool`,
    but we won’t be using this in our lean code. If you find yourself working with
    Boolean logic in your own coding, though, be sure to check out the *stdbool.h*
    header. You can find more details on just about everything C in Prinz and Crawford’s
    [*C in a Nutshell*](https://www.oreilly.com/library/view/c-in-a/0596006977/) (O’Reilly).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45018734452728-marker)) C99引入了一个新类型，`_Bool`，但在我们的精简代码中我们不会使用它。如果你在自己的编码中遇到布尔逻辑，请务必查看*stdbool.h*头文件。你可以在Prinz和Crawford的[*C
    in a Nutshell*](https://www.oreilly.com/library/view/c-in-a/0596006977/)（O’Reilly）中找到关于C的更多细节。
- en: ^([2](ch03.xhtml#idm45018734265544-marker)) Many languages, including C, are
    clever enough to realize that if Reg is not ready, we don’t even have to bother
    checking on Kaori. This behavior is often referred to as “short circuit evaluation.”
    Short circuit comparisons can be very useful when the tests involved are computationally
    expensive.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.xhtml#idm45018734265544-marker)) 许多语言，包括C语言，都足够聪明，意识到如果Reg尚未准备好，我们甚至无需打扰Kaori。这种行为通常称为“短路评估”。当涉及的测试计算昂贵时，短路比较非常有用。
- en: ^([3](ch03.xhtml#idm45018734246248-marker)) And like the `&&` operator, the
    C compiler optimizes the case where Reg can join by not asking Kaori at all.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.xhtml#idm45018734246248-marker)) 就像`&&`运算符一样，C编译器通过优化Reg可以连接的情况，根本不询问Kaori。
- en: '^([4](ch03.xhtml#idm45018732222664-marker)) Did you know many shampoo bottles
    come with an algorithm for washing your hair? But don’t follow the algorithm too
    closely: many times the instructions really are as simple as “lather, rinse, repeat,”
    which is an infinite loop! There is no check as to when you have repeated enough.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.xhtml#idm45018732222664-marker)) 你知道吗，许多洗发水瓶子都带有一个洗头发的算法？但不要太过拘泥于算法：很多时候指令真的就是那么简单的“涂抹、冲洗、重复”，这是一个无限循环！没有检查何时重复次数足够的内容。
- en: ^([5](ch03.xhtml#idm45018732082600-marker)) A quick nerdy detail, if you’re
    curious. *Prefix* operators come before the value or expression they are meant
    to operate on. The `i--` expression contains an example of a *postfix* operator—one
    that comes after the value or expression. In C, all of the binary operators like
    + or * or == are *infix* operators, coming “in between” the operands.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.xhtml#idm45018732082600-marker)) 如果你好奇的话，有一个快速的技术细节。*前缀*运算符出现在它们所操作的值或表达式之前。`i--`表达式包含了一个*后缀*运算符的示例—后缀运算符出现在值或表达式之后。在C语言中，所有的二元运算符如+、*或==都是*中缀*运算符，出现在操作数“之间”。
