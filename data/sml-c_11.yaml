- en: Chapter 11\. Custom Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 自定义库
- en: 'We’ve already seen how to include the headers of useful libraries that come
    with the Arduino IDE as well as how to add third-party libraries for some of the
    more interesting peripherals and sensors. But as you build up your catalog of
    microcontroller projects, you’re likely to create some code that you reuse. I
    regularly employ the maxim that there are only three numbers in the universe:
    0, 1, and many. If you find a chunk of code you use a second time, you’re in that
    “many” category and it is probably time to consider making your own library.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何包含Arduino IDE自带的有用库的头文件，以及如何为一些更有趣的外设和传感器添加第三方库。但是在构建您的微控制器项目目录时，您可能会创建一些重复使用的代码。我经常使用的格言是宇宙中只有三个数字：0、1和许多。如果您发现一段代码您第二次使用，您就属于“许多”类别，现在可能是时候考虑制作自己的库了。
- en: That statement may seem dramatic. It certainly sounds grandiose. Happily, it
    is a fairly straightforward process and really does make reuse a snap down the
    road.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种说法可能听起来有些夸张。它确实听起来很宏伟。幸运的是，这是一个相当简单的过程，确实可以使未来的重复使用变得轻而易举。
- en: I do want to admit that the project in this chapter is bigger than our past
    projects in every sense. If remote-control robotic cars don’t spike your interest,
    feel free to skip the bulk of this chapter. I would still recommend reading [“Multifile
    Projects”](#smallerc-CHP-11-SECT-2) and [“Creating the Library”](#smallerc-CHP-11-SECT-3.4)
    to get a sense of the steps involved in writing a library for your own use within
    the Arduino IDE. You can safely skip this chapter in favor of exploring an IoT
    project in [Chapter 12](ch12.xhtml#smallerc-CHP-12).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实想承认，本章项目在各个方面都比我们以往的项目都大。如果遥控机器人车不引起您的兴趣，可以放心地跳过本章大部分内容。我仍然建议阅读[“多文件项目”](#smallerc-CHP-11-SECT-2)
    和[“创建库”](#smallerc-CHP-11-SECT-3.4) 了解在Arduino IDE中为自己使用编写库的步骤。您可以安全地跳过本章，转而探索[第
    12 章](ch12.xhtml#smallerc-CHP-12) 中的物联网项目。
- en: Creating Your Own Library
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的库
- en: To get started on a custom library, you’ll need some code to reuse. The best
    way to find reusable code is to create some usable code first. We can kick off
    a normal project and then extract the parts that seem likely to work well in other
    projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建自定义库，您需要一些可重用的代码。找到可重用代码的最佳方法是首先创建一些可用的代码。我们可以启动一个普通项目，然后提取那些看似在其他项目中可能效果良好的部分。
- en: For this project, we’ll create a motorized car that can be driven with simple
    forward, backward, left, and right buttons. Once that is all working, we can break
    out the various “drive” functions into a separate file to highlight how the Arduino
    IDE works with multiple files. And finally, with a little multifile experience
    in your back pocket, we’ll make the leap to radio control and see how to encapsulate
    that communication in a library that can be shared between our car and a separate
    navigation project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将创建一个可以用简单的前进、后退、左右按钮驱动的电动车。一旦一切正常运行，我们可以将各种“驱动”功能拆分到一个单独的文件中，以突显Arduino
    IDE如何处理多个文件。最后，通过一点多文件的经验，我们将迈向无线电控制，并看看如何将该通信封装在一个库中，以便我们的车辆和单独的导航项目共享使用。
- en: '[Figure 11-1](#smallerc-CHP-11-FIG-robot-car-pic) shows the setup we’re going
    to use. I bought these parts from Adafruit, but you can assemble a similar car
    from other parts just as easily. (See [Appendix B](app02.xhtml#smallerc-APP-B)
    for the exact part numbers I used.) The physical car is reasonably simple, but
    definitely requires some assembly. I had to make a trip to my local hardware store
    for a few of the small machine screws, but the prefabricated chassis from Adafruit
    sure made things simpler. The chassis has perfect holes and sockets to guide the
    attachment of both the rear motors and the loose caster on the front. I just rested
    a breadboard and battery on top, but there are ample spots to mount these with
    clips, screws, or zip ties.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](#smallerc-CHP-11-FIG-robot-car-pic) 展示了我们将要使用的设置。我从Adafruit购买了这些零件，但您也可以轻松地从其他零件组装类似的小车。（见[附录 B](app02.xhtml#smallerc-APP-B)
    获取我使用的确切零件号码。）物理小车相当简单，但确实需要一些组装。我不得不去本地五金店买一些小机械螺丝，但Adafruit的预制底盘确实简化了事情。底盘有完美的孔和插座，可引导后部电机和前部活动轮的固定。我只是把面包板和电池放在顶部，但有足够的地方可以用夹子、螺丝或拉链带固定它们。'
- en: '![smac 1101](Images/smac_1101.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1101](Images/smac_1101.png)'
- en: Figure 11-1\. Our robot car
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1 我们的机器人小车
- en: '[Figure 11-2](#smallerc-CHP-11-FIG-robot-car-wiring) shows the wiring of our
    microcontroller, navigation joystick, and the DRV8833 motor driver breakout board.
    There are a lot more connections on this project, but hopefully not so many that
    you are overwhelmed.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-2](#smallerc-CHP-11-FIG-robot-car-wiring) 显示了我们微控制器、导航摇杆和DRV8833电机驱动板的接线。在这个项目中还有更多的连接，但希望没有太多让你感到不知所措的地方。'
- en: '![smac 1102](Images/smac_1102.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1102](Images/smac_1102.png)'
- en: Figure 11-2\. Wiring for the robot car
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-2\. 机器人车的接线图
- en: Robotics in general is a big interest of mine, but the mechanical elements are
    (way) out of my field of expertise. The extra learning required to pull off this
    project my first time around was challenging but fun—at least more fun than frustrating.
    I’ve never worked with motors before, so getting them mounted, powered, and properly
    connected so I could control them through software certainly required a little
    trial and error and no small amount of exasperated utterances. But if this particular
    project does not hold much interest for you, feel free to just follow along with
    the deconstruction of our code and see how to pull those parts back together in
    a library. But I will say that the first time you make a wheel spin by pressing
    a button, you feel like you can conquer the world. :)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人技术总体上是我非常感兴趣的一个领域，但其中的机械元素（远远）超出了我的专业领域。第一次尝试这个项目时需要额外的学习，这既是挑战，也是乐趣——至少比沮丧更有趣。我以前从未与电机打过交道，因此将它们安装、供电和正确连接以便通过软件控制它们，当然需要一些试验和不少的沮丧的叹息。但如果这个特定项目对你不太感兴趣，随时可以跟随我们的代码拆解，并看看如何将这些部分组合成一个库。但我可以说，第一次通过按下按钮让轮子旋转时，你会觉得自己可以征服世界。
    :)
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If looking at the diagram in [Figure 11-2](#smallerc-CHP-11-FIG-robot-car-wiring)
    gives you the heebie-jeebies, you can look for robotic car kits that come with
    all the necessary parts as well as detailed assembly instructions. The kits usually
    have their own coding instructions, too. Feel free to get the kit running “as
    is” and get comfortable with the electronics first. Then come back here to work
    through my code examples and apply them (probably with a few modifications that
    will reinforce the work we’re doing here) to your fully functioning car.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看到 [图 11-2](#smallerc-CHP-11-FIG-robot-car-wiring) 的图表让你感到不安，你可以寻找配备所有必要零件以及详细组装说明书的机器人车套件。这些套件通常也有它们自己的编码说明。随意先让套件“原样”运行，并先熟悉电子设备。然后再回到这里，通过我的代码示例并应用它们（可能需要一些加强我们这里工作的修改）到你的完全运行的车辆上。
- en: Preprocessor Directives
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理指令
- en: 'We’ve seen a couple of preprocessor directives already: `#include` and `#define`
    are both handled by the preprocessor. And the name “preprocessor” probably gives
    you a hint about its role in compiling your code. These directives are processed
    before your code is compiled.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个预处理指令：`#include` 和 `#define` 都由预处理器处理。而“预处理器”这个名称可能已经让你对其在编译代码中的作用有了一些了解。这些指令在编译你的代码之前被处理。
- en: The `#include` directive is used to bring in code defined in a separate file.
    After inclusion, it looks to the compiler as if you had typed in that external
    file as part of your own code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include` 指令用于引入定义在另一个文件中的代码。引入后，编译器会将其视为你在自己的代码中键入了该外部文件的内容。'
- en: The `#define` directive, as we’ve been using it, puts a human-friendly name
    on some literal. We can then use the name in our code rather than remembering
    the correct literal every time. And if we ever need to change that value, say,
    move an LED connection to a different pin on our controller, we only need to change
    it once. As with `#include`, the preprocessor replaces each instance of a `#define`
    name with its literal as though you had typed the literal directly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们一直使用的那样，`#define` 指令将一个友好的名称放在某个字面值上。然后我们可以在我们的代码中使用这个名称，而不是每次记住正确的字面值。而且，如果我们需要更改这个值，比如将LED连接移动到控制器上的其他引脚，我们只需要更改一次。与`#include`
    一样，预处理器将每个 `#define` 名称的实例替换为其字面值，就像你直接键入字面值一样。
- en: 'For our car, let’s use `#define` for the pins on our navigation joystick as
    we have with other connected peripherals:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的车辆，让我们像我们连接的其他外设一样使用 `#define` 来定义导航摇杆上的引脚：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I should point out that you can use `#define` with values other than numbers.
    Perhaps you have a standard error message or text response. Those can be defined,
    too:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，你可以使用`#define`来定义除了数字以外的其他值。也许你有一个标准的错误消息或文本响应。这些也可以定义：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Knowing how `#define` works with the preprocessor also explains why we don’t
    put a semicolon at the end. We don’t want the semicolon showing up in our code,
    after all.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 知道`#define`如何与预处理器一起工作也解释了为什么我们不在末尾放置分号。毕竟，我们不希望分号出现在我们的代码中。
- en: Preprocessor Macros
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理器宏
- en: You can take `#define` a step further as well. Not only does it handle strings,
    it can handle small pieces of logic, almost like a function. These snippets are
    often referred to as *macros* to distinguish them from actual functions. A macro
    (or macroinstruction) transforms some bit of input to a corresponding bit of output,
    typically via substitutions. Macros are not function calls. Macros are not pushed
    onto or popped off of the stack.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以进一步使用`#define`。它不仅可以处理字符串，还可以处理小段逻辑，几乎像一个函数一样。这些片段通常被称为*宏*，以区别于实际的函数。宏（或宏指令）将一些输入转换为相应的输出，通常通过替换实现。宏不是函数调用。宏不会被压入或弹出堆栈。
- en: 'Macros are great when you have a repeated bit of code that just doesn’t rise
    to the level of needing a function. They are also great when you want your snippet
    to remain data-type agnostic. For example, consider a simple macro to determine
    the minimum of two values. Here’s the definition and an example of how to use
    it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 宏在你有一段重复的代码，但不需要定义一个函数的情况下非常有用。当你希望代码片段保持数据类型无关时，宏也很棒。例如，考虑一个简单的宏来确定两个值的最小值。这里是定义和如何使用的示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create the macro, we use `#define` and a name, like before, but then we
    supply a variable (or variables) in parentheses. Whatever arguments you pass to
    the macro replace the variables in the macro’s snippet. That snippet, in turn,
    replaces the spot where it was called. It’s as if you had typed the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建宏，我们使用`#define`和一个名称，就像之前一样，然后在括号中提供一个（或多个）变量。你传递给宏的任何参数都会替换宏片段中的变量。然后，该片段替换调用它的位置。就好像你键入了以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That simple replacement process can be powerful. But do be careful. Because
    the replacement is so simple, you can create problems if you pass complex expressions
    to your macro. If, say, your expression uses an operator of lower precedence than
    one used in your macro, the intended outcome can be wrong or even uncompilable.
    You can avoid some of these problems with judicious use of parentheses, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的替换过程非常强大。但要小心。由于替换过程非常简单，如果将复杂表达式传递给宏，可能会出现问题。例如，如果你的表达式使用的运算符优先级低于宏中使用的运算符，那么预期的结果可能是错误的，甚至无法编译。通过合理使用括号可以避免其中一些问题，像这样：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even then you can create some odd code by passing just the right (er, wrong)
    expressions. The GNU documentation on C and the C preprocessor even has an entire
    section devoted to [macro pitfalls](https://oreil.ly/aKdZT).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，通过传递适当的（嗯，错误的）表达式，你仍然可以生成一些奇怪的代码。GNU关于C和C预处理器的文档甚至专门有一个章节讨论[宏的陷阱](https://oreil.ly/aKdZT)。
- en: We don’t need any macros just yet, but they’re common enough that I want you
    to recognize them if you find them in the wild. The C preprocessor is actually
    quite an interesting entity in its own right. It’s a great target for some independent
    research after you finish this book!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们还不需要任何宏，但它们很常见，如果你在其他地方找到它们，我希望你能识别出来。事实上，C预处理器本身非常有趣。在完成本书后，它是独立研究的一个很好的目标！
- en: Custom Type Definitions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型定义
- en: 'Beyond constants and macros, libraries often make use of another feature of
    C: the `typedef` operator. You can use `typedef` to assign an alias to some other
    type. That might sound unnecessary, and it technically is, but there are several
    cases where it is very convenient and leads to more readable, maintainable code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常量和宏之外，库通常还利用C的另一个特性：`typedef`操作符。你可以使用`typedef`为某种其他类型分配一个别名。这听起来可能是不必要的，而且从技术上讲确实如此，但在某些情况下非常方便，可以导致更易读、易于维护的代码。
- en: 'We saw the use of some of these `typedef` aliases in [Chapter 10](ch10.xhtml#smallerc-CHP-10).
    The `byte`, `uint8_t`, and `uint32_t` specifiers were all created with `typedef`.
    If the Arduino environment didn’t provide those for you, you could create them
    yourself like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第10章](ch10.xhtml#smallerc-CHP-10)中看到了一些`typedef`别名的使用。`byte`、`uint8_t`和`uint32_t`的指定类型都是通过`typedef`创建的。如果Arduino环境没有为你提供这些类型，你也可以像这样自己创建：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The “_t” suffix is popular for these aliases. It’s an easy way to highlight
    the fact that the name is an alias built with `typedef`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '"_t"后缀对这些别名非常流行。这是突出显示名称是使用`typedef`构建的别名的简单方式。'
- en: 'You can also use `typedef` with the `struct` keyword to make more palatable
    names for your custom, rich data types. For example, we could have used `typedef`
    in [“Defining Structures”](ch06.xhtml#smallerc-CHP-6-SECT-5.1) and defined our
    transaction like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`struct`关键字中使用`typedef`来为你的自定义丰富数据类型取一个更易读的名称。例如，在[“定义结构”](ch06.xhtml#smallerc-CHP-6-SECT-5.1)中我们可以使用`typedef`定义我们的事务如下：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This feature is not something strictly necessary for our simple library, but
    many libraries do use `typedef` to provide names for types that make more sense
    in the context of the library or that are simply easier to work with. Let’s go
    ahead and define a type for any variables that might store one of our direction
    constants:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性对于我们简单的库并不是必需的，但许多库确实使用`typedef`来为在库上下文中更合理的名称提供类型。让我们继续定义一个类型，该类型可以存储我们的方向常量之一的变量：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’ll stick with the signed version of `char` since we might find uses for
    negative values down the road. Negative numbers make great error codes if you
    are otherwise only expecting positive numbers, for example. Now let’s use our
    new type to create some typed constants:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用`char`的有符号版本，因为将来可能会用到负值。例如，如果你只期望正数，负数可以作为很好的错误代码。现在让我们使用我们的新类型创建一些类型化常量：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Recall the discussion of `const` versus `#define` in [“Constants: const versus
    #define”](ch09.xhtml#smallerc-CHP-9-SIDEBAR-const-define). This is one of those
    spots where we aren’t really doing anything that demands one approach or the other,
    but the `const` approach does add some inherent documentation to our code that
    could be useful to other readers. And I should say that 90% of the time the first
    “other reader” that sees your code is you, but you after a few weeks or months
    away from the project. Hints about your intentions like the `direction_t` type
    can be very useful in jogging your own memory.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '回想一下在[“常量：const versus #define”](ch09.xhtml#smallerc-CHP-9-SIDEBAR-const-define)中`const`与`#define`的讨论。这是一个我们并没有真正需要选择其一的地方，但`const`方法确实为我们的代码添加了一些固有的文档说明，对其他读者可能会有用。我应该说，90%的情况下，看你的代码的第一个“其他读者”是你自己，但那是在几周或几个月之后。像`direction_t`类型这样关于你意图的提示在唤醒你自己的记忆时非常有用。'
- en: Our Car Project
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的汽车项目
- en: Let’s get going! This will be our “version one” project with some extra abstraction
    that should help as we break up this project into reusable pieces. (You can take
    a look at [version 0](https://oreil.ly/Mr2ED) if you want to start with a simple
    proof of functionality.) As you work with your own project, you may not have the
    motors wired up exactly as I do. Your navigation input (buttons or a joystick)
    might be connected a little differently. Test out your setup and don’t be afraid
    of changing which pins get set `HIGH` or `LOW` in the various driving functions.
    Happily, that can all be tweaked here in software. The end goal is simply to get
    your car to roll forward when you push the joystick up.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗！这将是我们的“第一个版本”项目，有些额外的抽象应该有助于我们将这个项目拆分为可重复使用的部分。（如果你想从一个简单的功能验证开始，可以查看[版本
    0](https://oreil.ly/Mr2ED)。）当你处理自己的项目时，可能会发现自己的电机布线与我的不完全相同。你的导航输入（按钮或摇杆）可能连接方式稍有不同。测试一下你的设置，不要害怕在各种驾驶函数中更改设置为`HIGH`或`LOW`的引脚。幸运的是，所有这些都可以在软件中调整。最终目标只是在你推动摇杆向上时让你的车向前滚动。
- en: 'Here’s version 1 of our car build. As always, you can type this up yourself
    or just open [*ch11/car1/car1.ino*](https://oreil.ly/8kqQL):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的汽车构建的第一版。如往常一样，你可以自己输入这些内容，或者直接打开[*ch11/car1/car1.ino*](https://oreil.ly/8kqQL)：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Feel free to take a break from the book at this point and just have some fun.
    :) Can you drive both forward and backward? When you move the joystick left or
    right, does the car turn the way you want? Can you parallel park between two stuffed
    animal obstacles? It might feel a little awkward following your car around with
    the tethered joystick, but we’ll fix that shortly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，随时从书本中休息一下，放松一下吧。 :) 你可以前后驾驶吗？当你把摇杆向左或向右移动时，车会按照你的意愿转弯吗？你能在两个填充动物障碍物之间平行停放吗？用绳子连接的摇杆跟随你的车可能会感觉有点尴尬，但我们很快就会解决这个问题。
- en: Multifile Projects
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多文件项目
- en: Welcome back! Hope you managed to safely parallel park your new roadster. With
    a working program as our baseline, let’s break it up into some reusable parts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎回来！希望你成功地将新跑车平行停放好。有了一个工作程序作为我们的基线，让我们把它拆分成一些可重复使用的部分。
- en: C, as a language, does not really worry about where your code lives. As long
    as *gcc* can find all of the source files, header files, and libraries you mention
    in your code, it will produce usable output. Creating multifile projects for the
    Arduino IDE is a little different, however. The IDE manages some integration steps
    that would normally be left to you on the desktop. Since we’re concentrating on
    microcontrollers at this point, we’ll stick to what needs to be done in the Arduino
    IDE. If you are curious about building larger projects outside of Arduino, I’ll
    again recommend Prinz and Crawford’s [*C in a Nutshell*](https://www.oreilly.com/library/view/c-in-a/0596006977/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种语言，C并不关心代码的存放位置。只要*gcc*能找到您代码中提到的所有源文件、头文件和库，它就会生成可用的输出。但在Arduino IDE中创建多文件项目略有不同。IDE管理一些整合步骤，这些步骤通常由桌面版您自行处理。由于我们目前专注于微控制器，因此我们将专注于Arduino
    IDE中的操作。如果您对在Arduino以外构建更大项目感兴趣，我会再次推荐普林兹和克劳福德的[*C in a Nutshell*](https://www.oreilly.com/library/view/c-in-a/0596006977/)。
- en: We’ll start by converting our current project into a multifile project with
    no change in functionality. Then we’ll extend our robot car to support remote
    radio control and see how powerful shared code can be.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将当前项目转换为具有相同功能的多文件项目开始。然后，我们将扩展我们的机器人车以支持远程无线电控制，并看看共享代码的强大之处。
- en: In our small car example, we have several functions devoted to making the car
    move. Those related functions are perfect for separating into their own file.
    They all serve a similiar purpose. Their related purpose is not necessary for
    creating separate files, but it’s a popular means of organizing the pieces of
    a larger project. A small number of files, each with a small number of functions,
    can be easier to maintain and debug than a huge file with lots of functions. But
    if you break up functions randomly, it will be difficult to remember which files
    contain which functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小车示例中，我们有几个函数专门用于让汽车运动。这些相关函数非常适合分离到自己的文件中。它们都为相似的目的服务。尽管将相关功能放在单独的文件中并非必需，但这是组织更大项目片段的流行方式。少量文件，每个文件中有少量函数，可能比一个包含大量函数的巨大文件更易于维护和调试。但如果随意拆分函数，将很难记住哪些文件包含哪些函数。
- en: 'The Arduino IDE gives us a few options for breaking up our projects: we can
    add new *.ino* files, we can include custom header files, or we can create and
    then import a custom library. The rest of this chapter looks at all three of these
    mechanisms.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino IDE为我们提供了几种选项来分解项目：我们可以添加新的*.ino*文件，可以包含自定义头文件，或者可以创建并导入自定义库。本章的其余部分将讨论这三种机制。
- en: Code (.ino) Files
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码（.ino）文件
- en: To start, let’s save this project under a new name so that we have a backup
    in case something goes awry and we want to refer back to a working project. From
    the “File” menu in the Arduino IDE, select the “Save As…” option. I chose the
    highly creative and original name *car2*. You are free to be as creative or even
    more so if the muse strikes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将此项目另存为新名称，以便在出现问题并希望查看工作正常的项目时备用。在Arduino IDE的“文件”菜单中，选择“另存为…”选项。我选择了极具创意和原创性的名称*car2*。如果灵感来临，您可以更加创意无限。
- en: Now let’s take all five of our driving functions and move them to their own
    file. To add a new file, use the downward pointing triangle button on the right-hand
    side near the top. That button opens a small menu, as shown in [Figure 11-3](#smallerc-CHP-11-FIG-ide-new-tab).
    Select “New Tab” from that menu.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将我们所有五个驾驶函数移动到它们自己的文件中。要添加新文件，请使用右侧顶部附近的向下箭头按钮。该按钮将打开一个小菜单，如[图 11-3](#smallerc-CHP-11-FIG-ide-new-tab)所示。从该菜单中选择“新建标签”。
- en: '![smac 1103](Images/smac_1103.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1103](Images/smac_1103.png)'
- en: Figure 11-3\. Creating a new tab in the Arduino IDE
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-3\. 在Arduino IDE中创建新标签
- en: Next, you’ll be prompted to name the tab, as shown in [Figure 11-4](#smallerc-CHP-11-FIG-ide-name-new-tab).
    Enter the name **`drive.ino`** in the field and then click the OK button.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将提示您命名标签，如[图 11-4](#smallerc-CHP-11-FIG-ide-name-new-tab)所示。在字段中输入名称**`drive.ino`**，然后单击“确定”按钮。
- en: '![smac 1104](Images/smac_1104.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1104](Images/smac_1104.png)'
- en: Figure 11-4\. Naming our new file
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-4\. 给我们的新文件命名
- en: 'You should now have a new tab named “drive” (with no suffix showing). Go ahead
    and cut the five driving functions (including `allstop()`) from the “car2” tab
    and then paste them into our new “drive” tab. That tab will end up with the following
    code ([*ch11/car2/drive.ino*](https://oreil.ly/pRodD)):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个名为“drive”的新选项卡（没有显示后缀）。继续从“car2”选项卡中剪切五个驾驶函数（包括`allstop()`），然后粘贴到我们的新“drive”选项卡中。该选项卡最终将具有以下代码（[*ch11/car2/drive.ino*](https://oreil.ly/pRodD)）：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That’s actually all the work required to separate these pieces of code! You
    now have your first multifile Arduino project. Click the Verify (checkmark) button
    to make sure your project still compiles in its new, two-file configuration. Everything
    should still work. You can even upload this to your controller and still drive
    your car.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是分离这些代码片段所需的所有工作！现在你有了你的第一个多文件 Arduino 项目。点击验证（对号）按钮，确保你的项目在新的两个文件配置中仍然能够编译通过。一切应该还能正常工作。你甚至可以将其上传到你的控制器并继续驾驶你的车。
- en: If the project does not verify or upload, check to make sure you didn’t drop
    a curly brace or perhaps grab an extra line from the original file. You should
    also make sure the name you picked for your newly separated file ends with that
    *.ino* extension.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目无法验证或上传，请检查确保你没有丢掉花括号或者可能从原始文件中多拿了一行。您还应该确保您为新分离的文件选择的名称以 *.ino* 扩展名结尾。
- en: The Arduino IDE performs a little magic for us with *.ino* files. Our main project
    file (*car2.ino* in the *car2* folder, in this case) is prepared first. Any other
    *.ino* files will then be included in alphabetical order. You may have noticed
    that our *drive.ino* file has no `#include` statements. And yet, we clearly use
    the pin constants defined in our main file. As far as the compiler is concerned,
    there is only one large *.ino* file to compile, so successive *.ino* files see
    all of the functions, `#defines`, and global variables from the files that came
    before. At this time, there is no way to change the order of the separate *.ino*
    files; they are always incorporated alphabetically.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino IDE 在 *.ino* 文件中为我们执行了一点魔法。首先准备我们的主项目文件（在本例中是 *car2.ino* 在 *car2* 文件夹中）。然后按字母顺序包含任何其他
    *.ino* 文件。您可能已经注意到我们的 *drive.ino* 文件没有 `#include` 语句。然而，我们明显使用了在主文件中定义的引脚常量。对于编译器而言，只有一个大的
    *.ino* 文件需要编译，因此后续的 *.ino* 文件可以看到前面文件中的所有函数、`#defines` 和全局变量。目前还没有办法改变单独的 *.ino*
    文件的顺序；它们总是按字母顺序合并。
- en: Header Files
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件
- en: So how can all these separate files work together so seamlessly? The IDE adds
    one more piece of magic before loading these separate files. It creates a header
    file with *forward declarations* of all of the functions and global variables
    in your *.ino* file. Forward declarations are brief descriptions of what your
    function is named, what parameters it has, and what type of value it will return.
    They allow separate files to use a function without needing to have its full implementation.
    Each header, in turn, is automatically included in your main project file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么所有这些单独的文件是如何如此无缝地共同工作的呢？在加载这些单独文件之前，IDE 添加了一个魔法步骤。它创建了一个带有*前向声明*的头文件，其中包括你
    *.ino* 文件中所有函数和全局变量的简要描述。前向声明是关于你的函数命名、参数和返回值类型的简短描述。它们允许单独的文件在没有完整实现的情况下使用函数。每个头文件依次自动包含在你的主项目文件中。
- en: You can see the effect of this in our simple two-tab project. The *drive.ino*
    file does not need to include any extra information to make use of our `#define`
    pin entries. And the code in our main *car2.ino* file can call the functions defined
    in *drive.ino* without worrying about the ordering or specific location of the
    functions. In the end, both files fit together perfectly to complete our project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们简单的两个选项卡项目中看到这一效果。*drive.ino* 文件不需要包含任何额外的信息来使用我们的 `#define` 引脚条目。而且在我们的主
    *car2.ino* 文件中的代码可以调用 *drive.ino* 中定义的函数，而无需担心函数的顺序或特定位置。最终，这两个文件完美地结合在一起完成了我们的项目。
- en: You can also create your own header files. This can be nice for housekeeping.
    For example, if you have many `#define` statements, you could place them in their
    own header. Or if you want a low-tech means of sharing some directives between
    projects, you can make a copy of a header and put it in another project. It is
    largely up to you what makes the most sense for your own projects. Many successful
    makers out there have dozens or hundreds of projects each with one single *.ino*
    file. I just want to make sure you know how to split things into more manageable
    pieces if that one big file starts to overwhelm you.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建自己的头文件。这对于整理很有用。例如，如果有许多`#define`语句，您可以将它们放在自己的头文件中。或者，如果您希望以低技术手段在项目之间共享一些指令，您可以复制一个头文件并将其放在另一个项目中。对于您自己的项目来说，最合理的方法很大程度上取决于您自己。许多成功的制作者有数十甚至数百个项目，每个项目只有一个单独的*.ino*文件。我只是想确保您知道，如果那一个大文件开始让您不知所措，如何将其分割成更易管理的部分。
- en: In service of that goal, let’s break up our main project just a little more.
    Let’s try the trick of putting some of our `#define` directives in their own header
    file. We’ll move the eight pin constants. Create a new tab as before, and name
    it **`pins.h`** when prompted. The new tab should show the full name of the file,
    *pins.h*, to help distinguish it from *.ino* files that hide the extension.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，让我们再次稍微拆分我们的主项目。让我们尝试将一些`#define`指令放入它们自己的头文件中。我们将移动这八个引脚常量。像以前一样创建一个新的标签，并在提示时将其命名为**`pins.h`**。新的标签应显示文件的完整名称*pins.h*，以帮助区分它与隐藏扩展名的*.ino*文件。
- en: 'Cut the eight `#define` lines and the relevant comments from *car2* and paste
    them into *pins.h*. The result should look like [*ch11/car2/pins.h*](https://oreil.ly/pwQM6):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从*car2*中剪切八个`#define`行和相关的注释，并将它们粘贴到*pins.h*中。结果应如[*ch11/car2/pins.h*](https://oreil.ly/pwQM6)所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we just need to add an include statement to our *car2* tab at the top of
    our file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需在我们的文件顶部的*car2*标签中添加一个包含语句：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can check your work against my [version 2](https://oreil.ly/EWAV9). Your
    project should still verify (and upload) just as before. Feel free to give it
    a try and make sure you can still drive your car.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据我的[版本 2](https://oreil.ly/EWAV9)检查您的工作。您的项目应该像以前一样进行验证（和上传）。请随意尝试，并确保您仍然可以驾驶您的汽车。
- en: Warning
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Pay close attention to the double quotes around our *pins.h* header name. Previous
    `#include` statements used angle brackets (<>: less than, greater than). The distinction
    is intentional. The angle brackets tell the compiler to look for the header in
    the standard include path. Typically, that means you are bringing in a header
    from a known library.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们*pins.h*头文件名周围的双引号。先前的`#include`语句使用的是尖括号（<>：小于、大于）。这种区别是有意的。尖括号告诉编译器在标准包含路径中查找头文件。通常情况下，这意味着您正在从已知库中引入一个头文件。
- en: The quotes tell the compiler the file to be included is in the same folder as
    the file doing the including. Typically, that means you are bringing in a header
    file you wrote specifically for this project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 引号告诉编译器，要包含的文件与包含它的文件位于同一文件夹中。通常情况下，这意味着你在为这个项目专门编写的头文件。
- en: Again, divvying up a project is not a requirement or something you always do
    with large files, but it can be helpful. It allows you to concentrate on one part
    of your code without accidentally changing another part. If you collaborate with
    other programmers, working on separate files can also make it easier to combine
    your efforts at the end. In the end, though, it really is up to you and what you
    feel comfortable with.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，将项目分割并非强制要求，也不是在处理大文件时总是要做的事情，但这样做可能很有帮助。这样可以让你集中精力在代码的一部分上，避免意外改变另一部分。如果与其他程序员合作，使用单独的文件也可以更轻松地在最后将你们的工作结合起来。但最终，这完全取决于你自己和你感觉舒适的方式。
- en: Importing Custom Libraries
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入自定义库
- en: Beyond multiple *.ino* and *.h* files, though, you can also build your own Arduino
    IDE library. If you have code that you want to use in multiple projects or perhaps
    share with others via public code sites like GitHub, a library is a great choice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了多个*.ino*和*.h*文件外，您还可以构建自己的Arduino IDE库。如果您有代码想要在多个项目中使用，或者通过GitHub等公共代码站点与他人共享，库是一个很好的选择。
- en: Happily, creating a custom library doesn’t require too much effort. You need
    at least one *.cpp* file and a matching header (*.h*) file. You can have more
    files, if needed, as well as a few niceties we’ll discuss in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 令人高兴的是，创建自定义库并不需要太多的工作量。您至少需要一个*.cpp*文件和一个匹配的头文件（*.h*）。如果需要的话，您还可以拥有更多文件，以及我们将在下一节讨论的一些细微之处。
- en: Facilitating Communication
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 促进沟通
- en: Our robot car is spiffy, but following it around with a tethered joystick is
    clunky. A *radio-controlled* robot car would be even spiffier! We can do that,
    and using a library to manage that radio communication is a great way to guarantee
    we don’t cross any signals—literally. We can use a library to make sure multiple
    parties have access to common definitions (say, the value for driving “forward”).
    We can also put the rules of a protocol into a library’s functions. It’s a bit
    like making sure everyone is speaking the same language.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人车看起来很棒，但是用有线操纵杆跟在后面有点笨重。使用*无线电控制*的机器人车会更加酷！我们可以做到这一点，使用一个库来管理无线电通信是确保我们不会发生信号冲突的好方法——从字面上来说。我们可以使用库来确保多方可以访问共同的定义（比如“向前驾驶”的值）。我们还可以把协议的规则放入库的函数中。这有点像确保每个人都在说同一种语言。
- en: Libraries can supply more than the vocabulary of this hypothetical language.
    They can also enforce the rules of conversation. Who speaks first? Who speaks
    next? Is a response required? Can there be more than one listener? You answer
    questions like these with the functions you write in your library. As long as
    two (or more) projects use the same library, the details you encoded in the library’s
    functions will make sure everyone plays nicely together.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以提供的不仅仅是这种假设语言的词汇表。它们还可以强制执行对话的规则。谁先说话？接下来谁说？需要回复吗？可以有多个听众吗？通过你在库中编写的函数来回答这些问题。只要两个（或更多）项目使用同一个库，你在库函数中编码的细节将确保所有人都和谐相处。
- en: Let’s create a library to send and receive radio signals. We’ll create two separate
    projects that both use this library. We’ll start by replacing the joystick that
    is currently wired to our car with a radio component. Then we’ll create a controller
    project that pairs our newly liberated joystick with a similar radio. This does
    mean we need two microcontrollers, by the way. I’ll use another Metro Mini, but
    they don’t have to be identical. If you have some other controller lying around
    that is compatible with our radio and can use our library, any combination of
    controllers should work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个库来发送和接收无线电信号。我们将创建两个分开的项目，两者都使用这个库。我们将首先用一个无线电元件替换当前连接到我们车上的操纵杆。然后，我们将创建一个控制器项目，将我们新获得的操纵杆与类似的无线电配对。顺便说一句，这意味着我们需要两个微控制器。我将使用另一个Metro
    Mini，但它们不必完全相同。如果你有其他与我们的无线电兼容并可以使用我们的库的控制器闲置，任何控制器组合都应该可以工作。
- en: Retrofitting Our Car
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的车改装计划
- en: Let’s swap out the joystick for a radio transceiver. I’m using the nicely packaged
    [RFM69HCW](https://oreil.ly/JhUn8) high-power breakout from Adafruit. It’s about
    $10 and is reasonably straightforward to connect. Plus, it comes with some nice
    features like encrypted transmissions that can only be decrypted by a similar
    chip with the same encryption key (that you provide in code). [Figure 11-5](#smallerc-CHP-11-FIG-radio-car-wiring)
    shows the wiring diagram for our microcontroller, the motor driver, and our radio.
    I had to relocate several of the DRV8833 connections as the RFM69HCW requires
    the use of specific pins on our Metro Mini microcontroller (more on that in [“Our
    radio-control library header”](#smallerc-CHP-11-SECT-3.4.2)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把操纵杆换成无线电收发器。我正在使用Adafruit提供的精美包装的[RFM69HCW](https://oreil.ly/JhUn8)高功率断口。它售价约为10美元，连接起来相对简单。此外，它还具有一些不错的功能，比如只有使用相同加密密钥的类似芯片才能解密的加密传输。[图 11-5](#smallerc-CHP-11-FIG-radio-car-wiring)显示了我们的微控制器、电机驱动器和无线电的布线图。由于RFM69HCW需要在我们的Metro
    Mini微控制器上使用特定引脚，我不得不重新定位几个DRV8833的连接（在[“我们的无线电控制库标头”](#smallerc-CHP-11-SECT-3.4.2)中有更多信息）。
- en: '![smac 1105](Images/smac_1105.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1105](Images/smac_1105.png)'
- en: Figure 11-5\. Wiring for the robot car with radio transceiver
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-5\. 带有无线电收发器的机器人车的布线图
- en: Of course the power and ground pins should be connected as well. I used a 9V
    for the microcontroller (which in turn supplies power to the radio) and a separate
    power supply for the DRV8833\. The lonely green wire attached to the top of the
    RFM69HCW is just a three-inch piece of wire serving as the simplest possible antenna.^([1](ch11.xhtml#idm45018712401128))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，电源和地线引脚也应该连接好。我为微控制器使用了9V电源（该电源又供电给无线电），并为DRV8833使用了独立的电源。连接到RFM69HCW顶部的那根绿色孤单电线只是一个三英寸长的简单天线的一部分。^([1](ch11.xhtml#idm45018712401128))
- en: '[Figure 11-6](#smallerc-CHP-11-FIG-radio-car-pic) shows the assembled components,
    all ready to roll with no wires attached!'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-6](#smallerc-CHP-11-FIG-radio-car-pic)展示了装配好的组件，已经准备好滚动，没有任何连接线！'
- en: '![smac 1106](Images/smac_1106.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1106](Images/smac_1106.png)'
- en: Figure 11-6\. Our wire-free robot car
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-6\. 我们的无线无线电小车
- en: Well, no wires to a joystick, that is. The breadboard is rather lousy with wires.
    This *is* a bigger project than we’ve tackled so far. If a radio-controlled car
    isn’t up your alley, feel free to skip to the next chapter. But before you go,
    check out [“Creating the Library”](#smallerc-CHP-11-SECT-3.4) on creating the
    library code and its header file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，没有连接到操纵杆的电线。面包板上有很多电线。这个项目比我们迄今为止处理的项目要大。如果无线电控制的小车不是您的菜，可以跳到下一章。但在您离开之前，请查看[“创建库”](#smallerc-CHP-11-SECT-3.4)关于创建库代码及其头文件的部分。
- en: I’m using two separate power supplies to keep the motors separate from the microcontroller
    and the radio. If you have more experience powering Arduino projects and want
    to use a different configuration, go right ahead! The important part is that we
    have our radio ready to receive driving instructions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用两个单独的电源供应来保持电机与微控制器和无线电分开。如果您有更多经验用Arduino项目供电并想使用不同的配置，那就尽管去做！重要的是我们的无线电已准备好接收驾驶指令。
- en: Creating a Controller
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个控制器
- en: We also need a new project to take input from our joystick and send that information
    out over the radio. [Figure 11-7](#smallerc-CHP-11-FIG-controller-wiring) shows
    the wiring. Only one battery is required for the controller; the radio can be
    safely powered from the 5V pin of our microcontroller.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个新项目来接收来自我们操纵杆的输入并将该信息发送到无线电上。[图 11-7](#smallerc-CHP-11-FIG-controller-wiring)显示了接线情况。控制器只需要一个电池；无线电可以安全地从我们的微控制器的5V引脚供电。
- en: '![smac 1107](Images/smac_1107.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1107](Images/smac_1107.png)'
- en: Figure 11-7\. Wiring for the radio controller
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-7\. 无线电控制器的接线
- en: I powered the controller with a USB power pack plugged into the Metro Mini.
    [Figure 11-8](#smallerc-CHP-11-FIG-controller-pic) shows the final result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我用USB电源包将控制器连接到了Metro Mini。[图 11-8](#smallerc-CHP-11-FIG-controller-pic)展示了最终结果。
- en: '![smac 1108](Images/smac_1108.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1108](Images/smac_1108.png)'
- en: Figure 11-8\. Our wire-free controller
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-8\. 我们的无线控制器
- en: Not the most glamorous of gadgets, but it does send radio signals! At least,
    it will once we add a little code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不是最引人注目的小工具，但它确实发送无线电信号！至少，一旦我们添加一点代码，它就会发送。
- en: Creating the Library
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建库
- en: The code for both our car and our controller will require our radio library,
    so let’s start there. We’ll be creating one header file and one *.cpp* file to
    accommodate the C++-centric nature of the Arduino IDE. The actual code will still
    be (mostly) vanilla C, it just needs to live in a file with that *.cpp* extension.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小车和控制器的代码都需要我们的无线电库，所以让我们从这里开始。我们将创建一个头文件和一个*.cpp*文件，以适应Arduino IDE的C++中心性质。实际代码仍将是（大部分）纯C，只是需要放在具有*.cpp*扩展名的文件中。
- en: How you go about writing this code is really up to you. You can write everything
    in one file and then separate out the parts that go into the header (much like
    we did earlier in this chapter). You can also use the header as a sort of outline
    or plan. Fill out the header with your constants and names of your functions,
    then go create the *.cpp* file to implement those functions. Regardless of which
    path sounds better to you, we need to put the files in a specific place before
    the IDE will recognize them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如何编写这段代码完全取决于您。您可以在一个文件中编写所有内容，然后将要放入头文件的部分分离出来（就像我们在本章前面所做的那样）。您还可以将头文件用作大纲或计划。填写头文件中的常量和函数名称，然后创建*.cpp*文件来实现这些函数。无论哪种路径听起来更好，我们都需要将文件放在特定位置，以便IDE能够识别它们。
- en: The libraries folder
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库文件夹
- en: We place all of the files for our library inside one folder that goes in the
    *libraries* folder wherever your Arduino sketches live. On my Linux box, that’s
    the *Arduino* folder in my home directory. If you’re not sure where that folder
    is on your system, you can check the preferences in the Arduino IDE. From the
    File menu, select the Preferences option. You should see a dialog similar to [Figure 11-9](#smallerc-CHP-11-FIG-ide-sketch-location).
    Notice the “Sketchbook location” toward the top. That’s where the *libraries*
    folder needs to go. If there isn’t one there already, go ahead and create that
    now.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将库中的所有文件放在一个文件夹中，该文件夹位于您的Arduino草图所在的*libraries*文件夹中。在我的Linux系统中，这是我主目录中的*Arduino*文件夹。如果您不确定系统中该文件夹的位置，可以在Arduino
    IDE的首选项中查看。从“文件”菜单中，选择“首选项”选项。您应该看到类似于[图 11-9](#smallerc-CHP-11-FIG-ide-sketch-location)的对话框。注意顶部的“草图位置”。*libraries*文件夹需要放在那里。如果那里还没有这样的文件夹，请立即创建。
- en: '![smac 1109](Images/smac_1109.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![smac 1109](Images/smac_1109.png)'
- en: Figure 11-9\. The Sketchbook location preference setting
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-9\. Sketchbook位置首选项设置
- en: It’s actually useful that we’re looking at this folder now, since we need to
    manually install the library for our radio breakout. It will go in this same folder.
    I’m using the [radio library](https://oreil.ly/YLphd) written by the folks at
    Adafruit.^([2](ch11.xhtml#idm45018712345416)) Download the ZIP archive from the
    green “Code” drop-down button. Unzip that file and rename the resulting folder
    **`RadioHead`**. Place this *RadioHead* folder in the *libraries* folder, and
    that’s it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看这个文件夹实际上很有用，因为我们需要手动安装我们的无线电模块库。它将放在同一个文件夹中。我使用由Adafruit团队编写的[无线电库](https://oreil.ly/YLphd)。^([2](ch11.xhtml#idm45018712345416))从绿色的“代码”下拉按钮下载ZIP存档。解压文件并将生成的文件夹重命名为**`RadioHead`**。将此*RadioHead*文件夹放入*libraries*文件夹中，就完成了。
- en: Well, that’s it for the radio library. We still need to make a folder for our
    own, yet to be written, library. Inside the *libraries* folder, create a new folder
    and pick a name for your custom library. Since this is a *r*adio *c*ontrol library
    for a *r*obot *c*ar, and the title of this book ends in those two letters, I chose
    to name mine *SmalleRC*. You are under no pressure to use such delightful, nerdy
    puns for your library names, by the way. This is where the “custom” adjective
    comes in. Customize your library however you like!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这就是关于无线电库的全部内容。我们仍然需要为我们尚未编写的库创建一个文件夹。在*libraries*文件夹内，创建一个新文件夹并为您的自定义库选择一个名称。由于这是一个用于*r*obot
    *c*ar的*r*adio *c*ontrol库，并且本书的标题以这两个字母结尾，我选择将其命名为*SmalleRC*。顺便说一句，您无需压力使用这样的有趣、书呆子风格的名称来命名您的库。这就是“自定义”形容词的作用。按照您的喜好自定义您的库！
- en: Our radio-control library header
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的无线电控制库标头
- en: Inside your new library folder, then, let’s create our files. I’ll use the second
    approach and start with the header file, [*SmalleRC.h*](https://oreil.ly/koHtr).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的新库文件夹里，让我们创建我们的文件。我会采用第二种方法，从头文件[*SmalleRC.h*](https://oreil.ly/koHtr)开始。
- en: 'We’ll load the headers we need for our radio work as well as the *Arduino.h*
    header in case we rely on any Arduino-specific functions in our library code.
    We’ll define several constants and then provide some function prototypes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载我们在无线电工作中需要的标头，以及*Arduino.h*标头，以防我们的库代码依赖于任何Arduino特定的函数。我们将定义几个常量，然后提供一些函数原型：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_custom_libraries_CO1-1)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_custom_libraries_CO1-1)'
- en: We’ll use a header guard like we did with *pins.h*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像*pins.h*一样使用一个头文件保护。
- en: '[![2](Images/2.png)](#co_custom_libraries_CO1-2)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_custom_libraries_CO1-2)'
- en: Our library code may need some of the Arduino-specific types or functions, so
    we include this header. It is automatically included in our main project by the
    IDE, which is why we haven’t seen this `#include` before.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的库代码可能需要一些Arduino特定的类型或函数，因此我们包含了这个标头。这个标头由IDE自动包含在我们的主项目中，这就是为什么我们之前没有看到这个`#include`。
- en: '[![3](Images/3.png)](#co_custom_libraries_CO1-3)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_custom_libraries_CO1-3)'
- en: The SPI ([Serial Peripheral Interface](https://oreil.ly/eZmyO)) header allows
    us to perform complex communication (i.e., something other than `HIGH` and `LOW`
    or single values) with a peripheral using only a few wires. We’ll use this type
    of connection with our radio breakout board. Our microcontroller has very specific
    pins for SPI, so we don’t have to specify which ones to use. [Figure 11-7](#smallerc-CHP-11-FIG-controller-wiring)
    shows the correct connections to make.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: SPI（[串行外围接口](https://oreil.ly/eZmyO)）标头允许我们使用只有几根线的外设执行复杂通信（即不是`HIGH`和`LOW`或单个值）。我们将使用这种类型的连接与我们的无线电模块板。我们的微控制器有非常特定的SPI引脚，因此我们不必指定要使用哪些引脚。[图 11-7](#smallerc-CHP-11-FIG-controller-wiring)展示了正确的连接方式。
- en: '[![4](Images/4.png)](#co_custom_libraries_CO1-4)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_custom_libraries_CO1-4)'
- en: We’ll need the RH_RF69 library we just installed to talk to the radio.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要刚刚安装的RH_RF69库来与无线电通信。
- en: '[![5](Images/5.png)](#co_custom_libraries_CO1-5)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_custom_libraries_CO1-5)'
- en: While SPI takes care of most communication needs, these `define` entries fill
    in some details needed by the RH_RF69 library to operate our radio, including
    the frequency to use (`RF69_FREQ`; use 433 MHz in Europe and 868 or 915 MHz in
    the Americas) and which pins handle the interrupts and resets.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SPI处理了大多数通信需求，但这些`define`条目填补了RH_RF69库操作我们的无线电所需的一些细节，包括要使用的频率（`RF69_FREQ`；在欧洲使用433
    MHz，在美洲使用868或915 MHz）以及处理中断和复位的引脚。
- en: '[![6](Images/6.png)](#co_custom_libraries_CO1-6)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_custom_libraries_CO1-6)'
- en: We’ll define a few of our own constants to help coordinate the initialization
    of our radio. We’ll distinguish failures in a way that can help us debug any issues.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一些自己的常量来帮助协调我们的无线电的初始化。我们将以一种可以帮助我们调试任何问题的方式区分故障。
- en: '[![7](Images/7.png)](#co_custom_libraries_CO1-7)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_custom_libraries_CO1-7)'
- en: We can put our `typedef` here so that everyone importing this library has access
    to the `direction_t` type alias. We’ll also include our directions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里放置我们的`typedef`，以便每个导入这个库的人都可以访问`direction_t`类型别名。我们还将包含我们的方向。
- en: '[![8](Images/8.png)](#co_custom_libraries_CO1-8)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_custom_libraries_CO1-8)'
- en: These are the forward declarations (also called function prototypes) for our
    library. We’ll need to write the complete functions in our *.cpp* file, and those
    functions will have the same names and parameters as the ones declared here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们库的前向声明（也称为函数原型）。我们需要在我们的*.cpp*文件中编写完整的函数，并且这些函数将与此处声明的名称和参数相同。
- en: That’s quite a lot of detail in one header file! But that’s what header files
    are for. In the absence of any other documentation, reading a header file should
    tell you just about everything you need to know to use a library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个头文件中包含了相当多的细节！但这就是头文件的作用。在没有任何其他文档的情况下，阅读头文件应该告诉您几乎所有您需要知道的东西来使用库。
- en: Warning
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: I’m cheating a bit with this header. For an Arduino library that you intend
    to share with others, you wouldn’t normally dictate the pins to use in connecting
    peripherals. We have the ability to make this header match up with our physical
    project, but other users might not have the same controller or the same free pins.
    See [“Sharing online”](#smallerc-CHP-11-SECT-3.8.3) for some tips on digging deeper
    into shareable library creation. For libraries meant solely for your own projects,
    though, you’re allowed a shortcut or two.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个头文件，我稍微作弊了。对于打算与他人分享的Arduino库，您通常不会指定连接外围设备的引脚。我们有能力使这个头文件与我们的物理项目匹配，但其他用户可能没有相同的控制器或相同的空闲引脚。查看[“在线分享”](#smallerc-CHP-11-SECT-3.8.3)以获取一些有关深入了解可共享库创建的提示。不过，对于专门用于自己项目的库，您可以允许几个捷径。
- en: Our radio-control library code
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的无线电控制库代码
- en: 'To complete our library, then, we need to write some code and implement the
    functions that were prototyped in our header file. This code is not very complex,
    but it does have several novel parts related to enabling and communicating with
    our radio. You can type it in yourself or pull up [*SmalleRC.cpp*](https://oreil.ly/pc5v4)
    in your editor:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们的库，我们需要编写一些代码并实现在我们的头文件中声明的函数。这些代码并不是非常复杂，但它确实有几个与启用和与我们的无线电通信相关的新颖部分。您可以自己键入它，也可以在您的编辑器中打开[*SmalleRC.cpp*](https://oreil.ly/pc5v4)：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](Images/1.png)](#co_custom_libraries_CO2-1)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_custom_libraries_CO2-1)'
- en: Include our recently built header file with all the pins, directions, and radio
    configuration information.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 包含我们最近构建的包含所有引脚、方向和无线电配置信息的头文件。
- en: '[![2](Images/2.png)](#co_custom_libraries_CO2-2)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_custom_libraries_CO2-2)'
- en: Create a radio control object similar to the NeoPixel objects in previous projects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类似于前期项目中的NeoPixel对象的无线电控制对象。
- en: '[![3](Images/3.png)](#co_custom_libraries_CO2-3)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_custom_libraries_CO2-3)'
- en: Initialize the radio. This code is based on the examples included with the library
    we installed. See [“Sharing online”](#smallerc-CHP-11-SECT-3.8.3) for a few more
    details on examples and other library documentation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化无线电。此代码基于我们安装的库中包含的示例。查看[“在线分享”](#smallerc-CHP-11-SECT-3.8.3)以获取有关示例和其他库文档的更多详细信息。
- en: '[![4](Images/4.png)](#co_custom_libraries_CO2-4)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_custom_libraries_CO2-4)'
- en: Part of the radio initialization is setting an encryption key that will make
    sure only other radios using the same key can communicate with us. These values
    are exactly those from the example. Feel free to change them, just make sure the
    key is 16 bytes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无线电初始化的一部分是设置一个加密密钥，确保只有使用相同密钥的其他无线电设备可以与我们通信。这些值正是示例中的那些。如果愿意，可以随意更改它们，只需确保密钥为16字节。
- en: '[![5](Images/5.png)](#co_custom_libraries_CO2-5)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_custom_libraries_CO2-5)'
- en: A simple function to broadcast a direction. The radio library expects a packet
    of `uint8_t` values, so we create a one-element array to match. The library can
    send longer messages, of course, but we only need to send this single value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的函数来广播一个方向。无线电库期望一个`uint8_t`值的数据包，因此我们创建一个单元素数组来匹配。当然，该库可以发送更长的消息，但我们只需要发送这一个单值。
- en: '[![6](Images/6.png)](#co_custom_libraries_CO2-6)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_custom_libraries_CO2-6)'
- en: The receiving function to read any directions coming from the controller. Again,
    the radio library can handle longer messages, but we only need the first byte,
    which should contain our direction. If there’s no message at all, return `-1`
    to let the caller know nothing was ready. Otherwise, return the direction we received
    or `STOP` as a default.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接收函数用于读取从控制器传来的任何方向指令。同样，无线电库可以处理更长的消息，但我们只需要第一个字节，它应该包含我们的方向。如果根本没有消息，返回`-1`以告知调用者没有准备好的消息。否则，返回我们收到的方向，或者默认返回`STOP`。
- en: With our custom library in place, we can look at writing the actual projects
    for the car and the controller. But we sure whizzed through this code! If you’re
    curious about radio communication, I encourage you to [play with the examples](https://oreil.ly/7YRVZ)
    from the radio library to get a better feel for what possibilities and limits
    exist.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的自定义库，我们可以开始编写汽车和控制器的实际项目。但我们确实在这段代码中快速穿过了！如果您对无线电通信感兴趣，我建议您[尝试一些例子](https://oreil.ly/7YRVZ)来更好地了解可能性和限制。
- en: Updating the Car Project
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新汽车项目
- en: Now we need to write the code for the car. (Feel free to review the physical
    setup of the car and breakouts in [“Retrofitting Our Car”](#smallerc-CHP-11-SECT-3.2).)
    Essentially, we are going to replace the logic for polling the joystick with a
    call to check for data from the radio. We’ll pause for a few milliseconds to avoid
    starting and stopping the motors too quickly. Otherwise, we’ll run a pretty tight
    loop so that the car feels responsive to our remote controller.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写汽车的代码。（随意查看汽车的物理设置和[“改装我们的汽车”](#smallerc-CHP-11-SECT-3.2)中的打破点。）基本上，我们将用一个从无线电接收数据的调用来替换轮询操纵杆的逻辑。我们会暂停几毫秒，以避免电机快速启停。否则，我们将运行一个相当紧密的循环，使汽车对我们的遥控器反应灵敏。
- en: 'I based this version ([*car3*](https://oreil.ly/Dk0JC)) on the *car2* project,
    which had the separate *pins.h* and *drive.ino* files. We no longer need the pins
    for the joystick in this project, so the header file is a bit shorter:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我基于*car2*项目创建了这个版本（[*car3*](https://oreil.ly/Dk0JC)），该项目有单独的*pins.h*和*drive.ino*文件。在这个项目中，我们不再需要操纵杆的引脚，所以头文件变得稍微短一些：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The driving functions are completely unchanged so I’ll leave those out, but
    you can review the code ([“Code (.ino) Files”](#smallerc-CHP-11-SECT-2.1)) if
    you want. The code for the main [*car3.ino*](https://oreil.ly/JcLJl) file should
    feel familiar, but obviously we need to include the header file of our new radio
    library:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶功能完全没有改变，所以我将它们略过，但如果您愿意，您可以查看代码（[“代码（.ino）文件”](#smallerc-CHP-11-SECT-2.1)）。主要的[*car3.ino*](https://oreil.ly/JcLJl)文件的代码应该感觉很熟悉，但显然我们需要包括我们新的无线电库的头文件：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that I’m using the new navigation constants (like `rc_LEFT`) defined
    in the *SmalleRC.h* file. But that’s really all the code we need now to drive
    our car! This is one of the many benefits from separating out chunks of common
    code. By building on that shared code, you can more quickly create some very interesting
    projects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我正在使用*SmalleRC.h*文件中定义的新导航常量（如`rc_LEFT`）。但这就是我们现在驾驶汽车所需的所有代码！这是通过分离共享代码块的众多好处之一。通过在这些共享代码基础上构建，您可以更快地创建一些非常有趣的项目。
- en: There’s no good way to test this new *car3* project just yet, but go ahead and
    upload it to your microcontroller. If nothing else, you can use the Serial Monitor
    tool to ensure that there were no errors in starting up the radio to receive.
    I went with the “no news is good news” approach to errors in the `setup()` function,
    but feel free to alter that a bit to produce a success message if you like.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有很好的方法来测试这个新的*car3*项目，但请继续将其上传到您的微控制器上。如果没有其他问题，您可以使用串行监视器工具确保无线电启动没有错误。对于`setup()`函数中的错误，我采取了“没有消息就是好消息”的方法，但如果您愿意，可以稍微修改以生成成功消息。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Now that the Arduino IDE knows about our *SmalleRC* library, you can actually
    edit the source files of that library in place and then reverify or reupload the
    project. If you do have some trouble starting the radio, for example, add some
    debugging calls to `Serial.println()` in *SmalleRC.cpp*. Once you have the problem
    isolated and solved, you can remove the debugging statements and upload once more.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Arduino IDE已经知道我们的*SmalleRC*库，您实际上可以直接在该库的源文件上进行编辑，然后重新验证或重新上传项目。例如，如果您在启动无线电时遇到问题，请在*SmalleRC.cpp*中添加一些调试调用到`Serial.println()`。一旦您已经找到并解决了问题，您可以删除调试语句并重新上传一次。
- en: Getting It Under Control
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把控制权在手中
- en: 'Next up is getting the controller programmed. (Again, look back at [“Creating
    a Controller”](#smallerc-CHP-11-SECT-3.3) if you still need to build the physical
    remote control.) Here we take the joystick polling and instead of sending the
    results to the motors, we broadcast any directional information over our radio.
    This is a pretty small project thanks to the library, so I left it in a single
    [*ch11/controller/controller.ino*](https://oreil.ly/rSPTh) file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是编程控制器。（如果你还需要构建物理遥控器，请回顾一下[“创建控制器”](#smallerc-CHP-11-SECT-3.3)。）在这里，我们对摇杆轮询进行了处理，而不是将结果发送给电机，而是通过无线电广播任何方向信息。多亏了这个库，这是一个相当小的项目，所以我把它放在了一个单独的
    [*ch11/controller/controller.ino*](https://oreil.ly/rSPTh) 文件中：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We could have put the logic of the `readDirection()` function right inside our
    `loop()` function, but I like how concise `loop()` is with this small abstraction.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以把 `readDirection()` 函数的逻辑直接放在我们的 `loop()` 函数中，但我喜欢这种用小抽象使 `loop()` 函数变得简洁的方式。
- en: Try verifying this new project and if you hit any snags, add a few more `Serial.println()`
    statements. And remember, you can also add those to your library code if needed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试验证这个新项目，如果遇到任何问题，添加几个 `Serial.println()` 语句。并记住，如果需要的话，你也可以将它们添加到你的库代码中。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: For projects like this, where so much work is done in libraries (not just our
    custom one, but also libraries like `RF_RH69`) `println()` calls may not help
    with every problem. Bugs in downloaded libraries do happen, but they’re pretty
    rare. I find many problems are caused by me getting some of the wiring wrong.
    So if things still aren’t working, try double-checking your connections between
    the microcontroller and the various peripherals.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样大量使用库的项目（不仅仅是我们的自定义库，还有像 `RF_RH69` 这样的库），`println()` 调用可能并不能帮助解决每一个问题。下载的库中确实会出现
    bug，但这种情况相当罕见。我发现许多问题是由于我错接了一些线路引起的。所以，如果事情仍然没有解决，请尝试再次检查你的微控制器与各种外围设备之间的连接。
- en: Go Driving!
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开车吧！
- en: No code. No diagrams. No instructions. Just another point in this chapter where
    I wholly encourage you to go play. :) Try powering up both projects and see what
    happens when you move the joystick. There are definitely things that could go
    wrong! If the wiring isn’t quite right, for example, the car might move, but not
    in the direction you meant. (I accidentally swapped the right-side motor input
    pins when moving the project to a full-size breadboard, for example. The right
    wheel turned, but in the wrong direction.) Or if we have the wrong pins connected
    to the joystick, we might not send any signal at all.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 没有代码。没有图表。没有指导。在这一章中，我完全鼓励你去玩耍。 :) 尝试同时启动两个项目，看看当你移动摇杆时会发生什么。肯定会出现一些问题！例如，如果接线不太对，车可能会移动，但不是你想要的方向。（例如，当我把项目移到全尺寸面包板时，我意外地交换了右侧电机输入引脚。右轮转动了，但方向错了。）或者如果我们连接摇杆的引脚错了，可能会完全没有发送任何信号。
- en: If the car doesn’t budge, it’s time yet again to break out your debugging skills.
    You can have both projects connected to your computer at the same time, by the
    way. They will simply be on different serial ports. (Remember, you can set which
    port you use for your microcontroller through the Tools menu in the Arduino IDE.)
    You can use `Serial.println()` statements to make sure your inputs, sends, receives,
    and drives are all doing what you expect them to do. Just watch out for success!
    When you do get things working, it’s surprisingly easy to drive your car right
    off the desk and leave a string of electronics dangling from your USB cable. Or,
    you know, so I’m told.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果汽车一动不动，又到了展示你调试技能的时候了。顺便提一下，你可以同时连接两个项目到你的电脑上。它们只是连接到不同的串行端口上。 （记住，在 Arduino
    IDE 的工具菜单中可以设置你的微控制器使用哪个端口。）你可以使用 `Serial.println()` 语句来确保你的输入、发送、接收和驱动都按照你的预期工作。只需关注成功！当你把事情搞定时，很容易就能把你的车开到桌子上，留下一串电子设备悬挂在
    USB 线上。或者，你懂的，就是这样告诉我的。
- en: Documentation and Distribution
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档和分发
- en: Once your library is working and you’ve had enough fun zipping around your room,
    it’s time to think about adding a little documentation to your project. Documentation
    is great. Not just for other programmers who might use your library, either. If
    you step away from a project even just for a few days, any documentation you wrote
    can be surprisingly useful for helping you get your own mind back up to speed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的库可以工作了，并且你已经在房间里充分享受了足够的乐趣，那么是时候考虑为你的项目添加一些文档了。文档非常重要。不仅仅是为了其他可能会使用你的库的程序员。即使你离开一个项目只有几天，你写的任何文档也会出人意料地对帮助你自己快速理清思路很有用。
- en: Keywords
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键词
- en: One very simple piece of documentation that you can add for use with the Arduino
    IDE is a single text file called *keywords.txt*. For a custom library, it should
    contain two columns, separated by a tab. The first column contains functions,
    constants, and data types defined in your library. The second column should contain
    one entry from [Table 11-1](#smallerc-CHP-11-TAB-keywords-txt) indicating the
    category of the name in the first column.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加到用于Arduino IDE的非常简单的文档之一是称为*keywords.txt*的单个文本文件。对于自定义库，它应该包含两列，用制表符分隔。第一列包含库中定义的函数、常量和数据类型。第二列应包含[表 11-1](#smallerc-CHP-11-TAB-keywords-txt)中的一个条目，指示第一列中名称的类别。
- en: Table 11-1\. Keyword categories for documenting Arduino libraries
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1\. 用于文档化Arduino库的关键字类别
- en: '| Category Name | Purpose | Appearance |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 类别名称 | 目的 | 外观 |'
- en: '| --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| KEYWORD1 | data types | orange, bold |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| KEYWORD1 | 数据类型 | 橙色, 粗体 |'
- en: '| KEYWORD2 | functions | orange, plain |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| KEYWORD2 | 函数 | 橙色, 普通 |'
- en: '| LITERAL1 | constants | blue, plain |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| LITERAL1 | 常量 | 蓝色, 普通 |'
- en: While limited, these few categories can still help programmers who rely on the
    IDE cues for things like whether or not they spelled a function name correctly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有限，这几个类别仍然可以帮助依赖IDE提示的程序员，比如他们是否正确拼写了函数名。
- en: 'For our library, then, we could create the following entries (again, separated
    by a tab) in our own [*keywords.txt*](https://oreil.ly/o3KjH) file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的库，我们可以在我们自己的[*keywords.txt*](https://oreil.ly/o3KjH)文件中创建以下条目（再次用制表符分隔）：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Basically, that list is everything we defined in our *SmalleRC.h* file minus
    the few constants that were used only by the radio library. If you restart your
    IDE at this point, the functions and other names listed in the file will share
    the same syntax highlighting that the core language uses! Very cool.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，该列表包含了我们在*SmalleRC.h*文件中定义的所有内容，减去仅由无线电库使用的少量常量。如果您此时重新启动您的IDE，文件中列出的函数和其他名称将与核心语言使用的语法高亮显示相同！非常酷。
- en: Warning
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be sure to use real tab characters to separate the columns in *keywords.txt*.
    Spaces will not work. Many editors (like VS Code, for example) have a reasonable
    setting that turns all tabs into the appropriate number of spaces when the file
    is saved. There are many reasons that quiet change can be useful in source files,
    but we don’t want it here.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在*keywords.txt*中使用真正的制表符来分隔列。空格是不起作用的。许多编辑器（例如VS Code）有一个合理的设置，当保存文件时，将所有制表符转换为适当数量的空格。在源文件中，这种静默更改可能有很多有用的原因，但在这里我们不想要它。
- en: If you can’t temporarily disable this feature in your editor of choice, *keywords.txt*
    really is just a text file. You can create or edit it using any text editor, including
    very simple ones like Notepad in Windows 10 or TextEdit in macOS.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法在您选择的编辑器中暂时禁用此功能，*keywords.txt*确实只是一个文本文件。您可以使用任何文本编辑器创建或编辑它，包括像Windows
    10中的记事本或macOS中的TextEdit这样非常简单的编辑器。
- en: Including examples
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包括示例
- en: Including a few example projects with your library is another great addition
    that doesn’t require too much effort. You simply create an *examples* folder in
    the folder with your library code and *keywords.txt* file. Inside *examples*,
    then, you can place a few project folders. (Use the entire folder, not just the
    *.ino* file inside.)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 包括几个示例项目与您的库一起是另一个很好的补充，而且不需要太多的工作。您只需在包含库代码和*keywords.txt*文件的文件夹中创建一个名为*examples*的文件夹。然后，在*examples*文件夹中，您可以放置几个项目文件夹（使用整个文件夹，而不仅仅是内部的*.ino*文件）。
- en: Example projects should be short and sweet. Don’t include unnecessary features
    that don’t make use of the library if at all possible. You want a new user to
    see the important parts of your library and how they fit within a sketch. If your
    library is fairly rich, don’t be afraid of providing several smaller examples
    that each focus on a particular aspect of the library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目应该简短而精炼。如果可能的话，不要包含不使用该库的不必要功能。您希望新用户能看到库的重要部分以及它们在草图中的使用方式。如果您的库相当丰富，不要害怕提供几个小示例，每个示例都侧重于库的特定方面。
- en: Of course, you will find the other end of that “smaller, focused” spectrum in
    the wild. Sometimes a single example contains a demonstration of every single
    feature in a library. While these expansive examples do highlight the use of a
    library, they can make it more difficult for an outsider to extract details. If
    you’re only trying to learn about one or two of the functions in a library, big
    examples can be overwhelming.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你会在野外发现那种“更小、更专注”的反面。有时一个单一的示例包含了库中每一个特性的演示。虽然这些广泛的示例确实突出了库的使用，但对于外部人员来提取详细信息可能会更加困难。如果你只是想了解库中的一个或两个功能，那么大型示例可能会令人不知所措。
- en: But any example is better than no examples! If you only have the energy for
    the single, comprehensive approach, include it. If you host it somewhere public
    like GitHub, you might even invite other users to contribute some focused examples
    from their own projects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但任何例子总比没有例子好！如果你只有精力进行单一全面的方法，那就包括它。如果你将它托管在像GitHub这样的公共位置，甚至可以邀请其他用户从他们自己的项目中贡献一些专注的示例。
- en: Sharing online
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线分享
- en: 'If you do get serious about sharing your code, you’ll want to check out the
    official [Library Guide](https://oreil.ly/hB0rX) online, as well as the excellent
    [Library Specification](https://oreil.ly/uifGf) document. There are a few more
    things you can add to your library folder if you want it to feel polished. You
    can even get your library to work with the Library Manager in the IDE. A quick
    heads-up, though: these docs (reasonably) use C++. C++ has many more facilities
    for sharing the appropriate parts of your code while hiding the implementation
    details. There are definitely bits of syntax that will be new to you, but hopefully
    nothing too overwhelming.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的打算分享你的代码，你可能需要查阅官方的[库指南](https://oreil.ly/hB0rX)，以及优秀的[库规范](https://oreil.ly/uifGf)文档。如果你希望使你的库更加完善，可以向库文件夹中添加一些内容。你甚至可以让你的库在IDE中的库管理器中工作起来。不过，请注意：这些文档（合理地）使用C++。C++有许多更多的设施可以用来分享代码的适当部分，同时隐藏实现细节。肯定会有一些语法细节对你来说是新的，但希望不会太难以理解。
- en: As a first step toward publishing your library, check out the [FAQ](https://oreil.ly/3y4IT)
    direct from the Arduino team.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 作为发布库的第一步，请查看来自Arduino团队的[常见问题解答](https://oreil.ly/3y4IT)。
- en: Next Steps
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Even if you never publish a library, we have seen how to manage larger projects
    with several tricks including preprocessor macros, type aliasing, and using multiple
    tabs in the Arduino IDE. We also covered creating simple libraries that you can
    manually install on your system to share between your own projects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你从未发布过库，我们也看到如何通过包括预处理器宏、类型别名以及在Arduino IDE中使用多个选项卡等多种技巧来管理更大的项目。我们还介绍了创建简单库的方法，这些库可以手动安装在系统上，以便在自己的项目之间共享。
- en: It’s useful to remember that the tab and library stuff is peculiar to the Arduino
    IDE. Other IDEs or environments may have their own quirks, but you can almost
    always find a way to use multiple files when needed. The main goal is to keep
    you productive with whatever tools you choose.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，选项卡和库文件这些东西是Arduino IDE特有的。其他IDE或环境可能有它们自己的怪癖，但通常情况下，你可以找到使用多个文件的方法。主要目标是让你能够在选择的任何工具上保持高效率。
- en: I mentioned that you might want to know a little C++ if you publish any libraries.
    C++ in general is an excellent topic to explore after this book. In the next chapter,
    we’ll look at a more advanced project as a stepping-stone out into the wider world.
    I’ll also suggest a few other topics worth considering as you continue to expand
    your C and Arduino skills.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到如果你要发布任何库，可能需要了解一些C++。总体来说，C++是一个在阅读本书后探索的极好主题。在下一章中，我们将看到一个更高级的项目，作为进入更广阔世界的一个台阶。我还会建议你继续扩展你的C和Arduino技能时考虑的一些其他主题。
- en: ^([1](ch11.xhtml#idm45018712401128-marker)) There are certainly [fancier options](https://oreil.ly/AEvxE)
    available if you are so inclined or want to communicate over longer distances.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.xhtml#idm45018712401128-marker)) 如果你倾向于或者需要在更长的距离上进行通信，肯定有更多的[高级选项](https://oreil.ly/AEvxE)可供选择。
- en: ^([2](ch11.xhtml#idm45018712345416-marker)) *Forked* would be a better verb
    than *written*. The Adafruit library is based on the [AirSpayce RadioHead](https://oreil.ly/nP82M)
    library written by Mike McCauley.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.xhtml#idm45018712345416-marker)) *分叉* 比 *编写* 更合适。Adafruit库基于Mike
    McCauley编写的[AirSpayce RadioHead](https://oreil.ly/nP82M)库。
