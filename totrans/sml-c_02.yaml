- en: Chapter 2\. Storing and Stating
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。存储与状态
- en: The essence of programming is the manipulation of data. A programming language
    provides humans an interface for telling the computer what that data is and what
    you want to do to that data. Languages designed for powerful machines may hide
    (or infer) a lot of the details about storing data, but C remains fairly simple
    in this regard. Perhaps simple is the wrong word, but its approach to data storage
    is straightforward while still allowing for complex manipulation. As we’ll see
    in [Chapter 6](ch06.xhtml#smallerc-CHP-6), C also provides the programmer with
    a window into the low-level aspects of where the data is stored in the computer’s
    memory. When we start working directly with microcontrollers in the latter half
    of this book, that access will become more important.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的本质是数据的操作。编程语言为人类提供了一个接口，告诉计算机这些数据是什么，以及你想对这些数据做什么。为强大的机器设计的语言可能会隐藏（或推断）关于存储数据的许多细节，但是在这方面，C语言仍然相对简单。也许简单这个词不太恰当，但它在数据存储方面的处理方法是直接的，同时仍然允许复杂的操作。正如我们将在[第6章](ch06.xhtml#smallerc-CHP-6)中看到的，C语言还为程序员提供了一个窗口，可以看到数据存储在计算机内存中的低级别方面。当我们在本书后半部分直接与微控制器工作时，这种访问将变得更加重要。
- en: For now though, I want to tackle some of the basics of C’s syntax so that we
    can start composing original programs rather than just copying lines of code from
    a book. This chapter has plenty of those lines, and you are heartily encouraged
    to copy them as you read! But hopefully, we’ll get to the point where you can
    create novel answers to your own programming challenges.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想先了解一些C语法的基础，这样我们就可以开始撰写原创程序，而不仅仅是从书本上复制代码行。本章包含大量这样的代码行，你在阅读时可以放心地复制它们！但希望到达这样一个阶段，你可以为自己的编程挑战创建新颖的答案。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you already feel comfortable with programming from your experience in another
    language, feel free to skim this chapter. You should read [“printf() and scanf()”](#smallerc-CHP-2-SECT-3)
    on the `printf()` and `scanf()` functions, but other sections will likely be familiar.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经对从其他语言中的编程经验感到满意，可以跳过本章。你应该阅读[“printf() and scanf()”](#smallerc-CHP-2-SECT-3)关于`printf()`和`scanf()`函数的部分，但其他部分可能会比较熟悉。
- en: Statements in C
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C语言中的语句
- en: Another concept you hear about as a fundamental element of programming is the
    notion of an *algorithm*. Algorithms are sets of instructions that process data
    and generally get things done on computers. One classic analogy for an algorithm
    is a kitchen recipe. Given a set of ingredients, here are the individual steps
    you take to turn those ingredients into something like a cake. In programming,
    those “individual steps” are statements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的另一个基本概念是*算法*的概念。算法是一组处理数据的指令，通常在计算机上完成任务。一个经典的算法类比是厨房食谱。给定一组原料，这里是你执行的每一个步骤，将这些原料转化为像蛋糕之类的东西。在编程中，这些“每一个步骤”就是语句。
- en: In C, statements come in a variety of flavors. In this chapter, I’ll be looking
    at declaration statements, initialization statements, function calls, and comments.
    Later chapters will tackle control statements and not-quite statements like creating
    your own functions and preprocessor commands.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，语句有多种形式。在本章中，我将讨论声明语句、初始化语句、函数调用和注释。后续章节将涉及控制语句以及像创建自己的函数和预处理器命令等近似语句。
- en: Statement Separators
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句分隔符
- en: 'Statements are separated from each other using a semicolon. Semicolons in C
    work a lot like periods do in English. Long sentences in English might span multiple
    lines, but you know to keep going until you see a period. Likewise, you might
    have several short sentences bunched up together on a single line, but you can
    easily distinguish them based on those periods. It can be easy to forget the semicolon
    at the end of a statement. If each statement fits on its own line, it becomes
    tempting to assume the compiler “sees” the same structure that humans can so easily
    pick out. Unfortunately, the compiler cannot. Even with our first, very simple
    program from [“Creating a C ‘Hello, World’”](ch01.xhtml#smallerc-CHP-1-SECT-2.2),
    the statement we used to print out some text in our terminal window needs to end
    with a semicolon. If you’re curious, try deleting that semicolon, save your file,
    and then recompile it. You’ll end up with something like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 语句之间使用分号分隔。在C语言中，分号的作用类似于英语中的句号。英语中的长句可能跨越多行，但你知道要一直读到句号为止。同样地，你可能会在同一行上有几个短句，但你可以根据这些句号轻松区分它们。很容易忘记语句末尾的分号。如果每个语句都放在自己的行上，你可能会假设编译器“看到”的结构与人类能够轻松理解的结构相同。不幸的是，编译器不能这样做。即使是我们的第一个非常简单的程序，来自[“创建一个C‘Hello,
    World’”](ch01.xhtml#smallerc-CHP-1-SECT-2.2)，我们用来在终端窗口打印文本的语句也需要以分号结尾。如果你感兴趣，试着删除那个分号，保存你的文件，然后重新编译它。你会得到像这样的结果：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Yuck. An error. But at least the error message is useful. It tells us two critical
    things: *what* went wrong (“expected ‘;'' after expression”) and *where* the compiler
    had trouble (“hello.c:4:27”, or the *hello.c* file, line 4, column 27). I don’t
    want to scare you off with an error message so early in your exploration of C,
    but you will definitely run into them. A lot. Happily, it just means you need
    to look at your source code a little closer and then try again.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，出错了。但至少错误消息很有用。它告诉我们两件关键的事情：出了什么问题（“expected ';' after expression”）和编译器在哪里遇到了问题（“hello.c:4:27”，或者*hello.c*文件，第4行，第27列）。我不想在你探索C语言的早期阶段就用一个错误消息吓到你，但你肯定会经常遇到它们。幸运的是，这意味着你需要更仔细地查看你的源代码，然后再试一次。
- en: Statement Flow
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句流程
- en: The separators tell the compiler where one statement ends and where the next
    begins. That order matters, too. The flow of statements is top to bottom, or left
    to right if multiple statements are on the same line. And multiple statements
    are definitely allowed! We can quickly expand our simple “Hello, World” program
    to be a little more verbose.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符告诉编译器语句在哪里结束和下一条语句从哪里开始。顺序也很重要。语句的流程是自上而下，如果多个语句在同一行上，则是从左到右。而且确实允许有多个语句！我们可以迅速将我们简单的“Hello,
    World”程序扩展得更加冗长。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When you have the time and energy, I highly recommend transcribing the source
    code by hand. This will give you a little more practice with C’s syntax. You’ll
    often make a mistake or two, as well. Spotting and fixing those mistakes is a
    great way to learn! Even if those mistakes can be a little frustrating from time
    to time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有时间和精力时，我强烈建议手动转录源代码。这会让你对C语言的语法更加熟练。你经常会犯一两个错误。发现和修正这些错误是学习的一个很好方式！即使有时候这些错误可能会让人有点沮丧。
- en: 'Consider the following program, [*ch02/verbose.c*](https://oreil.ly/wqnYC):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的程序，[*ch02/verbose.c*](https://oreil.ly/wqnYC)：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_storing_and_stating_CO1-1)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_storing_and_stating_CO1-1)'
- en: We start with a very similar statement to the one we used in *hello.c*. The
    only real difference is the text we print. Note that we end the line with our
    semicolon separator.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从与*hello.c*中使用的语句非常相似的语句开始。唯一真正的区别是我们打印的文本。请注意，我们用分号分隔符结束了这行。
- en: '[![2](Images/2.png)](#co_storing_and_stating_CO1-2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_storing_and_stating_CO1-2)'
- en: We have a second `printf()` statement similar to the first. It will indeed be
    executed second.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有第二个`printf()`语句与第一个类似。它确实会第二次执行。
- en: '[![3](Images/3.png)](#co_storing_and_stating_CO1-3)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_storing_and_stating_CO1-3)'
- en: And just to drive the point home, this third statement will be called after
    the first two. And the last two calls will come after this one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更加突出这一点，这第三个语句将在前两个之后被调用。最后两个调用将在此之后进行。
- en: 'Here’s the output of our simple multiline upgrade:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们简单多行升级的输出结果：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Nice. You can see how the output precisely follows the order of the statements
    in our program. Try switching them around and confirm for yourself that the flow
    of the program goes top to bottom. Or try putting two `printf()` calls on the
    same line. This isn’t meant to be tricky. I just want you to practice writing,
    running, and compiling code as often as possible. The more examples you try, the
    better you’ll get at avoiding the simple mistakes and the easier it will be to
    follow along with new code examples.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不错。你可以看到输出如何精确地按照程序中语句的顺序进行。尝试调换它们的顺序，并确认程序的流程是自上而下的。或者尝试在同一行上放置两个`printf()`调用。这不是要搞难题。我只是希望你尽可能经常地练习编写、运行和编译代码。你尝试的例子越多，你就越能避免简单的错误，也越容易跟上新代码示例的步伐。
- en: Variables and Types
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和类型
- en: 'We can do much more than just print text, of course. We can also store and
    manipulate data as we work to implement an algorithm or perform a task. In C (and
    in most languages), you store data in *variables*, which are powerful tools in
    problem solving. Those variables have *types*, which dictate what kinds of data
    you can store. Both of these concepts figure heavily in two of the statement flavors
    I mentioned: declarations and initializations.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅可以打印文本，还可以在实施算法或执行任务时存储和操作数据。在C语言（以及大多数语言中），你将数据存储在*变量*中，这是解决问题的强大工具。这些变量有*类型*，它们决定你可以存储哪些类型的数据。这两个概念在我提到的声明和初始化语句中起着重要作用。
- en: A variable is a placeholder for a value. A variable can hold simple values like
    numbers (how many students are in the class? what’s the total cost of the items
    in my shopping cart?) or more complex things (what’s the name of this particular
    student? what are each student’s grades? or even an actual complex value like
    the square root of –1). Variables can store data received from users, and they
    allow you to write programs that can solve general problems without rewriting
    the program itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是值的占位符。变量可以保存简单的值，如数字（班级中有多少学生？我的购物车中物品的总成本是多少？）或更复杂的事物（这个特定学生的名字是什么？每个学生的成绩是什么？甚至像-1的平方根这样的复杂值）。变量可以存储用户收到的数据，并允许你编写能够解决一般问题而不必重新编写程序本身的程序。
- en: Getting User Input
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: We’ll be exploring the details of defining and initializing variables shortly,
    but let’s first run with that idea of getting some input for the user to create
    dynamic output without recompiling our program every time. We’ll return to our
    “Hello, World” program and upgrade it a little. We can ask the user to give us
    their name and then greet them personally!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将探讨定义和初始化变量的详细内容，但首先让我们运行一下这个想法：让用户输入一些内容，以便在不每次重新编译程序的情况下生成动态输出。我们将返回到我们的“Hello,
    World”程序，并稍作升级。我们可以要求用户告诉我们他们的名字，然后个性化地问候他们！
- en: 'You’ve seen one output statement so far, our `printf()` function call we used
    to greet the planet. There is a counterpart, input function, too: `scanf()`. You
    can use print/scan pairs to prompt the user and then wait for them to type in
    an answer. We’ll store that answer in a variable. If you have done some programming
    in other languages, this next program should look familiar. If you’re new to programming
    and to C, the listing may be a little dense or weird—and that’s OK! Typing in
    these programs and getting them to run after fixing any typos you make is a useful
    way to learn.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了一个输出语句，即我们用来问候地球的`printf()`函数调用。还有一个对应的输入函数：`scanf()`。你可以使用打印/扫描配对来提示用户，然后等待他们输入答案。我们将把这个答案存储在一个变量中。如果你在其他语言中做过一些编程，下一个程序应该看起来很熟悉。如果你是编程和C语言的新手，这个列表可能有点密集或奇怪——没关系！输入这些程序并在修复任何拼写错误后使其运行，是学习的一种有效方式。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'A lot of programming is just thoughtful plagiarism. That’s a bit of a joke,
    but only a bit. You start out much the way humans start out with spoken language:
    repeating something you see (or hear) without necessarily understanding everything
    about it. If you perform that repetition enough, you discover the patterns inherent
    in the language and learn where you can make useful changes. Make enough of those
    useful changes, and you discover how to create new, meaningful things from scratch.
    That is our goal.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 很多编程只是有思想的剽窃。这有点开玩笑，但也只是一点点。你开始的方式很像人类开始使用口语的方式：重复你看到（或听到）的东西，而不一定完全理解它的所有内容。如果你重复这种行为足够多次，你就会发现语言中固有的模式，并学会在哪里可以做出有用的更改。做出足够多的有用更改，你就会发现如何从头开始创建新的有意义的事物。这是我们的目标。
- en: 'This [*ch02/hello2.c*](https://oreil.ly/OrUqu) program is simply another bit
    of code you can copy as you start down the path of programming discovery:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 [*ch02/hello2.c*](https://oreil.ly/OrUqu) 程序只是另一个代码片段，当你开始探索编程时可以复制：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Hopefully, the structure of this program looks familiar. We include our standard
    I/O library, we have a `main()` function, and that function has a body with multiple
    statements inside a pair of curly braces. That body, though, contains several
    new items. Let’s go through each line.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个程序的结构看起来很熟悉。我们包括我们的标准I/O库，我们有一个 `main()` 函数，并且该函数有一个包含多个语句的主体，都在一对花括号内。不过，该主体包含几个新项目。让我们逐行看一下。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here is our first example of the declaration of a variable. The variable’s name
    is, well, “name”. Its type is `char`, which is what C uses to refer to a single
    (ASCII) character.^([1](ch02.xhtml#idm45018742699768)) It is also an *array*,
    meaning it stores multiple `char` values in sequence. In our case, 20 such values
    can be stored. More on arrays in [Chapter 4](ch04.xhtml#smallerc-CHP-4). For now,
    just note that this variable can keep a person’s name as long as it is less than
    20 characters long.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个变量声明的例子。变量的名字是，“name”。它的类型是 `char`，这是C用来指代单个（ASCII）字符的类型。^([1](ch02.xhtml#idm45018742699768))
    它还是一个 *数组*，意味着它按顺序存储多个 `char` 值。在我们的情况下，可以存储20个这样的值。关于数组的更多信息，请参阅[第4章](ch04.xhtml#smallerc-CHP-4)。现在，只需注意这个变量可以保存一个人的名字，只要它少于20个字符。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a fairly standard `printf()` call—very similar to the one we used in
    our first program back in [“Creating a C ‘Hello, World’”](ch01.xhtml#smallerc-CHP-1-SECT-2.2).
    The only meaningful difference is the last characters inside the set of double
    quote marks. If you look at *hello.c* or *verbose.c*, you’ll notice the last two
    characters are a backslash and the letter “n”. The combination of those two characters
    (`\n`) represents a single “newline” character. If you add `\n` at the end, you
    are printing one line and any subsequent call to `printf()` will go on the next
    line. Conversely, if you omit the `\n`, the cursor in the terminal stays on the
    current line. This can be handy if you want to do things like print out a table
    but do so one table cell at a time. Or, in our case, if you want to prompt the
    user for some input, and then allow them to enter their response on the same line
    as the question.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当标准的 `printf()` 调用，与我们在第一个程序中使用的非常相似，详见[“创建C‘Hello, World’”](ch01.xhtml#smallerc-CHP-1-SECT-2.2)。唯一有意义的区别是双引号标记集合内的最后字符。如果你看一下
    *hello.c* 或 *verbose.c*，你会注意到最后两个字符是反斜杠和字母“n”。这两个字符的组合（`\n`）表示一个单独的“换行”字符。如果在末尾添加
    `\n`，则会打印一行，并且任何后续的 `printf()` 调用将在下一行进行。相反，如果省略 `\n`，终端中的光标将保持在当前行。如果你想要逐个单元格打印表格或者在我们的情况下，如果你想要提示用户输入一些内容，然后允许他们在同一行上输入响应，这将会很方便。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here is that new function I mentioned at the beginning of this section. The
    `scanf()` function “scans in” characters and can convert them into C data types
    like numbers, or in this case, an array of characters. Once converted, `scanf()`
    expects to store each “thing” in a variable. In this line, then, we’re scanning
    for a bunch of characters and we’ll store them in our `name` variable. We’ll look
    at the very strange syntax of the stuff inside the parentheses in [“printf() and
    scanf()”](#smallerc-CHP-2-SECT-3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在本节开头提到的新功能。`scanf()` 函数“扫描”字符并可以将它们转换为C数据类型，比如数字，或者在这种情况下，一组字符数组。一旦转换完成，`scanf()`
    函数期望将每个“东西”存储在一个变量中。在这一行中，我们正在扫描一堆字符，并将它们存储在我们的 `name` 变量中。我们将查看括号内的内容的非常奇怪的语法，详见[“printf()
    和 scanf()”](#smallerc-CHP-2-SECT-3)。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And lastly, we want to print our greeting. Again, this should look familiar,
    but now we have more strange syntax. If the `%s` jumps out at you as the same
    weird thing that was in the call to `scanf()`, congrats! You just spotted a very
    useful pattern. That pair of characters is exactly what C uses when printing or
    scanning an array of characters. An array of characters is such a common type
    in C that it has a simpler name: string. Hence the use of an “s” in this pair.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要打印我们的问候语。同样，这看起来应该很熟悉，但现在我们有更多奇怪的语法。如果 `%s` 让你感觉到与 `scanf()` 调用中的同样奇怪的事物相同，恭喜你！你刚刚发现了一个非常有用的模式。这一对字符正是C在打印或扫描字符数组时使用的内容。字符数组在C中是如此常见的一种类型，以至于它有一个更简单的名称：字符串。因此，在这对字符中使用“s”。
- en: So what’s happening with `name`? The `scanf()` call took whatever name you typed
    in (not including the Return key^([2](ch02.xhtml#idm45018742586888)) you pressed)
    and stored it in memory. Our `name` variable contains the memory location of those
    characters. When we come along with our `printf()` call, our first argument (the
    `"Well hello, %s!\n"` part) contains a few literal characters such as those in
    the word “Well” and a placeholder for a string (the `%s` part). Variables are
    great for filling placeholders. Whatever name you typed in will now be displayed
    back to you!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`name`发生了什么？`scanf()`调用获取了你输入的任何名字（不包括你按下的回车键^([2](ch02.xhtml#idm45018742586888))）并将其存储在内存中。我们的`name`变量包含了那些字符的内存位置。当我们使用`printf()`调用时，我们的第一个参数（`"Well
    hello, %s!\n"`部分）包含了一些字面上的字符，比如“Well”中的那些字符，以及一个字符串的占位符（`%s`部分）。变量非常适合填充占位符。无论你输入了什么名字，现在都会显示回来给你看！
- en: Also notice that we do include the special `\n` newline here on our greeting.
    That means we’ll print the greeting and then “hit the Return key” so that anything
    else to be shown in the terminal will go on the next line.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们在打印问候语时包含了特殊的`\n`换行符。这意味着我们将打印问候语，然后“按下回车键”，以便终端中显示的任何其他内容都将显示在下一行。
- en: Let’s go ahead and run the program to see how things work. You can use the Terminal
    tab at the bottom of VS Code, or the Terminal or Command app for your platform.
    You’ll need to compile it first with `gcc` then run either `a.out` or whatever
    name you chose using the `-o` option. You should get something similar to [Figure 2-1](#smallerc-CHP-2-FIG-hello2).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续运行程序，看看事情是如何运作的。你可以使用VS Code底部的终端选项卡，或者你平台的Terminal或Command应用程序。你需要先用`gcc`编译，然后运行`a.out`或者使用`-o`选项选择的任何名字。你应该会得到类似于[Figure 2-1](#smallerc-CHP-2-FIG-hello2)的结果。
- en: Notice that when you type in a name, it appears on the same line as the prompt
    asking you to enter it. That is exactly what we wanted when we left off the newline
    (`\n`) character. But try running it again and type in a different name. Did you
    get the results you expected? Try a third time. This dynamic behavior of responding
    to user input makes variables invaluable in computer programming. The same program
    can produce different output based on different input without being recompiled.
    That ability, in turn, has helped make computer programs invaluable to our everyday
    lives.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在你输入名字时，它会出现在要求你输入的提示的同一行。当我们省略换行符（`\n`）时，这正是我们想要的效果。但再试一次，输入一个不同的名字。你得到了期望的结果吗？再试第三次。这种对用户输入响应的动态行为使得变量在计算机编程中非常宝贵。同一个程序可以根据不同的输入产生不同的输出，而无需重新编译。这种能力反过来又帮助使计算机程序对我们日常生活变得非常宝贵。
- en: '![smac 0201](Images/smac_0201.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![smac 0201](Images/smac_0201.png)'
- en: Figure 2-1\. Our tailored Hello World output
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. 我们定制的Hello World输出
- en: Strings and Characters
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和字符
- en: 'Let’s look a little closer at the `char` type as well as its close cousin,
    the array of characters—`char[]`—better known as a string. When you declare a
    variable in C, you give it both a name and a type. The simplest declaration looks
    something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一看`char`类型以及它的近亲`char[]`——更为人所知的字符串。在C中声明变量时，你为它指定了名称和类型。最简单的声明看起来像这样：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here we create a variable named `response` with a type of `char`. The `char`
    type holds one character. We could store a “y” or an “n”, for example. [Chapter 5](ch05.xhtml#smallerc-CHP-5)
    will go through the memory address and reference details, but for now, just remember
    that a variable declaration sets aside a spot in memory with enough space to store
    one of whatever type you specified. If we had a series of questions to ask, then
    we could create a series of variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`response`的变量，类型为`char`。`char`类型可以容纳一个字符。例如，我们可以存储一个“y”或“n”。[第5章](ch05.xhtml#smallerc-CHP-5)将详细介绍内存地址和引用细节，但现在，只需记住变量声明会在内存中留出足够空间来存储你指定类型的内容。如果我们有一系列问题要问，那么我们可以创建一系列变量：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each of these variables can hold one character. But again, when you use a variable,
    you don’t have to predict or decide what that character will be in advance. The
    contents can vary. (Vary…variable…get it? :)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个变量都可以容纳一个字符。但是，当你使用变量时，你不需要预测或决定那个字符将在先。内容可以变化。（变化……变量……明白吗？ :)
- en: C compilers determine which encoding your source characters use. Older compilers
    use the older ASCII^([3](ch02.xhtml#idm45018742503880)) format while more recent
    compilers typically use UTF-8\. Both encodings include lower- and uppercase letters,
    numbers, and most of the symbols you see on your keyboard. To talk about a specific
    character rather than a variable of type `char`, you use single quotes to delimit
    it. For example, `'a'`, `'A'`, `'8'`, and `'@'` are all valid.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: C 编译器确定你的源字符使用哪种编码。旧的编译器使用旧的 ASCII^([3](ch02.xhtml#idm45018742503880)) 格式，而较新的编译器通常使用
    UTF-8。这两种编码都包括大小写字母、数字和大多数键盘上看到的符号。要讨论特定的字符而不是 `char` 类型的变量，你可以使用单引号将其界定。例如，`'a'`，`'A'`，`'8'`
    和 `'@'` 都是有效的。
- en: Special characters
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊字符
- en: A character can also be special. C supports things like tabs and newlines. We’ve
    seen the newline character (`\n`), but there are also a few other special characters
    listed in [Table 2-1](#smallerc-CHP-2-TABLE-special-chars). These special characters
    are coded using “escape sequences,” and the backslash is known as the “escape
    character”.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 字符也可以是特殊的。C 语言支持诸如制表符和换行符之类的东西。我们已经看到了换行符（`\n`），但还有其他几个特殊字符列在了[表 2-1](#smallerc-CHP-2-TABLE-special-chars)中。这些特殊字符使用“转义序列”编码，反斜杠被称为“转义字符”。
- en: Table 2-1\. Escape sequences in C
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. C 中的转义序列
- en: '| Char | ASCII | Name | Description |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Char | ASCII | Name | Description |'
- en: '| --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| \a | 7 | BEL | Make the terminal “beep” when printed |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| \a | 7 | BEL | 打印时使终端“响铃” |'
- en: '| \n | 10 | LF | Line Feed (standard line ending on Mac and Linux) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| \n | 10 | LF | 换行符（在 Mac 和 Linux 上的标准行结束符） |'
- en: '| \r | 13 | CR | Carriage Return (when used with `\n`, common line ending on
    Windows) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| \r | 13 | CR | 回车符（与 `\n` 一起使用时，在 Windows 上通常的行结束符） |'
- en: '| \t | 15 | HT | (Horizontal) Tab |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| \t | 15 | HT | (水平) 制表符 |'
- en: '| \\ | 92 |  | Used to place a literal backslash in a string or char |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| \\ | 92 |  | 用于在字符串或字符中放置字面反斜杠 |'
- en: '| \'' | 39 |  | Used to place a literal single quote in a char (no escape required
    in a string) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| \'' | 39 |  | 用于在字符中放置字面单引号（在字符串中不需要转义） |'
- en: '| \” | 34 |  | Used to place a literal double quote in a string (no escape
    required in a char) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| \” | 34 |  | 用于在字符串中放置字面双引号（在字符中不需要转义） |'
- en: '| *This is not an exhaustive list, but covers the characters we will use in
    this book.* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| *这不是详尽的列表，但涵盖了本书中将使用的字符。* |'
- en: 'These named shortcuts only cover the most popular characters. If you have to
    use other special characters, say an end of transmission (EOT, ASCII value 4)
    signal from a modem, you can give the character’s ASCII value in octal with the
    backslash. Our EOT character, then, would be `''\4''`, or sometimes you see three
    digits: `''\004''`. (Since ASCII is a 7-bit encoding, three octal digits cover
    the highest ASCII character. Which, if you’re curious, is delete (DEL, ASCII 127)
    or `''\177''` as an octal escape sequence. Some folks prefer the consistency of
    always seeing three digits.)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命名的快捷方式只涵盖了最流行的字符。如果你必须使用其他特殊字符，比如来自调制解调器的传输结束（EOT，ASCII 值 4）信号，你可以用反斜杠加八进制的
    ASCII 值表示该字符。因此我们的 EOT 字符将是 `'\4'`，有时你会看到三位数字表示：`'\004'`。（由于 ASCII 是一个 7 位编码，三位八进制数字涵盖了最高的
    ASCII 字符。如果你好奇的话，删除符（DEL，ASCII 127）或 `'\177'` 作为八进制转义序列。有些人更喜欢总是看到三位数字的一致性。）
- en: You might not need many of these shortcuts, but since Windows path names use
    the backslash character, it’s important to remember that some characters require
    this special prefix. And, of course, the newline character will continue to show
    up in many of our print statements. As you may have noticed with the octal escape
    sequences, the prefixing backslash is included inside the single quotes. So a
    tab is `'\t'` and the backslash is `'\\'`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不需要这些快捷方式，但由于 Windows 路径名使用反斜杠字符，重要的是要记住某些字符需要这种特殊前缀。当然，换行符将会继续出现在我们的许多打印语句中。正如你在八进制转义序列中所见，前缀反斜杠被包含在单引号内。因此制表符是
    `'\t'`，反斜杠是 `'\\'`。
- en: Strings
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are a series of `char`s, but a very formalized series. Many programming
    languages support such series, called arrays. [Chapter 4](ch04.xhtml#smallerc-CHP-4)
    introduces arrays in much more detail, but the array of `char` type—`char[]` in
    C syntax—is so common that I want to mention it separately.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一系列的 `char`，但是非常正式的一系列。许多编程语言支持这样的系列，称为数组。[第四章](ch04.xhtml#smallerc-CHP-4)将更详细地介绍数组，但
    `char[]` 类型的字符数组在 C 语法中非常常见，我想单独提一下。
- en: We’ve been working with strings without being very explicit about them. In our
    very first hello program, we called `printf()` with a string argument. A string
    in C is a collection of zero or more `char`s with a special, final “null” character,
    `\0` (with the ASCII value of 0). You typically include the characters in your
    code between double quotes, such as our `"Hello, world!\n"` argument. Happily,
    when you use those double quotes, you don’t have to add the `\0` yourself. It
    is implicit in the definition of a string literal.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在处理字符串时，并没有过多明确说明它们。在我们的第一个 hello 程序中，我们调用了 `printf()` 并传递了一个字符串参数。在 C 中，字符串是一个由零个或多个
    `char` 组成的集合，最后以特殊的“空”字符 `\0` 结尾（ASCII 值为0）。通常在双引号中包含代码中的字符，例如我们的 `"Hello, world!\n"`
    参数。幸运的是，当你使用这些双引号时，你不必自己添加 `\0`。这在字符串字面量的定义中是隐含的。
- en: 'Declaring string variables is as simple as declaring `char` variables:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 声明字符串变量就像声明 `char` 变量一样简单：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each of these variables could store simple things like a name, or more complex
    things like a multipart title, e.g., “Senior Code and Tasty Pie Developer.” A
    string can also be empty: “”. That may seem silly, but think about forms where
    you are entering things like names. If you happen to be a wildly successful pop
    star with just one name, the `lastname` variable above could be given the valid
    value `""` (i.e., just the terminating `''\0''`) to indicate that Drake and Cher
    are doing just fine without a surname.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量可以存储简单的东西，如姓名，或者更复杂的东西，如多部分标题，例如，“高级代码和美味派开发人员”。字符串也可以为空：“”。这看起来可能有点傻，但想想那些你输入姓名之类信息的表格。如果你碰巧是一个非常成功的流行歌星，只有一个名字，那么上面的
    `lastname` 变量可以被赋予有效值 `""`（即只是终止符 `'\0'`），表明 Drake 和 Cher 也没有姓氏也没问题。
- en: Numbers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'Not surprisingly, C also has types that can store numeric values. Or more precisely,
    C has types for storing numbers larger than what typically fits in variable of
    type `char`. (Even though the examples in this chapter so far have used `char`
    for storing actual characters, it’s still a numeric type and is good for storing
    small numbers that have nothing to do with a character encoding.) C breaks these
    numeric types into two subcategories: integers and floating point numbers (i.e.,
    decimals).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，C 也有可以存储数字值的类型。更准确地说，C 拥有用于存储比 `char` 类型变量能容纳的数字更大的类型。（尽管本章迄今的示例中使用 `char`
    存储实际字符，但它仍然是数值类型，并且适合存储与字符编码无关的小数字。）C 将这些数值类型分为两个子类别：整数和浮点数（即小数）。
- en: Integer types
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数类型
- en: The integer types store simple numbers. The main type is called `int`, but there
    are many variations. The main difference in the variations is the size of the
    biggest number that can be stored in a variable of the given type. [Table 2-2](#smallerc-CHP-2-TABLE-types-and-sizes)
    summarizes the types and their storage capacities.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型存储简单的数字。主要类型称为 `int`，但有许多变体。这些变体的主要区别在于能够存储在给定类型变量中的最大数字的大小。[表 2-2](#smallerc-CHP-2-TABLE-types-and-sizes)
    总结了这些类型及其存储容量。
- en: Table 2-2\. Integer types and their typical sizes
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 整数类型及其典型大小
- en: '| Type | Bytes | Range | Notes |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 字节 | 范围 | 备注 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| char | 1 | –127 to +127 or 0 to 255 | Normally for letters; can also store
    small numbers |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| char | 1 | –127 到 +127 或 0 到 255 | 通常用于字母；也可以存储小数字 |'
- en: '| short | 2 | –32,767 to +32,767 |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| short | 2 | –32,767 到 +32,767 |  |'
- en: '| int | 2 or 4 | –32,767 to +32,767 or –2,147,483,647 to +2,147,483,647 | Varies
    by implementation |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| int | 2 或 4 | –32,767 到 +32,767 或 –2,147,483,647 到 +2,147,483,647 | 实现有所不同
    |'
- en: '| long | 4 | –2,147,483,647 to +2,147,483,647 |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| long | 4 | –2,147,483,647 到 +2,147,483,647 |  |'
- en: '| long long | 8 | –9,223,372,036,854,775,807 to +9,223,372,036,854,775,807
    | Introduced in C99 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| long long | 8 | –9,223,372,036,854,775,807 到 +9,223,372,036,854,775,807 |
    C99 引入 |'
- en: '| *While `char` is defined as one byte, the other sizes are system dependent.*
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| *虽然 `char` 被定义为一个字节，其他大小都是依赖于系统的。* |'
- en: Most of the types above are *signed* types,^([4](ch02.xhtml#idm45018742299128))
    which means that they can store values less than zero. All five types also have
    an explicit *unsigned* variation (e.g., `unsigned int` or `unsigned char`) that
    is the same size in bits/bytes but does not store negative values. Their ranges
    start at zero and end at roughly double the top of the signed range, as shown
    in [Table 2-3](#smallerc-CHP-2-TABLE-unsigned-sizes).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数上述类型是*有符号*类型，^([4](ch02.xhtml#idm45018742299128)) 这意味着它们可以存储小于零的值。这五种类型还都有显式的*无符号*变体（例如，`unsigned
    int` 或 `unsigned char`），它们的位/字节大小相同，但不存储负值。它们的范围从零开始，大致到达有符号范围的两倍，如 [表 2-3](#smallerc-CHP-2-TABLE-unsigned-sizes)
    所示。
- en: Table 2-3\. Unsigned integer types and their typical sizes
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-3。无符号整数类型及其典型大小
- en: '| Type | Bytes | Range |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 字节 | 范围 |'
- en: '| --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| unsigned char | 1 | 0 to 255 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 无符号字符 | 1 | 0 到 255 |'
- en: '| unsigned short | 2 | 0 to 65535 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 无符号短整型 | 2 | 0 到 65535 |'
- en: '| unsigned int | 2 or 4 | 0 to 65535 or 0 to 4,294,967,295 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 无符号整型 | 2或4 | 0 到 65535或0 到 4,294,967,295 |'
- en: '| unsigned long | 4 | 0 to 4,294,967,295 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 无符号长整型 | 4 | 0 到 4,294,967,295 |'
- en: '| unsigned long long | 8 | 0 to 18,446,744,073,709,551,615 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 无符号长长整型 | 8 | 0 到 18,446,744,073,709,551,615 |'
- en: Here are some sample integer type declarations. Note the declaration of the
    `x` and `y` variables. You often see coordinates on a grid or graph discussed
    in terms of “x and y.” C allows you to declare multipe variable names with the
    same type using a comma to separate them. There’s nothing special about this format,
    but if you ever have some short, related variable names, this might be a nice
    option.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些整数类型声明的示例。注意`x`和`y`变量的声明。你经常会在网格或图表上看到坐标“x和y”讨论。C允许你使用逗号分隔的方式声明多个相同类型的变量名。这种格式没有什么特别之处，但如果你有一些简短相关的变量名，这可能是一个不错的选择。
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you have small values to store, say “up to one dozen” or “top 100,” remember
    that you can use the `char` type. It is only 1 byte in length and the compiler
    doesn’t care if you ever print the value as an actual character or as a simple
    number.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要存储小值，比如“最多一打”或“前100”，请记住可以使用`char`类型。它只有1字节长度，编译器不会在乎你是否将该值打印为实际字符还是简单数字。
- en: Floating point types
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点类型
- en: If you are storing fractional or financial numbers, you can use the `float`
    or `double` types. These are both floating point types where the decimal point
    is not fixed (e.g., it can float), capable of storing values like 999.9 or 3.14\.
    But because we are talking about computers that think in discrete chunks, the
    floating point types store an approximation of the value encoded in 1s and 0s
    like an `int`. The `float` type is a 32-bit encoding that can store a wide range
    of values from very small fractions to very large exponentials. But `float` is
    most accurate in a narrow band between roughly –32k to 32k and six significant
    places after the decimal point.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要存储分数或财务数字，可以使用`float`或`double`类型。这两种都是浮点类型，其中小数点不固定（可以浮动），能够存储像999.9或3.14这样的值。但因为我们在讨论以1和0编码的离散块思考的计算机，浮点类型存储的是值的近似值，就像`int`一样。`float`类型是一种32位编码，可以存储从非常小的分数到非常大的指数的各种值。但在大约-32k到32k之间，小数点后的六个有效位数时，`float`是最准确的。
- en: The `double` type has “double” the precision of a `float`.^([5](ch02.xhtml#idm45018742233528))
    This means roughly 15 decimal digits will be accurately represented. We’ll see
    a few places where this approximation can cause problems, but for general purposes
    like a receipt total or a reading from a temperature sensor, these types are sufficient.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`类型比`float`类型精度“翻倍”。^([5](ch02.xhtml#idm45018742233528)) 这意味着大约可以精确表示15个十进制数字。我们将看到一些近似值可能会导致问题的地方，但对于像收据总额或从温度传感器读取的数据这样的一般用途来说，这些类型是足够的。'
- en: 'As with the other types, you place the type before the name:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型一样，你需要在名字之前放置类型：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since normal decimal numbers can also store integral values like 6 (as 6.0),
    it might be tempting to use `float` for your default numeric type. But manipulating
    numbers encoded with decimal points can be expensive on tiny CPUs like an Arduino.
    And even on big chips, it is still more expensive than working with simple integers.
    For performance and accuracy reasons, most C programmers stick with `int` unless
    they have an explicit reason not to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为普通的十进制数字也可以存储像6这样的整数值（如6.0），所以可能会倾向于将`float`用作默认的数字类型。但在像Arduino这样的微型CPU上操作带有小数点的数字可能会很昂贵。即使在大芯片上，与简单整数相比，它仍然更昂贵。出于性能和精度的原因，大多数C程序员都坚持使用`int`，除非有明确的理由不使用。
- en: Variable Names
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量名
- en: Regardless of what type a variable is, it has a name. For the most part, you
    are free to use any name you want, but there are a few rules you have to follow.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无论变量是什么类型，它都有一个名字。大多数情况下，你可以自由选择任何你想要的名字，但是有一些规则你必须遵循。
- en: In C, variable names can start with any letter or the underscore character (“_”).
    After that initial character, a name can have more letters, more underscores,
    or numbers. Variable names are case sensitive (`total` and `Total` are not the
    same variable) and are (usually) limited to 31 characters long,^([6](ch02.xhtml#idm45018742180600))
    although convention keeps them shorter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，变量名可以以任何字母或下划线字符（“_”）开头。在初始字符之后，名称可以有更多字母、下划线或数字。变量名区分大小写（`total`和`Total`不是同一个变量），通常长度限制为
    31 个字符长，^([6](ch02.xhtml#idm45018742180600)) 虽然惯例上它们更短。
- en: C also has several *keywords* that are reserved for use by the C language itself.
    Because the keywords in [Table 2-4](#smallerc-CHP-2-TAB-c-keywords) already mean
    something to C, they cannot be used as variable names. Some implementations may
    reserve other words (such as `asm`, `typeof`, and `inline`), but most alternate
    keywords begin with one or two underscores to help make conflicts with your own
    variable names unlikely.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言还有几个 *关键字* 是为 C 语言本身保留的。因为 [表格 2-4](#smallerc-CHP-2-TAB-c-keywords) 中的关键字已经对
    C 有意义，所以它们不能用作变量名。某些实现可能会保留其他单词（例如`asm`，`typeof`和`inline`），但大多数备用关键字都以一个或两个下划线开头，以减少与您自己的变量名冲突的可能性。
- en: Table 2-4\. C keywords
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 2-4\. C 关键字
- en: '| Reserved words |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 保留字 |'
- en: '| --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| _Bool | default | if | static |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| _Bool | default | if | static |'
- en: '| _Complex | do | int | struct |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| _Complex | do | int | struct |'
- en: '| _Imaginary | double | long | switch |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| _Imaginary | double | long | switch |'
- en: '| auto | else | register | typedef |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| auto | else | register | typedef |'
- en: '| break | enum | restrict | union |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| break | enum | restrict | union |'
- en: '| case | extern | return | unsigned |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| case | extern | return | unsigned |'
- en: '| char | float | short | void |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| char | float | short | void |'
- en: '| const | for | signed | volatile |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| const | for | signed | volatile |'
- en: '| continue | goto | sizeof | while |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| continue | goto | sizeof | while |'
- en: 'If you do stumble upon a conflict with a keyword when declaring your variables,
    you’ll see an error similar to the error you get if you use an invalid variable
    name, such as one starting with a number:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在声明变量时遇到关键字冲突，你将会看到类似于使用无效变量名（例如以数字开头）时的错误：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That phrase “expected identifier” is a strong indicator your variable is the
    cause of the error. The compiler was expecting a variable name but found a keyword
    instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那个“expected identifier”短语是表明您的变量是错误原因的强烈指示器。编译器期望一个变量名，但找到一个关键字。
- en: Variable Assignments
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量赋值
- en: 'In our *hello2.c* example, we relied on a rather implicit assignment to our
    `name` variable. As an argument to the `scanf()` function, whatever the user types
    is stored in that variable. But we can (and often do) make direct assignments
    to variables. You use the equal sign (“=”) to indicate an assignment like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *hello2.c* 示例中，我们依赖对`name`变量的相当隐式的赋值。作为`scanf()`函数的参数，用户输入的任何内容都存储在该变量中。但我们可以（而且经常）直接对变量进行赋值。您可以使用等号（“=”）来指示这样的赋值操作：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You have now successfully stored the value `7` in the variable `total`. Congratulations!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功将值`7`存储在变量`total`中。
- en: 'You can overwrite that value at any time, too:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以随时覆盖该值：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While back-to-back assignments is a bit wasteful, there is nothing wrong with
    this snippet of C. The variable `total` will only retain one integer value, though,
    so the most recent assignment is the winner, `42` in this case.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管连续的赋值有点浪费，但这段 C 代码没有任何问题。变量`total`只会保留一个整数值，所以最近的赋值会胜出，在本例中是`42`。
- en: 'You often see variables defined and assigned an initial value (*initialized*
    in programmer-speak) at the same time:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常看到变量定义并同时分配初始值（在程序员的说法中称为初始化）：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both `total` and `answer` now have values you can use, but both can still be
    changed as needed. That’s exactly what variables do.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`total`和`answer`都有可以使用的值，但都可以根据需要更改。这正是变量的作用。
- en: Literals
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面值
- en: 'Those simple values we are plugging into variables in these examples are called
    *literals*. A literal is just a value that needs no interpretation. Numbers, characters
    inside single quotes, or strings inside double quotes all count as literals:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这些示例中插入变量的那些简单值称为 *字面值*。字面值只是一个不需要解释的值。数字、单引号内的字符或双引号内的字符串都算是字面值：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hopefully, those first two variable definitions look familiar. But notice when
    we initialized our string called `label`, we did not give the array a length.
    The C compiler infers the size from the literal we use in the initialization.
    In this case, then, `label` is 12 characters long; 11 for the letters in the word
    “Description” and one more for the terminating `'\0'`. You can give string variables
    more room if you know you’ll need it later in your code, but you should not specify
    too little room.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这前两个变量定义看起来很熟悉。但请注意，当我们初始化名为`label`的字符串时，我们没有给数组指定长度。C编译器会根据我们在初始化中使用的文字推断大小。在这种情况下，`label`有12个字符长；“Description”单词中的11个字母加上一个用于终止的`'\0'`。如果你知道以后在代码中会需要更多空间，可以给字符串变量更多空间，但不应指定太少的空间。
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you do try to assign a string literal that is too long for its `char[]`
    variable, you’ll likely see a warning from the compiler:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您试图为其`char[]`变量分配一个过长的字符串文字，您可能会从编译器看到一个警告：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s a fairly specific error, so hopefully you’ll find it easy to fix. Your
    program will still run, by the way. Notice that the compiler gave you a *warning*
    rather than an *error* as we’ve seen in some previous examples with compiler problems.
    Warnings typically mean the compiler thinks you are making a mistake, but you
    get the benefit of the doubt. It’s usually best to address warnings anyway, but
    it is not required.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当具体的错误，所以希望您会发现很容易修复。顺便说一句，你的程序仍然会运行。请注意，编译器给了你一个*警告*而不是我们在之前一些例子中看到的*错误*。警告通常意味着编译器认为您在犯错，但您得到了怀疑的好处。通常最好去处理警告，但这不是必需的。
- en: printf() and scanf()
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: printf()和scanf()
- en: We have already seen how to print out information using `printf()` and how to
    accept user input with `scanf()`, but I glossed over many of the details of both
    functions. Let’s look at some of those details now.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`printf()`打印信息，以及如何使用`scanf()`接受用户输入，但我忽略了这两个函数的许多细节。现在让我们来看看其中一些细节。
- en: printf() Formats
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: printf()格式
- en: The `printf()` function is C’s primary output function. We have already used
    it for printing simple strings like `"Hello, world\n"`. We also peeked at using
    it to print a variable in [“Getting User Input”](#smallerc-CHP-2-SECT-2.1). It
    can print all variable types, you just need to supply the correct *format string*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf()`函数是C的主要输出函数。我们已经用它来打印简单的字符串，如`"Hello, world\n"`。我们还窥视了如何在[“获取用户输入”](https://oreil.ly/DcU5k)中打印变量。它可以打印所有变量类型，您只需要提供正确的*格式字符串*。'
- en: 'When we call `printf()`, the first thing we supply is usually a string literal.
    That first argument is known as the format string. You can have simple strings
    that are echoed “as is” to the terminal, or you can print (and format) the values
    of variables. You use the format string to let `printf()` know what’s coming.
    You do that by including *format specifiers* such as our `%s` from [*ch02/hello2.c*](https://oreil.ly/DcU5k).
    Let’s print a few of those variables we have been creating while discussing declarations
    and assignments. Consider [*ch02/hello3.c*](https://oreil.ly/qhIIT):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`printf()`时，我们通常首先提供一个字符串文字。第一个参数称为格式字符串。您可以使用简单的字符串将其“原样”回显到终端，也可以打印（和格式化）变量的值。您使用格式字符串让`printf()`知道接下来会发生什么。您通过包括*格式说明符*，如我们从[*ch02/hello2.c*](https://oreil.ly/DcU5k)中的`%s`来做到这一点。让我们打印一些在讨论声明和赋值时创建的那些变量。考虑[*ch02/hello3.c*](https://oreil.ly/qhIIT)：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here’s the result:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是结果：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compare the output to the source code. You can see that we mostly print out
    the characters in our format string as is. But when we encounter a format specifier,
    we substitute the value of one of the arguments that follow the format string.
    Look closely at our first call to `printf()`. We have two format specifiers in
    the format string. After that string, we supply two variables. The variables fill
    in the format specifiers in order, left to right. If you check the output, you
    can see that first line of output does indeed include the value of `count` first,
    followed by the value of `total`. Neat. And we got the output of our `char` and
    string variables, too.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出与源代码进行比较。你可以看到，我们大多数打印出格式字符串中的字符。但是当我们遇到格式说明符时，我们会用跟随格式字符串的参数之一的值来替换它。仔细看看我们对`printf()`的第一次调用。我们的格式字符串中有两个格式说明符。在该字符串之后，我们提供了两个变量。这些变量按顺序填充格式说明符，从左到右。如果您检查输出，可以看到第一行输出确实首先包括`count`的值，然后是`total`的值。很整洁。我们还得到了`char`和字符串变量的输出。
- en: If you noticed that each type uses a different specifier, congratulations! You’re
    finding the important differences in these statements. (And if it all still looks
    a little like gibberish, don’t give up! The patterns—and the things that don’t
    fit the patterns—will start to stand out as you read and practice more.) In fact,
    `printf()` has quite a range of format specifiers, as shown in [Table 2-5](#smallerc-CHP-2-TAB-common-specifiers).
    Some are obvious and are clearly associated with a particular type. Others are
    a little more esoteric, but that’s what books are for. You’ll memorize the few
    specifiers you use most often and can always look up the less popular ones when
    you need them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到每种类型使用了不同的说明符，恭喜您！您正在找出这些语句中的重要差异。（如果这一切看起来像胡言乱语，不要放弃！随着您的阅读和实践，模式以及与模式不符合的事物将开始显现。）事实上，`printf()`
    拥有相当多的格式说明符，如 [表 2-5](#smallerc-CHP-2-TAB-common-specifiers) 所示。一些说明符显而易见，并且明确与特定类型相关联。其他一些则有点玄学，但这就是书籍存在的意义。您会记住您经常使用的几个说明符，并且在需要时可以随时查找不那么常用的那些。
- en: Table 2-5\. Common format specifier types for `printf()`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-5\. `printf()` 的常见格式说明符类型
- en: '| Specifier | Type(s) | Description |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 说明符 | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `%c` | `char` | Print out a single character |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `%c` | `char` | 打印单个字符 |'
- en: '| `%d` | `int, short, long` | Print integer values in base 10 (“decimal”) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | `int, short, long` | 打印十进制整数值 |'
- en: '| `%f` | `float, double` | Print floating point values |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `%f` | `float, double` | 打印浮点数值 |'
- en: '| `%i` | `int, short` | Print integer values in base 10 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `%i` | `int, short` | 打印十进制整数值 |'
- en: '| `%li, %lli` | `long, long long` | Print long integer values in base 10 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `%li, %lli` | `long, long long` | 打印长整数值 |'
- en: '| `%s` | `char[]` (string) | Print array of char as text |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | `char[]`（字符串） | 打印字符数组作为文本 |'
- en: There are other formats as well, but I’ll leave those for later where we need
    to print out odd or special bits of data. These formats will cover the vast majority
    of what you need day-to-day. [Appendix B](app02.xhtml#smallerc-APP-B) includes
    a more detailed discussion of all the formats used in this book.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他格式，但我会将它们留给以后需要打印出奇怪或特殊数据的场合。这些格式将涵盖您日常所需的绝大部分内容。[附录 B](app02.xhtml#smallerc-APP-B)
    包括了本书中使用的所有格式的更详细讨论。
- en: Tailored Output
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化输出
- en: But what about formatting those values? After all, C uses the phrases “format
    string” and “format specifier.” You add information to the format specifier to
    achieve this goal. One of the most common examples of this is printing floating
    point numbers like bank account balances or analog sensor readings. Let’s give
    ourselves some interesting decimals and try printing them out.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何格式化这些值呢？毕竟，C 使用了“格式字符串”和“格式说明符”这些术语。您需要向格式说明符添加信息以达到这个目标。这其中最常见的一个例子就是打印像银行账户余额或模拟传感器读数之类的浮点数。让我们给自己一些有趣的小数并尝试打印它们出来。
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We declare three variables, one `float` and two `double` types. We use the
    `%f` format specifier in our `printf()` statements. Great! Here’s what we get
    after compiling and running the program:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了三个变量，一个是 `float` 类型，另外两个是 `double` 类型。我们在 `printf()` 语句中使用了 `%f` 格式说明符。太好了！在编译和运行程序后，我们得到了以下结果：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Hmm, they all had six decimal places, even though we didn’t specify how many
    we wanted and none of our variables have exactly six decimal places. To get just
    the right amount of information, you give the format specifier some extra details.
    All specifiers can accept both width and precision arguments. Both are optional,
    and you can supply either or both. The extra details look like a decimal number:
    *`width.precision`* and these details go between the percent sign and the type
    character, as shown in [Figure 2-2](#smallerc-CHP-2-FIG-width-precision).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Hmm，它们都有六位小数，即使我们没有指定想要多少位数，我们的变量中也没有确切有六位小数。为了获得恰到好处的信息量，您需要给格式说明符提供一些额外的细节。所有的说明符都可以接受宽度和精度参数。这两者都是可选的，您可以提供其中一个或两个。额外的细节看起来像一个十进制数：*`宽度.精度`*，这些细节位于百分号和类型字符之间，如
    [图 2-2](#smallerc-CHP-2-FIG-width-precision) 所示。
- en: '![smac 0202](Images/smac_0202.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![smac 0202](Images/smac_0202.png)'
- en: Figure 2-2\. Implicit casting hierarchy
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 隐式类型转换层次
- en: 'Using both of these options makes a lot of sense for floating point numbers.
    We can now ask for more or less digits. Try changing the three `printf()` calls
    in [*ch02/floats.c*](https://oreil.ly/Os37q) like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点数来说，同时使用这两个选项非常有意义。现在我们可以请求更多或更少的数字位数。尝试像这样更改 [*ch02/floats.c*](https://oreil.ly/Os37q)
    中的三个 `printf()` 调用：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I added the vertical bar or pipe character (`|`) just before and after the
    expanded format specifiers so that you can see just how the width element affects
    the output. Take a look at the new results:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我在扩展的格式说明符之前和之后添加了竖线或管道字符(`|`)，以便你看到宽度元素如何影响输出。看看新的结果：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](Images/1.png)](#co_storing_and_stating_CO2-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_storing_and_stating_CO2-1)'
- en: Our value, `0.5`, is displayed with two decimal places of precision in a total
    field width of five characters. Because we don’t need all five spots, one space
    character is added at the beginning.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的值`0.5`以五个字符的总字段宽度显示，精确到小数点后两位。因为我们不需要所有五个位置，所以在开头添加了一个空格字符。
- en: '[![2](Images/2.png)](#co_storing_and_stating_CO2-2)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_storing_and_stating_CO2-2)'
- en: A longer decimal number is printed within 12 spots. Notice that we get the same
    six decimal places as we did without specifying any width or precision.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 较长的十进制数字被打印在12个位置内。请注意，我们得到的六位小数与未指定任何宽度或精度时相同。
- en: '[![3](Images/3.png)](#co_storing_and_stating_CO2-3)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_storing_and_stating_CO2-3)'
- en: An even longer decimal number is shown within 12 spots but includes 10 places
    of precision. Notice here that 12 is the *total* width—including the spots occupied
    by the numbers after the decimal point.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更长的十进制数在12个位置内显示，但包括10位精度。请注意，这里的12是*总*宽度，包括小数点后的数字所占用的位置。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For `printf()`, the precision you request and the actual value you are printing
    take precedence over the width if given. You regularly see floating point formats
    like `“%0.2f”` or `“%.1f”` that give you the right number of decimal places within
    the exact number of spots required. Applying these two example formats to π, for
    example, would result in `3.14` and `3.1`, respectively.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`printf()`，如果给定，你请求的精度和实际打印的值优先于宽度。你经常会看到像`“%0.2f”`或`“%.1f”`这样的浮点格式，它们在需要的确切位置内给出正确数量的小数位数。例如，将这两个示例格式应用于π，结果分别为`3.14`和`3.1`。
- en: 'With other types such as strings or ints, the width option is fairly straightforward.
    For example, you can print tabular data quite easily, as shown in [*ch02/tabular.c*](https://oreil.ly/nQC7x),
    by using the same widths regardless of the value being printed like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型，如字符串或整数，宽度选项相对来说比较直接。例如，你可以像在[*ch02/tabular.c*](https://oreil.ly/nQC7x)中展示的那样，使用相同的宽度打印表格数据，而不管所打印的值是什么。
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With wonderful columnar results:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 带有精彩的列结果：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Very nice. And notice how I tackled the column labels. I used format specifiers
    and string literals rather than a single string with the labels manually spaced
    apart. I did it this way to highlight the use of output widths, even though doing
    it manually wouldn’t be difficult. In fact, it would be easier to center the labels
    over these few columns manually. If you’re up for a little exercise, open the
    *tabular.c* file and try adjusting that first `printf()` to see if you can get
    the labels centered.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。请注意我如何处理列标签。我使用了格式说明符和字符串字面量，而不是单个手动空格分隔的字符串。我这样做是为了突出输出宽度的使用，即使手动操作也不难。事实上，手动将标签居中于这几列将更容易。如果你愿意做个小练习，打开*tabular.c*文件，尝试调整第一个`printf()`，看看是否能使标签居中。
- en: While the width option is straightforward for all types, for nonfloating point
    formats, the effect of adding the precision option may not be as intuitive. For
    strings, specifying a precision results in truncating text to fit the given field
    width. (For `int` and `char` types, it typically has no effect, but your compiler
    may warn you not to rely on such “typical” behavior.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于所有类型来说，宽度选项都很直观，但对于非浮点格式，添加精度选项的影响可能不那么直观。对于字符串，指定精度会导致截断文本以适应给定的字段宽度。（对于`int`和`char`类型，通常没有影响，但你的编译器可能会警告你不要依赖这种“典型”行为。）
- en: scanf() and Parsing Inputs
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`scanf()`和解析输入
- en: 'On the flip side of output is input. We took a peek at using the `scanf()`
    function to do this at the beginning of this chapter in [“Getting User Input”](#smallerc-CHP-2-SECT-2.1).
    By now you might recognize the `%s` we used in that simple program as a format
    specifier. That familiarity goes deeper: you can use all of the format specifiers
    listed in [Table 2-5](#smallerc-CHP-2-TAB-common-specifiers) with `scanf()` to
    get those types of values from user input.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的另一面是输入。在本章开头，我们看了一眼如何使用`scanf()`函数来进行这样的操作[“获取用户输入”](#smallerc-CHP-2-SECT-2.1)。到现在你可能已经认识到我们在那个简单程序中使用的`%s`作为格式说明符。这种熟悉程度更深：你可以在`scanf()`中使用在[表格 2-5](#smallerc-CHP-2-TAB-common-specifiers)中列出的所有格式说明符来获取用户输入的这些类型的值。
- en: There is one important point I need to make about the variables you use with
    `scanf()`. We got a little lucky scanning for a string in our first example. Strings
    in C, if you recall, are really just arrays of type `char`. We’ll see more on
    this topic in Chapters [4](ch04.xhtml#smallerc-CHP-4) and [6](ch06.xhtml#smallerc-CHP-6),
    but for our purpose here, I’ll just note that arrays are a special case of *pointers*
    in C. Pointers are special values that refer to the *address* (location) of things
    in memory. The `scanf()` function uses the address of a variable, not its value.
    Indeed, the point of `scanf()` is to put a value into a variable. Since arrays
    are really pointers, you can use a `char` array variable directly. But to use
    numeric and individual `char` variables with `scanf()`, you have to use a special
    prefix on the variable name, the ampersand (`&`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点很重要，关于你在 `scanf()` 中使用的变量。在我们的第一个示例中，扫描字符串有点幸运。如果你还记得，C 中的字符串实际上只是 `char`
    类型的数组。我们将在第[4](ch04.xhtml#smallerc-CHP-4)章和第[6](ch06.xhtml#smallerc-CHP-6)章看到更多关于这个主题的内容，但在这里，我只想指出数组在
    C 中是指针的一种特殊情况。指针是特殊的值，指向内存中的地址（位置）。`scanf()` 函数使用变量的地址，而不是其值。实际上，`scanf()` 的目的是将一个值放入一个变量中。由于数组实际上是指针，你可以直接使用
    `char` 数组变量。但是，要使用数字和单个 `char` 变量与 `scanf()` 一起使用，你必须在变量名上使用一个特殊的前缀，即和号（`&`）。
- en: 'I’ll go into the `&` prefix in a lot more detail in [Chapter 6](ch06.xhtml#smallerc-CHP-6),
    but it tells the compiler to use the address of the variable—perfect for `scanf()`.
    Take a look at this small snippet:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第6章](ch06.xhtml#smallerc-CHP-6)中更详细地讨论 `&` 前缀，但它告诉编译器使用变量的地址——非常适合 `scanf()`。看一下这个小片段：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice the difference in the use of the `name` variable in the `scanf()` line
    and the use of the `&age` variable. That is solely down to `name` being an array
    and `age` being a simple integer. This is regrettably one of those things that
    is easy to forget. Not regrettably, it is easy to fix and the compiler will remind
    you if you forget:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `scanf()` 行中使用 `name` 变量和使用 `&age` 变量的区别。这完全取决于 `name` 是一个数组，而 `age` 是一个简单的整数。这是一个容易忘记的事情。不过，幸运的是，这很容易修复，如果你忘记了，编译器会提醒你：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you see this “expects type” error, just remember that `int`, `float`, `char`,
    and similar nonarray variables always need the `&` prefix when used with `scanf()`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到这个“期望类型”错误时，只需记住，`int`、`float`、`char` 和类似的非数组变量在与 `scanf()` 一起使用时总是需要 `&`
    前缀。
- en: Operators and Expressions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符和表达式
- en: With variables and I/O statements, we now have some really powerful building
    blocks in our programming toolbox. But storing and printing values is pretty boring
    as coding goes. We want to start doing some work with the contents of those variables.
    One of the first rungs up the code complexity ladder is the ability to calculate
    new values. In C (and many other languages), you can perform calculations with
    the help of *operators*, symbols that allow you to do things like add, subtract,
    multiply, or compare (i.e., perform an “operation”) on two or more values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过变量和 I/O 语句，我们在编程工具箱中有了一些非常强大的构建模块。但是，存储和打印值在编码中相当无聊。我们想要开始对这些变量的内容进行一些工作。在代码复杂性阶梯的第一个阶段，你可以计算新值。在
    C（以及许多其他语言）中，你可以借助*运算符*执行计算，这些符号允许你执行诸如加法、减法、乘法或比较（即执行“操作”）等操作。
- en: C includes several predefined operators for doing basic mathematic and logic
    work. (Advanced math and logic can be done by writing your own functions, which
    we’ll look at in [Chapter 5](ch05.xhtml#smallerc-CHP-5).) With the exception of
    a special ternary operator (`?:`, discussed in [“The Ternary Operator and Conditional
    Assignment”](ch03.xhtml#smallerc-CHP-3-SECT-2.3)), C’s operators work with either
    one or two values. [Figure 2-3](#smallerc-CHP-2-FIG-binary-op) shows how these
    unary and binary operators fit with values and expressions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: C 包含几个预定义的运算符，用于进行基本的数学和逻辑工作。（高级数学和逻辑可以通过编写自己的函数来完成，我们将在[第5章](ch05.xhtml#smallerc-CHP-5)中进行讨论。）除了一个特殊的三元运算符（`?:`，在[“三元运算符和条件赋值”](ch03.xhtml#smallerc-CHP-3-SECT-2.3)中讨论），C
    的运算符可以使用一个或两个值。[图2-3](#smallerc-CHP-2-FIG-binary-op)展示了这些一元和二元运算符如何与值和表达式配合使用。
- en: '![smac 0203](Images/smac_0203.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![smac 0203](Images/smac_0203.png)'
- en: Figure 2-3\. Binary operator syntax
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3。二元运算符语法
- en: Notice that you can use operators on more than two values in a sequence, but
    under the hood, C will be treating that sequence as a series of pairs. In general,
    operators work with *expressions*. The term “expression” is quite expansive. An
    expression can be as simple as a literal value or a single variable. It can also
    be so complex that it requires multiple lines of code to write down. The key thing
    to remember when you see discussions of expressions is that they have (or will
    produce) a value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以在一个序列上使用多个值的操作符，但在底层，C 将会将该序列视为一系列的对。一般来说，操作符可以与*表达式*一起使用。术语“表达式”是相当广泛的。一个表达式可以很简单，比如一个字面值或一个单一变量。它也可以非常复杂，以至于需要多行代码来编写。当你看到有关表达式的讨论时，要记住的关键点是它们具有（或将产生）一个值。
- en: Arithmetic Operators
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术操作符
- en: Perhaps the most intuitive operators in C are those used for mathematical calculations.
    [Table 2-6](#smallerc-CHP-2-TABLE-math-ops) shows the operators built into C.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，也许最直观的操作符是用于数学计算的那些。[表格 2-6](#smallerc-CHP-2-TABLE-math-ops) 展示了内置于
    C 语言中的操作符。
- en: Table 2-6\. Arithmetic Operators
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 2-6\. 算术操作符
- en: '| Operator | Operation | Description |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 操作 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `+` | Addition | Add two values |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 | 将两个值相加 |'
- en: '| `-` | Subtraction | Subtract the second value from the first |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法 | 从第一个值中减去第二个值 |'
- en: '| `*` | Multiplication | Multiply two values |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 | 两个值相乘 |'
- en: '| `/` | Division | Divide the first value by the second |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法 | 将第一个值除以第二个值 |'
- en: '| `%` | Remainder | Find the remainder after dividing the first (integer) value
    by the second |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取余 | 求第一个（整数）值除以第二个值的余数 |'
- en: You can do math with literals or variables or expressions, or some combination
    of those things. Let’s try a simple program to ask the user for two integers and
    then use those values to do some calculations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对字面值、变量或表达式进行数学计算，或者它们的某种组合。让我们试一个简单的程序，要求用户输入两个整数，然后使用这些值进行一些计算。
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Try this short program out yourself. You can type it in or open up the [*ch02/calcs.c*](https://oreil.ly/w13kJ)
    file. Compile and run and you should get output similar to this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请自己尝试运行这个简短的程序。你可以自己输入它，或者打开[*ch02/calcs.c*](https://oreil.ly/w13kJ) 文件。编译并运行，你应该会得到类似以下的输出：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Hopefully, most of those answers make sense and fit with your expectations.
    Some results that seem odd might be our attempt to divide two numbers. Instead
    of getting a floating point approximation of something like 8.33333, we got a
    flat-out 8. Remember that the `int` type does not support fractions. If you divide
    two `int`s, you always get another `int` as the result and any decimal portion
    is simply dropped. And I do mean dropped, not rounded. A division result of 8.995,
    for example, would come back as simply 8, and a negative answer, say –7.89, would
    come back as –7.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 希望大部分答案都能让你感到合理并符合你的期望。有些看似奇怪的结果可能是我们尝试对两个数字进行除法的结果。与其说是得到了类似8.33333这样的浮点近似值，不如说我们直接得到了8。请记住，`int`
    类型不支持分数。如果你将两个 `int` 数相除，结果总是另一个 `int`，而任何小数部分都会被简单地舍弃。我说的是被舍弃，而不是四舍五入。例如，除法结果为8.995时，将会返回8，而负数答案，比如–7.89，将会返回–7。
- en: Order of Operations
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算顺序
- en: 'But what if we make a more complex expression with two (or more) operators?
    We can upgrade our program a little to take three integers and combine them in
    different ways. Check out [*ch02/calcs2.c*](https://oreil.ly/wznGj):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们使用两个（或更多）操作符创建一个更复杂的表达式会怎样？我们可以稍微升级我们的程序，让它接受三个整数，并以不同的方式组合它们。查看[*ch02/calcs2.c*](https://oreil.ly/wznGj)：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Feel free to tweak the code to try other combinations if you like. As it stands,
    you can compile and run this program to get the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以随意调整代码来尝试其他组合。如现在的情况，你可以编译并运行此程序以获得以下输出：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Do these answers match what you expected? If not, it’s likely due to the *precedence*
    of different operators. C does not handle large expressions in a simple, left-to-right
    manner. Some operators are more important than others—they have precedence over
    lesser operators. C will perform the most important operations first, wherever
    they are in the expression, before moving on to do the remaining operations. You’ll
    often see the phrase “order of operations” used when talking about evaluating
    expressions with a mix of operators.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些答案是否符合你的预期？如果不符合，很可能是由于不同操作符的*优先级*。C 语言并不简单地按照从左到右的方式处理大表达式。一些操作符比其他操作符更重要——它们具有优先于较低级操作符的优先级。C
    将首先执行最重要的操作，无论它们在表达式中的位置如何，然后再进行其余的操作。在讨论包含混合操作符的表达式时，你经常会看到“运算顺序”的术语被使用。
- en: 'Multiplication, division, and remainder (`*`, `/`, `%`) operations will all
    be done before addition and subtraction (`+`, `-`) operations. Where you have
    a series of the same or equivalent operators, then those calculations are done
    left to right. Usually that’s fine and we can get the answer we need by being
    a little careful in how we arrange the parts of our expression. When we can’t
    rely on a simple arrangement, we can use parentheses to create a specific, custom
    order of operations. Consider this snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法、除法和取余(`*`, `/`, `%`)操作将在加法和减法(`+`, `-`)操作之前执行。当你有一系列相同或等效的操作符时，这些计算将从左向右进行。通常情况下这是没问题的，通过仔细安排表达式的部分我们可以得到需要的答案。当我们不能依赖简单的排列顺序时，我们可以使用括号创建特定的自定义操作顺序。考虑以下代码片段：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here we have three orderings, but only the final one, `average3`, is correct.
    The parenthetical expression, `14 + 20`, is evaluated first. One way to think
    about this is that parentheses have a higher order of precedence than arithmetic
    operations. You are free to use parentheses anywhere you like, by the way, even
    if it only adds visual clarity to an otherwise correctly ordered expression.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三种排列方式，但只有最后一个`average3`是正确的。括号表达式`14 + 20`首先被计算。可以这样思考，括号比算术操作有更高的优先级。顺便说一句，你可以随意使用括号，即使它只是为了增加对本来就正确排序的表达式的视觉清晰度。
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The notion of “visual clarity” is very subjective. If the parentheses are necessary
    for calculating the correct answer, then of course you need to use them. If they
    are not strictly necessary, use them wherever they help you read the expression
    more easily. It is possible to have too many parentheses, making it more difficult
    to read your code. Above all, be consistent in your use.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: “视觉清晰度”的概念非常主观。如果括号在计算正确答案时是必需的，那么当然你需要使用它们。如果它们并不是绝对必需的，只要能帮助你更轻松地阅读表达式，你就可以随处使用。有时候括号太多反而会增加代码的阅读难度。最重要的是，在使用中保持一致性。
- en: 'Parentheses can also be nested if you have particularly messy expressions similar
    to some of these:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有特别混乱的表达式，括号也可以嵌套，类似于其中的一些情况：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In expressions like these, the innermost parenthetical expression, `(1 + 2)`,
    is evaluated first and then you work your way back out.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些表达式中，最内层的括号表达式`(1 + 2)`首先被计算，然后你逐步向外处理。
- en: Type Casting
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'We’ve talked about variable types quite a bit in this chapter, but expressions
    also have a type, and sometimes that leads to surprises for the uninitiated. Consider
    this following snippet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经讨论了变量类型，但表达式也有类型，有时这会给未经培训的人带来惊喜。考虑以下代码片段：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Any guesses at what will show up if we print out `one_third` and `average`?
    Try creating a small C program to test your theory. Your results should look like
    this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你猜得出如果我们打印出`one_third`和`average`会显示什么吗？试着创建一个小的C程序来测试你的理论。你的结果应该像这样：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But “one third” should be 0.333333 and our average of 12 and 5 should be 8.5\.
    What happened? Well, the compiler saw a bunch of integers and performed integer
    math. If you think back to grade school, you may have learned to do long division
    with remainders, i.e., “3 goes into 1 zero times with a remainder of 3.” For C,
    that means that integer 1 divided by integer 3 is integer 0. (Recall that the
    `%` operator will give you the remainder value if you need it.)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但是“one third”应该是0.333333，我们12和5的平均数应该是8.5。发生了什么？嗯，编译器看到了一堆整数，并进行了整数运算。如果你回想起小学时学的长除法，你可能知道，“3除以1得0，余数是3。”对于C语言来说，这意味着整数1除以整数3得到整数0。（回忆一下，如果需要，`%`运算符会给出余数值。）
- en: 'Is there any way to get the floating point answer we want? Yes! In fact, there
    are a number of ways to get the right answer. Perhaps the simplest way to do this
    in our made-up examples is to use floating point literals in the initialization
    expressions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有办法获得我们想要的浮点数答案呢？是的！实际上，有许多方法可以得到正确的答案。也许在我们的虚构示例中最简单的方法是在初始化表达式中使用浮点字面量：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Try changing your program, and hopefully you’ll get new, correct output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改你的程序，希望你能得到新的正确输出：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: But what about cases where we are not using literals? What if we change our
    average calculation in the snippet to use a third, `int` variable?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们不使用字面量呢？如果我们在代码片段中改变平均计算以使用第三个`int`变量呢？
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'How could we get the average to come out correctly in this case? C supports
    *type casting*, which allows you to tell the compiler to treat a value as if it
    had some other type. Very handy for just this type of situation. We can *cast*
    our `count` variable as a `float` like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们如何使平均值正确出现？C 支持*类型转换*，允许你告诉编译器将一个值视为具有其他某种类型。对于这种情况非常方便。我们可以像这样将我们的`count`变量*转换*为`float`：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You put the type you want in parentheses before the value or expression that
    you want to convert. And now that we have a floating point value in our calculation,
    the rest of the calculation will be “upgraded” to a floating point expression
    and we’ll get the correct answer. That process of upgrading is not just a happy
    accident. The compiler does this on purpose and the process even has a name, *implicit
    type casting*.^([7](ch02.xhtml#idm45018734580792)) [Figure 2-4](#smallerc-CHP-2-FIG-promotions)
    shows you the upgrade path for many of the numeric types we have discussed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在想要转换为“更小”类型的值或表达式之前，你需要将所需类型放在括号中。现在我们的计算中有一个浮点数值，剩下的计算将会“升级”为浮点表达式，从而得到正确的答案。这种升级过程不仅仅是一种偶然。编译器是有意这样做的，这个过程甚至有一个名字，*隐式类型转换*。^([7](ch02.xhtml#idm45018734580792))
    [图 2-4](#smallerc-CHP-2-FIG-promotions) 展示了我们讨论过的许多数值类型的升级路径。
- en: In any expression with different types involved, the “biggest” type wins and
    everyone else will be promoted to that type. Notice that you can occasionally
    lose some important information in such conversions. A negative number will lose
    its sign if it gets promoted to an unsigned type. Or a long integer might be approximated
    rather poorly if it gets promoted to `float` or even to a `double`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何涉及不同类型的表达式中，“最大”的类型将获胜，其他人将被提升为该类型。请注意，这样的转换有时会丢失一些重要信息。如果一个负数被提升为无符号类型，它将失去它的符号。或者，如果将一个长整数提升为`float`甚至`double`，可能会得到非常糟糕的近似值。
- en: '![smac 0204](Images/smac_0204.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![smac 0204](Images/smac_0204.png)'
- en: Figure 2-4\. Implicit casting hierarchy
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 隐式类型转换层级结构
- en: 'As with parentheses that add clarity without changing the calculation, you
    can always use an explicit cast if it helps you understand what your expression
    is doing. But note that the order of operations is still in effect. For example,
    the following statements are *not* all the same:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就像括号可以增加清晰度而不改变计算一样，如果它有助于你理解表达式正在做什么，你总是可以使用显式转换。但请注意，操作顺序仍然有效。例如，以下语句*并不*都是相同的：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you add those lines to your testing program and then print out the three
    averages, you’ll notice that the first two work fine, but the third does not.
    Do you see why? The parentheses in the third calculation cause the original, wrong
    average with all integer types to be performed *before* that wrong answer is promoted
    to a `float`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些行添加到你的测试程序中，然后打印出三个平均值，你会注意到前两个没问题，但第三个不行。你看出为什么了吗？第三个计算中的括号导致先进行了带有所有整数类型的原始错误平均值，然后才将这个错误答案提升为`float`类型。
- en: Warning
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: I should also point out that any time you want to move down the promotion ladder
    to a “smaller” type, you must use an explicit cast. Luckily, the compiler can
    usually catch these situations and warn you.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该指出，任何时候你想要向“更小”的类型转换，都必须使用显式转换。幸运的是，编译器通常可以捕捉到这些情况并警告你。
- en: Next Steps
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Statements comprise the core of any computer language and we’ve seen the basic
    syntax for how C uses them to assign values, perform calculations, and print results.
    You may have to get used to including that semicolon at the end of statements,
    but that’ll start to feel natural before long. Typing in the examples and running
    them is your best route to that happy feeling.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 语句是任何计算机语言的核心，我们已经看到了 C 语言如何使用它们来赋值、执行计算和输出结果的基本语法。你可能需要习惯在语句末尾加上分号，但不久之后这将开始感觉自然。输入这些示例并运行它们是你获得这种愉悦感的最佳途径。
- en: If you did try any of the calculating demo programs, you may have been tempted
    to enter a zero for one of the divisors. (If you weren’t tempted, go try it now!)
    However, C cannot divide by zero and gives up. You will get an error like “Floating
    point exception (core dumped)” or a result like “NaN” for “not a number.” How
    could we prevent such a crash? The next chapter will look at comparison operations
    and control statements that grant us exactly this ability.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试过任何计算演示程序，可能会诱惑你为其中一个除数输入零。（如果你没有尝试过，请现在尝试！）然而，C语言无法除以零并放弃计算。你将收到像“Floating
    point exception (core dumped)”这样的错误，或者像“NaN”这样的结果，表示“非数值”。我们如何避免这样的崩溃？下一章将讨论比较操作和控制语句，使我们能够做到这一点。
- en: ^([1](ch02.xhtml#idm45018742699768-marker)) While some support for wide characters
    was added to C in the1990s, C generally does not deal well with the more popular
    UTF character encodings such as UTF-8, UTF-16, etc. Those encodings allow for
    multibyte characters, and C’s `char` type was built with single bytes in mind.
    (More on types in [“Strings and Characters”](#smallerc-CHP-2-SECT-2.2).) If you
    work with international or localized text, you’ll want to research some libraries
    to help. While I won’t cover localization in detail, I do go into more depth on
    libraries in general in [Chapter 7](ch07.xhtml#smallerc-CHP-7).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm45018742699768-marker)) 虽然C语言在1990年代增加了对宽字符的某些支持，但通常不太适用于更流行的UTF字符编码，如UTF-8、UTF-16等。这些编码允许多字节字符，而C的`char`类型则设计为单字节。
    （更多关于类型的信息请参见[“字符串和字符”](#smallerc-CHP-2-SECT-2.2)）。如果你处理国际化或本地化文本，你可能需要研究一些库来帮助。虽然我不会详细介绍本地化，但我在[第7章](ch07.xhtml#smallerc-CHP-7)中对库进行了更深入的探讨。
- en: ^([2](ch02.xhtml#idm45018742586888-marker)) You might still see discussions
    online about including or excluding a “carriage return,” which is just old coder
    jargon for an end-of-line marker. It is a term inherited from early typewriters
    which had a literal mechanism to return the paper carriage to a starting position
    so you could begin the next line of text.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm45018742586888-marker)) 你可能仍然会在网上看到关于是否包含或排除“回车符”的讨论，这只是旧编码人员对行尾标记的俚语。这个术语继承自早期的打字机，其具有将纸张车辆返回到起始位置的字面机制，以便你可以开始下一行文字。
- en: ^([3](ch02.xhtml#idm45018742503880-marker)) American Standard Code for Information
    Interchange, originally a 7-bit encoding built for Teletype machines. Now with
    8-bit variants, it is still based on English. Other, more extensible encodings
    such as Unicode and its UTF-8 option have become the norm.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm45018742503880-marker)) 美国信息交换标准代码（American Standard Code
    for Information Interchange），最初是为电传打字机而设计的7位编码。现在有8位变体，仍然基于英语。其他更具可扩展性的编码，如Unicode及其UTF-8选项，已成为常态。
- en: ^([4](ch02.xhtml#idm45018742299128-marker)) The `char` type can actually be
    either signed or unsigned depending on your compiler.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm45018742299128-marker)) `char` 类型实际上可以是有符号的或无符号的，这取决于你的编译器。
- en: ^([5](ch02.xhtml#idm45018742233528-marker)) These formats were specified by
    the IEEE (Institute of Electrical and Electronics Engineers). The 32-bit version
    is called “single precision,” and the 64-bit version is “double.” Higher precisions
    exist, and the spec ([IEEE 754](https://oreil.ly/rxm00)) continues to be developed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm45018742233528-marker)) 这些格式由IEEE（电气和电子工程师协会）规定。32位版本称为“单精度”，64位版本称为“双精度”。还存在更高精度，规范（[IEEE
    754](https://oreil.ly/rxm00)）仍在发展中。
- en: ^([6](ch02.xhtml#idm45018742180600-marker)) The GNU C compiler, for example,
    does not impose any limit. But for compatibility and conformity, sticking to much
    less than 31 characters is still advisable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#idm45018742180600-marker)) 例如，GNU C编译器并没有强加任何限制。但为了兼容性和一致性，仍然建议保持远低于31个字符。
- en: ^([7](ch02.xhtml#idm45018734580792-marker)) Sometimes you may hear the terms
    “type promotion” or “automatic type conversion” as well.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#idm45018734580792-marker)) 有时您可能会听到“类型提升”或“自动类型转换”这样的术语。
