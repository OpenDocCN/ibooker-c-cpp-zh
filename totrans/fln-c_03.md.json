["```cpp\n/* Handle for registry keys */\ntypedef struct Key* RegKey;\n\n/* Create a new registry key identified via the provided 'key_name' */\nRegKey createKey(char* key_name);\n\n/* Store the provided 'value' to the provided 'key' */\nvoid storeValue(RegKey key, char* value);\n\n/* Make the key available for being read (by other\n functions that are not part of this code example) */\nvoid publishKey(RegKey key);\n```", "```cpp\n#define STRING_SIZE 100\n#define MAX_KEYS 40\n\nstruct Key\n{\n  char key_name[STRING_SIZE];\n  char key_value[STRING_SIZE];\n};\n\n/* file-global array holding all registry keys */\nstatic struct Key* key_list[MAX_KEYS];\n\nRegKey createKey(char* key_name)\n{\n  RegKey newKey = calloc(1, sizeof(struct Key));\n  strcpy(newKey->key_name, key_name);\n  return newKey;\n}\n\nvoid storeValue(RegKey key, char* value)\n{\n  strcpy(key->key_value, value);\n}\n\nvoid publishKey(RegKey key)\n{\n  int i;\n  for(i=0; i<MAX_KEYS; i++)\n  {\n    if(key_list[i] == NULL)\n    {\n      key_list[i] = key;\n      return;\n    }\n  }\n}\n```", "```cpp\nRegKey my_key = createKey(\"myKey\");\nstoreValue(my_key, \"A\");\npublishKey(my_key);\n```", "```cpp\nErrorCode status = func();\nif(status == MAJOR_ERROR)\n{\n  /* abort program */\n}\nelse if(status == MINOR_ERROR)\n{\n  /* handle error */\n}\nelse if(status == OK)\n{\n  /* continue normal execution */\n}\n```", "```cpp\ntypedef enum\n{\n  MINOR_ERROR,\n  MAJOR_ERROR,\n  OK\n}ErrorCode;\n\nErrorCode func();\n```", "```cpp\nErrorCode func()\n{\n  if(minorErrorOccurs())\n  {\n    return MINOR_ERROR;\n  }\n  else if(majorErrorOccurs())\n  {\n    return MAJOR_ERROR;\n  }\n  else\n  {\n    return OK;\n  }\n}\n```", "```cpp\n/* Error codes returned by this registry */\ntypedef enum\n{\n  OK,\n  OUT_OF_MEMORY,\n  INVALID_KEY,\n  INVALID_STRING,\n  STRING_TOO_LONG,\n  CANNOT_ADD_KEY\n}RegError;\n\n/* Handle for registry keys */\ntypedef struct Key* RegKey;\n\n/* Create a new registry key identified via the provided 'key_name'.\n Returns OK if no problem occurs, INVALID_KEY if the 'key'\n parameter is NULL, INVALID_STRING if 'key_name' is NULL,\n STRING_TOO_LONG if 'key_name' is too long, or OUT_OF_MEMORY\n if no memory resources are available. */\nRegError createKey(char* key_name, RegKey* key);\n\n/* Store the provided 'value' to the provided 'key'.\n Returns OK if no problem occurs, INVALID_KEY if the 'key'\n parameter is NULL, INVALID_STRING if 'value' is NULL, or\n STRING_TOO_LONG if 'value' is too long. */\nRegError storeValue(RegKey key, char* value);\n\n/* Make the key available for being read. Returns OK if no\n problem occurs, INVALID_KEY if 'key' is NULL, or CANNOT_ADD_KEY\n if the registry is full and no more keys can be published. */\nRegError publishKey(RegKey key);\n```", "```cpp\n#define STRING_SIZE 100\n#define MAX_KEYS 40\n\nstruct Key\n{\n  char key_name[STRING_SIZE];\n  char key_value[STRING_SIZE];\n};\n\n/* file-global array holding all registry keys */\nstatic struct Key* key_list[MAX_KEYS];\n\nRegError createKey(char* key_name, RegKey* key)\n{\n  if(key == NULL)\n  {\n    return INVALID_KEY;\n  }\n\n  if(key_name == NULL)\n  {\n    return INVALID_STRING;\n  }\n\n  if(STRING_SIZE <= strlen(key_name))\n  {\n    return STRING_TOO_LONG;\n  }\n\n  RegKey newKey = calloc(1, sizeof(struct Key));\n  if(newKey == NULL)\n  {\n    return OUT_OF_MEMORY;\n  }\n\n  strcpy(newKey->key_name, key_name);\n  *key = newKey;\n  return OK;\n}\n\nRegError storeValue(RegKey key, char* value)\n{\n  if(key == NULL)\n  {\n    return INVALID_KEY;\n  }\n\n  if(value == NULL)\n  {\n    return INVALID_STRING;\n  }\n\n  if(STRING_SIZE <= strlen(value))\n  {\n    return STRING_TOO_LONG;\n  }\n\n  strcpy(key->key_value, value);\n  return OK;\n}\n\nRegError publishKey(RegKey key)\n{\n  int i;\n  if(key == NULL)\n  {\n    return INVALID_KEY;\n  }\n\n  for(i=0; i<MAX_KEYS; i++)\n  {\n    if(key_list[i] == NULL)\n    {\n      key_list[i] = key;\n      return OK;\n    }\n  }\n\n  return CANNOT_ADD_KEY;\n}\n```", "```cpp\n  RegError err;\n  RegKey my_key;\n\n  err = createKey(\"myKey\", &my_key);\n  if(err == INVALID_KEY || err == INVALID_STRING)\n  {\n    printf(\"Internal application error\\n\");\n  }\n  if(err == STRING_TOO_LONG)\n  {\n    printf(\"Provided registry key name too long\\n\");\n  }\n  if(err == OUT_OF_MEMORY)\n  {\n    printf(\"Insufficient resources to create key\\n\");\n  }\n\n  err = storeValue(my_key, \"A\");\n  if(err == INVALID_KEY || err == INVALID_STRING)\n  {\n    printf(\"Internal application error\\n\");\n  }\n  if(err == STRING_TOO_LONG)\n  {\n    printf(\"Provided registry value to long to be stored to this key\\n\");\n  }\n\n  err = publishKey(my_key);\n  if(err == INVALID_KEY)\n  {\n    printf(\"Internal application error\\n\");\n  }\n  if(err == CANNOT_ADD_KEY)\n  {\n    printf(\"Key cannot be published, because the registry is full\\n\");\n  }\n```", "```cpp\nErrorCode status = func();\nif(status == MAJOR_ERROR || status == UNKNOWN_ERROR)\n{\n  /* abort program */\n}\nelse if(status == MINOR_ERROR)\n{\n  /* handle error */\n}\nelse if(status == OK)\n{\n  /* continue normal execution*/\n}\n```", "```cpp\ntypedef enum\n{\n  MINOR_ERROR,\n  MAJOR_ERROR,\n  UNKNOWN_ERROR,\n  OK\n}ErrorCode;\n\nErrorCode func();\n```", "```cpp\nErrorCode func()\n{\n  if(minorErrorOccurs())\n  {\n    return MINOR_ERROR;\n  }\n  else if(majorErrorOccurs())\n  {\n    return MAJOR_ERROR;\n  }\n  else if(internalError1Occurs() || internalError2Occurs())\n  {\n    return UNKNOWN_ERROR; ![1](assets/1.png)\n  }\n  else\n  {\n    return OK;\n  }\n}\n```", "```cpp\nRegError createKey(char* key_name, RegKey* key)\n{\n  if(key == NULL || key_name == NULL)\n  {\n    return INVALID_PARAMETER; ![1](assets/1.png)\n  }\n\n  if(STRING_SIZE <= strlen(key_name))\n  {\n    return STRING_TOO_LONG;\n  }\n\n  RegKey newKey = calloc(1, sizeof(struct Key));\n  if(newKey == NULL)\n  {\n    return OUT_OF_MEMORY;\n  }\n\n  strcpy(newKey->key_name, key_name);\n  *key = newKey;\n  return OK;\n}\n```", "```cpp\n/* Create a new registry key identified via the provided 'key_name'\n (must not be NULL, max. STRING_SIZE characters). Stores a handle\n to the key in the provided 'key' parameter (must not be NULL).\n Returns OK on success, or OUT_OF_MEMORY in case of insufficient memory. */\nRegError createKey(char* key_name, RegKey* key);\n```", "```cpp\nRegError createKey(char* key_name, RegKey* key)\n{\n  assert(key != NULL && key_name != NULL); ![1](assets/1.png)\n  assert(STRING_SIZE > strlen(key_name)); ![1](assets/1.png)\n\n  RegKey newKey = calloc(1, sizeof(struct Key));\n  if(newKey == NULL)\n  {\n    return OUT_OF_MEMORY;\n  }\n\n  strcpy(newKey->key_name, key_name);\n  *key = newKey;\n  return OK;\n}\n```", "```cpp\nvoid* func()\n{\n  if(somethingGoesWrong())\n  {\n    return NULL;\n  }\n  else\n  {\n    return some_pointer;\n  }\n}\n```", "```cpp\npointer = func();\nif(pointer != NULL)\n{\n  /* operate on the pointer */\n}\nelse\n{\n  /* handle error */\n}\n```", "```cpp\n/* Create a new registry key identified via the provided 'key_name'\n (must not be NULL, max. STRING_SIZE characters).\n Returns a handle to the key or NULL on error. */\nRegKey createKey(char* key_name);\n```", "```cpp\nRegKey createKey(char* key_name)\n{\n  assert(key_name != NULL);\n  assert(STRING_SIZE > strlen(key_name));\n\n  RegKey newKey = calloc(1, sizeof(struct Key));\n  if(newKey == NULL)\n  {\n    return NULL;\n  }\n\n  strcpy(newKey->key_name, key_name);\n  return newKey;\n}\n```", "```cpp\nvoid someFunction()\n{\n  if(something_goes_wrong)\n  {\n     logInFile(\"something went wrong\", ERROR_CODE, __func__);\n  }\n}\n```", "```cpp\n#define RETURN(x)          \\\ndo {                       \\\n logInFile(__func__, x);  \\\n return x;                \\\n} while (0)\n\nint soneFunction()\n{\n  RETURN(-1);\n}\n```", "```cpp\n/* max. size of string parameters (including NULL-termination) */\n#define STRING_SIZE 100\n\n/* Error codes returned by this registry */\ntypedef enum\n{\n  OK,\n  CANNOT_ADD_KEY\n}RegError;\n\n/* Handle for registry keys */\ntypedef struct Key* RegKey;\n\n/* Create a new registry key identified via the provided 'key_name'\n (must not be NULL, max. STRING_SIZE characters).  Returns a handle\n to the key or NULL on error. */\nRegKey createKey(char* key_name);\n\n/* Store the provided 'value' (must not be NULL, max. STRING_SIZE characters)\n to the 'key' (MUST NOT BE NULL) */\nvoid storeValue(RegKey key, char* value);\n\n/* Make the 'key' (must not be NULL) available for being read.\n Returns OK if no problem occurs or CANNOT_ADD_KEY if the\n registry is full and no more keys can be published. */\nRegError publishKey(RegKey key);\n```", "```cpp\n#define MAX_KEYS 40\n\nstruct Key\n{\n  char key_name[STRING_SIZE];\n  char key_value[STRING_SIZE];\n};\n\n/* macro to log debug info and to assert */\n#define logAssert(X)                        \\\nif(!(X))                                    \\\n{                                           \\\n printf(\"Error at line %i\", __LINE__);     \\\n assert(false);                            \\\n}\n\n/* file-global array holding all registry keys */\nstatic struct Key* key_list[MAX_KEYS];\n\nRegKey createKey(char* key_name)\n{\n  logAssert(key_name != NULL)\n  logAssert(STRING_SIZE > strlen(key_name))\n\n  RegKey newKey = calloc(1, sizeof(struct Key));\n  if(newKey == NULL)\n  {\n    return NULL;\n  }\n\n  strcpy(newKey->key_name, key_name);\n  return newKey;\n}\n\nvoid storeValue(RegKey key, char* value)\n{\n  logAssert(key != NULL && value != NULL)\n  logAssert(STRING_SIZE > strlen(value))\n\n  strcpy(key->key_value, value);\n}\n\nRegError publishKey(RegKey key)\n{\n  logAssert(key != NULL)\n\n  int i;\n  for(i=0; i<MAX_KEYS; i++)\n  {\n    if(key_list[i] == NULL)\n    {\n      key_list[i] = key;\n      return OK;\n    }\n  }\n\n  return CANNOT_ADD_KEY;\n}\n```", "```cpp\nRegKey my_key = createKey(\"myKey\");\nif(my_key == NULL)\n{\n  printf(\"Cannot create key\\n\");\n}\n\nstoreValue(my_key, \"A\");\n\nRegError err = publishKey(my_key);\nif(err == CANNOT_ADD_KEY)\n{\n  printf(\"Key cannot be published, because the registry is full\\n\");\n}\n```"]