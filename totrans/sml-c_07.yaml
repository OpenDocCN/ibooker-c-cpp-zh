- en: Chapter 7\. Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 图书馆
- en: 'One of C’s best qualities is the minimal adornment present in its compiled
    code. A favorite snipe at some more modern languages like Java is the size of
    the “Hello, World” program. Our very first program back in [“Creating a C ‘Hello,
    World’”](ch01.xhtml#smallerc-CHP-1-SECT-2.2) takes up a little over 16Kb on my
    Linux machine without any optimizations. Achieving the same output from a standalone
    executable on the same system using Java, though, requires tens of megabytes and
    much, much more effort to build. That’s not an entirely fair comparison since
    the Java hello application needs the entire Java runtime baked into the executable,
    but that’s also the point: C makes it easy to create lean code for a given system.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的一大优点是其编译代码中的最小装饰。对于一些更现代的语言如Java，有一个经典的笑话是关于“Hello, World”程序的大小。我们在[“创建C语言的‘Hello,
    World’”](ch01.xhtml#smallerc-CHP-1-SECT-2.2)中的第一个程序在我的Linux机器上占用了略多于16Kb的空间，没有进行任何优化。而在同一系统上使用Java来实现相同的输出，需要数十兆字节的空间，并且需要更多的工作量来构建。这并不是一个完全公平的比较，因为Java的Hello应用程序需要整个Java运行时嵌入到可执行文件中，但这也正是重点所在：对于特定系统，C语言可以轻松创建精简的代码。
- en: That ease is great when we’re tackling small things like “Hello, World” or even
    most of the examples from past chapters. But as we get ready to jump into the
    world of microcontrollers and Arduino, we’re left worrying about re-creating our
    own solutions to some pretty mundane problems. For example, we’ve written some
    of our own functions to compare strings. We wrote a fancier program to encode
    base64 content. That stuff is fun, but do we always have to do this type of work
    from scratch?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理小东西如“Hello, World”或者过去章节中的大多数示例时，这种简易性非常棒。但当我们准备跳入微控制器和Arduino的世界时，我们开始担心是否要重新创建一些相当乏味的问题的解决方案。例如，我们编写了一些自己的函数来比较字符串。我们编写了一个更复杂的程序来编码base64内容。这些都很有趣，但我们是否总是需要从头开始做这种工作呢？
- en: 'Happily, the answer to that question is: no. C supports the notion of using
    a *library* for quick, friendly expansion of its capabilities—without losing its
    lean profile for the final executable. A library is a bundle of code that can
    be imported into your projects to add new capabilities, like working with strings
    or talking to a wireless network. But the key to using libraries is that you only
    need to add the one that contains the features you need. That Java hello application
    would have latent support for creating an entire graphical interface and opening
    network connections, even though they would not be used just to print some text
    in a terminal window.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于这个问题的答案是：不需要。C语言支持使用*库*的概念，可以快速友好地扩展其功能，而不会影响最终可执行文件的精简性。库是一组代码的集合，可以导入到您的项目中以添加新功能，比如处理字符串或与无线网络通信。但使用库的关键在于，您只需要添加包含您需要功能的那一个库。相比之下，Java的Hello应用程序可能会包含整个图形界面和网络连接的支持，尽管这些功能在终端窗口中只是打印文本时不会被使用。
- en: With Arduino, for example, you’ll find libraries for most of the popular sensors
    like temperature components or light-level resistors and outputs like LEDs and
    LCD displays. You won’t have to write your own device driver to use a piece of
    electronic paper or change the color of an RGB LED. You can load up a library
    and get to work on *what* you want to display on that e-paper, and not worry about
    *how*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用Arduino时，您会发现为大多数流行的传感器如温度组件或光电阻器以及输出如LED和LCD显示器提供了库。您不需要编写自己的设备驱动程序来使用电子纸或更改RGB
    LED的颜色。您可以加载一个库，并专注于在电子纸上显示什么，而不必担心如何实现。
- en: The C Standard Library
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C标准库
- en: We have already used a couple libraries on our path to this point in the book.
    Even our very first program needed the *stdio.h* header for access to the `printf()`
    function. And our most recent work on pointers in [Chapter 6](ch06.xhtml#smallerc-CHP-6)
    required the `malloc()` function found in the *stdlib.h* header. We didn’t have
    to do much to get access to those bits. Indeed, we just wrote an `#include` statement
    at the top of our program and off we went!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中我们到达目前位置的路上已经使用了几个库。即使是我们的第一个程序也需要*stdio.h*头文件来访问`printf()`函数。而我们在[第6章](ch06.xhtml#smallerc-CHP-6)关于指针的最新工作需要*stdlib.h*头文件中的`malloc()`函数。我们不需要做太多事情就能访问到这些功能。事实上，我们只需在程序顶部写上一个`#include`语句，然后就可以开始工作了！
- en: The reason these functions are so easy to incorporate is that they belong to
    the C standard library. Every C compiler or development environment will have
    this library available. It may be packaged differently on different platforms
    (such as including or excluding the math functions), but you can always count
    on the overall content being ready for inclusion. I can’t cover everything in
    the library, but I do want to highlight some useful functions and the headers
    that provide them. In [“Putting It Together”](#smallerc-CHP-7-SECT-2), I’ll also
    cover where to look for other libraries that tackle a wider range of features.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数之所以如此易于集成，是因为它们属于 C 标准库。每个 C 编译器或开发环境都会提供此库。它在不同平台上的打包方式可能有所不同（例如包含或排除数学函数），但你始终可以指望它的整体内容可以被包含进来。我无法涵盖库中的所有内容，但我确实想要强调一些有用的函数和提供它们的头文件。在
    [“将其放在一起”](#smallerc-CHP-7-SECT-2) 中，我还将介绍在哪里查找处理更广泛功能的其他库。
- en: stdio.h
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stdio.h
- en: 'Obviously we’ve been using the *stdio.h* header from the very start. We have
    already used the two most useful functions (for our purposes): `printf()` and
    `scanf()`. The other functions in this header revolve around access to files.
    The microcontrollers we’ll be working with in the coming chapters do sometimes
    have filesystems, but the types of programs we’ll be writing won’t need that particular
    feature. Still, if you do want to work with files on a desktop or high-powered
    microcontroller, this header is a good place to start!'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始我们就一直在使用 *stdio.h* 头文件。我们已经使用了两个最有用的函数（对我们的目的而言）：`printf()` 和 `scanf()`。该头文件中的其他函数主要围绕文件访问展开。在接下来的章节中，我们将使用的微控制器有时会有文件系统，但我们将编写的程序类型不需要该特定功能。不过，如果你确实想在桌面或高性能微控制器上处理文件，这个头文件是一个很好的起点！
- en: stdlib.h
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stdlib.h
- en: We have also seen a few functions from *stdlib.h*, namely `malloc()` and `free()`.
    But this header has a few more useful tricks worth mentioning.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了 *stdlib.h* 中的几个函数，即 `malloc()` 和 `free()`。但是这个头文件还有一些更有用的技巧值得一提。
- en: atoi()
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: atoi()
- en: 'In [“Command-Line Arguments and main()”](ch05.xhtml#smallerc-CHP-5-SECT-7.2),
    I gave you an exercise to convert a string to a number. The “extra credit” note
    mentioned using *stdlib.h* to get access to C’s standard conversion function:
    `atoi()`. There are two other converters for other base types: `atol()` converts
    to a `long` value, and `atof()` converts to a floating point type, but contrary
    to the final letter in the function’s name, `atof()` returns a `double` value.
    (You can always cast that to the lower-precision `float` type if needed.)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“命令行参数和main()”](ch05.xhtml#smallerc-CHP-5-SECT-7.2) 中，我给了你一个将字符串转换为数字的练习。
    “额外积分”注释提到使用 *stdlib.h* 来访问 C 标准的转换函数：`atoi()`。还有另外两个转换函数用于其他基本类型：`atol()` 转换为
    `long` 值，而 `atof()` 转换为浮点类型，但与函数名称中的最后一个字母相反，`atof()` 返回一个 `double` 值。（如果需要，你可以将其转换为低精度的
    `float` 类型。）
- en: 'The solution to that extra exercise, [*ch07/sum2.c*](https://oreil.ly/x8J8O),
    highlights just how simple converting can be if you include the necessary header
    file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那个额外练习的解决方案，[*ch07/sum2.c*](https://oreil.ly/x8J8O)，突显了如果包含必要的头文件，转换就有多么简单：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pretty easy! Which is, of course, the hope in using a library function like
    this. You *could* write this conversion code yourself, but you can save a lot
    of time (and a fair amount of debugging) if you can find an appropriate library
    function to use instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单！当然，这也是使用库函数的希望所在。你*可以*自己编写这个转换代码，但如果你能找到一个合适的库函数来使用，你可以节省大量时间（和相当数量的调试）。
- en: Warning
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Do be a little careful with these functions. They stop parsing the string when
    they hit a nondigit character. If you attempt to convert the word “one” to a number,
    for example, that parsing stops immediately and `atoi()` (or the others) will
    return a 0 without any errors. If 0 can appear as a legitimate value in your string,
    you’ll need to add your own validity checks before calling them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些函数时要小心一些。它们在遇到非数字字符时会停止解析字符串。例如，如果尝试将单词“one”转换为数字，解析将立即停止，并且 `atoi()`（或其他函数）会返回0而没有任何错误。如果0可能是字符串中的一个合法值，你在调用它们之前需要添加自己的有效性检查。
- en: rand() and srand()
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rand() 和 srand()
- en: Random values play a fun role in many situations. Want to vary the colors of
    your LED lamp? Want to shuffle a virtual deck of cards? Need to simulate potential
    communication delays? Random numbers to the rescue!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随机值在许多情况下都起到了有趣的作用。想要改变 LED 灯的颜色吗？想要洗牌一副虚拟的扑克牌？需要模拟潜在的通信延迟吗？随机数来拯救！
- en: The `rand()` function returns a pseudorandom number between 0 and a constant
    (well, technically a *macro*; more on these in [“Special Values”](ch09.xhtml#smallerC-CHP-9-SECT-1.1)),
    `RAND_MAX`, also defined in *stdlib.h*. I say “pseudorandom” because the “random”
    number you get back is the product of an algorithm.^([1](ch07.xhtml#idm45018721966312))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand()`函数返回一个0到一个常量（技术上是一个*宏*；更多关于这些内容详见[“特殊值”](ch09.xhtml#smallerC-CHP-9-SECT-1.1)），即`RAND_MAX`之间的伪随机数。我说“伪随机”是因为你得到的“随机”数是算法的产物。^([1](ch07.xhtml#idm45018721966312))'
- en: A related function, `srand()`, can be used to *seed* the random number generating
    algorithm. The “seed” value is the starting point for the algorithm before it
    goes hopping around producing a nice variety of values. You can use `srand()`
    to supply new values every time your program runs—using the current timestamp,
    for example—or you can use the seed to produce a known list of numbers. That might
    seem like a strange thing to want, but it can be useful in testing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的函数`srand()`可以用来*种子*伪随机数生成算法。种子值是算法在跳跃产生各种值之前的起始点。你可以使用`srand()`来每次程序运行时提供新的值——例如当前时间戳——或者你可以使用种子来产生已知的数列。这可能看起来是一个奇怪的需求，但在测试中会很有用。
- en: 'Let’s try out these two functions to get a feel for their use. Take a look
    at [*ch07/random.c*](https://oreil.ly/sst4C):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试用这两个函数来感受它们的用法。看看[*ch07/random.c*](https://oreil.ly/sst4C)：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And let’s compile and run it to see the output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行它来看看输出：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On my system, then, the maximum value returned by `rand()` is 2147483647\. The
    first number we generate should be between 0 and 2147483647, and so it is. The
    second number we generate will be in the same range, but it comes after we provide
    a new seed value to `srand()`, so hopefully it’s different than `r1`, and that
    bears out.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，`rand()`返回的最大值是2147483647。我们生成的第一个数应该在0到2147483647之间，确实如此。我们生成的第二个数将在相同的范围内，但在我们为`srand()`提供一个新的种子值后，希望它与`r1`不同，结果确实如此。
- en: But look at those first two “random” numbers in the output of our second run.
    They’re exactly the same! Hardly random. As I mentioned, `rand()` is a pseudorandom
    generator. The default seed for the generating algorithm is 1 if you never call
    `srand()`. But if you call it with a constant like 5, that’s no better. It will
    be a different sequence of numbers, but every time you run the program it will
    be the same “different” sequence.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是看看我们第二次运行的输出中的前两个“随机”数。它们完全一样！几乎不随机。正如我所提到的，`rand()`是一个伪随机生成器。如果你从未调用过`srand()`，生成算法的默认种子是1。但是，如果你使用像5这样的常量调用它，情况也不会好转。它会生成不同的数列，但每次运行程序时都会是相同的“不同”数列。
- en: So, in order to get different pseudorandom numbers, you need to provide a seed
    that changes every time you run your program. The most common trick is to do what
    I did by including yet another header, *time.h* (see [“time.h”](#smallerc-CHP-7-SECT-1.5))
    and pull in the current timestamp (seconds since January 1, 1970). As long as
    we don’t manage to start the program twice in one second, we’ll get new sequences
    each run. You can see that seed turned out fine in the two runs above as the third
    number is indeed different between them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获得不同的伪随机数，你需要提供一个在每次运行程序时都会改变的种子。最常见的技巧是像我一样包含另一个头文件*time.h*（见[“time.h”](#smallerc-CHP-7-SECT-1.5)）并引入当前时间戳（自1970年1月1日以来的秒数）。只要我们不在一秒内两次启动程序，我们将在每次运行时得到新的序列。你可以在上述两次运行中看到，这种种子效果良好，因为第三个数字在它们之间确实是不同的。
- en: With that better seed^([2](ch07.xhtml#idm45018721851352)) in place, subsequent
    calls to `rand()` should look random from execution to execution. We can see that
    benefit with the PIN we generate for our final random number. The PIN is bounded
    using a popular trick for getting a random number in a range. You use the remainder
    operator to make sure you get an appropriately limited range, and then add a base
    value. For the PIN to have exactly four digits, we use a base of 1000 and a range
    of 9000 (0 to 8999 inclusive).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了更好的种子^([2](ch07.xhtml#idm45018721851352))之后，对`rand()`的后续调用应该在每次执行时看起来都是随机的。我们可以通过生成的最终随机数的PIN来看到这种好处。使用了一种获取范围内随机数的流行技巧来限制PIN。你可以使用取余运算符来确保你得到一个适当限制的范围，并且加上一个基值。为了PIN正好有四位数，我们使用了基数1000和范围9000（从0到8999包括）。
- en: exit()
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出()
- en: The final function from *stdlib.h* that I want to highlight is the `exit()`
    function. In [“Return values and main()”](ch05.xhtml#smallerc-CHP-5-SECT-7.1)
    we looked at using the `return` statement to end your program and optionally return
    a value from the `main()` function to provide some status information to the operating
    system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我要突出的*stdlib.h*中的最后一个函数是`exit()`函数。在[“返回值和main()”](ch05.xhtml#smallerc-CHP-5-SECT-7.1)中，我们看过使用`return`语句来结束程序，并可选地从`main()`函数返回一个值，以向操作系统提供一些状态信息。
- en: 'There is also a separate `exit()` function that takes an `int` argument that
    is used for the same exit code value as the `return` statement in the `main()`
    method. The difference between using `exit()` and returning from `main()` is that
    `exit()` can be called from any function and immediately quits the application.
    For example, we could write a “confirmation” function that asks the user if they
    are sure they want to quit. If they answer with a `*y*`, then we can use `exit()`
    at that point rather than returning some sentinel value to `main()` and then using
    `return`. Take a look at [*ch07/areyousure.c*](https://oreil.ly/W5lIr):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外还有一个单独的`exit()`函数，它接受一个`int`参数，用于与`main()`方法中的`return`语句相同的退出码值。使用`exit()`和从`main()`返回的区别在于，`exit()`可以从任何函数调用，并立即退出应用程序。例如，我们可以编写一个“确认”函数，询问用户是否确定要退出。如果他们回答`*y*`，那么我们可以在那一点上使用`exit()`，而不是返回一些特殊值给`main()`，然后使用`return`。查看[*ch07/areyousure.c*](https://oreil.ly/W5lIr)：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here is the output from two runs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两次运行的输出：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that when we use `exit()`, we don’t go back to the `main()` function
    or even finish the code in our `confirm()` function itself. We really do exit
    the program and supply an exit code to the operating system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们使用`exit()`时，我们不会返回到`main()`函数，甚至不会完成我们`confirm()`函数本身中的代码。我们真的退出程序并向操作系统提供退出码。
- en: Inside `main()`, by the way, it mostly doesn’t matter whether you use `return`
    or `exit()`, although the former is more “polite.” (For example, any cleanup from
    completing the `main()` function will still run if you use `return`. That same
    cleanup would be skipped if you use `exit()`.) It is also worth noting that simply
    making it to the end of the `main()` body as we have been doing all along is a
    fine and popular way to finish your program when there were no errors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在`main()`内部，无论您使用`return`还是`exit()`，大部分情况下都不会有太大差别，尽管前者更为“礼貌”。（例如，如果使用`return`，则从完成`main()`函数时的任何清理仍将运行。如果使用`exit()`，则会跳过同样的清理。）还值得注意的是，只要像我们一直在做的那样到达`main()`体的末尾是完成程序的一种很好且流行的方式，当然，在没有错误时完成程序时，这种方式会更好。
- en: string.h
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`string.h`'
- en: Strings are so common and so useful that they even have their own header file.
    The *string.h* header can be added to any program where you need to compare or
    manipulate strings beyond simply storing and printing them. This header describes
    more functions than we have time to cover here, but there are some import utilities
    we want to highlight in [Table 7-1](#smallerc-CHP-7-TABLE-string-lib).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串如此常见且如此有用，甚至有自己的头文件。*string.h*头文件可以添加到任何需要比简单存储和打印字符串更多地比较或操作字符串的程序中。这个头文件描述了比我们这里有时间涵盖的更多函数，但我们想要突出显示一些重要的实用程序在[表 7-1](#smallerc-CHP-7-TABLE-string-lib)中。
- en: Table 7-1\. Useful string functions
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. 有用的字符串函数
- en: '| Function | Description |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `strlen(char *s)` | Calculate the length of a string (not including the final
    null character) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `strlen(char *s)` | 计算字符串的长度（不包括最后的空字符） |'
- en: '| `strcmp(char *s1, char *s2)` | Compare two strings. Return -1 if s1 < s2,
    0 if s1 == s2, and 1 if s1 > s2 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `strcmp(char *s1, char *s2)` | 比较两个字符串。如果s1 < s2，则返回-1，如果s1 == s2，则返回0，如果s1
    > s2，则返回1 |'
- en: '| `strncmp(char *s1, char *s2, int n)` | Compare at most n bytes of s1 and
    s2 (results similar to strcmp) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `strncmp(char *s1, char *s2, int n)` | 比较s1和s2的最多n个字节（结果类似于strcmp） |'
- en: '| `strcpy(char *dest, char *src)` | Copy src to dest |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `strcpy(char *dest, char *src)` | 将src复制到dest |'
- en: '| `strncpy(char *dest, char *src, int n)` | Copy at most n bytes of src to
    dest |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `strncpy(char *dest, char *src, int n)` | 将src的最多n个字节复制到dest |'
- en: '| `strcat(char *dest, char *src)` | Append src to dest |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `strcat(char *dest, char *src)` | 将src追加到dest |'
- en: '| `strncat(char *dest, char *src, int n`) | Append at most n bytes of src to
    dest |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `strncat(char *dest, char *src, int n)` | 将最多n个字节的src附加到dest |'
- en: We can demonstrate all of these functions in a simple program, [*ch07/fullname.c*](https://oreil.ly/dzycy),
    by asking the user for their full name in pieces and (safely!) putting it together
    at the end. If we find we’re interacting with Dennis M. Ritchie, we’ll thank him
    for writing C.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个简单的程序中演示所有这些功能，[*ch07/fullname.c*](https://oreil.ly/dzycy)，通过请求用户提供其全名的各个部分（安全地！）在最后拼接起来。如果我们发现在与丹尼斯·里奇交互时，我们会感谢他编写了C语言。
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And an example run:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例运行：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Give this program a try yourself. If you do enter Dennis’s name (including
    the period after his middle initial: “M.”), do you get the thank-you message as
    expected?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让自己尝试这个程序。如果您输入了丹尼斯的姓名（包括他的中间名后面的句点：“M.”），您是否像预期的那样收到感谢消息？
- en: Warning
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It’s a common mistake to set the maximum number of characters to concatenate
    in `strncat()` to the length of the source string. Instead, you should set it
    to the maximum number of characters remaining in your destination. Your compiler
    may warn you about this mistake with a “specified bound X equals source length”
    message. (X, of course, would be the bound you specified when calling `strncat()`.)
    It’s just a warning, and you might well have exactly the length of your source
    remaining. But if you see the warning, double-check that you didn’t use the source
    length by accident.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将在`strncat()`中要连接的最大字符数设置为目标中剩余的最大字符数，而不是源字符串的长度。您的编译器可能会因此错误而发出“指定的边界X等于源长度”的警告消息。当然，X将是您在调用`strncat()`时指定的边界。这只是一个警告，你可能确实有与你的源长度完全相同的长度。但如果您看到这个警告，请再次检查，确保您没有意外使用源长度。
- en: As another example, we can revisit the notion of default values and overwriting
    arrays from [“Initializing strings”](ch04.xhtml#smallerc-CHP-4-SECT-1.2.1). You
    can delay the initialization of a character array until you know what the user
    has done. We can declare—but not initialize—a string, use it with `scanf()`, and
    then go back to the default if the user didn’t give us a good alternate value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，我们可以重新审视默认值的概念和从[“初始化字符串”](ch04.xhtml#smallerc-CHP-4-SECT-1.2.1)中覆盖数组。您可以延迟字符数组的初始化，直到您知道用户做了什么。我们可以声明但不初始化一个字符串，用`scanf()`使用它，然后如果用户没有给出良好的替代值，我们可以返回到默认值。
- en: 'Let’s try this with a question about the background color of some future, amazing
    application. We might assume a dark theme with a black background. We can prompt
    the user for a different value, or have them simply hit the Return key without
    entering a value if they want to keep the default. Here’s [*ch07/background.c*](https://oreil.ly/a89Jd):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个关于未来某个惊人应用程序背景颜色的问题。我们可能假设一个黑色背景的暗色主题。我们可以提示用户提供一个不同的值，或者如果他们想保留默认值，他们可以简单地按回车键。这里是[*ch07/background.c*](https://oreil.ly/a89Jd)：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_libraries_CO1-1)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_libraries_CO1-1)'
- en: Declare a string with enough capacity, but don’t set it to anything.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个具有足够容量的字符串，但不设置任何内容。
- en: '[![2](Images/2.png)](#co_libraries_CO1-2)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_libraries_CO1-2)'
- en: Get input from the user and store it in our array.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户处获取输入并将其存储在我们的数组中。
- en: '[![3](Images/3.png)](#co_libraries_CO1-3)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_libraries_CO1-3)'
- en: If the array is empty after prompting the user, store our default.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在提示用户后数组为空，请存储我们的默认值。
- en: '[![4](Images/4.png)](#co_libraries_CO1-4)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_libraries_CO1-4)'
- en: Show the final value, either from the user or from our default.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 展示最终值，可以是用户提供的，也可以是默认值。
- en: 'And here are some sample runs, including one where we keep the black background:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些示例运行，包括保留黑色背景的示例：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you are inviting the user to supply a value, just remember to allocate sufficient
    room in your array to contain whatever response the user might give you. If you
    can’t trust your users, `scanf()` has another trick that you can deploy. Just
    like the format specifiers in `printf()`, you can add a width to any input field
    in `scanf()`. For our previous example, say, we could change to an explicit limit
    of 19 (saving room for that final `''\0''` character):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您邀请用户提供一个值，请记住在数组中分配足够的空间以容纳用户可能提供的任何响应。如果您不能信任您的用户，`scanf()`有另一个技巧可以部署。就像在`printf()`中的格式说明符一样，您可以在`scanf()`中的任何输入字段中添加一个宽度。对于我们之前的例子，我们可以改变为显式的限制为19（为最终的`'\0'`字符节省空间）：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Easy peasy. It does look quite dense, but it’s a nice option for limited devices
    where you might not be able to allocate a lot of extra space in case of verbose
    users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。它看起来很密集，但对于可能无法为冗长用户提供大量额外空间的有限设备来说，这是一个不错的选择。
- en: math.h
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: math.h
- en: The *math.h* header declares several useful functions for performing a variety
    of arithmetic and trigonometric calculations. [Table 7-2](#smallerc-CHP-7-TABLE-math-lib)
    includes several of the more popular functions. All of these functions return
    a `double` value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*math.h*头文件声明了多个有用的函数，用于执行各种算术和三角函数计算。[表 7-2](#smallerc-CHP-7-TABLE-math-lib)
    包含了几个比较流行的函数。所有这些函数都返回`double`值。'
- en: Table 7-2\. Handy functions from *math.h*
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-2\. *math.h*中的便利函数
- en: '| Function | Description |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Trigonometric Functions |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 三角函数 |'
- en: '| `cos(double rad)` | Cosine |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `cos(double rad)` | 余弦 |'
- en: '| `sin(double rad)` | Sine |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `sin(double rad)` | 正弦 |'
- en: '| `atan(double rad)` | Arctangent |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `atan(double rad)` | 反正切 |'
- en: '| `atan2(double y, double x)` | Two-argument arctangent (angle between positive
    X axis and point (x,y)) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `atan2(double y, double x)` | 双参数反正切（正X轴与点（x，y）之间的角度） |'
- en: '| Roots and Exponents |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 根和指数 |'
- en: '| `exp(double x)` | *e*^x |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `exp(double x)` | *e*^x |'
- en: '| `log(double x)` | Natural logarithm (base *e*) of x |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `log(double x)` | x的自然对数（以 *e* 为底） |'
- en: '| `log10(double x)` | Common logarithm (base 10) of x |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `log10(double x)` | x的常用对数（以10为底） |'
- en: '| `pow(double x, double y)` | x^y |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `pow(double x, double y)` | x^y |'
- en: '| `sqrt(double x)` | Square root of x |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `sqrt(double x)` | x的平方根 |'
- en: '| Rounding |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 四舍五入 |'
- en: '| `ceil(double x)` | Ceiling function, next bigger integer from x |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `ceil(double x)` | ceiling函数，返回比x大的最小整数 |'
- en: '| `floor(double x)` | Floor function, next smaller integer from x |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `floor(double x)` | floor函数，返回比x小的最大整数 |'
- en: '| Signs |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 符号 |'
- en: '| `fabs(double x)`^([a](#idm45541405640408)) | Return the absolute value of
    x |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `fabs(double x)`^([a](#idm45541405640408)) | 返回x的绝对值 |'
- en: '| ^([a](#idm45541405640408-marker)) Oddly, the absolute value function for
    integer types, `abs()`, is declared in *stdlib.h*. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](#idm45541405640408-marker)) 奇怪的是，整数类型的绝对值函数`abs()`在*stdlib.h*中声明。 |'
- en: 'For any situation where you want an `int` or `long` answer, you just have to
    cast. For example, we could write a simple program ([*ch07/rounding.c*](https://oreil.ly/rEMTv))
    to average several integers and then round them to the nearest `int` value like
    this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了任何需要`int`或`long`答案的情况，你只需进行类型转换。例如，我们可以编写一个简单的程序（[*ch07/rounding.c*](https://oreil.ly/rEMTv)）来对多个整数求平均，并将结果四舍五入为最接近的`int`值，像这样：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we (may) need to help the compiler with this library, let’s take a look
    at the compile command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能需要帮助编译器使用这个库，让我们看一下编译命令：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, *math.h* declares functions in the C standard library, but those functions
    are not necessarily implemented in the same place as other functions. The binary
    containing most of the functions we’re discussing is *libc* (or *glibc* for GNU’s
    version). However, on many systems, the math functions live in a separate binary,
    *libm*, which requires that trailing **`-lm`** flag to make sure the compiler
    knows to link in the math library.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*math.h*声明了C标准库中的函数，但这些函数不一定实现在同一位置。包含大多数我们讨论的函数的二进制文件是*libc*（或GNU版本的*glibc*）。然而，在许多系统上，数学函数位于单独的二进制文件*libm*中，需要添加尾随的
    **`-lm`** 标志来确保编译器知道要链接数学库。
- en: 'Your system may differ. There’s no harm in trying to compile without the **`-lm`**
    option to see if your system automatically includes *libm* (or has all of the
    functions already included in *libc*). If you try compiling without the flag and
    you don’t get any errors, you’re in good shape! If you do need the library flag,
    you’ll see something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你的系统可能不同。尝试不使用 **`-lm`** 选项进行编译不会有任何损害，以查看系统是否自动包含*libm*（或已经在*libc*中包含了所有函数）。如果尝试编译而不使用该标志，并且没有收到任何错误消息，那就表示一切正常！如果确实需要该库标志，则会看到类似以下的信息：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try it yourself (with or without the library flag as needed). You should get
    85 as an answer. If rounding is something you do often, you can write your own
    function to simplify things and avoid littering your code with the slightly clunky
    business of adding the 0.5 value before calling `floor()` and casting the result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自己试试（根据需要使用或不使用库标志）。你应该得到85作为答案。如果经常需要进行四舍五入，可以编写自己的函数来简化操作，避免在代码中添加稍微繁琐的`floor()`调用和类型转换前加0.5值的麻烦事务。
- en: time.h
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: time.h
- en: 'This header gives you access to a number of utilities to help with determining
    and displaying time. It uses two types of storage for handling dates and times:
    a simple timestamp (with a type alias, `time_t`, representing the number of seconds
    since January 1, 1970, UTC) and a much more detailed structure, `struct tm`, with
    the following definition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件为你提供了一些工具，帮助确定和显示时间。它使用两种类型的存储来处理日期和时间：一个简单的时间戳（使用类型别名 `time_t`，代表自1970年1月1日以来的秒数，UTC时间）和一个更详细的结构体
    `struct tm`，其定义如下：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'I won’t be using this nifty structure with all the separated fields, but it
    can be useful if you are doing any work with dates and times, like you might find
    in a calendaring application. I will be using timestamps from, uh, time to time,
    as we’ve already seen in [“rand() and srand()”](#smallerc-CHP-7-SECT-1.2.2) for
    supplying a changing seed to the `srand()` function. [Table 7-3](#smallerc-CHP-7-TABLE-time-lib)
    shows some functions that work with these simple values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会使用这个漂亮的结构来处理所有分离的字段，但如果你正在处理日期和时间，比如在日历应用程序中可能会用到，它可能会很有用。我会不时使用时间戳，正如我们在[“rand()
    and srand()”](#smallerc-CHP-7-SECT-1.2.2) 中已经看到的，用于向 `srand()` 函数提供一个变化的种子。[表 7-3](#smallerc-CHP-7-TABLE-time-lib)
    展示了一些处理这些简单值的函数：
- en: Table 7-3\. Working with timestamps
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-3\. 时间戳处理
- en: '| Function | Description |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 描述 |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `char *ctime(time_t *t)` | Return a string of the local time |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `char *ctime(time_t *t)` | 返回本地时间的字符串 |'
- en: '| `struct tm *localtime(time_t *t)` | Expand a timestamp into the detailed
    structure |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `struct tm *localtime(time_t *t)` | 将时间戳展开为详细结构 |'
- en: '| `time_t mktime(struct tm *t)` | Reduce a structure to a timestamp |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `time_t mktime(struct tm *t)` | 将结构体转换为时间戳 |'
- en: '| `time_t time(time_t *t)` | Return the current time as a timestamp |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `time_t time(time_t *t)` | 返回当前时间作为时间戳 |'
- en: The definition of that last function, `time()`, might look a little weird. It
    both takes and returns a `time_t` pointer. You can call `time()` with either a
    `NULL` value or with a valid pointer to a variable of type `time_t`. If you use
    `NULL`, the current time is simply returned. If you supply a pointer, the current
    time is returned, but the variable pointed to is also updated with the current
    time. We only need the `NULL` option for our work with random numbers, but you’ll
    stumble on a few utility functions that use this pattern. It can be useful if
    you are working with heap memory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数 `time()` 的定义可能看起来有点奇怪。它既接受又返回一个 `time_t` 指针。你可以用 `NULL` 值或有效的 `time_t`
    类型变量的指针来调用 `time()`。如果使用 `NULL`，则简单地返回当前时间。如果提供指针，则返回当前时间，并更新指向的变量为当前时间。我们在处理随机数时只需要
    `NULL` 选项，但你会碰到一些使用这种模式的实用函数。如果你在处理堆内存时，这可能会很有用。
- en: ctype.h
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ctype.h
- en: Many situations where you process input from users require you to validate that
    the input conforms to some expected type or value. For example, a ZIP code should
    be five digits and a US state abbreviation should be two uppercase letters. The
    *ctype.h* header declares several handy functions for checking individual characters.
    It also has two helper functions that convert between upper- and lowercase. [Table 7-4](#smallerc-CHP-7-TABLE-ctype-lib)
    highlights several of these functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 许多处理用户输入的情况都要求你验证输入是否符合某种期望的类型或值。例如，邮政编码应为五位数字，美国州的缩写应为两个大写字母。*ctype.h* 头文件声明了几个检查单个字符的便利函数。它还有两个辅助函数，用于大小写转换。[表 7-4](#smallerc-CHP-7-TABLE-ctype-lib)
    强调了几个这样的函数。
- en: Table 7-4\. Working with characters using *ctype.h*
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-4\. 使用 *ctype.h* 处理字符
- en: '| Function | Description |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 描述 |'
- en: '| --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Testing |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 测试 |'
- en: '| `isalnum(int c)` | Is `c` a numeric character or a letter |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `isalnum(int c)` | 判断 `c` 是否为数字字符或字母 |'
- en: '| `isalpha(int c)` | Is `c` a letter |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `isalpha(int c)` | 判断 `c` 是否为字母 |'
- en: '| `isdigit(int c)` | Is `c` a decimal digit |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `isdigit(int c)` | 判断 `c` 是否为十进制数字 |'
- en: '| `isxdigit(int c)` | Is `c` a hexadecimal digit (case-insensitive) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `isxdigit(int c)` | 判断 `c` 是否为十六进制数字（不区分大小写） |'
- en: '| `islower(int c)` | Is `c` a lowercase letter |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `islower(int c)` | 判断 `c` 是否为小写字母 |'
- en: '| `isupper(int c)` | Is `c` an uppercase letter |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `isupper(int c)` | 判断 `c` 是否为大写字母 |'
- en: '| `isspace(int c)` | Is `c` a space, tab, newline, carriage return, vertical
    tab, or form feed |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `isspace(int c)` | 判断 `c` 是否为空格、制表符、换行符、回车符、垂直制表符或换页符 |'
- en: '| Conversion |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 转换 |'
- en: '| `tolower(int c)` | Return the lowercase version of `c` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `tolower(int c)` | 返回 `c` 的小写版本 |'
- en: '| `toupper(int c)` | Return the uppercase version of `c` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `toupper(int c)` | 返回 `c` 的大写版本 |'
- en: 'Don’t forget your Boolean operators! You can easily expand these tests to ask
    questions like “is not whitespace” with the `!` operator:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记你的布尔运算符！你可以轻松地扩展这些测试来询问诸如“不是空格”的问题，使用`!`运算符：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As with the math functions and getting a `double` result where you need an `int`,
    the conversion functions in *ctype.h* return an `int`, but you can easily cast
    it to a `char` as needed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与需要`int`的地方获取`double`结果的数学函数一样，`ctype.h`中的转换函数返回`int`，但你可以根据需要轻松地将其强制转换为`char`。
- en: Putting It Together
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装
- en: 'Let’s pull in a few of these new headers and use some of the topics from previous
    chapters to make a more rounded example. We’ll create a structure to store information
    on a simple bank account. We can use the new *string.h* utilities to add a name
    field to each account. And we’ll use the *math.h* functions to calculate a sample
    compound interest payment on the balance of the account. Here are the includes
    this example will require:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一些新的头文件，并使用前几章的一些主题来制作一个更加完整的示例。我们将创建一个结构来存储一个简单银行账户的信息。我们可以使用新的`string.h`工具向每个账户添加一个名字字段。而且我们将使用`math.h`函数来计算账户余额上的一个样本复利支付。这个示例将需要以下的包含文件：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With our headers ready, let’s dive in and get the program itself going.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好我们的头文件后，让我们深入进入并启动程序本身。
- en: Filling In Strings
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充字符串
- en: 'Let’s start our example by creating our account type including a string “name”
    field. The new `struct` is simple enough:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建包含一个字符串“name”字段的账户类型来开始我们的示例。新的`struct`非常简单：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now use our string functions to load up `name` with actual content after
    our structure is created. We can also use `malloc()` to create that structure
    in a function and return the address of our account. Here’s the new function,
    with some of the safety checks omitted just for readability:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的字符串函数在创建结构之后用实际内容填充`name`。我们还可以使用`malloc()`在函数中创建该结构并返回我们账户的地址。以下是新函数，为了可读性省略了一些安全检查：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice I chose to use `strncpy()` here. The idea is that I cannot guarantee
    the incoming `name` parameter will fit. Since I wrote the entire program, of course,
    I certainly can guarantee that detail, but that’s not the point. I want to make
    sure if I ever allow user input, say, by prompting the user for details, my `create()`
    function has some safeguards in place.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我选择在这里使用`strncpy()`。我的想法是我不能保证传入的`name`参数能够适应。当然，由于我写了整个程序，我当然能保证这个细节，但这不是重点。我想要确保如果我允许用户输入，比如通过提示用户输入详细信息，我的`create()`函数有一些安全措施。
- en: 'Let’s go ahead and create a function to print our account details. Hopefully,
    this code looks familiar from our work in [Chapter 6](ch06.xhtml#smallerc-CHP-6).
    We can also start our `main()` function to try out everything we’ve written so
    far:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个函数来打印我们的账户详细信息。希望这段代码看起来从我们在[第六章](ch06.xhtml#smallerc-CHP-6)的工作中很熟悉。我们还可以开始我们的`main()`函数来尝试我们到目前为止编写的一切：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s compile and run [*ch07/account1.c*](https://oreil.ly/i8vvr). Here’s our
    output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行[*ch07/account1.c*](https://oreil.ly/i8vvr)。这是我们的输出：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Hooray! So far, so good. Next up is figuring out an interest payment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 好极了！到目前为止，一切顺利。接下来是计算利息支付的问题。
- en: Finding Our Interest
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到我们的利息
- en: 'Using the `pow()` function from the *math.h* library, we can calculate a monthly
    compounded interest in one expression. I know I was taught this formula in high
    school, but I still have to look it up online any time I actually need to use
    it. Then we’ll update `main()` to add a year’s worth of interest (at 5%) to our
    account and print out the details again. Here are the new parts from [*ch07/account2.c*](https://oreil.ly/EAOwS):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`math.h`库中的`pow()`函数，我们可以在一个表达式中计算每月复利。我知道这个公式是在高中教的，但每次真正需要用到时，我还是得上网查一下。然后我们将更新`main()`以添加一年（5%利率）的利息到我们的账户，并再次打印出详细信息。以下是来自[*ch07/account2.c*](https://oreil.ly/EAOwS)的新部分：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That’s looking pretty good! Let’s compile and run *account2.c*. If your system
    needs the **`-lm`** math library flag, be sure to add it when you compile:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来非常不错！让我们编译并运行*account2.c*。如果你的系统在编译时需要**`-lm`**数学库标志，请确保在编译时添加它：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Everything worked! Although you are reading the final output from my code *after*
    I fixed the various little mistakes I made while writing it. I reversed the order
    of the source and destination strings in `strncpy()`, for example. It’s rare to
    get everything right the first time. The compiler will usually let you know what
    you got wrong. You just head back to your editor and fix it. Getting comfortable
    with mistakes—and with fixing them!—is one of the reasons I encourage you to type
    in some of these examples. Nothing like actually writing code to get better at
    writing code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都运行正常！尽管你现在是在我修复了写作过程中的各种小错误之后阅读最终输出的代码。例如，我在`strncpy()`中颠倒了源和目标字符串的顺序。第一次就把所有事情做对是很罕见的。编译器通常会告诉你哪里出错了。你只需回到编辑器中修复它。熟悉错误——以及修复它们！——是我鼓励你输入这些示例的原因之一。实际编写代码是提高编程能力的最佳方法之一。
- en: Finding New Libraries
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找新的库
- en: There are many more libraries out there for your consumption than I can possibly
    cover here. Indeed, there are more functions just in the C standard library; you
    can dig much deeper with the [GNU C Library](https://oreil.ly/58fLM) documentation
    online.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有比我在此提及的更多可供使用的库。事实上，在C标准库中，就有更多的函数；你可以通过在线查阅[GNU C库](https://oreil.ly/58fLM)的文档深入挖掘。
- en: Beyond the standard library, though, there are other libraries that can help
    with your projects. For those situations where you want a specialized library,
    your best bet these days is to search online. If you want to interact directly
    with a USB-connected device, for example, you could search for “C USB library”
    and wind up with the nifty *libusb* from [*https://libusb.info*](https://libusb.info).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准库之外，还有其他库可以帮助你的项目。对于那些需要专门库的情况，你最好的选择是在线搜索。例如，如果你想直接与USB连接的设备交互，可以搜索“C USB库”，最终可能找到很棒的*libusb*，它来自[*https://libusb.info*](https://libusb.info)。
- en: You can also find some lists of popular libraries, but those lists vary in quality
    and upkeep. Sadly, there is no central repository for “all things C” like one
    has with some languages. My advice is to look over the search results for links
    to reputable sites like [GitHub](https://github.com) or [gnu.org](https://gnu.org).
    And don’t be afraid to just read through the source code of the library. If anything
    you see raises a flag, pay attention. Most times you’ll be getting exactly what
    you expected, but a little caution is always advisable when using things you find
    online.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以找到一些流行库的列表，但这些列表的质量和维护情况各不相同。遗憾的是，没有像某些语言那样的“所有C语言事物”的中央存储库。我的建议是浏览搜索结果，寻找指向像[GitHub](https://github.com)或[gnu.org](https://gnu.org)这样的信誉网站的链接。并且不要害怕仅仅阅读库的源代码。如果你看到任何引起注意的地方，要多加关注。大多数情况下，你将得到你所期望的结果，但在使用在线资源时，始终保持一点谨慎是明智的。
- en: Next Steps
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Helping you get better at writing code is certainly one of the goals for this
    book. We’ve covered a number of the more common and popular libraries (and the
    header files that we must include to make use of their functions) in this chapter.
    There are certainly more libraries out there! Hopefully, you see how libraries
    and headers interact with your own code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助你提升编写代码能力当然是本书的目标之一。我们在本章节中涵盖了一些更常见和流行的库（以及我们必须包含的头文件，以便使用它们的函数）。当然还有更多的库在那里等着你！希望你能看到库和头文件如何与你自己的代码互动。
- en: We’ll be tackling microcontrollers next, and we’ll start looking at writing
    *tighter* code along the way. Good code isn’t necessarily a prerequisite for doing
    optimization work, but it sure helps. Feel free to review some of the examples
    from past chapters before forging ahead. Try making some changes. Try breaking
    things. Try fixing the things you broke. Every successful compile should count
    as a notch in your programmer belt.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将处理微控制器，并且在此过程中开始着眼于编写*更紧凑*的代码。良好的代码并不一定是进行优化工作的前提条件，但它确实有帮助。在继续前进之前，可以回顾一些过去章节的例子。试着做出一些改变。试着破坏一些东西。试着修复你破坏的东西。每一次成功的编译都应该成为你程序员生涯中的一个里程碑。
- en: ^([1](ch07.xhtml#idm45018721966312-marker)) That algorithm is deterministic
    and while that’s fine for most developers, it is not truly random.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.xhtml#idm45018721966312-marker)) 该算法是确定性的，虽然对大多数开发者来说这没问题，但它并非真正的随机。
- en: ^([2](ch07.xhtml#idm45018721851352-marker)) I don’t have space to cover good
    generators, but searching online for “C random generator” will net you some interesting
    options. There are better algorithms such as Blum Blum Shub or a Mersenne Twister,
    but you can also find hardware-dependent generators that are better still.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.xhtml#idm45018721851352-marker)) 我没有足够的空间来介绍好的生成器，但是在网上搜索“C随机生成器”将为您带来一些有趣的选项。有更好的算法，比如Blum
    Blum Shub或者Mersenne Twister，但您也可以找到硬件相关的生成器，它们可能更好。
