<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Smaller Systems"><div class="chapter" id="smallerc-CHP-9">
<h1><span class="label">Chapter 9. </span>Smaller Systems</h1>


<p>Now that we have the Arduino IDE ready to go, we can embark on the physically
satisfying world of writing C code to control things! LED things. Sensor things.
Button things. So many things! We’ll also dip our toes into the Internet of Things (IoT)
in <a data-type="xref" href="ch12.xhtml#smallerc-CHP-12-SECT-1.1">“IoT and Arduino”</a>.</p>

<p>In this chapter, I’ll touch on several Arduino peculiarities (most of them helpful,
some of them frustrating) while building some
small but complete projects that you can try yourself. <a data-type="xref" href="app01.xhtml#smallerc-APP-A-SECT-2">“Getting the Hardware: Adafruit”</a> contains
links for all the various components and microcontrollers I use in case you want to
replicate any of the projects exactly.</p>






<section data-type="sect1" data-pdf-bookmark="The Arduino Environment"><div class="sect1" id="smallerC-CHP-9-SECT-1">
<h1>The Arduino Environment</h1>

<p>I’m sure<a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="purpose of" id="ardIDE-language"/> you noticed that we did not write “complete” C programs
in <a data-type="xref" href="ch08.xhtml#smallerc-CHP-8">Chapter 8</a>. We had no <code>main()</code> function, and for the earlier examples, we
didn’t even import the usual header files. Yet we clearly had access to new
functions and things like the <code>HIGH</code> and <code>LOW</code> values we used to blink our first LED.</p>

<p>Where did those extras come from? It can feel at times like
the IDE is providing a bit of magic. It’s not, of course, but it is doing a lot
of work behind the scenes in the hopes of making you more productive. I want to point
out some of that hidden work so that you have a better understanding of the distinction
between C itself and the supporting elements provided by the Arduino IDE. Inevitably,
you’ll head to the web to search for examples of new topics as you build more
of your own projects. Knowing the difference between the language and the tools can make
those searches more fruitful.</p>

<p class="pagebreak-before less_space">The Arduino IDE quietly includes several headers for you to make up what can loosely
be called the “Arduino language.” It’s not a distinct language like Python, but it
certainly feels like something more than just the C-with-headers-and-libraries we’ve seen
so far. The Arduino language is more a collection of useful pieces (values and functions)
that make programming microcontrollers easier. I’ll be showing you several of the
more immediately beneficial parts, but you can get the complete list online. The
<a href="https://oreil.ly/wlwhf">Language Reference</a> at the Arduino site contains
a simple index of included features as well as links to details <a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="purpose of" data-startref="ardIDE-language" id="idm45018719077560"/>and examples.</p>








<section data-type="sect2" data-pdf-bookmark="Special Values"><div class="sect2" id="smallerC-CHP-9-SECT-1.1">
<h2>Special Values</h2>

<p>We <a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="constants" id="ardIDE-language-constants"/><a data-type="indexterm" data-primary="constants" id="constants"/><a data-type="indexterm" data-primary="symbolic constants" data-see="constants" id="idm45018719043592"/>relied on some of these “language” extensions just to make our first
LED blink. Let’s revisit that code but with more discussion of the named
values (the Arduino Language Reference calls these <em>constants</em>)
that are specific to the Arduino 
<span class="keep-together">environment</span>.<sup><a data-type="noteref" id="idm45018719041400-marker" href="ch09.xhtml#idm45018719041400">1</a></sup></p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">void</code><code> </code><code class="nf">setup</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>  </code><code class="c1">// put your setup code here, to run once:
</code><code>  </code><code class="c1">// Tell our board we want to write to the built-in LED
</code><code>  </code><code class="n">pinMode</code><code class="p">(</code><code class="n">LED_BUILTIN</code><code class="p">,</code><code> </code><code class="n">OUTPUT</code><code class="p">)</code><code class="p">;</code><code>          </code><a class="co" id="co_smaller_systems_CO1-1" href="#callout_smaller_systems_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code> </code><a class="co" id="co_smaller_systems_CO1-2" href="#callout_smaller_systems_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code class="p">}</code><code>
</code><code>
</code><code class="kt">void</code><code> </code><code class="nf">loop</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>  </code><code class="c1">// put your main code here, to run repeatedly:
</code><code>  </code><code class="c1">// A high value is 'on' for an LED
</code><code>  </code><code class="n">digitalWrite</code><code class="p">(</code><code class="n">LED_BUILTIN</code><code class="p">,</code><code> </code><code class="n">HIGH</code><code class="p">)</code><code class="p">;</code><code>       </code><a class="co" id="co_smaller_systems_CO1-3" href="#callout_smaller_systems_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code class="c1">// Now wait for 500 milliseconds
</code><code>  </code><code class="n">delay</code><code class="p">(</code><code class="mi">500</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="c1">// And write a low value to turn our LED off
</code><code>  </code><code class="n">digitalWrite</code><code class="p">(</code><code class="n">LED_BUILTIN</code><code class="p">,</code><code> </code><code class="n">LOW</code><code class="p">)</code><code class="p">;</code><code>        </code><a class="co" id="co_smaller_systems_CO1-4" href="#callout_smaller_systems_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
  </code><code class="c1">// and wait another 500ms
</code><code>  </code><code class="n">delay</code><code class="p">(</code><code class="mi">500</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_smaller_systems_CO1-1" href="#co_smaller_systems_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The <code>LED_BUILTIN</code> constant represents the number of the pin connected to
the LED found on most development boards. It won’t always be the same number for
every controller, but the IDE grabs the correct value based on the board you select.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO1-2" href="#co_smaller_systems_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p><code>OUTPUT</code> is the value we use to indicate we will send information to something
like an LED or a motor. We’ll see analogous <code>INPUT</code> and <code>INPUT_PULLUP</code> constants
when we tackle sensors and buttons.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO1-3" href="#co_smaller_systems_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p><code>HIGH</code> is a reference to the increased voltage used to “switch on”
the device attached to the pin. What “on” means depends on said device. It’s
pretty self-explanatory for an LED. :)</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO1-4" href="#co_smaller_systems_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>And <code>LOW</code> is the decreased voltage counterpart to <code>HIGH</code>, turning the LED off.</p></dd>
</dl>

<p>These named values are not variables. They are<a data-type="indexterm" data-primary="preprocessor macros" id="idm45018718923080"/> technically <em>preprocessor macros</em>.
The preprocessor is a step your code goes through before it
is compiled.<sup><a data-type="noteref" id="idm45018718922072-marker" href="ch09.xhtml#idm45018718922072">2</a></sup> You create these entities with the <code>
define</code> directive.
(The <code/> prefix might look familiar from <code>#include</code>,
and it should. Both “commands” are handled by the preprocessor.) We’ll
go into more depth on this directive in <a data-type="xref" href="ch11.xhtml#smallerc-CHP-11-SECT-1.1">“Preprocessor Directives”</a>, but its syntax is <span class="keep-together">simple:</span></p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#define LED_BUILTIN 13</code>
<code class="cp">#define HIGH 1</code>
<code class="cp">#define LOW  0</code></pre>

<p>The C preprocessor simply catches every instance of the macro’s name in your code
and replaces that name with the defined value. If we had a new controller with fewer pins,
for example, we could change our <code>#define</code> to, say, <code>8</code>. Then we wouldn’t have to
change any of the other parts of our program where we turn the onboard LED on <span class="keep-together">or off.</span></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="smallerc-CHP-9-SIDEBAR-const-define">
<h5>Constants: const versus #define</h5>
<p>In <a data-type="indexterm" data-primary="constants" data-secondary="const versus #define" id="idm45018718915272"/><a data-type="indexterm" data-primary="const keyword, #define versus" id="idm45018718913352"/><a data-type="indexterm" data-primary="#define directive" data-secondary="const keyword versus" data-primary-sortas="define directive" id="idm45018718912776"/><a data-type="indexterm" data-primary="literals" data-secondary="constants versus" id="idm45018718911560"/>computer programming, a <em>constant</em> is a variable or other reference to a value that
does not change at runtime. (That is different from a <em>literal</em> like the numbers and
strings discussed in <a data-type="xref" href="ch02.xhtml#smallerc-CHP-2-SECT-2.5.1">“Literals”</a>.) Using this generic definition,
it’s reasonable to refer to the <code>#define</code> entries we’ve seen as constants.</p>

<p>In C, we can also use the <code>const</code> keyword
to create a regular variable (of any type) and assign it some value. Once that value
is assigned, the compiler will make sure we never try to assign a new value. Such a
declaration would go like this:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">const</code> <code class="kt">double</code> <code class="n">lo_res_pi</code> <code class="o">=</code> <code class="mf">3.14</code><code class="p">;</code></pre>

<p>For a lot of the work we’ll do with Arduino, which approach you choose
won’t really matter. In many cases, the compiler will analyze how your
<code>const</code> variable is used and substitute the actual value as an optimization,
just as if you had used <code>#define</code>. But sometimes it is useful to have a
known, explicit type. In those situations, <code>const</code> is often the easiest
approach.</p>
</div></aside>

<p>And to be clear, <code>#define</code> <em>is</em> part of C (via the preprocessor). You can use it in
your own code whether you are writing for a microcontroller or for a desktop.
It’s the specific constants like <code>OUTPUT</code> that are part of the Arduino setup.
<a data-type="xref" href="#smallerc-CHP-9-TAB-arduino-constants">Table 9-1</a> shows some of the constants we’ll be
using in our<a data-type="indexterm" data-primary="constants" data-secondary="list of" id="idm45018718872088"/><a data-type="indexterm" data-primary="LED_BUILTIN constant" id="idm45018718871144"/><a data-type="indexterm" data-primary="INPUT constant" id="idm45018718870472"/><a data-type="indexterm" data-primary="INPUT_PULLUP constant" id="idm45018718869800"/><a data-type="indexterm" data-primary="OUTPUT constant" id="idm45018718867368"/><a data-type="indexterm" data-primary="HIGH constant" id="idm45018718866696"/><a data-type="indexterm" data-primary="LOW constant" id="idm45018718866024"/> projects.</p>
<table id="smallerc-CHP-9-TAB-arduino-constants">
<caption><span class="label">Table 9-1. </span>Useful constants defined for Arduino</caption>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>LED_BUILTIN</code></p></td>
<td><p>If the selected board has a built-in LED, this represents the pin number for that LED</p></td>
</tr>
<tr>
<td><p><code>INPUT</code></p></td>
<td><p>For pins that can perform both input and output, expect input</p></td>
</tr>
<tr>
<td><p><code>INPUT_PULLUP</code></p></td>
<td><p>Similar to INPUT, but use an internal pull-up resistor to report <code>HIGH</code> on something like an unpressed push button, and <code>LOW</code> while it is pressed</p></td>
</tr>
<tr>
<td><p><code>OUTPUT</code></p></td>
<td><p>For pins that can perform both input and output, expect output</p></td>
</tr>
<tr>
<td><p><code>HIGH</code></p></td>
<td><p>Friendly name for 1, meant for use with digital reading and writing</p></td>
</tr>
<tr>
<td><p><code>LOW</code></p></td>
<td><p>Friendly name for 0, meant for use with digital reading and writing</p></td>
</tr>
</tbody>
</table>

<p>You can get more details on these constants on the <a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="constants" data-startref="ardIDE-language-constants" id="idm45018718834136"/><a data-type="indexterm" data-primary="constants" data-startref="constants" id="idm45018718832808"/>official
<a href="https://oreil.ly/pS11s">Arduino Reference</a> page.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Special Types"><div class="sect2" id="smallerC-CHP-9-SECT-1.2">
<h2>Special Types</h2>

<p>Beyond<a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="types" id="ardIDE-language-types"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="in Arduino language" data-secondary-sortas="Arduino language" id="types-arduino"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="in Arduino language" data-tertiary-sortas="Arduino language" id="variables-types-arduino"/> those constants, the headers that are loaded for your Arduino sketches also include a
number of other data types that I want to highlight, as you might find them useful. These aren’t
really new types and aren’t even restricted to use in Arduino, but again, your sketches
have access<a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="bool" id="idm45018718824520"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="byte" id="idm45018718823336"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="size_t" id="idm45018718822120"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="String" id="idm45018718820904"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="int8_t" data-tertiary-sortas="int08_t" id="idm45018718819688"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="int16_t" id="idm45018718818200"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="int32_t" id="idm45018718816984"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="uint8_t" data-tertiary-sortas="uint08_t" id="idm45018718815768"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="uint16_t" id="idm45018718814280"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="uint32_t" id="idm45018718813064"/> to these and you will likely <a data-type="indexterm" data-primary="types (variables)" data-secondary="bool" id="idm45018718811720"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="byte" id="idm45018718810776"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="size_t" id="idm45018718809832"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="String" id="idm45018718808888"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="int8_t" data-secondary-sortas="int08_t" id="idm45018718807944"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="int16_t" id="idm45018718806728"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="int32_t" id="idm45018718805784"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="uint8_t" data-secondary-sortas="uint08_t" id="idm45018718804840"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="uint16_t" id="idm45018718803624"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="uint32_t" id="idm45018718802680"/>see them used in examples you find online.</p>

<p><a data-type="xref" href="#smallerc-CHP-9-TAB-arduino-typedefs">Table 9-2</a> lists several of these types with their sizes
and a brief <a data-type="indexterm" data-primary="bool (variable type)" id="idm45018718800536"/><a data-type="indexterm" data-primary="byte (variable type)" id="idm45018718799864"/><a data-type="indexterm" data-primary="size_t (variable type)" id="idm45018718799192"/><a data-type="indexterm" data-primary="String (variable type)" id="idm45018718798520"/><a data-type="indexterm" data-primary="int8_t (variable type)" data-primary-sortas="int08_t (variable type)" id="idm45018718797848"/><a data-type="indexterm" data-primary="int16_t (variable type)" id="idm45018718796904"/><a data-type="indexterm" data-primary="int32_t (variable type)" id="idm45018718796232"/><a data-type="indexterm" data-primary="uint8_t (variable type)" data-primary-sortas="uint08_t (variable type)" id="idm45018718795560"/><a data-type="indexterm" data-primary="uint16_t (variable type)" id="idm45018718794600"/><a data-type="indexterm" data-primary="uint32_t (variable type)" id="idm45018718793912"/>description.</p>
<table id="smallerc-CHP-9-TAB-arduino-typedefs">
<caption><span class="label">Table 9-2. </span>Useful constants defined for Arduino</caption>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>bool</code></p></td>
<td><p>Boolean type; <code>bool</code> variables can be assigned either <code>true</code> or <code>false</code></p></td>
</tr>
<tr>
<td><p><code>byte</code></p></td>
<td><p>Unsigned 8-bit integer type</p></td>
</tr>
<tr>
<td><p><code>size_t</code></p></td>
<td><p>Integer type corresponding to maximum size (in bytes) of an object on the selected board. The value you get from <code>sizeof</code>, for example, is of type <code>size_t</code>.</p></td>
</tr>
<tr>
<td><p><code>String</code></p></td>
<td><p>An object-oriented way of handling strings (note the capital “S” in the type) with several convenience functions available</p></td>
</tr>
<tr>
<td><p><span class="keep-together"><code>int8_t</code>, <code>int16_t</code>,</span> <code>int32_t</code></p></td>
<td><p>Signed integer types with explicit sizes (8, 16, and 32 bits, respectively)</p></td>
</tr>
<tr>
<td><p><span class="keep-together"><code>uint8_t</code>, <code>uint16_t</code>,</span> <code>uint32_t</code></p></td>
<td><p>Unsigned integer types with explicit sizes (8, 16, and 32 bits, respectively)</p></td>
</tr>
</tbody>
</table>

<p>With the exception of <code>String</code>, these types are<a data-type="indexterm" data-primary="aliases" id="idm45018718773000"/><a data-type="indexterm" data-primary="typedef operator" id="idm45018718772264"/> actually <em>aliases</em> of other
types. This is done with C’s <code>typedef</code> and is fairly straightforward.
For example, the <code>byte</code> type is an alias for <code>unsigned char</code> and can be
defined like this:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">typedef</code> <code class="kt">unsigned</code> <code class="kt">char</code> <code class="n">byte</code><code class="p">;</code></pre>

<p>We’ll do more work with <code>typedef</code> in <a data-type="xref" href="ch11.xhtml#smallerc-CHP-11-SECT-1.2">“Preprocessor Macros”</a>, but several
of the types are pretty handy. I use <code>byte</code> in particular in many of my own
projects as it makes more sense (and takes fewer keystrokes) than <code>unsigned char</code>,
but that’s just a personal preference. Either type defines an 8-bit slot
capable of storing values <a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="types" data-startref="ardIDE-language-types" id="idm45018718765928"/><a data-type="indexterm" data-primary="types (variables)" data-secondary="in Arduino language" data-secondary-sortas="Arduino language" data-startref="types-arduino" id="idm45018718764440"/><a data-type="indexterm" data-primary="variables" data-secondary="types" data-tertiary="in Arduino language" data-tertiary-sortas="Arduino language" data-startref="variables-types-arduino" id="idm45018718762072"/>from 0–255.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="“Built-In” Functions"><div class="sect2" id="smallerC-CHP-9-SECT-1.3">
<h2>“Built-In” Functions</h2>

<p>The <a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="functions" id="ardIDE-language-functions"/><a data-type="indexterm" data-primary="functions" data-secondary="Arduino built-in functions" id="functions-arduino"/>Arduino environment includes several headers that make some popular functions
available to you. You can make use of the functions<a data-type="indexterm" data-primary="pinMode() function" id="idm45018718751752"/><a data-type="indexterm" data-primary="digitalRead() function" id="idm45018718751080"/><a data-type="indexterm" data-primary="digitalWrite() function" id="idm45018718750408"/><a data-type="indexterm" data-primary="analogRead() function" id="idm45018718749736"/><a data-type="indexterm" data-primary="analogWrite() function" id="idm45018718749064"/><a data-type="indexterm" data-primary="delay() function" id="idm45018718748392"/><a data-type="indexterm" data-primary="delayMicroseconds() function" id="idm45018718747720"/><a data-type="indexterm" data-primary="micros() function" id="idm45018718747032"/><a data-type="indexterm" data-primary="millis() function" id="idm45018718746360"/><a data-type="indexterm" data-primary="abs() function" id="idm45018718745688"/><a data-type="indexterm" data-primary="constrain() function" id="idm45018718745016"/><a data-type="indexterm" data-primary="map() function" id="idm45018718744344"/><a data-type="indexterm" data-primary="max() function" id="idm45018718723208"/><a data-type="indexterm" data-primary="min() function" id="idm45018718722536"/><a data-type="indexterm" data-primary="pow() function" id="idm45018718721864"/><a data-type="indexterm" data-primary="sq() function" id="idm45018718721192"/><a data-type="indexterm" data-primary="sqrt() function" id="idm45018718720520"/> shown in <a data-type="xref" href="#smallerc-CHP-9-TAB-built-in-functions">Table 9-3</a>
without any explicit <code>#include</code> in your sketch.</p>
<table id="smallerc-CHP-9-TAB-built-in-functions">
<caption><span class="label">Table 9-3. </span>Functions available in Arduino</caption>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2"><p><em>Input/Output</em></p></td>
</tr>
<tr>
<td><p><code>void pinMode(pin, mode)</code></p></td>
<td><p>Set the specified pin to input or output mode</p></td>
</tr>
<tr>
<td><p><code>int digitalRead(pin)</code></p></td>
<td><p>Return value will be HIGH or LOW</p></td>
</tr>
<tr>
<td><p><code>void digitalWrite(pin, value)</code></p></td>
<td><p>Value should be HIGH or LOW</p></td>
</tr>
<tr>
<td><p><code>int analogRead(pin)</code></p></td>
<td><p>Returns 0–1023 (some boards offer 0–4095)</p></td>
</tr>
<tr>
<td><p><code>void analogWrite(pin, value)</code></p></td>
<td><p>Value is 0–255, must use PWM-capable pin</p></td>
</tr>
<tr>
<td colspan="2"><p><em>Time</em></p></td>
</tr>
<tr>
<td><p><code>void delay(ms)</code></p></td>
<td><p>Pause execution for specified number of milliseconds</p></td>
</tr>
<tr>
<td><p><code>void delayMicroseconds(micros)</code></p></td>
<td><p>Pause execution for specified number of microseconds</p></td>
</tr>
<tr>
<td><p><code>unsigned long micros()</code></p></td>
<td><p>Returns number of microseconds since program started</p></td>
</tr>
<tr>
<td><p><code>unsigned long millis()</code></p></td>
<td><p>Returns number of milliseconds since program started</p></td>
</tr>
<tr>
<td colspan="2"><p><em>Math (Unlisted return types depend on the type of the arguments)</em></p></td>
</tr>
<tr>
<td><p><code>abs(x)</code></p></td>
<td><p>Returns absolute value of x (int or float)</p></td>
</tr>
<tr>
<td><p><code>constrain(x, min, max)</code></p></td>
<td><p>Returns x, but bounded by min and max</p></td>
</tr>
<tr>
<td><p><code>map(x, fromLow, fromHigh, toLow, toHigh)</code></p></td>
<td><p>Returns x converted from “from” range to “to” range</p></td>
</tr>
<tr>
<td><p><code>max(x, y)</code></p></td>
<td><p>Returns the larger of x or y</p></td>
</tr>
<tr>
<td><p><code>min(x, y)</code></p></td>
<td><p>Returns the smaller of x or y</p></td>
</tr>
<tr>
<td><p><code>double pow(base, exp)</code></p></td>
<td><p>Returns base raised to the exp power</p></td>
</tr>
<tr>
<td><p><code>double sq(x)</code></p></td>
<td><p>Returns the square of x</p></td>
</tr>
<tr>
<td><p><code>double sqrt(x)</code></p></td>
<td><p>Returns the square root of x</p></td>
</tr>
<tr>
<td><p><code>double cos(rad)</code></p></td>
<td><p>Returns the cosine of the angle given in radians</p></td>
</tr>
<tr>
<td><p><code>double sin(rad)</code></p></td>
<td><p>Returns the sine of the angle given in radians</p></td>
</tr>
<tr>
<td><p><code>double tan(rad)</code></p></td>
<td><p>Returns the tangent of the angle given in radians</p></td>
</tr>
<tr>
<td colspan="2"><p><em>Random Numbers</em></p></td>
</tr>
<tr>
<td><p><code>void randomSeed(seed)</code></p></td>
<td><p>Initializes the generator; seed is an unsigned long</p></td>
</tr>
<tr>
<td><p><code>long random(max)</code></p></td>
<td><p>Returns a random long between 0 and max - 1</p></td>
</tr>
<tr>
<td><p><code>long random(min, max)</code></p></td>
<td><p>Returns a random long between min and max - 1</p></td>
</tr>
</tbody>
</table>

<p>The many<a data-type="indexterm" data-primary="cos() function" id="idm45018718714488"/><a data-type="indexterm" data-primary="sin() function" id="idm45018718668008"/><a data-type="indexterm" data-primary="tan() function" id="idm45018718667336"/><a data-type="indexterm" data-primary="randomSeed() function" id="idm45018718666664"/><a data-type="indexterm" data-primary="random() function" id="idm45018718665992"/><a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="functions" data-startref="ardIDE-language-functions" id="idm45018718665320"/><a data-type="indexterm" data-primary="functions" data-secondary="Arduino built-in functions" data-startref="functions-arduino" id="idm45018718663752"/> character tests from <em>ctype.h</em> such as <code>isdigit()</code> or <code>isupper()</code>
are also available automatically.<sup><a data-type="noteref" id="idm45018718661080-marker" href="ch09.xhtml#idm45018718661080">3</a></sup>
See <a data-type="xref" href="ch07.xhtml#smallerc-CHP-7-TABLE-ctype-lib">Table 7-4</a> for the full list.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Trying Out the Arduino “Stuff”"><div class="sect2" id="smallerC-CHP-9-SECT-1.4">
<h2>Trying Out the Arduino “Stuff”</h2>

<p>Let’s <a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="LED light example" id="ardIDE-language-led"/><a data-type="indexterm" data-primary="LED lights" data-secondary="Arduino language elements" id="LED-arduino-lang"/>put all of these new ideas into a project and see just how they work
(and work together). To do this, we’ll create a more interesting LED sketch. We’ll
make the LED “breathe” using the <code>analogWrite()</code> function and a little math.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The LED in question is not actually an analog device. It still has just the on and
off states. But many output devices like LEDs can simulate “degrees” of
on with a <a data-type="indexterm" data-primary="Pulse Width Modulation (PWM)" id="idm45018718651864"/><a data-type="indexterm" data-primary="pins" data-secondary="Pulse Width Modulation (PWM)" id="idm45018718651096"/>technique known as <em>Pulse Width Modulation</em> or PWM. The idea is that you
can turn the LED on and off rapidly in such a way that it appears dimmer. (Or working
with something like a motor, it might seem to turn slower.)</p>

<p>It’s important to note that not all pins on all controllers can do PWM output.
You need to check the datasheet or pinout diagram
for your controller.<sup><a data-type="noteref" id="idm45018718648824-marker" href="ch09.xhtml#idm45018718648824">4</a></sup> On the
Metro Mini I’ve been using in the projects so far, for example, only pins
3, 5, 6, 9, 10, and 11 support PWM.</p>
</div>

<p>We’ll use a different RGB LED this time. It has four pins: one ground, and one
each for the red, green, and blue channels. Each color will need its own connection
to the controller, so we’ll define some constants for those pins. We’ll
also define a few values for the breathing rate and our maximum number of radians,
(2 * π). <a data-type="xref" href="#smallerc-CHP-9-FIG-breathing-led-wiring">Figure 9-1</a> shows the wiring I used in this example. Remember that
using <code>analogWrite()</code> requires 
<span class="keep-together">paying</span> attention to which pins you connect. (I won’t
bother with a picture for this project; the fun is in running it yourself to see
the change in brightness!)</p>

<figure><div id="smallerc-CHP-9-FIG-breathing-led-wiring" class="figure">
<img src="Images/smac_0901.png" alt="smac 0901" width="889" height="699"/>
<h6><span class="label">Figure 9-1. </span>Wiring diagram for our breathing LED example</h6>
</div></figure>

<p>And now we can get to coding! As always, I encourage you to start a new sketch and
type this in yourself, but you can also just pop open <em>breathe.ino</em> and follow along.</p>

<p>For our <code>setup()</code>, we’ll get our color pin modes set to <code>OUTPUT</code> and pick a
random color for the LED. We’ll show that color on the LED for a few seconds
before starting the animation.</p>

<p>Our <code>loop()</code> function will drive the animation. We can use the <code>millis()</code> function to get an ever-increasing number. We’ll use our breathing rate and our max radians value to turn those milliseconds into radians. With the radians in hand, we’ll use the <code>sin()</code> function to get a nice fractional brightness that grows and fades. Finally, we’ll apply that brightness to the LED and pause a few milliseconds before animating the next step. Here’s the complete listing of <a href="https://oreil.ly/FHdP8"><em>ch09/breathe/breathe.ino</em></a>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="c1">// Output pins, have to make sure they support PWM</code>
<code class="cp">#define RED    5</code>
<code class="cp">#define GREEN  6</code>
<code class="cp">#define BLUE   9</code>

<code class="c1">// Some helper values</code>
<code class="cp">#define RATE 5000</code>
<code class="cp">#define PI_2 6.283185</code>

<code class="c1">// Color channel values for our LED</code>
<code class="n">byte</code> <code class="n">red</code><code class="p">;</code>
<code class="n">byte</code> <code class="n">green</code><code class="p">;</code>
<code class="n">byte</code> <code class="n">blue</code><code class="p">;</code>

<code class="kt">void</code> <code class="nf">setup</code><code class="p">()</code> <code class="p">{</code>
  <code class="c1">// Set our output pins</code>
  <code class="n">pinMode</code><code class="p">(</code><code class="n">RED</code><code class="p">,</code> <code class="n">OUTPUT</code><code class="p">);</code>
  <code class="n">pinMode</code><code class="p">(</code><code class="n">GREEN</code><code class="p">,</code> <code class="n">OUTPUT</code><code class="p">);</code>
  <code class="n">pinMode</code><code class="p">(</code><code class="n">BLUE</code><code class="p">,</code> <code class="n">OUTPUT</code><code class="p">);</code>

  <code class="c1">// Start the LED "off"</code>
  <code class="n">digitalWrite</code><code class="p">(</code><code class="n">RED</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
  <code class="n">digitalWrite</code><code class="p">(</code><code class="n">GREEN</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
  <code class="n">digitalWrite</code><code class="p">(</code><code class="n">BLUE</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>

  <code class="c1">// Get our PRNG ready, then pick our random colors</code>
  <code class="n">randomSeed</code><code class="p">(</code><code class="n">analogRead</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code>

  <code class="c1">// And pick our random color, but make sure it's relatively bright</code>
  <code class="n">red</code> <code class="o">=</code> <code class="n">random</code><code class="p">(</code><code class="mi">128</code><code class="p">,</code><code class="mi">255</code><code class="p">);</code>
  <code class="n">green</code> <code class="o">=</code> <code class="n">random</code><code class="p">(</code><code class="mi">128</code><code class="p">,</code><code class="mi">255</code><code class="p">);</code>
  <code class="n">blue</code> <code class="o">=</code> <code class="n">random</code><code class="p">(</code><code class="mi">128</code><code class="p">,</code><code class="mi">255</code><code class="p">);</code>

  <code class="c1">// Finally show the LED for a few seconds before starting the animation</code>
  <code class="n">analogWrite</code><code class="p">(</code><code class="n">RED</code><code class="p">,</code> <code class="n">red</code><code class="p">);</code>
  <code class="n">analogWrite</code><code class="p">(</code><code class="n">GREEN</code><code class="p">,</code> <code class="n">green</code><code class="p">);</code>
  <code class="n">analogWrite</code><code class="p">(</code><code class="n">BLUE</code><code class="p">,</code> <code class="n">blue</code><code class="p">);</code>
  <code class="n">delay</code><code class="p">(</code><code class="n">RATE</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">loop</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">double</code> <code class="n">ms_in_radians</code> <code class="o">=</code> <code class="p">(</code><code class="n">millis</code><code class="p">()</code> <code class="o">%</code> <code class="n">RATE</code><code class="p">)</code> <code class="o">*</code> <code class="n">PI_2</code> <code class="o">/</code> <code class="n">RATE</code><code class="p">;</code>
  <code class="kt">double</code> <code class="n">breath</code> <code class="o">=</code> <code class="p">(</code><code class="n">sin</code><code class="p">(</code><code class="n">ms_in_radians</code><code class="p">)</code> <code class="o">+</code> <code class="mf">1.0</code><code class="p">)</code> <code class="o">/</code> <code class="mf">2.0</code><code class="p">;</code>
  <code class="n">analogWrite</code><code class="p">(</code><code class="n">RED</code><code class="p">,</code> <code class="n">red</code> <code class="o">*</code> <code class="n">breath</code><code class="p">);</code>
  <code class="n">analogWrite</code><code class="p">(</code><code class="n">GREEN</code><code class="p">,</code> <code class="n">green</code> <code class="o">*</code> <code class="n">breath</code><code class="p">);</code>
  <code class="n">analogWrite</code><code class="p">(</code><code class="n">BLUE</code><code class="p">,</code> <code class="n">blue</code> <code class="o">*</code> <code class="n">breath</code><code class="p">);</code>
  <code class="n">delay</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>
<code class="p">}</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you don’t have an RGB LED, don’t worry! You can use a regular LED
and just write to the one pin of the LED rather than writing to the three separate
color pins. You won’t need to pick a random value, either; just use 255 (the
full brightness). Even if you have a multicolor LED, try rewriting the example
for a single-color LED as an exercise.</p>
</div>

<p>You can see that although we used several functions that are not part of C itself,
we did not need to manually <code>#include</code> anything. That is all down to the magic of
the Arduino IDE. It really does make development on these tiny boards <a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Arduino language elements" data-tertiary="LED light example" data-startref="ardIDE-language-led" id="idm45018718632616"/><a data-type="indexterm" data-primary="LED lights" data-secondary="Arduino language elements" data-startref="LED-arduino-lang" id="idm45018718465112"/>simpler.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Microcontroller I/O"><div class="sect1" id="smallerc-CHP-9-SECT-2">
<h1>Microcontroller I/O</h1>

<p>What else can we do with these extras supplied by our IDE? Lots! Let’s try
branching out from LEDs to try some inputs and some other types of output.</p>








<section data-type="sect2" data-pdf-bookmark="Sensors and Analog Input"><div class="sect2" id="smallerc-CHP-9-SECT-2.1">
<h2>Sensors and Analog Input</h2>

<p>An <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="sensors" data-tertiary="setup" id="ardmicro-sensor-setup"/><a data-type="indexterm" data-primary="sensors" data-secondary="setup" id="sensor-setup"/><a data-type="indexterm" data-primary="input" data-secondary="sensor setup" id="input-sensor-setup"/><a data-type="indexterm" data-primary="output" data-secondary="LED lights" data-see="LED lights" id="idm45018718455784"/><a data-type="indexterm" data-primary="analog input, sensor setup" id="analoginput-sensor-setup"/>easy step up from the simple sketches we’ve been building so far is to
add a sensor. Sensors come in all types: light, sound, temperature, air quality,
humidity, etc. And they’re usually inexpensive (although fancier ones do
come with fancier price tags). For example, the
<a href="https://oreil.ly/Bczhb">TMP36 Analog Temperature sensor</a> is only
$1.50 over at Adafruit. Let’s drop that sensor into a simple circuit
like the one shown in <a data-type="xref" href="#smallerc-CHP-9-FIG-tmp36-wiring">Figure 9-2</a> to see how the wiring works.</p>

<figure><div id="smallerc-CHP-9-FIG-tmp36-wiring" class="figure">
<img src="Images/smac_0902.png" alt="smac 0902" width="890" height="633"/>
<h6><span class="label">Figure 9-2. </span>Wiring diagram for our temperature example</h6>
</div></figure>

<p>Pretty easy! And this is a fairly common arrangement. Sensors need power. They can
either have a separate pin for power—like our TMP36—or many can draw enough
current directly from the data pin you connect it to (such as a photoresistor). We use
the <code>analogRead()</code> function to grab the current value of the sensor. Different boards
and different sensors support different ranges, but 10-bit (0–1023) ranges are common.
Exactly what those values mean depends on the sensor, of course. Our TMP36 ranges from
–50°C (a reading of 0) to 125°C (a reading<a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="sensors" data-tertiary="setup" data-startref="ardmicro-sensor-setup" id="idm45018718448408"/><a data-type="indexterm" data-primary="sensors" data-secondary="setup" data-startref="sensor-setup" id="idm45018718446872"/><a data-type="indexterm" data-primary="input" data-secondary="sensor setup" data-startref="input-sensor-setup" id="idm45018718445656"/><a data-type="indexterm" data-primary="analog input, sensor setup" data-startref="analoginput-sensor-setup" id="idm45018718444440"/> of 1023).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The Serial Monitor"><div class="sect2" id="smallerc-CHP-9-SECT-2.2">
<h2>The Serial Monitor</h2>

<p>While <a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Serial Port Monitor" id="ardIDE-serialport"/><a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="serial ports" id="ardmicro-serialport"/><a data-type="indexterm" data-primary="serial ports" id="serial-ports"/><a data-type="indexterm" data-primary="Serial Port Monitor" id="serial-port-monitor"/>you likely won’t have your Arduino project tethered to your main computer
for long, while it is connected, we can take advantage of a very handy feature of most
microcontrollers: the serial port. The Arduino IDE has a Serial Port Monitor you can
launch, as shown in <a data-type="xref" href="#smallerc-CHP-9-FIG-serial-monitor-menu">Figure 9-3</a>. During development, this is an excellent tool for
debugging and generally peeking into how things are going.</p>

<figure><div id="smallerc-CHP-9-FIG-serial-monitor-menu" class="figure">
<img src="Images/smac_0903.png" alt="smac 0903" width="1441" height="1319"/>
<h6><span class="label">Figure 9-3. </span>Accessing the Arduino IDE Serial Monitor</h6>
</div></figure>

<p>The port (selected via the Tools menu, also shown in  <a data-type="xref" href="#smallerc-CHP-9-FIG-serial-monitor-menu">Figure 9-3</a>)
and speed settings (selected at the bottom of the monitor window itself)
will vary depending on several factors, including your
OS, other devices you might have attached, and the particular Arduino board you
are using. For example, my Metro Mini on my Linux desktop communicates at 115200 baud (the classic
unit of measurement for the rate of serial communication; remember modems?)
on port <em>/dev/ttyUSB0</em> (the filesystem path to a “device” connection)
but a nifty <a href="https://oreil.ly/eSsOI">Trinket M0</a> microcontroller
uses port <em>/dev/ttyACM0</em>. That same Trinket on an old Windows system I have still uses<a data-type="indexterm" data-primary="Arduino IDE" data-secondary="Serial Port Monitor" data-startref="ardIDE-serialport" id="idm45018718430296"/><a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="serial ports" data-startref="ardmicro-serialport" id="idm45018718429048"/><a data-type="indexterm" data-primary="serial ports" data-startref="serial-ports" id="idm45018718427768"/><a data-type="indexterm" data-primary="Serial Port Monitor" data-startref="serial-port-monitor" id="idm45018718426824"/> a COM port.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Is It Hot in Here?"><div class="sect2" id="smallerc-CHP-9-SECT-2.3">
<h2>Is It Hot in Here?</h2>

<p>Let’s <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="sensors" data-tertiary="temperature output example" id="ardmicro-sensor-temp"/><a data-type="indexterm" data-primary="sensors" data-secondary="temperature output example" id="sensor-temp"/><a data-type="indexterm" data-primary="output" data-secondary="sensors, temperature output example" id="output-sensor-temp"/><a data-type="indexterm" data-primary="temperature output example" data-secondary="sensor readings" id="temp-sensor"/>put these two new topics to use in a project. We’ll use the
circuit shown in <a data-type="xref" href="#smallerc-CHP-9-FIG-tmp36-wiring">Figure 9-2</a>. You can start a new sketch
or open
<a href="https://oreil.ly/cal6o"><em>ch09/temp_serial/temp_serial.ino</em></a>
and follow along. The code is fairly straightforward. We
set up an input pin. Then we read from that pin and print the result in the serial
monitor in a loop. Let’s see the code:</p>

<pre data-type="programlisting" data-code-language="c"><code class="c1">// TMP36 is a 10-bit (0 - 1023) analog sensor</code>
<code class="c1">// 10mV / C with 500mV offset for temps below 0</code>
<code class="cp">#define TMP36_PIN 0</code>

<code class="kt">void</code> <code class="nf">setup</code><code class="p">()</code> <code class="p">{</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">begin</code><code class="p">(</code><code class="mi">115200</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">loop</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">raw</code> <code class="o">=</code> <code class="n">analogRead</code><code class="p">(</code><code class="n">TMP36_PIN</code><code class="p">);</code>
  <code class="kt">float</code> <code class="n">asVolts</code> <code class="o">=</code> <code class="n">raw</code> <code class="o">*</code> <code class="mf">5.0</code> <code class="o">/</code> <code class="mi">1024</code><code class="p">;</code>  <code class="c1">// Connected to 5V</code>
  <code class="kt">float</code> <code class="n">asC</code> <code class="o">=</code> <code class="p">(</code><code class="n">asVolts</code> <code class="o">-</code> <code class="mf">0.5</code><code class="p">)</code> <code class="o">*</code> <code class="mi">100</code><code class="p">;</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">print</code><code class="p">(</code><code class="n">asC</code><code class="p">);</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="s">" degrees C"</code><code class="p">);</code>
  <code class="kt">float</code> <code class="n">asF</code> <code class="o">=</code> <code class="p">(</code><code class="n">asC</code> <code class="o">*</code> <code class="mf">1.8</code><code class="p">)</code> <code class="o">+</code> <code class="mi">32</code><code class="p">;</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">print</code><code class="p">(</code><code class="n">asF</code><code class="p">);</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="s">" degrees F"</code><code class="p">);</code>
  <code class="n">delay</code><code class="p">(</code><code class="mi">5000</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Pretty spiffy! The bouncy nature of the readings is not uncommon. If we needed a steadier
reading, say, to prevent a false alarm going off,
there are a few electronic options we could employ, like adding resistors and
capacitors. We could also read from the sensor several times and take an average. Or we
could get even fancier and use statistics to toss any real outliers and then get the
average. But we mostly just wanted to prove the sensor is working and that we can see
the readings in the serial monitor. If you want to make sure the sensor is working, try
holding it gently with your fingers—they should be warmer than room temperature,
and you should see the trend of the readings going up.</p>
<div data-type="tip"><h6>Tip</h6>
<p>For a bit of fun, try popping open the “Serial Plotter” from the Tools
menu (just under the Serial Monitor). It tracks simple values printed via <code>Serial.println()</code>
as a graph. It can even track multiple values as separate lines; just print a space
in between the values on the same line.</p>
</div>

<p>But as I said, you likely won’t have your Arduino plugged into your USB port
constantly. Let’s explore a better <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="sensors" data-tertiary="temperature output example" data-startref="ardmicro-sensor-temp" id="idm45018718232008"/><a data-type="indexterm" data-primary="sensors" data-secondary="temperature output example" data-startref="sensor-temp" id="idm45018718230552"/><a data-type="indexterm" data-primary="output" data-secondary="sensors, temperature output example" data-startref="output-sensor-temp" id="idm45018718229368"/><a data-type="indexterm" data-primary="temperature output example" data-secondary="sensor readings" data-startref="temp-sensor" id="idm45018718228184"/>output option.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Segmented Displays"><div class="sect2" id="smallerc-CHP-9-SECT-2.4">
<h2>Segmented Displays</h2>

<p>LCD and<a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="segmented displays" data-tertiary="setup" id="ardmicro-display-setup"/><a data-type="indexterm" data-primary="segmented displays" data-secondary="setup" id="display-setup"/><a data-type="indexterm" data-primary="output" data-secondary="segmented displays" data-tertiary="setup" id="output-display-setup"/> segmented LED displays come in a wealth of size and price options. You can get
high-resolution LCDs the size of a postage stamp, touch-capable screens similar to those
found in cell phones, or segmented LED displays for text or numeric output. I picked up
a simple 4-digit LED display (a Velleman VMA425, shown in <a data-type="xref" href="#smallerc-CHP-9-FIG-segmented-display">Figure 9-4</a>)
with a driver chip built in (so you don’t need individual pin
connections for each separate segment) for less than $7 at a local Micro Center. We can use
just such a display to show our TMP36 readings (properly converted to Fahrenheit or Celsius)
without resorting to the serial monitor.</p>

<figure><div id="smallerc-CHP-9-FIG-segmented-display" class="figure">
<img src="Images/smac_0904.png" alt="smac 0904" width="5918" height="2490"/>
<h6><span class="label">Figure 9-4. </span>An example of a 4-digit, 7-segment display component</h6>
</div></figure>

<p>Unfortunately, these peripherals usually require a little help to operate. Fortunately, that
help is almost always<a data-type="indexterm" data-primary="Arduino IDE" data-secondary="libraries" data-tertiary="installing" id="idm45018718216664"/><a data-type="indexterm" data-primary="libraries" data-secondary="Arduino" data-tertiary="installing" id="idm45018718215416"/><a data-type="indexterm" data-primary="installing" data-secondary="Arduino libraries" id="idm45018718214200"/> readily available in the form of a library. We’ll go over
libraries in much more detail in <a data-type="xref" href="ch11.xhtml#smallerc-CHP-11">Chapter 11</a>, but we can take a short detour now
to grab what we need for our 4-digit LED display.</p>

<p>The driver chip I mentioned that comes with my particular display
is a TM1637. There was no magic involved in finding that name—it is noted on the
package and more plainly on the chip itself. Using the Arduino IDE Library Manager, I
entered “TM1637” as the search term.<sup><a data-type="noteref" id="idm45018718211544-marker" href="ch09.xhtml#idm45018718211544">5</a></sup> Several results came back, and I chose a library
(written by Avishay Orpaz) that looked simple and stable. After clicking the Install button, I simply included the library’s lone header file and was immediately ready to put up some numbers!<sup><a data-type="noteref" id="idm45018718210600-marker" href="ch09.xhtml#idm45018718210600">6</a></sup></p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;TM1637Display.h&gt;</code></pre>

<p>Doesn’t get much easier than that. You will often follow this process for adding new
peripherals, both sensors and other outputs. You may also decide nothing available is
quite right, and roll your own code. Again, we’ll look at the mechanics of
creating your own libray in <a data-type="xref" href="ch11.xhtml#smallerc-CHP-11">Chapter 11</a>.</p>

<p>I shouldn’t really say I was immediately ready after installing the library.
I did have to wire up the display. <a data-type="xref" href="#smallerc-CHP-9-FIG-tmp36-led-wiring">Figure 9-5</a> shows
the connections required. I also had to read the documentation
for the library which I found by clicking the “More info” link in the
Library Manager listing.</p>

<figure><div id="smallerc-CHP-9-FIG-tmp36-led-wiring" class="figure">
<img src="Images/smac_0905.png" alt="smac 0905" width="1106" height="672"/>
<h6><span class="label">Figure 9-5. </span>Wiring for temperatures on an LED display</h6>
</div></figure>

<p>Ignoring the TMP36 sensor for the moment,
<a href="https://oreil.ly/jzXm9"><em>ch09/display_test/display_test.ino</em></a>
is a simple test of the 4-digit display.
We’ll display “1234” to prove our connections are working and that we understand
the library functions from the documentation.</p>

<pre data-type="programlisting" data-code-language="c"><code class="c1">// Our 4-digit display uses a TM1637 chip and I2C
</code><code class="cp">#</code><code class="cp">include &lt;TM1637Display.h&gt;                  </code><a class="co" id="co_smaller_systems_CO2-1" href="#callout_smaller_systems_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code class="cp">
</code><code>
</code><code class="c1">// Name our pins
</code><code class="cp">#</code><code class="cp">define CLK       2                         </code><a class="co" id="co_smaller_systems_CO2-2" href="#callout_smaller_systems_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code class="cp">
</code><code class="cp">#</code><code class="cp">define DIO       3</code><code class="cp">
</code><code>
</code><code class="c1">// Create our 4-segment display object
</code><code class="n">TM1637Display</code><code> </code><code class="nf">display</code><code class="p">(</code><code class="n">CLK</code><code class="p">,</code><code> </code><code class="n">DIO</code><code class="p">)</code><code class="p">;</code><code>            </code><a class="co" id="co_smaller_systems_CO2-3" href="#callout_smaller_systems_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>

</code><code class="kt">void</code><code> </code><code class="nf">setup</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>  </code><code class="c1">// Get our display ready and set a medium brightness
</code><code>  </code><code class="n">display</code><code class="p">.</code><code class="n">clear</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>                          </code><a class="co" id="co_smaller_systems_CO2-4" href="#callout_smaller_systems_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
  </code><code class="n">display</code><code class="p">.</code><code class="n">setBrightness</code><code class="p">(</code><code class="mh">0x0f</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="n">display</code><code class="p">.</code><code class="n">showNumberDec</code><code class="p">(</code><code class="mi">1234</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="p">}</code><code>
</code><code>
</code><code class="kt">void</code><code> </code><code class="nf">loop</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>                               </code><a class="co" id="co_smaller_systems_CO2-5" href="#callout_smaller_systems_CO2-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_smaller_systems_CO2-1" href="#co_smaller_systems_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The library I chose has one header, so include that to get going.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO2-2" href="#co_smaller_systems_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The display needs two pins (in addition to power and ground), so name those for ease of use.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO2-3" href="#co_smaller_systems_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Create a global <code>display</code> variable similar to how we created the NeoPixel objects.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO2-4" href="#co_smaller_systems_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Use our <code>display</code> object with functions described in the documentation to initialize our display and put up a simple test number, 1234 in this case.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO2-5" href="#co_smaller_systems_CO2-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Nothing changes, and the display will hold whatever number it was last sent, so we can leave the <code>loop()</code> function empty.</p></dd>
</dl>

<p>Hooray! If all goes well, you’ll see something like <a data-type="xref" href="#smallerc-CHP-9-FIG-segmented-display">Figure 9-4</a>.
If you chose a different display or library and you aren’t seeing what you hoped, see if you
can find other examples of using your hardware or library online. Usually someone has
posted useful, minimal code examples you can easily copy and <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="segmented displays" data-tertiary="setup" data-startref="ardmicro-display-setup" id="idm45018718029272"/><a data-type="indexterm" data-primary="segmented displays" data-secondary="setup" data-startref="display-setup" id="idm45018718027944"/><a data-type="indexterm" data-primary="output" data-secondary="segmented displays" data-tertiary="setup" data-startref="output-display-setup" id="idm45018718026856"/>try yourself.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Buttons and Digital Input"><div class="sect2" id="smallerc-CHP-9-SECT-2.5">
<h2>Buttons and Digital Input</h2>

<p>But <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="buttons" data-tertiary="setup" id="ardmicro-buttons-setup"/><a data-type="indexterm" data-primary="buttons" data-secondary="setup" id="buttons-setup"/><a data-type="indexterm" data-primary="input" data-secondary="button setup" id="input-buttons-setup"/><a data-type="indexterm" data-primary="digital input, button setup" id="digitalinput-buttons-setup"/>we’re not done yet! We can add another peripheral to add a little more
functionality to our temperature display sketch and expand our coding skills at
the same time. Let’s attach a very common input: the push button. We’ll
use it to toggle our display between Fahrenheit and Celsius output.</p>

<p>I grabbed a <a href="http://adafru.it/367">Tactile Button</a> from Adafruit; it’s
simple and breadboard friendly. <a data-type="xref" href="#smallerc-CHP-9-FIG-tmp36-led-button">Figure 9-6</a> shows the final connections for
the TMP36 sensor, the 4-digit display, and our newly added button. The diagonal
connections to the button are intentional. Either diagonal works; other arrangements
are possible if you look at the specs for the button, but this choice guarantees
we get the functionality we need.</p>

<figure><div id="smallerc-CHP-9-FIG-tmp36-led-button" class="figure">
<img src="Images/smac_0906.png" alt="smac 0906" width="1106" height="699"/>
<h6><span class="label">Figure 9-6. </span>Wiring for our sensor, display, and button</h6>
</div></figure>

<p>To use the button, we need to set one pin to be an input and then use the <code>digitalRead()</code>
function on that pin. In particular, this button will use the <code>INPUT_PULLUP</code> constant.
This common approach causes the default state of the pin (when the button is not pressed)
to return <code>HIGH</code>. When the button is pressed, then, the pin will read <code>LOW</code>. We can watch
for that <code>LOW</code> value and use it to trigger a change—like our F/C choice.</p>

<p>But watch out! Just because we’re using the <code>digitalRead()</code> function does not mean
the button is digital. It takes time to get the physical mechanism all the way down. It
also takes a little time to fully release. All told, it takes a human much longer to press
the button than it does for the Arduino to register a change. Consider this naive read-and-change loop snippet:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">bool</code> <code class="n">useC</code> <code class="o">=</code> <code class="nb">false</code><code class="p">;</code> <code class="c1">// display temp in Celsius?</code>

<code class="kt">void</code> <code class="nf">loop</code><code class="p">()</code> <code class="p">{</code>
  <code class="c1">// ...</code>
  <code class="kt">int</code> <code class="n">toggle</code> <code class="o">=</code> <code class="n">digitalRead</code><code class="p">(</code><code class="n">BUTTON</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">toggle</code> <code class="o">==</code> <code class="n">LOW</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">useC</code> <code class="o">=</code> <code class="o">!</code><code class="n">useC</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="c1">// ...</code>
<code class="p">}</code></pre>

<p>The pin will read low for tens of milliseconds during even the fastest press. Our
microcontroller can read the pin and change the display much faster than we can let
go of the button, causing a crazy flicker as the display rapidly bounces between our
F and our C temperatures. We want to stop that flicker, so we have to be a little
more clever in our code. We <a data-type="indexterm" data-primary="debouncing" id="idm45018717974232"/>need to <em>debounce</em> the button. The idea of debouncing
has gained traction in a lot of user interface work—it generally means making
sure you don’t report multiple presses (or clicks or taps or whatever) in too
short a period.</p>

<p>I’ll show you a few methods we can use to accomplish this debounce behavior.
It usually involves keeping some extra state information around. For the first
debounce technique, I simply keep a <code>bool</code> that tracks when the button state first
changes. If that flag is <code>true</code>, we just pause for a second. (In <a data-xrefstyle="select:nopage" data-type="xref" href="#smallerc-CHP-9-SECT-2.6">“Just How Hot Is It?”</a>,
we pause for exactly one second, in fact, but you can certainly choose a different
delay.) After that gap has passed, we can read another <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="buttons" data-tertiary="setup" data-startref="ardmicro-buttons-setup" id="idm45018717969880"/><a data-type="indexterm" data-primary="buttons" data-secondary="setup" data-startref="buttons-setup" id="idm45018717968424"/><a data-type="indexterm" data-primary="input" data-secondary="button setup" data-startref="input-buttons-setup" id="idm45018717967208"/><a data-type="indexterm" data-primary="digital input, button setup" data-startref="digitalinput-buttons-setup" id="idm45018717965992"/>change.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Just How Hot Is It?"><div class="sect2" id="smallerc-CHP-9-SECT-2.6">
<h2>Just How Hot Is It?</h2>

<p>So let’s <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="sensors" data-tertiary="temperature output example" id="ardmicro-sensor-temps"/><a data-type="indexterm" data-primary="sensors" data-secondary="temperature output example" id="sensor-temps"/><a data-type="indexterm" data-primary="output" data-secondary="sensors, temperature output example" id="output-sensor-temps2"/><a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="segmented displays" data-tertiary="temperature output example" id="ardmicro-display-temp"/><a data-type="indexterm" data-primary="segmented displays" data-secondary="temperature output example" id="display-temp"/><a data-type="indexterm" data-primary="output" data-secondary="segmented displays" data-tertiary="temperature output example" id="output-display-temp"/><a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="buttons" data-tertiary="temperature output example" id="ardmicro-buttons-temp"/><a data-type="indexterm" data-primary="buttons" data-secondary="temperature output example" id="buttons-temp"/><a data-type="indexterm" data-primary="temperature output example" data-secondary="buttons and displays" id="temp-button"/>tie all of these new topics together and create the code for the
components we wired up in <a data-type="xref" href="#smallerc-CHP-9-FIG-tmp36-led-button">Figure 9-6</a>. We’ll initialize
our display in the setup. In the loop, we’ll read the temperature, print out
some debugging statements to the serial monitor, put the temperature on the display
in the correct units, and then watch the button to see if we need to change those
units. You can open
<a href="https://oreil.ly/flVsn"><em>ch09/temp_display/temp_display.ino</em></a>
or type in the following code:</p>

<pre data-type="programlisting" data-code-language="c"><code class="c1">// TMP36 is a 10-bit (0 - 1023) analog sensor</code>
<code class="c1">// 10mV / C with 500mV offset for temps below 0</code>
<code class="c1">// Our 4-digit display uses a TM1637 chip and I2C</code>
<code class="cp">#include &lt;TM1637Display.h&gt;</code>

<code class="c1">// Name our pins</code>
<code class="cp">#define TMP36_PIN 0</code>
<code class="cp">#define CLK       2</code>
<code class="cp">#define DIO       3</code>
<code class="cp">#define BUTTON    8</code>

<code class="c1">// Create our 4-segment display object</code>
<code class="n">TM1637Display</code> <code class="nf">display</code><code class="p">(</code><code class="n">CLK</code><code class="p">,</code> <code class="n">DIO</code><code class="p">);</code>

<code class="c1">// Build the letters "F" and "C"</code>
<code class="c1">// Segment bits run clockwise from top (bit 1) to center (64)</code>
<code class="kt">uint8_t</code> <code class="n">segmentF</code><code class="p">[]</code> <code class="o">=</code> <code class="p">{</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">32</code> <code class="o">|</code> <code class="mi">64</code> <code class="o">|</code> <code class="mi">16</code> <code class="p">};</code>
<code class="kt">uint8_t</code> <code class="n">segmentC</code><code class="p">[]</code> <code class="o">=</code> <code class="p">{</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">32</code> <code class="o">|</code> <code class="mi">16</code> <code class="o">|</code> <code class="mi">8</code> <code class="p">};</code>

<code class="c1">// Keep track of scale</code>
<code class="kt">bool</code> <code class="n">useC</code> <code class="o">=</code> <code class="nb">false</code><code class="p">;</code>

<code class="c1">// Manage button at human time</code>
<code class="kt">bool</code> <code class="n">debounce</code> <code class="o">=</code> <code class="nb">false</code><code class="p">;</code>

<code class="kt">void</code> <code class="nf">setup</code><code class="p">()</code> <code class="p">{</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">begin</code><code class="p">(</code><code class="mi">115200</code><code class="p">);</code>
  <code class="n">display</code><code class="p">.</code><code class="n">clear</code><code class="p">();</code>
  <code class="n">display</code><code class="p">.</code><code class="n">setBrightness</code><code class="p">(</code><code class="mh">0x0f</code><code class="p">);</code>
  <code class="n">pinMode</code><code class="p">(</code><code class="n">BUTTON</code><code class="p">,</code> <code class="n">INPUT_PULLUP</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">loop</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">raw</code> <code class="o">=</code> <code class="n">analogRead</code><code class="p">(</code><code class="n">TMP36_PIN</code><code class="p">);</code>
  <code class="kt">float</code> <code class="n">asVolts</code> <code class="o">=</code> <code class="n">raw</code> <code class="o">*</code> <code class="mf">5.0</code> <code class="o">/</code> <code class="mi">1024</code><code class="p">;</code>  <code class="c1">// Connected to 5V</code>
  <code class="kt">float</code> <code class="n">asC</code> <code class="o">=</code> <code class="p">(</code><code class="n">asVolts</code> <code class="o">-</code> <code class="mf">0.5</code><code class="p">)</code> <code class="o">*</code> <code class="mi">100</code><code class="p">;</code>
  <code class="kt">int</code> <code class="n">wholeC</code> <code class="o">=</code> <code class="p">(</code><code class="kt">int</code><code class="p">)(</code><code class="n">asC</code> <code class="o">+</code> <code class="mf">0.5</code><code class="p">);</code>
  <code class="kt">int</code> <code class="n">wholeF</code> <code class="o">=</code> <code class="p">(</code><code class="kt">int</code><code class="p">)((</code><code class="n">asC</code> <code class="o">*</code> <code class="mf">1.8</code><code class="p">)</code> <code class="o">+</code> <code class="mi">32</code> <code class="o">+</code> <code class="mf">0.5</code><code class="p">);</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">print</code><code class="p">(</code><code class="n">raw</code><code class="p">);</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">print</code><code class="p">(</code><code class="s">" "</code><code class="p">);</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="n">asC</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">useC</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">display</code><code class="p">.</code><code class="n">showNumberDec</code><code class="p">(</code><code class="n">wholeC</code><code class="p">,</code> <code class="nb">false</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
    <code class="n">display</code><code class="p">.</code><code class="n">setSegments</code><code class="p">(</code><code class="n">segmentC</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">);</code>
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="n">display</code><code class="p">.</code><code class="n">showNumberDec</code><code class="p">(</code><code class="n">wholeF</code><code class="p">,</code> <code class="nb">false</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
    <code class="n">display</code><code class="p">.</code><code class="n">setSegments</code><code class="p">(</code><code class="n">segmentF</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">debounce</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">debounce</code> <code class="o">=</code> <code class="nb">false</code><code class="p">;</code>
    <code class="n">delay</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code>
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">1000</code><code class="p">;</code> <code class="n">i</code> <code class="o">+=</code> <code class="mi">10</code><code class="p">)</code> <code class="p">{</code>
      <code class="kt">int</code> <code class="n">toggle</code> <code class="o">=</code> <code class="n">digitalRead</code><code class="p">(</code><code class="n">BUTTON</code><code class="p">);</code>
      <code class="k">if</code> <code class="p">(</code><code class="n">toggle</code> <code class="o">==</code> <code class="n">LOW</code><code class="p">)</code> <code class="p">{</code>
        <code class="n">useC</code> <code class="o">=</code> <code class="o">!</code><code class="n">useC</code><code class="p">;</code>
        <code class="n">debounce</code> <code class="o">=</code> <code class="nb">true</code><code class="p">;</code>
        <code class="k">break</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="n">delay</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>Notice I use a new function from the TM1637 library: <code>setSegments()</code>. This function
allows you to turn on any pattern of segments you want. You can make cute animations
or present a somewhat rough version of any English letter. You can see my results in
<a data-type="xref" href="#smallerc-CHP-9-FIG-tmp36-led-live">Figure 9-7</a>.</p>

<figure><div id="smallerc-CHP-9-FIG-tmp36-led-live" class="figure">
<img src="Images/smac_0907.png" alt="smac 0907" width="4032" height="3024"/>
<h6><span class="label">Figure 9-7. </span>Our temperature reading on an LED display</h6>
</div></figure>

<p>Give this bigger example a try with your own setup. The project is in the <em>ch09</em> folder
as <em>temp_display</em>. You can adjust the debounce pause or try making the “C”
pattern a lowercase version. Tweaking existing projects is a great way to build up
your understanding of new concepts! Speaking of new concepts, there are two more biggies
I want to cover for the Arduino platform: memory management <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="sensors" data-tertiary="temperature output example" data-startref="ardmicro-sensor-temps" id="idm45018717653608"/><a data-type="indexterm" data-primary="sensors" data-secondary="temperature output example" data-startref="sensor-temps" id="idm45018717652104"/><a data-type="indexterm" data-primary="output" data-secondary="sensors, temperature output example" data-startref="output-sensor-temps2" id="idm45018717650872"/><a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="segmented displays" data-tertiary="temperature output example" data-startref="ardmicro-display-temp" id="idm45018717649640"/><a data-type="indexterm" data-primary="segmented displays" data-secondary="temperature output example" data-startref="display-temp" id="idm45018717648120"/><a data-type="indexterm" data-primary="output" data-secondary="segmented displays" data-tertiary="temperature output example" data-startref="output-display-temp" id="idm45018717646888"/><a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="buttons" data-tertiary="temperature output example" data-startref="ardmicro-buttons-temp" id="idm45018717645384"/><a data-type="indexterm" data-primary="buttons" data-secondary="temperature output example" data-startref="buttons-temp" id="idm45018717643864"/><a data-type="indexterm" data-primary="temperature output example" data-secondary="buttons and displays" data-startref="temp-button" id="idm45018717642632"/>and interrupts.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Memory Management on Arduino"><div class="sect1" id="smallerc-CHP-9-SECT-3">
<h1>Memory Management on Arduino</h1>

<p>Memory management <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="types of" id="idm45018717639240"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="types of" data-secondary-sortas="Arduino" id="idm45018717637992"/>is much more important on small devices, so I want to
highlight how memory works on a microcontroller like Arduino.
Arduino has three types of memory. <em>Flash</em> memory is where our program
is stored. <em>SRAM</em> is <a data-type="indexterm" data-primary="SRAM (static random-access memory)" id="idm45018717635416"/>where the program operates while the Arduino has power. And
finally, <em>EEPROM</em> allows <a data-type="indexterm" data-primary="EEPROM (electronically erasable programmable read-only memory)" id="idm45018717634200"/>you to read and write a small amount of data that will
persist between power cycles. Let’s look at each of these types of memory
in more detail and see how we can use them in our code.</p>








<section data-type="sect2" data-pdf-bookmark="Flash (PROGMEM)"><div class="sect2" id="smallerc-CHP-9-SECT-3.1">
<h2>Flash (PROGMEM)</h2>

<p>If <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="PROGMEM" id="ardmicro-memory-flash"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="PROGMEM" data-secondary-sortas="Arduino" id="memory-arduino-flash"/><a data-type="indexterm" data-primary="PROGMEM (flash memory)" id="prog-flash"/><a data-type="indexterm" data-primary="flash memory" id="flash"/>the word “flash” sounds familiar, it probably is. This is the same type
of memory found in flash (or thumb) drives. It is much slower than something like RAM,
but it is generally on par with storage like hard drives. It is also persistent and does
not require power to retain its information. That makes it perfect for storing our
compiled sketches.</p>

<p>In microcontroller parlance, you may also hear a less familiar term: <em>PROGMEM</em> or
“program memory.” It’s the same memory, but the latter term tells
you a little more about what we’re doing with that memory.</p>

<p>Even though this flash is the same technology as you find in thumb drives,
we don’t have write access to this memory when our
program is running. Writing is reserved for the “upload” step in our IDE.
The chip is put in a special mode for modification, and the new program is loaded. After
the upload is complete, the chip restarts, reads the new program from flash, and off we go. We do have read access, though.</p>

<p>Most Arduino chips have more flash storage than you need for your compiled program.
You can make use of the leftover space to reduce the amount of RAM needed to run
your program. Since RAM is almost always more limited, this feature can be a real boon.
You can store arrays or strings or individual values. You can use special functions to
grab those stored values as you need them while your program is actively running.</p>










<section data-type="sect3" data-pdf-bookmark="Storing values in flash"><div class="sect3" id="smallerc-CHP-9-SECT-3.1.1">
<h3>Storing values in flash</h3>

<p>To get a particular value into flash for use in your code, you can use the special
<code>PROGMEM</code> modifier<a data-type="indexterm" data-primary="variables" data-secondary="in flash memory" data-secondary-sortas="flash memory" id="idm45018717620648"/> when declaring and initializing the variable. For example, we
could store an array of 32-bit colors that would work with the RGBW NeoPixel ring
from <a data-type="xref" href="ch08.xhtml#smallerc-CHP-8-SECT-4.3">“C++ Considerations”</a>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">const</code> <code class="n">PROGMEM</code> <code class="kt">uint32_t</code> <code class="n">colors</code><code class="p">[]</code> <code class="o">=</code> <code class="p">{</code>
  <code class="mh">0xCC000000</code><code class="p">,</code> <code class="mh">0x00CC0000</code><code class="p">,</code> <code class="mh">0x0000CC00</code><code class="p">,</code> <code class="mh">0x000000CC</code><code class="p">,</code>
  <code class="mh">0xCC336699</code><code class="p">,</code> <code class="mh">0xCC663399</code><code class="p">,</code> <code class="mh">0xCC339966</code><code class="p">,</code> <code class="mh">0xCC996633</code>
<code class="p">};</code></pre>

<p>At this point, the <code>colors</code> array is no longer a simple list of 32-bit values. It
now contains the location of these values in flash. You need a special function to
get at the contents of this array.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Reading values from flash"><div class="sect3" id="smallerc-CHP-9-SECT-3.1.2">
<h3>Reading values from flash</h3>

<p>Those <a data-type="indexterm" data-primary="reading from flash memory" id="read-flash"/>special functions are defined in the
<a href="https://oreil.ly/nIk62"><em>pgmspace.h</em> header</a>.
In recent versions
of the Arduino IDE, that header is one of the many “behind-the-scenes”
elements handled for you automatically. There are several functions for reading absolutely
every data type supported on Arduino. <a data-type="xref" href="#smallerc-CHP-9-TAB-pgm-read">Table 9-4</a> lists the few functions
we’ll use in our projects.</p>
<table id="smallerc-CHP-9-TAB-pgm-read">
<caption><span class="label">Table 9-4. </span>Program memory (flash) read functions</caption>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>pgm_read_byte()</code></p></td>
<td><p>Read one byte</p></td>
</tr>
<tr>
<td><p><code>pgm_read_word()</code></p></td>
<td><p>Read one word (two bytes, like <code>int</code> on many microcontrollers)</p></td>
</tr>
<tr>
<td><p><code>pgm_read_dword()</code></p></td>
<td><p>Read one double word (four bytes, like <code>long</code>)</p></td>
</tr>
<tr>
<td><p><code>pgm_read_float()</code></p></td>
<td><p>Read four bytes as a <code>float</code> or <code>double</code></p></td>
</tr>
</tbody>
</table>

<p>If <a data-type="indexterm" data-primary="functions" data-secondary="for flash memory" data-secondary-sortas="flash memory" id="idm45018717581192"/><a data-type="indexterm" data-primary="pgm_read_byte() function" id="idm45018717579912"/><a data-type="indexterm" data-primary="pgm_read_word() function" id="idm45018717579224"/><a data-type="indexterm" data-primary="pgm_read_dword() function" id="idm45018717578536"/><a data-type="indexterm" data-primary="pgm_read_float() function" id="idm45018717577848"/>we wanted to get the first entry from our <code>colors</code> array for actual use, we could
use the <code>pgm_read_dword()</code> function like so:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">uint32_t</code> <code class="n">firstColor</code> <code class="o">=</code> <code class="n">pgm_read_dword</code><code class="p">(</code><code class="o">&amp;</code><code class="n">colors</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code></pre>

<p>This is obviously a little cumbersome. When you are running low on RAM, though, cumbersome is often a fair trade-off. 32 bytes for eight colors is not much, but what about a 256-color palette? At four bytes per color, that’s an entire kilobyte. Some microcontrollers like our Metro Mini have a tiny 2K operating memory, so offloading such a palette to flash memory is a big win.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Reading strings from flash"><div class="sect3" id="smallerc-CHP-9-SECT-3.1.3">
<h3>Reading strings from flash</h3>

<p>Printing <a data-type="indexterm" data-primary="strings" data-secondary="reading from flash memory" id="strings-flash"/>to the serial monitor is a great way to debug your program, or even just
to watch what’s going on as a sort of cheap status indicator. However, every
one of the strings you print consumes some precious runtime memory. Moving these
strings off to flash is a great way to reclaim some of that space. You simply
pull the string you need out of flash just at the moment you need it. If you put
it into a common, reusable buffer, that buffer is the only memory we have to make
room for at runtime.</p>

<p>This is such a common memory-saving technique that the Arduino environment includes
a special macro to<a data-type="indexterm" data-primary="F() macro" id="idm45018717530840"/> simplify the round trip: <code>F()</code>.
(Again, more on macros and <code>#define</code> in <a data-type="xref" href="ch11.xhtml#smallerc-CHP-11-SECT-1.2">“Preprocessor Macros”</a>.)
<code>F()</code> is remarkably easy to use
and provides an immediate savings. Say we have a few debugging statements like this:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">setup</code><code class="p">()</code> <code class="p">{</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">begin</code><code class="p">(</code><code class="mi">115200</code><code class="p">);</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="s">"Initializing..."</code><code class="p">);</code>
  <code class="c1">// ...</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="s">"Setting pin modes..."</code><code class="p">);</code>
  <code class="c1">// ...</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="s">"Ready"</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>There are likely other variables and such in your program, too. Verifying your
code in the Arduino IDE might produce some output similar to this:</p>

<pre data-type="programlisting">Sketch uses 4548 bytes (14%) of program storage space. Maximum is 32256 bytes.
Global variables use 275 bytes (13%) of dynamic memory,
leaving 1773 bytes for local variables. Maximum is 2048 bytes.</pre>

<p>Great. We have plenty of room at the moment, but 1773 bytes is not much! Let’s
use the <code>F()</code> macro now to move those strings to flash memory:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">setup</code><code class="p">()</code> <code class="p">{</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">begin</code><code class="p">(</code><code class="mi">115200</code><code class="p">);</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="n">F</code><code class="p">(</code><code class="s">"Initializing..."</code><code class="p">));</code>
  <code class="c1">// ...</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="n">F</code><code class="p">(</code><code class="s">"Setting pin modes..."</code><code class="p">));</code>
  <code class="c1">// ...</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="n">F</code><code class="p">(</code><code class="s">"Ready"</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>Pretty simple to incorporate, right? And now if we verify our program, we can see
a small but advantageous change:</p>

<pre data-type="programlisting">Sketch uses 4608 bytes (14%) of program storage space. Maximum is 32256 bytes.
Global variables use 225 bytes (10%) of dynamic memory,
leaving 1823 bytes for local variables. Maximum is 2048 bytes.</pre>

<p>Our new sketch takes up a little more room in flash, but a little less room at
runtime. That’s exactly what we came for. Now, obviously, removing those
debugging statements entirely saves space in both types of memory, but there
are certainly times when you will have nice peripherals such as mini LCD displays
that show text. <code>F()</code> can give you more room to play without<a data-type="indexterm" data-primary="strings" data-secondary="reading from flash memory" data-startref="strings-flash" id="idm45018717271752"/><a data-type="indexterm" data-primary="reading from flash memory" data-startref="read-flash" id="idm45018717270568"/><a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="PROGMEM" data-startref="ardmicro-memory-flash" id="idm45018717269656"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="PROGMEM" data-secondary-sortas="Arduino" data-startref="memory-arduino-flash" id="idm45018717268152"/><a data-type="indexterm" data-primary="PROGMEM (flash memory)" data-startref="prog-flash" id="idm45018717266392"/><a data-type="indexterm" data-primary="flash memory" data-startref="flash" id="idm45018717265448"/> much added effort.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="SRAM"><div class="sect2" id="smallerc-CHP-9-SECT-3.2">
<h2>SRAM</h2>

<p>I’ve <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="SRAM" id="ardmicro-memory-sram"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="SRAM" data-secondary-sortas="Arduino" id="memory-arduino-sram"/><a data-type="indexterm" data-primary="SRAM (static random-access memory)" id="sram"/>been tossing around the terms “at runtime” and “operating
memory,” among others. These terms refer to a type of memory called <em>SRAM</em>.
Static random-access memory is the Arduino equivalent to the generic RAM
term so often applied to bigger systems.<sup><a data-type="noteref" id="idm45018717257432-marker" href="ch09.xhtml#idm45018717257432">7</a></sup> Flash is where our program is stored, SRAM is
where our program operates. The stack and heap mentioned in <a data-type="xref" href="ch06.xhtml#smallerc-CHP-6-FIG-stack-and-heap">Figure 6-3</a> are found
here in SRAM while your program is running. The operating size of your program is
limited by the amount of SRAM you have. Let’s take a look at some implications of this limit.</p>










<section data-type="sect3" data-pdf-bookmark="Stacks and heaps"><div class="sect3" id="smallerc-CHP-9-SECT-3.2.1">
<h3>Stacks and heaps</h3>

<p>Recall the<a data-type="indexterm" data-primary="heap" data-secondary="in SRAM" data-secondary-sortas="SRAM" id="idm45018717250728"/><a data-type="indexterm" data-primary="stack" data-secondary="in SRAM" data-secondary-sortas="SRAM" id="idm45018717249448"/> discussion of global variables and the heap from <a data-type="xref" href="ch06.xhtml#smallerc-CHP-6-SECT-1.3">“Local Variables and the Stack”</a>.
I mentioned that you could potentially run out of memory if you had too many variables
or made too many nested function calls. It is a largely theoretical discussion if
you have gigabytes or even terabytes of memory like modern 
<span class="keep-together">desktop</span> systems. But 2K?
What about our Metro Mini and its meager 2K of SRAM? The stack and heap—active
at runtime, so not part of flash memory—must fit in this limited space as we run our
Arduino sketches.</p>

<p>Imagine redoing the addresses from <a data-type="xref" href="ch06.xhtml#smallerc-CHP-6-FIG-stack-and-heap">Figure 6-3</a> to fit in 2K.
That middle is <em>much</em> smaller now. It is much easier to imagine too many function calls
or too many global variables or <code>malloc()</code> allocations. If you wrote out 32 bytes per
line (64 hexadecimal characters), it would take just 64 lines to represent the entire
contents of SRAM on some microcontrollers. That’s <em>one</em> two-sided piece of paper from a high
school notepad! That means a careless loop or large array can overrun our SRAM
and cause our program to crash.</p>

<p>For example, our recursive Fibonacci calculating function could easily fill up
available memory after a few dozen calls—especially since we will still need
memory for our LEDs, sensor libraries, etc. It’s not forbidden to use
recursion when working with microcontrollers, but it does require paying a little more
attention to detail on your part.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Global variables in Arduino"><div class="sect3" id="smallerc-CHP-9-SECT-3.2.2">
<h3>Global variables in Arduino</h3>

<p>Unlike<a data-type="indexterm" data-primary="variables" data-secondary="scope" data-tertiary="global" id="variables-scope-global-arduino"/><a data-type="indexterm" data-primary="scope of variables" data-secondary="global" data-tertiary="in Arduino" data-tertiary-sortas="Arduino" id="scope-global-arduino"/><a data-type="indexterm" data-primary="global variables" data-secondary="in Arduino" data-secondary-sortas="Arduino" id="global-arduino"/> desktop applications where globals (allocated on the heap)
are almost always optional (if convenient), the Arduino environment makes
regular use of them. The Arduino IDE hides a lot of the effort done on our behalf
to create a viable, executable program. Remember that we don’t write our own <code>main()</code>
function, for example. As such, if we need to initialize a variable in the <code>setup()</code>
function and then refer to that variable in our <code>loop()</code> function, we have to use a
globally declared variable.</p>

<p>That fact is not terribly controversial. Many examples online, and certainly in this
book, rely on globals. But given our limited space, it does require more of that
attention to detail. For example, I often use <code>int</code> for any numeric variable
that I know isn’t going to store numbers in the billions. It’s almost
muscle memory to type out <code>int count = 0;</code>. Well, if I’m going to be counting
successive button presses so that I can distinguish between single or double (or even
triple) clicks, that count fits easily in 
<span class="keep-together">a <code>byte</code>.</span> Remembering to use the smallest
appropriate data type is a great habit to 
<span class="keep-together">get into.</span></p>

<p>In fact, if you get <em>really</em> pressed for memory, remember that you can read and
manipulate individual bits using the operators we discussed in <a data-type="xref" href="ch04.xhtml#smallerc-CHP-4-SECT-3.4">“Bitwise Operators”</a>.
If you had two buttons and needed to track potential triple clicks, those counts could
<em>both</em> fit in one <code>byte</code> variable. Indeed, you could store the count of <em>four</em> buttons
in that variable. That’s definitely a little extreme, but again, when you need
it, every byte counts. We’re not on desktops<a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="SRAM" data-startref="ardmicro-memory-sram" id="idm45018717207992"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="SRAM" data-secondary-sortas="Arduino" data-startref="memory-arduino-sram" id="idm45018717206456"/><a data-type="indexterm" data-primary="SRAM (static random-access memory)" data-startref="sram" id="idm45018717204696"/> anymore, Toto.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="EEPROM"><div class="sect2" id="smallerc-CHP-9-SECT-3.3">
<h2>EEPROM</h2>

<p>If <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="EEPROM" id="ardmicro-memory-eeprom"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="EEPROM" data-secondary-sortas="Arduino" id="memory-arduino-eeprom"/><a data-type="indexterm" data-primary="EEPROM (electronically erasable programmable read-only memory)" id="eeprom"/>you did come to Arduino from the land of desktop computing, you may also have noticed
the lack of filesystem discussions. You likely weren’t surprised that a physical,
3.5” hard drive was not attached to your tiny microcontroller, but the lack of
long-term, read-write storage may have caught you off guard. Power cycle your Arduino,
and every variable starts off back at the beginning. Many, many satisfying projects
do not require any such storage, but some do. Happily, many controllers
have some (limited) capacity for storing values you can manipulate in the form of
electronically erasable programmable read-only memory, or <em>EEPROM</em>.</p>

<p>Not every microcontroller includes EEPROM. Enough don’t, in fact, that this
type of memory is not something the IDE expects you to use. You have to include
the <em>EEPROM.h</em> header manually to store and retrieve values from this area. We only
need two of the functions from this<a data-type="indexterm" data-primary="functions" data-secondary="for EEPROM" data-secondary-sortas="EEPROM" id="idm45018717195112"/><a data-type="indexterm" data-primary="get() function" id="idm45018717193864"/><a data-type="indexterm" data-primary="put() function" id="idm45018717193192"/> libray: <code>get()</code> and <code>put()</code>, but you can see the other functions available in the
<a href="https://oreil.ly/Hbgqn">EEPROM library documentation</a>.</p>

<p>Both functions take two arguments: an offset into EEPROM (the “address” in
the documentation) and some “data,” which can be a variable or <code>struct</code> for
<code>get()</code>, or also a literal value for <code>put()</code>. Putting and getting a <code>float</code>, for example,
would look something like this:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;EEPROM.h&gt;</code>

<code class="kt">float</code> <code class="n">temperature</code><code class="p">;</code>

<code class="kt">void</code> <code class="nf">setup</code><code class="p">()</code> <code class="p">{</code>
  <code class="n">EEPROM</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">temperature</code><code class="p">);</code>
  <code class="c1">// ... other initialization stuff</code>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">loop</code><code class="p">()</code> <code class="p">{</code>
  <code class="c1">// ... things happen, temperature changes</code>
  <code class="n">EEPROM</code><code class="p">.</code><code class="n">put</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">temperature</code><code class="p">);</code>
  <code class="c1">// things continue to happen ...</code>
<code class="p">}</code></pre>

<p>Notice that unlike the <code>scanf()</code> function we have used to accept input from users,
I did <em>not</em> use <code>&amp;</code> with the <code>temperature</code> variable in the call to <code>get()</code>. This
library does the work of assigning the value to the correct location for you. You
usually read from EEPROM during <code>setup()</code>, so hopefully it’s easy to be a little
careful and remember to use simple variables and not their addresses. In the snippet
above, <code>EEPROM.get()</code> will
fill our <code>temperature</code> variable with the value stored in EEPROM exactly as we expect.</p>

<p>Using <code>get()</code> and <code>put()</code> and remembering the exact byte offset of where you stored
your persistent values in EEPROM may seem tedious, and I agree that it is. In return,
however, you have total control over what goes
in and how you retrieve it. Just make sure that you manage your addresses correctly.
If you are storing two <code>float</code> numbers and a <code>byte</code>, in that order, you need to make sure
the second <code>float</code> is stored at address 4 and the <code>byte</code> at address 8. Or better yet,
use <code>sizeof</code> to advance a running location variable by exactly the right amount.</p>

<p>It’s important to know that
reading and writing to EEPROM is “expensive,” in that it is not a speedy
operation. EEPROM also has limits on how often it can be read and changed. You
aren’t likely to hit those read/write limits, and the speed is fine for
initializing our tiny projects, but EEPROM is definitely not a simple extension <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="EEPROM" data-startref="ardmicro-memory-eeprom" id="idm45018717148168"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="EEPROM" data-secondary-sortas="Arduino" data-startref="memory-arduino-eeprom" id="idm45018717146584"/><a data-type="indexterm" data-primary="EEPROM (electronically erasable programmable read-only memory)" data-startref="eeprom" id="idm45018717144824"/>of SRAM.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Remembering Choices"><div class="sect2" id="smallerc-CHP-9-SECT-3.4">
<h2>Remembering Choices</h2>

<p>All of<a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="LED lights example" id="ardmicro-memory-led"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="LED lights example" data-secondary-sortas="Arduino" id="memory-arduino-led"/><a data-type="indexterm" data-primary="LED lights" data-secondary="memory management example" id="LED-memory"/> this memory stuff sure is esoteric. I think it’s time for another kitchen
sink example! Let’s get that nifty LED ring wired back up and add a tactile button
to change its color. We’ll store the selected color in EEPROM, too, so that if
we shut off the Arduino and turn it back on later, the ring will light up with our most
recent choice. This project uses only the ring and the button, as shown in <a data-type="xref" href="#smallerc-CHP-9-FIG-eeprom-button-wiring">Figure 9-8</a>.</p>

<figure><div id="smallerc-CHP-9-FIG-eeprom-button-wiring" class="figure">
<img src="Images/smac_0908.png" alt="smac 0908" width="1328" height="945"/>
<h6><span class="label">Figure 9-8. </span>Wiring for our EEPROM demo with our LED ring and button</h6>
</div></figure>

<p>Along the way, we can use a new technique to debounce the button, and we’ll
even borrow the debounce concept to keep from writing to EEPROM too much. When you
let users change things, they often take you up on the offer and change them a lot.
If they press the button to change the color, we’ll wait a few seconds before
committing that change to EEPROM, in case they just want to quickly cycle through the
colors to see their options.</p>

<p>If you are up for a challenge, try sketching out (get it?) a solution yourself before
reviewing the code here. But that is a pretty hefty challenge. Feel free to enter
in this code or compile and upload
<a href="https://oreil.ly/yir2G"><em>ch09/ring_eeprom/ring_eeprom.ino</em></a>
if you’d rather just
get on with the joy of changing LED colors!</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;Adafruit_NeoPixel.h&gt;</code>
<code class="cp">#include &lt;EEPROM.h&gt;</code>

<code class="cp">#define RING_PIN    3</code>
<code class="cp">#define RING_COUNT 24</code>
<code class="cp">#define BUTTON_PIN  2</code>

<code class="kt">int</code> <code class="n">previousState</code> <code class="o">=</code> <code class="n">HIGH</code><code class="p">;</code>
<code class="kt">int</code> <code class="n">pause</code> <code class="o">=</code> <code class="mi">250</code><code class="p">;</code>
<code class="kt">int</code> <code class="n">countdown</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>

<code class="k">const</code> <code class="n">PROGMEM</code> <code class="kt">uint32_t</code> <code class="n">colors</code><code class="p">[]</code> <code class="o">=</code> <code class="p">{</code>
  <code class="mh">0xCC000000</code><code class="p">,</code> <code class="mh">0x00CC0000</code><code class="p">,</code> <code class="mh">0x0000CC00</code><code class="p">,</code> <code class="mh">0x000000CC</code><code class="p">,</code>
  <code class="mh">0xCC336699</code><code class="p">,</code> <code class="mh">0xCC663399</code><code class="p">,</code> <code class="mh">0xCC339966</code><code class="p">,</code> <code class="mh">0xCC996633</code>
<code class="p">};</code>
<code class="k">const</code> <code class="n">byte</code> <code class="n">colorCount</code> <code class="o">=</code> <code class="mi">8</code><code class="p">;</code>
<code class="n">byte</code> <code class="n">colorIndex</code><code class="p">;</code>

<code class="n">Adafruit_NeoPixel</code> <code class="nf">ring</code><code class="p">(</code><code class="n">RING_COUNT</code><code class="p">,</code> <code class="n">RING_PIN</code><code class="p">,</code> <code class="n">NEO_GRBW</code><code class="p">);</code>

<code class="kt">void</code> <code class="nf">setup</code><code class="p">()</code> <code class="p">{</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">begin</code><code class="p">(</code><code class="mi">115200</code><code class="p">);</code>
  <code class="n">pinMode</code><code class="p">(</code><code class="n">BUTTON_PIN</code><code class="p">,</code> <code class="n">INPUT_PULLUP</code><code class="p">);</code>
  <code class="n">retrieveIndex</code><code class="p">();</code>
  <code class="n">ring</code><code class="p">.</code><code class="n">begin</code><code class="p">();</code>             <code class="c1">// Initialize our ring</code>
  <code class="n">ring</code><code class="p">.</code><code class="n">setBrightness</code><code class="p">(</code><code class="mi">128</code><code class="p">);</code>  <code class="c1">// Set a comfortable mid-level brightness</code>
  <code class="n">ring</code><code class="p">.</code><code class="n">fill</code><code class="p">(</code><code class="n">pgm_read_dword</code><code class="p">(</code><code class="o">&amp;</code><code class="n">colors</code><code class="p">[</code><code class="n">colorIndex</code><code class="p">]));</code>
  <code class="n">ring</code><code class="p">.</code><code class="n">show</code><code class="p">();</code>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">loop</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">toggle</code> <code class="o">=</code> <code class="n">digitalRead</code><code class="p">(</code><code class="n">BUTTON_PIN</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">toggle</code> <code class="o">!=</code> <code class="n">previousState</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">toggle</code> <code class="o">==</code> <code class="n">LOW</code><code class="p">)</code> <code class="p">{</code>
      <code class="c1">// "falling" state, so do our work</code>
      <code class="n">previousState</code> <code class="o">=</code> <code class="n">LOW</code><code class="p">;</code>
      <code class="n">colorIndex</code><code class="o">++</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="n">colorIndex</code> <code class="o">&gt;=</code> <code class="n">colorCount</code><code class="p">)</code> <code class="p">{</code>
        <code class="n">colorIndex</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="n">ring</code><code class="p">.</code><code class="n">fill</code><code class="p">(</code><code class="n">pgm_read_dword</code><code class="p">(</code><code class="o">&amp;</code><code class="n">colors</code><code class="p">[</code><code class="n">colorIndex</code><code class="p">]));</code>
      <code class="n">ring</code><code class="p">.</code><code class="n">show</code><code class="p">();</code>
      <code class="n">countdown</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
      <code class="c1">// "rising", just record the new state</code>
      <code class="n">previousState</code> <code class="o">=</code> <code class="n">HIGH</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">countdown</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">countdown</code><code class="o">--</code><code class="p">;</code>
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">countdown</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Time's up! Record the current color index to EEPROM</code>
    <code class="n">countdown</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code> <code class="c1">// stop counting down</code>
    <code class="n">storeIndex</code><code class="p">();</code>
  <code class="p">}</code>
  <code class="n">delay</code><code class="p">(</code><code class="mi">100</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">retrieveIndex</code><code class="p">()</code> <code class="p">{</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">print</code><code class="p">(</code><code class="n">F</code><code class="p">(</code><code class="s">"RETRIEVE ... "</code><code class="p">));</code>
  <code class="n">EEPROM</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">colorIndex</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">colorIndex</code> <code class="o">&gt;=</code> <code class="n">colorCount</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="n">F</code><code class="p">(</code><code class="s">"ERROR, using default"</code><code class="p">));</code>
    <code class="c1">// Got a bad value from EEPROM, use default of 0</code>
    <code class="n">colorIndex</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="c1">// And try to store this good value</code>
    <code class="n">storeIndex</code><code class="p">();</code>
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="n">Serial</code><code class="p">.</code><code class="n">print</code><code class="p">(</code><code class="n">colorIndex</code><code class="p">);</code>
    <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="n">F</code><code class="p">(</code><code class="s">" OK"</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">storeIndex</code><code class="p">()</code> <code class="p">{</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">print</code><code class="p">(</code><code class="n">F</code><code class="p">(</code><code class="s">"STORE ... "</code><code class="p">));</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">print</code><code class="p">(</code><code class="n">colorIndex</code><code class="p">);</code>
  <code class="n">EEPROM</code><code class="p">.</code><code class="n">put</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">colorIndex</code><code class="p">);</code>
  <code class="n">Serial</code><code class="p">.</code><code class="n">println</code><code class="p">(</code><code class="n">F</code><code class="p">(</code><code class="s">" OK"</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>There are three parts of this program I specifically want to highlight. The first
is the use of the <code>previousState</code> variable to track the state of our button. Rather
than use a Boolean value to know if we are in the middle of a debounce period, I
only act on the button press when I notice it changing from a <code>HIGH</code> state to the
<code>LOW</code> state. It’s about the same amount of work, but I wanted to show you
an alternative.</p>

<p>The other two interesting parts are the functions at the bottom,
<code>retrieveIndex()</code> and <code>storeIndex()</code>. Here you can see the use of the EEPROM
functions. Storing the index is straightforward, but I added a safety check when
reading the index to make sure that it is a valid<a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="memory management" data-tertiary="LED lights example" data-startref="ardmicro-memory-led" id="idm45018717120296"/><a data-type="indexterm" data-primary="memory" data-secondary="in Arduino" data-tertiary="LED lights example" data-secondary-sortas="Arduino" data-startref="memory-arduino-led" id="idm45018717118712"/><a data-type="indexterm" data-primary="LED lights" data-secondary="memory management example" data-startref="LED-memory" id="idm45018716796616"/> value.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Interrupts"><div class="sect1" id="smallerc-CHP-9-SECT-4">
<h1>Interrupts</h1>

<p>There is <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="interrupts" data-tertiary="purpose of" id="ardmicro-interrupt-purpose"/><a data-type="indexterm" data-primary="input" data-secondary="interrupts" data-tertiary="purpose of" id="input-interrupt-purpose"/><a data-type="indexterm" data-primary="interrupts" data-secondary="purpose of" id="interrupt-purpose"/>one last bit of cool functionality that can streamline the code you
write to handle inputs like our tactile buttons. While not
peculiar to Arduino, the use of <em>interrupts</em> is not something many desktop
or web developers encounter anymore. Interrupts are hardware signals that
can trigger software responses. Interrupts can let you know that some network
data has arrived, or that a USB device was connected, or maybe a key was pressed.
They get their name from the advantageous fact that they “interrupt” the normal flow of your program and transfer control somewhere else.</p>

<p>I say advantageous because interrupts can significantly simplify the process of
worrying about asynchronous, unreliable events. Think about typing at your
keyboard. One way your operating system could go about “listening”
for keys to be pressed is to run a big loop and check every key, one after the
other, to see if it had been pressed recently. What a tedious task. Even if we
abstract things a little bit so that the operating system can ask if <em>any</em> key
has been pressed, we would need to ask this question of every input device. Every
hard drive, every thumb drive, the mouse, the mic, every USB port, etc., etc.
That type of polling just isn’t something we want to worry about. Interrupts
take away that worry. When a key is pressed, a signal arrives telling your
computer to go check the keyboard. It’s an on-demand system.</p>

<p>When such a demand is made, the computer typically goes to a function
you have supplied with the express intent of handling the interruption in
question. You register a handler and the operating system does the management
of stopping anything else that is happening and switching to that handler.</p>

<p>On an Arduino project, you can use interrupts for various input devices like
our tactile buttons. Rather than polling the button like we’ve done in
some of our previous projects, we can register a function for the button
press. We write our loop without any mention of the button. No polling,
no debounce flag or timer, nothing. The microcontroller is doing its own
internal work to watch each of its pins, and when one of them changes, say the
one attached to our button, an interrupt fires and we jump to our registered
function.</p>








<section data-type="sect2" data-pdf-bookmark="Interrupt Service Routines"><div class="sect2" id="smallerc-CHP-9-SECT-4.1">
<h2>Interrupt Service Routines</h2>

<p>An <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="interrupts" data-tertiary="ISRs (interrupt service routines)" id="ardmicro-interrupt-isr"/><a data-type="indexterm" data-primary="input" data-secondary="interrupts" data-tertiary="ISRs (interrupt service routines)" id="input-interrupt-isr"/><a data-type="indexterm" data-primary="interrupts" data-secondary="ISRs (interrupt service routines)" id="interrupt-isr"/><a data-type="indexterm" data-primary="ISRs (interrupt service routines)" id="isr"/><a data-type="indexterm" data-primary="functions" data-secondary="ISRs (interrupt service routines)" id="functions-isr"/>interrupt service routine, or ISR, is really just a function. But you do want to obey a few rules and a few guidelines:</p>

<ul>
<li>
<p>An ISR cannot have any parameters (rule)</p>
</li>
<li>
<p>An ISR should not return any values (guideline)</p>
</li>
<li>
<p>Timing functions like <code>delay()</code> and <code>millis()</code> themselves use
interrupts so you can’t use them inside an ISR (rule)<sup><a data-type="noteref" id="idm45018716772200-marker" href="ch09.xhtml#idm45018716772200">8</a></sup></p>
</li>
<li>
<p>Because you are “holding up the line” while inside your ISR, these functions
should be designed to run as quickly as possible (guideline)</p>
</li>
</ul>

<p>To register an ISR in Arduino, you use <a data-type="indexterm" data-primary="attachInterrupt() function" id="idm45018716768952"/>the <code>attachInterrupt()</code> function. That function
takes three arguments:</p>

<ul>
<li>
<p>The interrupt to listen for: use the function <code>digitalPinToInterrupt(pin)</code> for this argument</p>
</li>
<li>
<p>The ISR: just give the name of the function you want to use</p>
</li>
<li>
<p>The mode, one of:</p>

<ul>
<li>
<p><code>LOW</code>: triggered when the pin is LOW</p>
</li>
<li>
<p><code>CHANGE</code>: triggered when there is any change in the pin’s value</p>
</li>
<li>
<p><code>RISING</code>: triggered when the pin goes from <code>LOW</code> to <code>HIGH</code></p>
</li>
<li>
<p><code>FALLING</code>: triggered when the pin goes from <code>HIGH</code> to <code>LOW</code></p>
</li>
<li>
<p><code>HIGH</code>: some—but not all—boards support triggers when a pin is <code>HIGH</code></p>
</li>
</ul>
</li>
</ul>

<p>If you no longer want to handle an interrupt, you can<a data-type="indexterm" data-primary="detachInterrupt() function" id="idm45018716755080"/> use <code>detachInterrupt()</code>. That
function takes one argument, the same <code>digitalPinToInterrupt(pin)</code> as the first
argument to <code>attachInterrupt()</code>. (This helper function correctly translates your pin number
to the necessary interrupt number. It is not recommended to supply the <a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="interrupts" data-tertiary="ISRs (interrupt service routines)" data-startref="ardmicro-interrupt-isr" id="idm45018716752808"/><a data-type="indexterm" data-primary="input" data-secondary="interrupts" data-tertiary="ISRs (interrupt service routines)" data-startref="input-interrupt-isr" id="idm45018716751208"/><a data-type="indexterm" data-primary="interrupts" data-secondary="ISRs (interrupt service routines)" data-startref="interrupt-isr" id="idm45018716749704"/><a data-type="indexterm" data-primary="ISRs (interrupt service routines)" data-startref="isr" id="idm45018716748472"/><a data-type="indexterm" data-primary="functions" data-secondary="ISRs (interrupt service routines)" data-startref="functions-isr" id="idm45018716747512"/>interrupt number
directly.)</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Interrupt-Driven Programming"><div class="sect2" id="smallerc-CHP-9-SECT-4.2">
<h2>Interrupt-Driven Programming</h2>

<p>Let’s dive<a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="interrupts" data-tertiary="buttons example" id="ardmicro-interrupt-led"/><a data-type="indexterm" data-primary="input" data-secondary="interrupts" data-tertiary="buttons example" id="input-interrupt-led"/><a data-type="indexterm" data-primary="interrupts" data-secondary="buttons example" id="interrupt-led"/><a data-type="indexterm" data-primary="LED lights" data-secondary="interrupts example" id="LED-interrupt"/><a data-type="indexterm" data-primary="buttons" data-secondary="interrupts example" id="button-interrupt"/> into one more project to try harnessing an interrupt.
We’ll take our LED ring and light
up one LED after the other to make a cycling animation. We’ll use a
button to change the speed of that cycle. We certainly could write this
type of program without interrupts, but I think you’ll like how much
cleaner this project is than our example that polled the button to
change the color of the LED ring. We’ll actually use the exact same
hardware setup as we did for that project. You can look back at
<a data-type="xref" href="#smallerc-CHP-9-FIG-eeprom-button-wiring">Figure 9-8</a> if you need to re-create it.</p>

<p class="pagebreak-before less_space">As always, feel free to grab this sketch
(<a href="https://oreil.ly/iZ5JJ"><em>ch09/ring_interrupt/ring_interrupt.ino</em></a>),
or enter it yourself. The only wiring on this project is connecting the
power and ground of the NeoPixel ring and the data line to an acceptable pin on
your microcontroller. You’ll need to check the documentation for your board
to see which pins support interrupts. For our Metro Mini (compatible with the
Arduino Uno), we can use either pin 2 or pin 3:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#</code><code class="cp">include &lt;Adafruit_NeoPixel.h&gt;</code><code class="cp">
</code><code>
</code><code class="cp">#</code><code class="cp">define RING_PIN    3</code><code class="cp">
</code><code class="cp">#</code><code class="cp">define RING_COUNT 24</code><code class="cp">
</code><code class="cp">#</code><code class="cp">define BUTTON_PIN  2</code><code class="cp">
</code><code>
</code><code class="kt">int</code><code> </code><code class="n">pause</code><code> </code><code class="o">=</code><code> </code><code class="mi">1000</code><code class="p">;</code><code>                                            </code><a class="co" id="co_smaller_systems_CO3-1" href="#callout_smaller_systems_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>

</code><code class="n">Adafruit_NeoPixel</code><code> </code><code class="nf">ring</code><code class="p">(</code><code class="n">RING_COUNT</code><code class="p">,</code><code> </code><code class="n">RING_PIN</code><code class="p">,</code><code> </code><code class="n">NEO_GRBW</code><code class="p">)</code><code class="p">;</code><code>
</code><code>
</code><code class="kt">void</code><code> </code><code class="nf">nextPause</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>                                           </code><a class="co" id="co_smaller_systems_CO3-2" href="#callout_smaller_systems_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="n">pause</code><code> </code><code class="o">=</code><code class="o">=</code><code> </code><code class="mi">250</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>    </code><code class="n">pause</code><code> </code><code class="o">=</code><code> </code><code class="mi">1000</code><code class="p">;</code><code>
</code><code>  </code><code class="p">}</code><code> </code><code class="k">else</code><code> </code><code class="p">{</code><code>
</code><code>    </code><code class="n">pause</code><code> </code><code class="o">/</code><code class="o">=</code><code> </code><code class="mi">2</code><code class="p">;</code><code>
</code><code>  </code><code class="p">}</code><code>
</code><code class="p">}</code><code>
</code><code>
</code><code class="kt">void</code><code> </code><code class="nf">setup</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>  </code><code class="n">pinMode</code><code class="p">(</code><code class="n">BUTTON_PIN</code><code class="p">,</code><code> </code><code class="n">INPUT_PULLUP</code><code class="p">)</code><code class="p">;</code><code>                         </code><a class="co" id="co_smaller_systems_CO3-3" href="#callout_smaller_systems_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code class="n">attachInterrupt</code><code class="p">(</code><code class="n">digitalPinToInterrupt</code><code class="p">(</code><code class="n">BUTTON_PIN</code><code class="p">)</code><code class="p">,</code><code>         </code><a class="co" id="co_smaller_systems_CO3-4" href="#callout_smaller_systems_CO3-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
      </code><code class="n">nextPause</code><code class="p">,</code><code> </code><code class="n">FALLING</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="n">ring</code><code class="p">.</code><code class="n">begin</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>             </code><code class="c1">// Initialize our ring           </code><a class="co" id="co_smaller_systems_CO3-5" href="#callout_smaller_systems_CO3-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code class="c1">
</code><code>  </code><code class="n">ring</code><code class="p">.</code><code class="n">setBrightness</code><code class="p">(</code><code class="mi">128</code><code class="p">)</code><code class="p">;</code><code>  </code><code class="c1">// Set a comfortable brightness
</code><code>  </code><code class="n">ring</code><code class="p">.</code><code class="n">show</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>              </code><code class="c1">// Start with all pixels off
</code><code class="p">}</code><code>
</code><code>
</code><code class="kt">void</code><code> </code><code class="nf">loop</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>  </code><code class="k">for</code><code> </code><code class="p">(</code><code class="kt">int</code><code> </code><code class="n">p</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code class="p">;</code><code> </code><code class="n">p</code><code> </code><code class="o">&lt;</code><code> </code><code class="n">RING_COUNT</code><code class="p">;</code><code> </code><code class="n">p</code><code class="o">+</code><code class="o">+</code><code class="p">)</code><code> </code><code class="p">{</code><code>                     </code><a class="co" id="co_smaller_systems_CO3-6" href="#callout_smaller_systems_CO3-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a><code>
    </code><code class="n">ring</code><code class="p">.</code><code class="n">clear</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="n">ring</code><code class="p">.</code><code class="n">setPixelColor</code><code class="p">(</code><code class="n">p</code><code class="p">,</code><code> </code><code class="mi">0</code><code class="p">,</code><code> </code><code class="mi">255</code><code class="p">,</code><code> </code><code class="mi">0</code><code class="p">,</code><code> </code><code class="mi">0</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="n">ring</code><code class="p">.</code><code class="n">show</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="n">delay</code><code class="p">(</code><code class="n">pause</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="p">}</code><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_smaller_systems_CO3-1" href="#co_smaller_systems_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Set an initial pause duration of 1 second for our ring animation.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO3-2" href="#co_smaller_systems_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Create a concise function to respond to button presses by cycling through different pause durations.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO3-3" href="#co_smaller_systems_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Setup our button pin as an <code>INPUT_PULLUP</code>, just as we have before.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO3-4" href="#co_smaller_systems_CO3-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Configure <code>nextPause()</code> to handle the event of our button being pressed.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO3-5" href="#co_smaller_systems_CO3-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Set up our LED ring, also like we have before.</p></dd>
<dt><a class="co" id="callout_smaller_systems_CO3-6" href="#co_smaller_systems_CO3-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>Our animation loop does not have to include any button-polling logic (hooray!).</p></dd>
</dl>

<p>Hopefully, this feels simpler than our other projects that included buttons. Our
<code>loop()</code> function is devoted solely to driving the animated pixel around the ring.
And although I use the <code>FALLING</code> mode to trigger the interrupt, we could have
used <code>RISING</code> just as easily for this example. Changing that mode is a great
tweak to try now if you’re curious about the<a data-type="indexterm" data-primary="Arduino microcontrollers" data-secondary="interrupts" data-tertiary="buttons example" data-startref="ardmicro-interrupt-led" id="idm45018716323736"/><a data-type="indexterm" data-primary="input" data-secondary="interrupts" data-tertiary="buttons example" data-startref="input-interrupt-led" id="idm45018716322408"/><a data-type="indexterm" data-primary="interrupts" data-secondary="buttons example" data-startref="interrupt-led" id="idm45018716321080"/><a data-type="indexterm" data-primary="LED lights" data-secondary="interrupts example" data-startref="LED-interrupt" id="idm45018716319992"/><a data-type="indexterm" data-primary="buttons" data-secondary="interrupts example" data-startref="button-interrupt" id="idm45018716318904"/> effect.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="smallerc-CHP-9-SECT-5">
<h1>Exercises</h1>

<p>Now that we’ve seen several sketches up and running with help from the Arduino
environment to make use of some interesting peripherals, here are a few small projects
you can try to test your new skills. I’m including the wiring diagrams for my setups,
but you are certainly welcome to arrange the components however you like and use
whichever pins are appropriate for your microcontroller. The solutions are in the
<a href="https://oreil.ly/ezhYB"><em>ch09/exercises</em></a> folder.</p>
<ol>
<li>
<p><em>Automatic night-light</em>. With a photoresistor and an LED (see <a data-type="xref" href="#smallerc-CHP-9-FIG-night-light-wiring">Figure 9-9</a>), create a night-light that responds to a decrease in light by increasing the brightness of the LED. Try using the <code>map()</code> function to convert the sensor reading value to an appropriate LED value. (You can use a NeoPixel or a regular LED with PWM.)</p>

<figure class="width-55"><div id="smallerc-CHP-9-FIG-night-light-wiring" class="figure">
<img src="Images/smac_0909.png" alt="smac 0909" width="890" height="702"/>
<h6><span class="label">Figure 9-9. </span>Wiring for an automatic night-light</h6>
</div></figure>
</li>

</ol>
<ol class="pagebreak-before" start="2">
<li>
<p><em>Stopwatch</em>. Use our 4-digit display and one button (see <a data-type="xref" href="#smallerc-CHP-9-FIG-stopwatch-wiring">Figure 9-10</a>) to create a stopwatch. When you first press the button, the stopwatch starts and tracks the elapsed time in seconds (up to 99:99 seconds). Pressing the button again will stop the count. Pressing it a third time will reset the stopwatch to 0:00.</p>

<figure class="width-55"><div id="smallerc-CHP-9-FIG-stopwatch-wiring" class="figure">
<img src="Images/smac_0910.png" alt="smac 0910" width="948" height="738"/>
<h6><span class="label">Figure 9-10. </span>Wiring for a simple stopwatch</h6>
</div></figure>
</li>

</ol>
<ol start="3">
<li>
<p><em>Scoreboard</em>. Use four buttons and a 4-digit display (see <a data-type="xref" href="#smallerc-CHP-9-FIG-scoreboard-wiring">Figure 9-11</a>) to run a small scoreboard for two teams. The left two digits of the display will keep the score for team 1, the right two digits for team 2. Use two buttons for each team: one to increase their score and one to decrease it. Start small and build up. Get one button working. Then get one team working. Finally, get both teams working. You may need to consult the documentation for your segmented display library to make sure you can update the score for one team without clobbering the score for the other team.</p>

<figure class="width-55"><div id="smallerc-CHP-9-FIG-scoreboard-wiring" class="figure">
<img src="Images/smac_0911.png" alt="smac 0911" width="977" height="738"/>
<h6><span class="label">Figure 9-11. </span>Wiring for a scoreboard</h6>
</div></figure>
</li>

</ol>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Next Steps"><div class="sect1" id="smallerc-CHP-9-SECT-6">
<h1>Next Steps</h1>

<p>My goodness that was a lot of code. But I sincerely hope you enjoyed our tour
of the functions and features available for programming in Arduino. We tried out
several new peripherals and covered the ways Arduino programmers can work with limited
memory. We also introduced the topic of
<a href="https://oreil.ly/z4YpN">interrupts</a>.
You are wholly encouraged to feel overwhelmed! Hopefully not discouraged, though. If any
of the examples remain unclear, let them sit a day or two and come back to try again.</p>

<p>The next chapter won’t be quite so intense. In the discussion on memory, we
saw that sometimes you have to be a bit clever when dealing with microcontrollers.
We’ll take a look at how you
can optimize some patterns common in Arduino programming by concentrating on
a single, simple example.
The optimizations are certainly valid on desktops, too, they just might not make as
much of an impact. But right now, we’re still focusing on Arduino, so read on
to see just how much of an impact a few small changes can have!</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45018719041400"><sup><a href="ch09.xhtml#idm45018719041400-marker">1</a></sup> Generic C calls these named values <em>symbolic constants</em>. I’ll use the unqualified “constant” to match the Arduino documentation.</p><p data-type="footnote" id="idm45018718922072"><sup><a href="ch09.xhtml#idm45018718922072-marker">2</a></sup> This is true for GCC, but some compilers use wholly separate executables for preprocessing and compiling.</p><p data-type="footnote" id="idm45018718661080"><sup><a href="ch09.xhtml#idm45018718661080-marker">3</a></sup> The Arduino Language provides some alternate names for these functions with slightly different casing that you might find more readable, like <code>isDigit()</code> and <code>isUpperCase()</code>.</p><p data-type="footnote" id="idm45018718648824"><sup><a href="ch09.xhtml#idm45018718648824-marker">4</a></sup> On typical pinout diagrams, digital pins that can do PWM often have a ~ prefix or other distinguishing mark.</p><p data-type="footnote" id="idm45018718211544"><sup><a href="ch09.xhtml#idm45018718211544-marker">5</a></sup> Other popular driver chips such as the MAX7219 will have similar search results.</p><p data-type="footnote" id="idm45018718210600"><sup><a href="ch09.xhtml#idm45018718210600-marker">6</a></sup> If you are using a similar display, it has a nicely documented repo on <a href="https://oreil.ly/RVv2F">GitHub</a>.</p><p data-type="footnote" id="idm45018717257432"><sup><a href="ch09.xhtml#idm45018717257432-marker">7</a></sup> Dynamic random-access memory, or <em>DRAM</em>, is <a data-type="indexterm" data-primary="DRAM (dynamic random-access memory)" id="idm45018717256280"/><a data-type="indexterm" data-primary="volatile memory" id="idm45018717255528"/>the type of memory you buy in “sticks” and physically insert into your aging Windows 7 box so you can eke one more year out of it. The “dynamic” term here indicates this RAM needs to be refreshed periodically by drawing a little power—in contrast to SRAM, which does not. Both types, however, require at least <em>some</em> power and are therefore termed <em>volatile</em>, as their contents will be reset during a power cycle.</p><p data-type="footnote" id="idm45018716772200"><sup><a href="ch09.xhtml#idm45018716772200-marker">8</a></sup> The <code>micros()</code> function will work, but only for a millisecond or two. <code>delayMicroseconds()</code> uses a different mechanism to pause, so it actually can be used. But you really don’t want to delay inside an ISR at all if you can help it.</p></div></div></section></div></body></html>