["```cpp\n    void main()\n    {\n      int my_data;\n    }\n    ```", "```cpp\n    int my_global_data;\n    static int my_fileglobal_data;\n    void main()\n    {\n      static int my_local_data;\n    }\n    ```", "```cpp\n    void main()\n    {\n      char* my_string = \"Hello World\";\n    }\n    ```", "```cpp\n    void main()\n    {\n      void* my_data = malloc(1000);\n      /* work with the allocated 1000 byte memory */\n      free(my_data);\n    }\n    ```", "```cpp\n/* Performs a Caesar encryption with the fixed key 3.\n   The parameter 'text' must contain a text with only capital letters.\n   The parameter 'length' must contain the length of the text excluding\n   NULL termination. */\nvoid caesar(char* text, int length)\n{\n  for(int i=0; i<length; i++)\n  {\n    text[i] = text[i]+3; ![1](assets/1.png)\n    if(text[i] > 'Z')\n    {\n      text[i] = text[i] - 'Z' + 'A' - 1; ![2](assets/2.png)\n    }\n  }\n}\n```", "```cpp\nvoid someCode()\n{\n  /* This variable is an automatic variable that is put on the stack and\n that will run out of scope at the end of the function */\n  int my_variable;\n\n  {\n    /* This variable is an automatic variable that is put on the stack and\n that will run out of scope right after this code block, which is\n after the first '}' */\n    int my_array[10];\n  }\n}\n```", "```cpp\n#define MAX_TEXT_SIZE 64\n\nvoid encryptCaesarText()\n{\n  char text[MAX_TEXT_SIZE];\n  strlcpy(text, \"PLAINTEXT\", MAX_TEXT_SIZE);\n  caesar(text, strnlen(text, MAX_TEXT_SIZE));\n  printf(\"Encrypted text: %s\\n\", text);\n}\n```", "```cpp\n#define ARRAY_SIZE 1024\n\nint global_array[ARRAY_SIZE]; /* variable in static memory, global scope */\nstatic int file_global_array[ARRAY_SIZE]; /* variable in static memory with\n scope limited to this file */\n\nvoid someCode()\n{\n  static int local_array[ARRAY_SIZE]; /* variable in static memory with\n scope limited to this function */\n}\n```", "```cpp\n#define MAX_TEXT_SIZE 1024\n\nvoid encryptCaesarText()\n{\n  static char text[MAX_TEXT_SIZE];\n  strlcpy(text, \"LARGETEXTTHATCOULDBETHOUSANDCHARACTERSLONG\", MAX_TEXT_SIZE);\n  caesar(text, strnlen(text, MAX_TEXT_SIZE));\n  printf(\"Encrypted text: %s\\n\", text);\n}\n```", "```cpp\nvoid encryptCaesarText()\n{\n  /* open file (omit error handling to keep the code simple) */\n  FILE* f = fopen(\"my-file.txt\", \"r\");\n\n  /* get file length */\n  fseek(f, 0, SEEK_END);\n  int size = ftell(f);\n\n  /* allocate buffer */\n  char* text = malloc(size);\n\n  ...\n}\n```", "```cpp\nvoid someCode()\n{\n  char* memory = malloc(size);\n  ...\n  /* do something with the memory */\n  ...\n  /* don't care about freeing the memory */\n}\n```", "```cpp\n/* Returns the length of the file with the provided 'filename' */\nint getFileLength(char* filename)\n{\n  FILE* f = fopen(filename, \"r\");\n  fseek(f, 0, SEEK_END);\n  int file_length = ftell(f);\n  fclose(f);\n  return file_length;\n}\n\n/* Stores the content of the file with the provided 'filename' into the\n provided  'buffer' (which has to be least of size 'file_length'). The\n file must only contain capital letters with no newline in between\n (that's what our caesar function accepts as input). */\nvoid readFileContent(char* filename, char* buffer, int file_length)\n{\n  FILE* f = fopen(filename, \"r\");\n  fseek(f, 0, SEEK_SET);\n  int read_elements = fread(buffer, 1, file_length, f);\n  buffer[read_elements] = '\\0';\n  fclose(f);\n}\n\nvoid encryptCaesarFile()\n{\n  char* text;\n  int size = getFileLength(\"my-file.txt\");\n  if(size>0)\n  {\n    text = malloc(size);\n    readFileContent(\"my-file.txt\", text, size);\n    caesar(text, strnlen(text, size));\n    printf(\"Encrypted text: %s\\n\", text);\n    /* you don't free the memory here */\n  }\n}\n```", "```cpp\n#define DATA_SIZE 1024\nvoid function()\n{\n  char* memory = malloc(DATA_SIZE);\n  /* work with memory */\n  free(memory);\n}\n```", "```cpp\n/* Allocates and returns a buffer that has to be freed by the caller */\nchar* functionA()\n{\n  char* memory = malloc(data_size); ![1](assets/1.png)\n  /* fill memory */\n  return memory;\n}\n\nvoid functionB()\n{\n  char* memory = functionA();\n  /* work with the memory */\n  free(memory); ![2](assets/2.png)\n}\n```", "```cpp\n/* For the provided 'filename', this function reads text from the file and\n prints the Caesar-encrypted text. This function is responsible for\n allocating and deallocating the required buffers for storing the\n file content */\nvoid encryptCaesarFile(char* filename)\n{\n  char* text;\n  int size = getFileLength(filename);\n  if(size>0)\n  {\n    text = malloc(size);\n    readFileContent(filename, text, size);\n    caesar(text, strnlen(text, size));\n    printf(\"Encrypted text: %s\\n\", text);\n    free(text);\n  }\n}\n\n/* For all files in the current directory, this function reads text\n from the file and prints the Caesar-encrypted text. */\nvoid encryptDirectoryContent()\n{\n  struct dirent *directory_entry;\n  DIR *directory = opendir(\".\");\n  while ((directory_entry = readdir(directory)) != NULL)\n  {\n    encryptCaesarFile(directory_entry->d_name);\n  }\n  closedir(directory);\n}\n```", "```cpp\nvoid* checkedMalloc(size_t size)\n{\n  void* pointer = malloc(size);\n  assert(pointer);\n  return pointer;\n}\n\n#define DATA_SIZE 1024\nvoid someFunction()\n{\n  char* memory = checkedMalloc(DATA_SIZE);\n  /* work with the memory */\n  free(memory);\n}\n```", "```cpp\n#define NEW(object, type)                   \\\ndo {                                        \\\n object = malloc(sizeof(type));            \\\n if(!object)                               \\\n {                                         \\\n printf(\"Malloc Error: %s\\n\", __func__); \\\n assert(false);                          \\\n }                                         \\\n} while (0)\n\n#define DELETE(object) free(object)\n\ntypedef struct{\n  int x;\n  int y;\n}MyStruct;\n\nvoid someFunction()\n{\n  MyStruct* myObject;\n  NEW(myObject, MyStruct);\n  /* work with the object */\n  DELETE(myObject);\n}\n```", "```cpp\n/* Allocates memory and asserts if no memory is available */\nvoid* safeMalloc(size_t size)\n{\n  void* pointer = malloc(size);\n  assert(pointer); ![1](assets/1.png)\n  return pointer;\n}\n\n/* Deallocates the memory of the provided 'pointer' */\nvoid safeFree(void *pointer)\n{\n  free(pointer);\n}\n\n/* For the provided file 'filename', this function reads text from the file\n   and prints the Caesar-encrypted text. This function is responsible for\n   allocating and deallocating the required buffers for storing the\n   file content */\nvoid encryptCaesarFile(char* filename)\n{\n  char* text;\n  int size = getFileLength(filename);\n  if(size>0)\n  {\n    text = safeMalloc(size);\n    readFileContent(filename, text, size);\n    caesar(text, strnlen(text, size));\n    printf(\"Encrypted text: %s\\n\", text);\n    safeFree(text);\n  }\n}\n```", "```cpp\nvoid someFunction()\n{\n  char* pointer = NULL; /* explicitly invalidate the uninitialized pointer */\n  pointer = malloc(1024);\n\n  if (pointer != NULL) /* check pointer validity before accessing it */\n  {\n    /* work with pointer*/\n  }\n\n  free(pointer);\n  pointer = NULL; /* explicitly invalidate the pointer to freed memory */\n}\n```", "```cpp\n/* For the provided file 'filename', this function reads text from the file\n   and prints the Caesar-encrypted text. This function is responsible for\n   allocating and deallocating the required buffers for storing the\n   file content */\nvoid encryptCaesarFile(char* filename)\n{\n  char* text = NULL; ![1](assets/1.png)\n  int size = getFileLength(filename);\n  if(size>0)\n  {\n    text = safeMalloc(size);\n    if(text != NULL) ![2](assets/2.png)\n    {\n      readFileContent(filename, text, size);\n      caesar(text, strnlen(text, size));\n      printf(\"Encrypted text: %s\\n\", text);\n    }\n    safeFree(text);\n    text = NULL; ![1](assets/1.png)\n  }\n}\n```", "```cpp\n#define MAX_ELEMENTS 20;\n#define ELEMENT_SIZE 255;\n\ntypedef struct\n{\n  bool occupied;\n  char memory[ELEMENT_SIZE];\n}PoolElement;\n\nstatic PoolElement memory_pool[MAX_ELEMENTS];\n\n/* Returns memory of at least the provided 'size' or NULL\n if no memory chunk from the pool is available */\nvoid* poolTake(size_t size)\n{\n  if(size <= ELEMENT_SIZE)\n  {\n    for(int i=0; i<MAX_ELEMENTS; i++)\n    {\n      if(memory_pool[i].occupied == false)\n      {\n        memory_pool[i].occupied = true;\n        return &(memory_pool[i].memory);\n      }\n    }\n  }\n  return NULL;\n}\n\n/* Gives the memory chunk ('pointer') back to the pool */\nvoid poolRelease(void* pointer)\n{\n  for(int i=0; i<MAX_ELEMENTS; i++)\n  {\n    if(&(memory_pool[i].memory) == pointer)\n    {\n      memory_pool[i].occupied = false;\n      return;\n    }\n  }\n}\n```", "```cpp\n#define ELEMENT_SIZE 255\n#define MAX_ELEMENTS 10\n\ntypedef struct\n{\n  bool occupied;\n  char memory[ELEMENT_SIZE];\n}PoolElement;\n\nstatic PoolElement memory_pool[MAX_ELEMENTS];\n\nvoid* poolTake(size_t size)\n{\n  if(size <= ELEMENT_SIZE)\n  {\n    for(int i=0; i<MAX_ELEMENTS; i++)\n    {\n      if(memory_pool[i].occupied == false)\n      {\n        memory_pool[i].occupied = true;\n        return &(memory_pool[i].memory);\n      }\n    }\n  }\n  return NULL;\n}\n\nvoid poolRelease(void* pointer)\n{\n  for(int i=0; i<MAX_ELEMENTS; i++)\n  {\n    if(&(memory_pool[i].memory) == pointer)\n    {\n      memory_pool[i].occupied = false;\n      return;\n    }\n  }\n}\n\n#define MAX_FILENAME_SIZE ELEMENT_SIZE\n\n/* Prints the Caesar-encrypted 'filename'.This function is responsible for\n allocating and deallocating the required buffers for storing the\n file content.\n Notes: The filename must be all capital letters and we accept that the\n '.' of the filename will also be shifted by the Caesar encryption. */\nvoid encryptCaesarFilename(char* filename)\n{\n  char* buffer = poolTake(MAX_FILENAME_SIZE);\n  if(buffer != NULL)\n  {\n    strlcpy(buffer, filename, MAX_FILENAME_SIZE);\n    caesar(buffer, strnlen(buffer, MAX_FILENAME_SIZE));\n    printf(\"\\nEncrypted filename: %s \", buffer);\n    poolRelease(buffer);\n  }\n}\n\n/* For all files in the current directory, this function reads text from the\n file and prints the Caesar-encrypted text. */\nvoid encryptDirectoryContent()\n{\n  struct dirent *directory_entry;\n  DIR *directory = opendir(\".\");\n  while((directory_entry = readdir(directory)) != NULL)\n  {\n    encryptCaesarFilename(directory_entry->d_name);\n    encryptCaesarFile(directory_entry->d_name);\n  }\n  closedir(directory);\n}\n```"]