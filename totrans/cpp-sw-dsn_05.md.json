["```cpp\n//---- <Shape.h> ---------------- \nclass Shape\n{\n public:\n   virtual ~Shape() = default;\n\n   virtual void draw( /*some arguments*/ ) const = 0;  ![1](assets/1.png)\n};\n\n//---- <Circle.h> ---------------- \n#include <Point.h>\n#include <Shape.h>\n\nclass Circle : public Shape\n{\n public:\n   explicit Circle( double radius )\n      : radius_( radius )\n   {\n      /* Checking that the given radius is valid */\n   }\n\n   double radius() const { return radius_; }\n   Point  center() const { return center_; }\n\n   void draw( /*some arguments*/ ) const override;  ![2](assets/2.png)\n\n private:\n   double radius_;\n   Point center_{};\n};\n\n//---- <Circle.cpp> ---------------- \n#include <Circle.h>\n#include /* some graphics library */\n\nvoid Circle::draw( /*some arguments*/ ) const\n{\n   // ... Implementing the logic for drawing a circle }\n\n//---- <Square.h> ---------------- \n#include <Point.h>\n#include <Shape.h>\n\nclass Square : public Shape\n{\n public:\n   explicit Square( double side )\n      : side_( side )\n   {\n      /* Checking that the given side length is valid */\n   }\n\n   double side  () const { return side_; }\n   Point  center() const { return center_; }\n\n   void draw( /*some arguments*/ ) const override;  ![3](assets/3.png)\n\n private:\n   double side_;\n   Point center_{};\n};\n\n//---- <Square.cpp> ---------------- \n#include <Square.h>\n#include /* some graphics library */\n\nvoid Square::draw( /*some arguments*/ ) const\n{\n   // ... Implementing the logic for drawing a square }\n\n```", "```cpp\n//---- <Circle.h> ----------------\n\n#include <Shape.h>\n\nclass Circle : public Shape\n{\n public:\n   // ... No implementation of the draw() member function anymore\n};\n\n//---- <OpenGLCircle.h> ----------------\n\n#include <Circle.h>\n\nclass OpenGLCircle : public Circle\n{\n public:\n   explicit OpenGLCircle( double radius )\n      : Circle( radius )\n   {}\n\n   void draw( /*some arguments*/ ) const override;\n};\n\n//---- <OpenGLCircle.cpp> ----------------\n\n#include <OpenGLCircle.h>\n#include /* OpenGL graphics library headers */\n\nvoid OpenGLCircle::draw( /*some arguments*/ ) const\n{\n   // ... Implementing the logic for drawing a circle by means of OpenGL\n}\n\n//---- <Square.h> ----------------\n\n#include <Shape.h>\n\nclass Square : public Shape\n{\n public:\n   // ... No implementation of the draw() member function anymore\n};\n\n//---- <OpenGLSquare.h> ----------------\n\n#include <Square.h>\n\nclass OpenGLSquare : public Square\n{\n public:\n   explicit OpenGLSquare( double side )\n      : Square( side )\n   {}\n\n   void draw( /*some arguments*/ ) const override;\n};\n\n//---- <OpenGLSquare.cpp> ----------------\n\n#include <OpenGLSquare.h>\n#include /* OpenGL graphics library headers */\n\nvoid OpenGLSquare::draw( /*some arguments*/ ) const\n{\n   // ... Implementing the logic for drawing a square by means of OpenGL\n}\n```", "```cpp\nclass Shape\n{\n public:\n   virtual ~Shape() = default;\n\n   virtual void draw( /*some arguments*/ ) const = 0;\n   virtual void serialize( /*some arguments*/ ) const = 0;  ![4](assets/4.png)\n};\n\n```", "```cpp\n//---- <DrawStrategy.h> ---------------- \nclass Circle;\nclass Square;\n\nclass DrawStrategy\n{\n public:\n   virtual ~DrawStrategy() = default;\n\n   virtual void draw( Circle const& circle, /*some arguments*/ ) const = 0;  ![5](assets/5.png)\n   virtual void draw( Square const& square, /*some arguments*/ ) const = 0;  ![6](assets/6.png)\n};\n\n```", "```cpp\n//---- <Shape.h> ----------------\n\nclass Shape\n{\n public:\n   virtual ~Shape() = default;\n\n   virtual void draw( /*some arguments*/ ) const = 0;\n   // ... Potentially other functions, e.g. a 'serialize()' member function\n};\n```", "```cpp\n//---- <Circle.h> ---------------- \n#include <Shape.h>\n#include <DrawStrategy.h>\n#include <memory>\n#include <utility>\n\nclass Circle : public Shape\n{\n public:\n   explicit Circle( double radius, std::unique_ptr<DrawStrategy> drawer )  ![7](assets/7.png)\n      : radius_( radius )\n      , drawer_( std::move(drawer) )  ![8](assets/8.png)\n   {\n      /* Checking that the given radius is valid and that\n         the given std::unique_ptr instance is not nullptr */\n   }\n\n   void draw( /*some arguments*/ ) const override\n   {\n      drawer_->draw( *this, /*some arguments*/ );  ![10](assets/10.png)\n   }\n\n   double radius() const { return radius_; }\n\n private:\n   double radius_;\n   std::unique_ptr<DrawStrategy> drawer_;  ![9](assets/9.png)\n};\n\n//---- <Square.h> ---------------- \n#include <Shape.h>\n#include <DrawStrategy.h>\n#include <memory>\n#include <utility>\n\nclass Square : public Shape\n{\n public:\n   explicit Square( double side, std::unique_ptr<DrawStrategy> drawer )  ![7](assets/7.png)\n      : side_( side )\n      , drawer_( std::move(drawer) )  ![8](assets/8.png)\n   {\n      /* Checking that the given side length is valid and that\n         the given std::unique_ptr instance is not nullptr */\n   }\n\n   void draw( /*some arguments*/ ) const override\n   {\n      drawer_->draw( *this, /*some arguments*/ );  ![10](assets/10.png)\n   }\n\n   double side() const { return side_; }\n\n private:\n   double side_;\n   std::unique_ptr<DrawStrategy> drawer_;  ![9](assets/9.png)\n};\n\n```", "```cpp\n//---- <DrawCircleStrategy.h> ---------------- \nclass Circle;\n\nclass DrawCircleStrategy  ![11](assets/11.png)\n{\n public:\n   virtual ~DrawCircleStrategy() = default;\n\n   virtual void draw( Circle const& circle, /*some arguments*/ ) const = 0;\n};\n\n//---- <Circle.h> ---------------- \n#include <Shape.h>\n#include <DrawCircleStrategy.h>\n#include <memory>\n#include <utility>\n\nclass Circle : public Shape\n{\n public:\n   explicit Circle( double radius, std::unique_ptr<DrawCircleStrategy> drawer )\n      : radius_( radius )\n      , drawer_( std::move(drawer) )\n   {\n      /* Checking that the given radius is valid and that\n         the given 'std::unique_ptr' is not a nullptr */\n   }\n\n   void draw( /*some arguments*/ ) const override\n   {\n      drawer_->draw( *this, /*some arguments*/ );\n   }\n\n   double radius() const { return radius_; }\n\n private:\n   double radius_;\n   std::unique_ptr<DrawCircleStrategy> drawer_;\n};\n\n//---- <DrawSquareStrategy.h> ---------------- \nclass Square;\n\nclass DrawSquareStrategy  ![12](assets/12.png)\n{\n public:\n   virtual ~DrawSquareStrategy() = default;\n\n   virtual void draw( Square const& square, /*some arguments*/ ) const = 0;\n};\n\n//---- <Square.h> ---------------- \n#include <Shape.h>\n#include <DrawSquareStrategy.h>\n#include <memory>\n#include <utility>\n\nclass Square : public Shape\n{\n public:\n   explicit Square( double side, std::unique_ptr<DrawSquareStrategy> drawer )\n      : side_( side )\n      , drawer_( std::move(drawer) )\n   {\n      /* Checking that the given side length is valid and that\n         the given 'std::unique_ptr' is not a nullptr */\n   }\n\n   void draw( /*some arguments*/ ) const override\n   {\n      drawer_->draw( *this, /*some arguments*/ );\n   }\n\n   double side() const { return side_; }\n\n private:\n   double side_;\n   std::unique_ptr<DrawSquareStrategy> drawer_;\n};\n\n```", "```cpp\n//---- <OpenGLCircleStrategy.h> ----------------\n\n#include <Circle.h>\n#include <DrawCircleStrategy.h>\n#include /* OpenGL graphics library */\n\nclass OpenGLCircleStrategy : public DrawCircleStrategy\n{\n public:\n   explicit OpenGLCircleStrategy( /* Drawing related arguments */ );\n\n   void draw( Circle const& circle, /*...*/ ) const override;\n\n private:\n   /* Drawing related data members, e.g. colors, textures, ... */\n};\n```", "```cpp\n//---- <DrawStrategy.h> ----------------\n\ntemplate< typename T >\nclass DrawStrategy\n{\n public:\n   virtual ~DrawStrategy() = default;\n   virtual void draw( T const& ) const = 0;\n};\n```", "```cpp\n//---- <OpenGLCircleStrategy.h> ----------------\n\n#include <Circle.h>\n#include <DrawStrategy.h>\n#include /* OpenGL graphics library */\n\nclass OpenGLCircleStrategy : public DrawStrategy<Circle>\n{\n   // ...\n};\n```", "```cpp\n#include <Circle.h>\n#include <Square.h>\n#include <OpenGLCircleStrategy.h>\n#include <OpenGLSquareStrategy.h>\n#include <memory>\n#include <vector>\n\nint main()\n{\n   using Shapes = std::vector<std::unique_ptr<Shape>>;\n\n   Shapes shapes{};\n\n   // Creating some shapes, each one\n   //   equipped with the corresponding OpenGL drawing strategy\n   shapes.emplace_back(\n      std::make_unique<Circle>(\n         2.3, std::make_unique<OpenGLCircleStrategy>(/*...red...*/) ) );\n   shapes.emplace_back(\n      std::make_unique<Square>(\n         1.2, std::make_unique<OpenGLSquareStrategy>(/*...green...*/) ) );\n   shapes.emplace_back(\n      std::make_unique<Circle>(\n         4.1, std::make_unique<OpenGLCircleStrategy>(/*...blue...*/) ) );\n\n   // Drawing all shapes\n   for( auto const& shape : shapes )\n   {\n      shape->draw( /*some arguments*/ );\n   }\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <DrawCircleStrategy.h> ----------------\n\nclass Circle;\n\nclass DrawCircleStrategy\n{\n public:\n   virtual ~DrawCircleStrategy() = default;\n\n   virtual void draw( Circle const& circle, /*some arguments*/ ) const = 0;\n};\n\n//---- <SerializeCircleStrategy.h> ----------------\n\nclass Circle;\n\nclass SerializeCircleStrategy\n{\n public:\n   virtual ~SerializeCircleStrategy() = default;\n\n   virtual void serialize( Circle const& circle, /*some arguments*/ ) const = 0;\n};\n\n//---- <Circle.h> ----------------\n\n#include <Shape.h>\n#include <DrawCircleStrategy.h>\n#include <SerializeCircleStrategy.h>\n#include <memory>\n#include <utility>\n\nclass Circle : public Shape\n{\n public:\n   explicit Circle( double radius\n                  , std::unique_ptr<DrawCircleStrategy> drawer\n                  , std::unique_ptr<SerializeCircleStrategy> serializer\n                  /* potentially more strategy-related arguments */ )\n      : radius_( radius )\n      , drawer_( std::move(drawer) )\n      , serializer_( std::move(serializer) )\n      // ...\n   {\n      /* Checking that the given radius is valid and that\n the given std::unique_ptrs are not nullptrs */\n   }\n\n   void draw( /*some arguments*/ ) const override\n   {\n      drawer_->draw( *this, /*some arguments*/ );\n   }\n\n   void serialize( /*some arguments*/ ) const override\n   {\n      serializer_->serialize( *this, /*some arguments*/ );\n   }\n\n   double radius() const { return radius_; }\n\n private:\n   double radius_;\n   std::unique_ptr<DrawCircleStrategy> drawer_;\n   std::unique_ptr<SerializeCircleStrategy> serializer_;\n   // ... Potentially more strategy-related data members\n};\n```", "```cpp\nnamespace std {\n\ntemplate< typename ForwardIt, typename UnaryPredicate >\nconstexpr ForwardIt\n   partition( ForwardIt first, ForwardIt last, UnaryPredicate p );  ![13](assets/13.png)\n\ntemplate< typename RandomIt, typename Compare >\nconstexpr void\n   sort( RandomIt first, RandomIt last, Compare comp );  ![14](assets/14.png)\n\n} // namespace std \n```", "```cpp\nnamespace std {\n\ntemplate< typename T, typename Deleter = std::default_delete<T> >  ![15](assets/15.png)\nclass unique_ptr;\n\ntemplate< typename T, typename Deleter >  ![16](assets/16.png)\nclass unique_ptr<T[], Deleter>;\n\n} // namespace std \n```", "```cpp\n//---- <Circle.h> ---------------- \n#include <Shape.h>\n#include <DrawCircleStrategy.h>\n#include <memory>\n#include <utility>\n\ntemplate< typename DrawCircleStrategy >  ![17](assets/17.png)\nclass Circle : public Shape\n{\n public:\n   explicit Circle( double radius, DrawCircleStrategy drawer )\n      : radius_( radius )\n      , drawer_( std::move(drawer) )\n   {\n      /* Checking that the given radius is valid */\n   }\n\n   void draw( /*some arguments*/ ) const override\n   {\n      drawer_( *this, /*some arguments*/ );  ![18](assets/18.png)\n   }\n\n   double radius() const { return radius_; }\n\n private:\n   double radius_;\n   DrawCircleStrategy drawer_;  // Could possibly be omitted, if the given\n                                // strategy is presumed to be stateless. };\n\n```", "```cpp\nclass Shape\n{\n public:\n   virtual ~Shape() = default;\n\n   virtual void translate( /*some arguments*/ ) = 0;\n   virtual void rotate( /*some arguments*/ ) = 0;\n\n   virtual void draw( /*some arguments*/ ) const = 0;\n   virtual void serialize( /*some arguments*/ ) const = 0;\n\n   // ... Potentially other member functions ... };\n\nvoid rotateAroundPoint( Shape& shape );  ![1](assets/1.png)\nvoid mergeShapes( Shape& s1, Shape& s2 );  ![2](assets/2.png)\nvoid writeToFile( Shape const& shape );  ![3](assets/3.png)\nvoid sendViaRPC( Shape const& shape );  ![4](assets/4.png)\n// ... \n```", "```cpp\n//---- <CalculatorCommand.h> ---------------- \nclass CalculatorCommand\n{\n public:\n   virtual ~CalculatorCommand() = default;\n\n   virtual int execute( int i ) const = 0;  ![1](assets/1.png)\n   virtual int undo( int i ) const = 0;  ![2](assets/2.png)\n};\n\n```", "```cpp\n//---- <Add.h> ---------------- \n#include <CalculatorCommand.h>\n\nclass Add : public CalculatorCommand\n{\n public:\n   explicit Add( int operand ) : operand_(operand) {}\n\n   int execute( int i ) const override  ![3](assets/3.png)\n   {\n      return i + operand_;\n   }\n   int undo( int i ) const override  ![4](assets/4.png)\n   {\n      return i - operand_;\n   }\n\n private:\n   int operand_{};\n};\n\n//---- <Subtract.h> ---------------- \n#include <CalculatorCommand.h>\n\nclass Subtract : public CalculatorCommand\n{\n public:\n   explicit Subtract( int operand ) : operand_(operand) {}\n\n   int execute( int i ) const override  ![5](assets/5.png)\n   {\n      return i - operand_;\n   }\n   int undo( int i ) const override  ![6](assets/6.png)\n   {\n      return i + operand_;\n   }\n\n private:\n   int operand_{};\n};\n\n```", "```cpp\n//---- <Calculator.h> ---------------- \n#include <CalculatorCommand.h>\n#include <stack>\n\nclass Calculator\n{\n public:\n   void compute( std::unique_ptr<CalculatorCommand> command );  ![7](assets/7.png)\n   void undoLast();  ![8](assets/8.png)\n\n   int result() const;\n   void clear();\n\n private:\n   using CommandStack = std::stack<std::unique_ptr<CalculatorCommand>>;\n\n   int current_{};  ![9](assets/9.png)\n   CommandStack stack_;  ![10](assets/10.png)\n};\n\n//---- <Calculator.cpp> ---------------- \n#include <Calculator.h>\n\nvoid Calculator::compute( std::unique_ptr<CalculatorCommand> command )  ![7](assets/7.png)\n{\n   current_ = command->execute( current_ );\n   stack_.push( std::move(command) );\n}\n\nvoid Calculator::undoLast()  ![8](assets/8.png)\n{\n   if( stack_.empty() ) return;\n\n   auto command = std::move(stack_.top());\n   stack_.pop();\n\n   current_ = command->undo(current_);\n}\n\nint Calculator::result() const\n{\n   return current_;\n}\n\nvoid Calculator::clear()\n{\n   current_ = 0;\n   CommandStack{}.swap( stack_ );  // Clearing the stack }\n\n```", "```cpp\n//---- <Main.cpp> ---------------- \n#include <Calculator.h>\n#include <Add.h>\n#include <Subtract.h>\n#include <cstdlib>\n\nint main()\n{\n   Calculator calculator{};  ![11](assets/11.png)\n\n   auto op1 = std::make_unique<Add>( 3 );  ![12](assets/12.png)\n   auto op2 = std::make_unique<Add>( 7 );  ![13](assets/13.png)\n   auto op3 = std::make_unique<Subtract>( 4 );  ![14](assets/14.png)\n   auto op4 = std::make_unique<Subtract>( 2 );  ![15](assets/15.png)\n\n   calculator.compute( std::move(op1) );  // Computes 0 + 3, stores and returns 3\n   calculator.compute( std::move(op2) );  // Computes 3 + 7, stores and returns 10\n   calculator.compute( std::move(op3) );  // Computes 10 - 4, stores and returns 6\n   calculator.compute( std::move(op4) );  // Computes 6 - 2, stores and returns 4 \n   calculator.undoLast();  // Reverts the last operation,\n                           // stores and returns 6 \n   int const res = calculator.result();  // Get the final result: 6 \n   // ... \n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nclass Command  ![17](assets/17.png)\n{ /* Abstract interface to perform and undo any kind of action. */ };\n\nclass ThreadPool\n{\n public:\n   explicit ThreadPool( size_t numThreads );\n\n   inline bool   isEmpty() const;\n   inline size_t size()    const;\n   inline size_t active()  const;\n   inline size_t ready()   const;\n\n   void schedule( std::unique_ptr<Command> command );  ![16](assets/16.png)\n\n   void wait();\n\n   // ... };\n\n```", "```cpp\nclass FormattingCommand : public Command  ![18](assets/18.png)\n{ /* Implementation of formatting a disk */ };\n\nclass PrintCommand : public Command  ![19](assets/19.png)\n{ /* Implementation of performing a printer job */ }\n\nint main()\n{\n   // Creating a thread pool with initially two working threads\n   ThreadPool threadpool( 2 );\n\n   // Scheduling two concurrent tasks\n   threadpool.schedule(\n      std::make_unique<FormattingCommand>( /*some arguments*/ ) );\n   threadpool.schedule(\n      std::make_unique<PrintCommand>( /*some arguments*/ ) );\n\n   // Waiting for the thread pool to complete both commands\n   threadpool.wait();\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nnamespace std {\n\ntemplate< typename InputIt, typename UnaryFunction >\nconstexpr UnaryFunction\n   for_each( InputIt first, InputIt last, UnaryFunction f );  ![20](assets/20.png)\n\n} // namespace std \n```", "```cpp\n#include <algorithms>\n#include <cstdlib>\n\nvoid multBy10( int& i )\n{\n   i *= 10;\n}\n\nint main()\n{\n   std::vector<int> v{ 1, 2, 3, 4, 5 };\n\n   // Multiplying all integers with 10\n   std::for_each( begin(v), end(v), multBy10 );\n\n   // Printing all integers\n   std::for_each( begin(v), end(v), []( int& i ){\n      std::cout << i << '\\n';\n   } );\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\nnamespace std {\n\ntemplate< typename ForwardIt, typename UnaryPredicate >\nconstexpr ForwardIt\n   partition( ForwardIt first, ForwardIt last, UnaryPredicate p );  ![21](assets/21.png)\n\ntemplate< typename InputIt, typename UnaryFunction >\nconstexpr UnaryFunction\n   for_each( InputIt first, InputIt last, UnaryFunction f );  ![22](assets/22.png)\n\n} // namespace std \n```", "```cpp\n//---- <CalculatorStrategy.h> ---------------- \nclass CalculatorStrategy\n{\n public:\n   virtual ~CalculatorStrategy() = default;\n\n   virtual int compute( int i ) const = 0;\n};\n\n//---- <Calculator.h> ---------------- \n#include <CalculatorStrategy.h>\n\nclass Calculator\n{\n public:\n   void set( std::unique_ptr<CalculatorStrategy> operation );  ![23](assets/23.png)\n   void compute( int value );  ![24](assets/24.png)\n\n   // ... \n private:\n   int current_{};\n   std::unique_ptr<CalculatorStrategy> operation_;  // Requires a default! };\n\n//---- <Calculator.cpp> ---------------- \n#include <Calculator.h>\n\nvoid set( std::unique_ptr<CalculatorStrategy> operation )  ![23](assets/23.png)\n{\n   operation_ = std::move(operation);\n}\n\nvoid Calculator::compute( int value )  ![24](assets/24.png)\n{\n   current_ = operation_.compute( value );\n}\n\n```", "```cpp\n#include <cstdlib>\n#include <iostream>\n#include <span>\n#include <vector>\n\nvoid print( std::span<int> s )  ![1](assets/1.png)\n{\n   std::cout << \" (\";\n   for( int i : s ) {\n      std::cout << ' ' << i;\n   }\n   std::cout << \" )\\n\";\n}\n\nint main()\n{\n   std::vector<int> v{ 1, 2, 3, 4 };  ![2](assets/2.png)\n\n   std::vector<int> const w{ v };  ![3](assets/3.png)\n   std::span<int> const s{ v };  ![4](assets/4.png)\n\n   w[2] = 99;  // Compilation error! ![5](assets/5.png)\n   s[2] = 99;  // Works! ![6](assets/6.png)\n\n   // Prints ( 1 2 99 4 );\n   print( s );  ![7](assets/7.png)\n\n   v = { 5, 6, 7, 8, 9 };  ![8](assets/8.png)\n   s[2] = 99;  // Works! ![9](assets/9.png)\n\n   // Prints ?\n   print( s );  ![10](assets/10.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nstd::span<int> const s{ v };  // s acts as pointer to the first element of v\nint* const ptr{ v.data() };   // Equivalent semantical meaning\n```", "```cpp\nstd::span<int const> const s{v};   // s represents a const pointer to a const int\nint const* const ptr{ v.data() };  // Equivalent semantical meaning\n```", "```cpp\n( 1 2 99 4 )\n```", "```cpp\n( 1 2 99 4 )\n```", "```cpp\ntemplate< typename ForwardIt, typename T >\nconstexpr ForwardIt remove( ForwardIt first, ForwardIt last, T const& value );\n```", "```cpp\nstd::vector<int> vec{ 1, -3, 27, 42, 4, -8, 22, 42, 37, 4, 18, 9 };  ![11](assets/11.png)\n\nauto const pos = std::max_element( begin(vec), end(vec) );  ![12](assets/12.png)\n\nvec.erase( std::remove( begin(vec), end(vec), *pos ), end(vec) );  ![13](assets/13.png)\n\n```", "```cpp\n( 1 -3 27 4 -8 22 37 4 18 9 )\n```", "```cpp\n( 1 -3 27 4 -8 22 42 37 18 9 )\n```", "```cpp\ntemplate< typename T, typename Alloc, typename U >\nconstexpr typename std::vector<T,Alloc>::size_type\n   erase( std::vector<T,Alloc>& c, U const& value );\n```", "```cpp\nstd::vector<int> vec{ 1, -3, 27, 42, 4, -8, 22, 42, 37, 4, 18, 9 };\n\nauto const pos = std::max_element( begin(vec), end(vec) );\nauto const greatest = *pos;  ![14](assets/14.png)\n\nvec.erase( std::remove( begin(vec), end(vec), greatest ), end(vec) );\n\n```", "```cpp\nstd::vector<int> v1{ 1, 2, 3, 4, 5 };\n\nauto v2{ v1 };  ![15](assets/15.png)\n\nassert( v1 == v2 );  ![16](assets/16.png)\nassert( v1.data() != v2.data() );  ![17](assets/17.png)\n\nv2[2] = 99;  ![18](assets/18.png)\n\nassert( v1 != v2 );  ![19](assets/19.png)\n\nauto const v3{ v1 };  ![20](assets/20.png)\n\nv3[2] = 99;  // Compilation error! \n```", "```cpp\nint to_int( std::string_view );\n```", "```cpp\nbool to_int( std::string_view s, int& );\n```", "```cpp\nstd::unique_ptr<int> to_int( std::string_view );\n```", "```cpp\nstd::optional<int> to_int( std::string_view );\n```", "```cpp\n#include <charconv>\n#include <cstdlib>\n#include <optional>\n#include <sstream>\n#include <string>\n#include <string_view>\n\nstd::optional<int> to_int( std::string_view sv )\n{\n   std::optional<int> oi{};\n   int i{};\n\n   auto const result = std::from_chars( sv.data(), sv.data() + sv.size(), i );\n   if( result.ec != std::errc::invalid_argument ) {\n      oi = i;\n   }\n\n   return oi;\n}\n\nint main()\n{\n   std::string value = \"42\";\n\n   if( auto optional_int = to_int( value ) )\n   {\n      // ... Success: the returned std::optional contains an integer value\n   }\n   else\n   {\n      // ... Failure: the returned std::optional does not contain a value\n   }\n}\n```", "```cpp\n#include <cstdlib>\n#include <functional>\n\nvoid foo( int i )\n{\n   std::cout << \"foo: \" << i << '\\n';\n}\n\nint main()\n{\n   // Create a default std::function instance. Calling it results\n   // in a std::bad_function_call exception\n   std::function<void(int)> f{};  ![1](assets/1.png)\n\n   f = []( int i ){  // Assigning a callable to 'f' ![2](assets/2.png)\n      std::cout << \"lambda: \" << i << '\\n';\n   };\n\n   f(1);  // Calling 'f' with the integer '1' ![3](assets/3.png)\n\n   auto g = f;  // Copying 'f' into 'g' ![4](assets/4.png)\n\n   f = foo;  // Assigning a different callable to 'f' ![5](assets/5.png)\n\n   f(2);  // Calling 'f' with the integer '2' ![6](assets/6.png)\n   g(3);  // Calling 'g' with the integer '3' ![7](assets/7.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nusing FunctionType        = double(double);\nusing FunctionPointerType = double(*)(double);\n// Alternatively:\n// using FunctionPointerType = FunctionType*;\n```", "```cpp\nlambda: 1\n```", "```cpp\nfoo: 2\n```", "```cpp\nlambda: 3\n```", "```cpp\n//---- <Shape.h> ---------------- \nclass Shape\n{\n public:\n   virtual ~Shape() = default;\n   virtual void draw( /*some arguments*/ ) const = 0;\n};\n\n//---- <Circle.h> ---------------- \n#include <Shape.h>\n#include <functional>\n#include <utility>\n\nclass Circle : public Shape\n{\n public:\n   using DrawStrategy = std::function<void(Circle const&, /*...*/)>;  ![8](assets/8.png)\n\n   explicit Circle( double radius, DrawStrategy drawer )  ![10](assets/10.png)\n      : radius_( radius )\n      , drawer_( std::move(drawer) )  ![11](assets/11.png)\n   {\n      /* Checking that the given radius is valid and that\n         the given 'std::function' instance is not empty */\n   }\n\n   void draw( /*some arguments*/ ) const override\n   {\n      drawer_( *this, /*some arguments*/ );\n   }\n\n   double radius() const { return radius_; }\n\n private:\n   double radius_;\n   DrawStrategy drawer_;  ![12](assets/12.png)\n};\n\n//---- <Square.h> ---------------- \n#include <Shape.h>\n#include <functional>\n#include <utility>\n\nclass Square : public Shape\n{\n public:\n   using DrawStrategy = std::function<void(Square const&, /*...*/)>;  ![9](assets/9.png)\n\n   explicit Square( double side, DrawStrategy drawer )  ![10](assets/10.png)\n      : side_( side )\n      , drawer_( std::move(drawer) )  ![11](assets/11.png)\n   {\n      /* Checking that the given side length is valid and that\n         the given 'std::function' instance is not empty */\n   }\n\n   void draw( /*some arguments*/ ) const override\n   {\n      drawer_( *this, /*some arguments*/ );\n   }\n\n   double side() const { return side_; }\n\n private:\n   double side_;\n   DrawStrategy drawer_;  ![12](assets/12.png)\n};\n\n```", "```cpp\n//---- <OpenGLCircleStrategy.h> ---------------- \n#include <Circle.h>\n\nclass OpenGLCircleStrategy\n{\n public:\n   explicit OpenGLCircleStrategy( /* Drawing related arguments */ );\n\n   void operator()( Circle const& circle, /*...*/ ) const;  ![13](assets/13.png)\n\n private:\n   /* Drawing related data members, e.g. colors, textures, ... */\n};\n\n```", "```cpp\n#include <Circle.h>\n#include <Square.h>\n#include <OpenGLCircleStrategy.h>\n#include <OpenGLSquareStrategy.h>\n#include <memory>\n#include <vector>\n\nint main()\n{\n   using Shapes = std::vector<std::unique_ptr<Shape>>;\n\n   Shapes shapes{};\n\n   // Creating some shapes, each one\n   //   equipped with the corresponding OpenGL drawing strategy\n   shapes.emplace_back(\n      std::make_unique<Circle>( 2.3, OpenGLCircleStrategy(/*...red...*/) ) );\n   shapes.emplace_back(\n      std::make_unique<Square>( 1.2, OpenGLSquareStrategy(/*...green...*/) ) );\n   shapes.emplace_back(\n      std::make_unique<Circle>( 4.1, OpenGLCircleStrategy(/*...blue...*/) ) );\n\n   // Drawing all shapes\n   for( auto const& shape : shapes )\n   {\n      shape->draw();\n   }\n\n   return EXIT_SUCCESS;\n}\n```"]