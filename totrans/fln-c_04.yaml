- en: Chapter 3\. Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章\. 内存管理
- en: Each program stores some values in memory to use them later on in the program.
    This functionality is so common for programs that modern programming languages
    make doing it as easy as possible. The C++ programming language, as well as other
    object-oriented programming languages, provides constructors and destructors,
    which make it very easy to have a defined place and time to allocate and clean
    up memory. The Java programming language even comes with a garbage collector,
    which makes sure that memory that is not used anymore by the program is made available
    to others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序都会将一些值存储在内存中以在程序后面使用它们。这种功能对于现代编程语言来说是如此普遍，以至于现代编程语言使其尽可能简单。C++ 编程语言以及其他面向对象的编程语言提供了构造函数和析构函数，这使得分配和清理内存非常简单。Java
    编程语言甚至配备了垃圾回收器，确保程序不再使用的内存可以释放给其他程序使用。
- en: Compared to that, programming in C is special in the way that the programmer
    has to manually manage the memory. The programmer has to decide whether to put
    variables on the stack, on the heap, or in static memory. Also, the programmer
    has to make sure that heap variables are manually cleaned up afterwards, and there
    is no mechanism like a destructor or a native garbage collector, which would make
    some of these tasks much easier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，C 编程在程序员需要手动管理内存的方式上是特殊的。程序员必须决定是将变量放在栈上、堆上还是静态内存中。此外，程序员必须确保堆变量在使用后手动清理，而没有像析构函数或本地垃圾回收器等机制，这会使这些任务中的一些变得更容易。
- en: 'Guidance on how to perform such tasks is well scattered over the internet,
    which makes it quite hard to answer questions like the following: “Should that
    variable go on the stack or on the heap?” To answer that as well as other questions,
    this chapter presents patterns on how to handle memory in C programs. The patterns
    provide guidance on when to use the stack, when to use the heap, and when and
    how to clean up heap memory. To make the core idea of the patterns easier to grasp,
    the patterns are applied to a running code example throughout the chapter.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何执行这些任务的指导广泛分布在互联网上，这使得回答以下问题变得非常困难：“该变量应该放在栈上还是堆上？”为了回答这个问题以及其他问题，本章节介绍了如何在
    C 程序中处理内存的模式。这些模式指导何时使用栈、何时使用堆以及何时如何清理堆内存。为了更容易理解模式的核心思想，本章在整个章节中应用了一个运行中的代码示例。
- en: '[Figure 3-1](#fig_memory) shows an overview of the patterns discussed in this
    chapter and their relationships, and [Table 3-1](#tab_memory) provides a summary
    of the patterns.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#fig_memory) 显示了本章讨论的模式及其关系概述，而 [表 3-1](#tab_memory) 则提供了这些模式的摘要。'
- en: '![Overview of patterns on memory management](assets/fluc_0301.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![内存管理模式概览](assets/fluc_0301.png)'
- en: Figure 3-1\. Overview of patterns for memory management
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 内存管理模式概览
- en: Table 3-1\. Patterns for memory management
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 内存管理模式
- en: '|  | Pattern name | Summary |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  | 模式名称 | 摘要 |'
- en: '| --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  | Stack First | Deciding the storage class and memory section (stack, heap,
    …) for variables is a decision every programmer has to make often. It gets exhausting
    if for each and every variable, the pros and cons of all possible alternatives
    have to be considered in detail. Therefore, simply put your variables on the stack
    by default to profit from automatic cleanup of stack variables. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  | 先栈后堆 | 对于变量来说，决定存储类别和内存区段（栈、堆等）是每个程序员经常要做的决定。如果每个变量都要详细考虑所有可能替代方案的利弊，那会很累人。因此，默认情况下将变量放在栈上，以便从自动清理栈变量中获益。'
- en: '|  | Eternal Memory | Holding large amounts of data and transporting it between
    function calls is difficult because you have to make sure that the memory for
    the data is large enough and that the lifetime extends across your function calls.
    Therefore, put your data into memory that is available throughout the whole lifetime
    of your program. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  | 永久内存 | 在函数调用之间传输大量数据并持久保存是困难的，因为您必须确保数据的内存足够大且生命周期跨越函数调用。因此，将您的数据放入整个程序生命周期内都可用的内存中。'
- en: '|  | Lazy Cleanup | Having dynamic memory is required if you need large amounts
    of memory and memory where you don’t know the required size beforehand. However,
    handling cleanup of dynamic memory is a hassle and is the source of many programming
    errors. Therefore, allocate dynamic memory and let the operating system cope with
    deallocation by the end of your program. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  | 惰性清理 | 如果需要大量内存或者预先不知道所需大小的内存，则需要动态内存。然而，处理动态内存的清理是一件麻烦事，并且是许多编程错误的根源。因此，分配动态内存，并且让操作系统在程序结束时处理清理。
    |'
- en: '|  | Dedicated Ownership | The great power of using dynamic memory comes with
    the great responsibility of having to properly clean that memory up. In larger
    programs, it becomes difficult to make sure that all dynamic memory is cleaned
    up properly. Therefore, right at the time when you implement memory allocation,
    clearly define and document where it’s going to be cleaned up and who is going
    to do that. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  | 专属所有权 | 使用动态内存的强大力量伴随着正确清理该内存的责任。在较大的程序中，确保所有动态内存正确清理变得困难。因此，在实现内存分配时，明确定义和记录何时以及由谁来清理它非常重要。
    |'
- en: '|  | Allocation Wrapper | Each allocation of dynamic memory might fail, so
    you should check allocations in your code to react accordingly. This is cumbersome
    because you have many places for such checks in your code. Therefore, wrap the
    allocation and deallocation calls, and implement error handling or additional
    memory management organization in these wrapper functions. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  | 分配包装器 | 每次动态内存分配可能失败，因此您应该在代码中检查分配情况以做出相应反应。这很繁琐，因为您的代码中有许多这样的检查点。因此，封装分配和释放调用，并在这些包装函数中实现错误处理或附加的内存管理组织。
    |'
- en: '|  | Pointer Check | Programming errors that lead to accessing an invalid pointer
    cause uncontrolled program behavior, and such errors are difficult to debug. However,
    because your code works with pointers frequently, there is a good chance that
    you have introduced such programming errors. Therefore, explicitly invalidate
    uninitialized or freed pointers and always check pointers for validity before
    accessing them. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  | 指针检查 | 导致访问无效指针的编程错误会导致不受控制的程序行为，这些错误很难调试。然而，因为您的代码频繁使用指针，很可能引入这类编程错误。因此，显式地使未初始化或释放的指针无效，并且在访问之前始终检查指针的有效性。
    |'
- en: '|  | Memory Pool | Frequently allocating and deallocating objects from the
    heap leads to memory fragmentation. Therefore, hold a large piece of memory throughout
    the whole lifetime of your program. At runtime, retrieve fixed-size chunks of
    that memory pool instead of directly allocating new memory from the heap. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  | 内存池 | 频繁从堆中分配和释放对象会导致内存碎片化。因此，在整个程序生命周期中持有一个大块内存。在运行时，从该内存池中检索固定大小的块，而不是直接从堆中分配新内存。
    |'
- en: Data Storage and Problems with Dynamic Memory
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据存储及动态内存问题
- en: 'In C you have several options for where to put your data:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，您有多种选项可以存放数据：
- en: 'You can put the data on the stack. The stack is a fixed-size memory reserved
    for each thread (allocated when creating the thread). When calling a function
    in such a thread, a block on the top of the stack is reserved for the function
    parameters and automatic variables used by that function. After the function call,
    that memory is automatically cleaned up. To put data on the stack, simply declare
    variables in the functions where they are used. These variables can be accessed
    as long as they don’t run out of scope (when the function block ends):'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆栈中存放数据。堆栈是为每个线程保留的固定大小内存（在线程创建时分配）。调用线程中的函数时，堆栈顶部的块会被保留用于函数参数和函数中使用的自动变量。函数调用后，该内存会自动清理。要将数据放入堆栈中，只需在使用它们的函数中声明变量。只要这些变量不超出范围（函数块结束时），就可以访问这些变量：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can put data into static memory. The static memory is a fixed-size memory
    in which the allocation logic is fixed at compile time. To use the static memory,
    simply place the `static` keyword in front of your variable declaration. Such
    variables are available throughout the whole lifetime of your program. The same
    holds true for global variables, even without the `static` keyword:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将数据放入静态内存。静态内存是一个固定大小的内存，其分配逻辑在编译时确定。要使用静态内存，只需在变量声明前加上 `static` 关键字。这些变量在整个程序生命周期内都可用。即使没有
    `static` 关键字，全局变量也是如此：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If your data is of fixed size and immutable, you can simply store it directly
    in the static memory where the code is stored. Quite often, fixed string values
    are stored this way. Such data is available throughout the whole lifetime of your
    program (even though, in the example below, the pointer to that data runs out
    of scope):'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的数据是固定大小且不可变的，你可以直接将其存储在代码所在的静态内存中。经常情况下，固定的字符串值就是这样存储的。这些数据在整个程序的生命周期内都是可用的（即使在下面的例子中，指向这些数据的指针超出了作用域）：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can allocate dynamic memory on the heap to store the data. The heap is
    a global memory pool available for all processes on the system, and it is up to
    the programmer to allocate and deallocate from that pool at any time:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在堆上分配动态内存来存储数据。堆是系统上所有进程可用的全局内存池，程序员可以随时从中分配和释放内存：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Allocating dynamic memory is the starting point where things can easily go
    wrong, and tackling the problems that can arise is the focus of this chapter.
    Using dynamic memory in C programs comes with many problems that have to be solved
    or at least considered. The following outlines the major problems with dynamic
    memory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 分配动态内存是事情可能出错的起点，并解决可能出现的问题是本章的重点。在C程序中使用动态内存会带来许多必须解决或至少考虑的问题。以下是动态内存的主要问题概述：
- en: Memory that is allocated has to be freed at some point later on. When not doing
    so for all memory you allocated, you’ll consume more memory than you need and
    have a so-called memory leak. If that happens frequently and your applications
    runs for a long time, you’ll end up having no additional memory.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配的内存必须在稍后某个时间点释放。如果没有为你分配的所有内存这样做，你将消耗比需要更多的内存，并且会产生所谓的内存泄漏。如果这种情况经常发生，并且你的应用程序运行时间很长，最终可能导致没有额外的内存可用。
- en: Freeing memory more than once is a problem and can lead to undefined program
    behavior, which is really bad. Worst case, nothing goes wrong in the actual code
    line where you made the mistake, but at some random point later in time, your
    program might crash. Such errors are a hassle to debug.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放内存超过一次是一个问题，可能导致未定义的程序行为，这是非常糟糕的。最糟糕的情况是，在你犯错的实际代码行中可能没有任何问题，但在随机时间后，你的程序可能会崩溃。这些错误是调试时的一个麻烦。
- en: Trying to access freed memory is a problem as well. It is easy to free some
    memory and then later on make a mistake and dereference a pointer to that memory
    (a so-called dangling pointer). Again, this leads to error situations that are
    a hassle to debug. Best case, the program would simply crash. Worst case, it would
    not crash and the memory already belongs to somebody else. Errors related to using
    that memory are a security risk and might show up as some kind of hard-to-understand
    error later during program execution.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试访问已释放的内存也是一个问题。很容易释放一些内存，然后在稍后错误地引用指向该内存的指针（即所谓的悬空指针）。同样，这会导致难以调试的错误情况。最好的情况是，程序会简单地崩溃。最糟糕的情况是，它不会崩溃，并且该内存已经属于其他人。与使用该内存相关的错误是安全风险，并可能在程序执行后的某个时候显示为某种难以理解的错误。
- en: You have to cope with lifetime and ownership of allocated data. You have to
    know who cleans up which data when, and that can be particularly tricky in C.
    In C++ it would be possible to simply allocate data for objects in the constructor
    and free them in the destructor. In combination with C++ *smart pointers*, you
    even have the option to automatically clean up an object if it runs out of scope.
    However, that is not possible in C because we don’t have destructors. We are not
    notified when a pointer runs out of scope and the memory should be cleaned up.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须处理分配数据的生命周期和所有权。你必须知道谁在何时清理哪些数据，在C语言中尤其棘手。在C++中，可以简单地在构造函数中为对象分配数据，在析构函数中释放它们。结合C++的智能指针，甚至可以在对象超出作用域时自动清理它们。然而，在C中这是不可能的，因为我们没有析构函数。我们不会在指针超出作用域时收到通知，并且应清理内存。
- en: Working with heap memory takes more time compared to working with memory from
    the stack or with static memory. The allocation of heap memory has to be protected
    against race conditions because other processes use the same pool of memory. This
    makes allocation slower. Accessing the heap memory is also slower because, in
    comparison, the stack memory is accessed more often and thus more likely already
    resides in the cache or in CPU registers.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与堆内存工作相比，与堆栈或静态内存工作需要更多时间。堆内存的分配必须受到竞争条件的保护，因为其他进程使用同一内存池。这使得分配变慢。访问堆内存也更慢，因为与之相比，堆栈内存被更频繁地访问，因此更可能已经驻留在缓存或CPU寄存器中。
- en: A huge issue with heap memory is that it becomes fragmented, which is depicted
    in [Figure 3-2](#fig_fragmentation). If you allocate memory blocks A, B, and C
    and later on free memory block B, your overall free heap memory is no longer consecutive.
    If you want to allocate a large memory block D, you won’t get that memory, although
    there is enough total memory available. However, as that available memory is not
    consecutive, your `malloc` call will fail. Fragmentation is a huge issue in memory-constrained
    systems that run for a long time (like embedded real-time systems).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆内存的一个巨大问题是它会变得碎片化，这在[图3-2](#fig_fragmentation)中有所描述。 如果你分配了内存块A、B和C，然后释放了内存块B，你的整体空闲堆内存就不再是连续的。
    如果你想要分配一个大的内存块D，你将无法获得那块内存，尽管总内存是足够的。 然而，由于可用内存不是连续的，你的`malloc`调用将失败。 在长时间运行的内存受限系统中（如嵌入式实时系统），碎片化是一个巨大的问题。
- en: '![Memory fragmentation](assets/fluc_0302.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![内存碎片化](assets/fluc_0302.png)'
- en: Figure 3-2\. Memory fragmentation
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2\. 内存碎片化
- en: Tackling these issues is not easy. The patterns in the following sections describe
    bit by bit how to either avoid dynamic allocation or live with it in an acceptable
    way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些问题并不容易。 以下各节中的模式逐步描述了如何避免动态分配或以可接受的方式使用它。
- en: Running Example
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'You want to implement a simple program that encrypts some text with the Caesar
    cipher. The Caesar cipher replaces each letter with another letter that is some
    fixed number of positions down the alphabet. For example, if the fixed number
    of positions is 3, then the letter A would be replaced by letter D. You start
    to implement a function that performs the Caesar encryption:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要实现一个简单的程序，用凯撒密码加密一些文本。 凯撒密码用另一个字母替换每个字母，这个字母在字母表中向下移动了一定数量的位置。 例如，如果固定的位置数为3，那么字母A将被字母D替换。
    你开始实现一个执行凯撒加密的函数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_memory_management_CO1-1)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_memory_management_CO1-1)'
- en: Characters in C are stored as numeric values, and you can shift the character
    down the alphabet by adding a numeric value to a character.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，字符以数值形式存储，你可以通过向字符添加数值来将字符向字母表下移。
- en: '[![2](assets/2.png)](#co_memory_management_CO1-2)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_memory_management_CO1-2)'
- en: If we shift beyond the letter *Z*, we restart at the beginning of the alphabet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们超出字母*Z*，我们将重新从字母表的开头开始。
- en: Now you simply want to check if your function works, and you need to feed it
    some text in order to do that. Your function takes a pointer to a string. But
    where should you store that string? Should you allocate it dynamically or should
    you work with memory from the stack? You realize the simplest solution is to use
    the Stack First to store the string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只是想检查你的函数是否有效，并且你需要提供一些文本来做到这一点。 你的函数接受一个指向字符串的指针。 但是你应该把那个字符串存储在哪里呢？ 应该动态分配还是使用栈内存？
    你意识到最简单的解决方案是首先使用栈来存储字符串。
- en: Stack First
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先用栈
- en: Context
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: You want to store data and access it at a later point in your program. You know
    its maximum size beforehand, and the data is not very large in size (just a few
    bytes).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在程序中存储数据并在以后的某个时间点访问它。 你事先知道它的最大大小，并且数据大小不是很大（只有几个字节）。
- en: Problem
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**Deciding the storage class and memory section (stack, heap, …) for variables
    is a decision every programmer has to make often. It gets exhausting if for each
    and every variable, the pros and cons of all possible alternatives have to be
    considered in detail.**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**决定变量的存储类和内存段（栈、堆等）是每个程序员经常必须做出的决定。 如果对于每个变量都必须详细考虑所有可能替代方案的利弊，那么这将变得很繁琐。**'
- en: For storing data in your C program, you have a myriad of possibilities, of which
    the most common ones are storage on the stack, in static memory, or in dynamic
    memory. Each of these possibilities has its own specific benefits and drawbacks,
    and the decision of where to store the variable is very important. It affects
    the lifetime of the variable and determines whether the variable is cleaned up
    automatically or whether you have to manually clean it up.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的C程序中存储数据，你有很多可能性，其中最常见的是在栈上、静态内存中或动态内存中存储。 每种可能性都有其特定的优点和缺点，决定变量存储在哪里非常重要。
    它影响变量的生命周期，并确定变量是否会自动清理或者你是否必须手动清理。
- en: This decision also affects the required effort and discipline for you as a programmer.
    You want to make your life as easy as possible, so if you have no special requirements
    for storing the data, you want to use the kind of memory that requires the least
    possible effort with allocation, deallocation, and bug fixes due to potential
    programming errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定还影响了作为程序员的所需的努力和纪律。你希望尽可能地简化生活，因此如果对存储数据没有特殊要求，你希望使用需要最少的分配、释放和由于潜在编程错误导致的错误修复的内存类型。
- en: Solution
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Simply put your variables on the stack by default to profit from automatic
    cleanup of stack variables.**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认将变量放在堆栈上，以从堆栈变量的自动清理中获益。**'
- en: All variables declared inside a code block are by default so-called *automatic
    variables* that are put on the stack and automatically cleaned up once the code
    block ends (when the variable runs out of scope). It could be made explicit that
    a variable is declared as an automatic variable by putting the `auto` storage-class
    specifier before it, but this is rarely done because it is the default anyway.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在代码块内声明的变量默认为所谓的*自动变量*，这些变量被放置在堆栈上，并在代码块结束时（变量超出作用域时）自动清理。可以通过在变量前加上`auto`存储类说明符来明确声明变量为自动变量，但这很少这样做，因为这已经是默认行为。
- en: You can pass the memory from the stack along to other functions (for example,
    Caller-Owned Buffer), but make sure not to return the address of such a variable.
    The variable runs out of scope at the end of the function and is automatically
    cleaned up. Returning the address of such a variable would lead to a dangling
    pointer, and accessing it results in undefined program behavior and possibly a
    crash of the program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将来自堆栈的内存传递给其他函数（例如，调用者拥有缓冲区），但请确保不要返回此类变量的地址。变量在函数结束时超出作用域并自动清理。返回这样一个变量的地址将导致悬空指针，并且访问它将导致未定义的程序行为，可能导致程序崩溃。
- en: 'The following code shows a very simple example with variables on the stack:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了一个非常简单的例子，其中包含堆栈上的变量：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Variable Length Arrays
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变长数组
- en: The array in the preceding code is of fixed size. It is very common to put only
    data of fixed size known at compile time on the stack, but it is also possible
    to decide the size of stack variables during runtime. This is done using functions
    like `alloca()` (which is not part of the C standard and which causes stack overflows
    if you allocate too much) or using variable length arrays (regular arrays whose
    size is specified by a variable), which are introduced with the C99 standard.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的数组大小是固定的。在编译时只将固定大小的数据放在堆栈上是非常常见的，但也可以在运行时决定堆栈变量的大小。这可以通过使用`alloca()`等函数（它不是C标准的一部分，并且如果分配太多可能会导致堆栈溢出），或者使用变长数组（其大小由变量指定的常规数组）来实现，这在C99标准中引入。
- en: Consequences
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响
- en: Storing the data on the stack makes it easy to access that data. Compared to
    dynamically allocated memory, there is no need to work with pointers. This makes
    it possible to eliminate the risk of programming errors related to dangling pointers.
    Also, there is no heap fragmentation and memory cleanup is easier. The variables
    are automatic variables, which means they are automatically cleaned up. There
    is no need to manually free the memory, and that eliminates the risk of memory
    leaks or accidentally freeing memory multiple times. In general, most of the hard-to-debug
    errors related to incorrect memory usage can be eliminated by simply putting variables
    on the stack.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据存储在堆栈上使得访问数据变得容易。与动态分配的内存相比，无需使用指针。这可以消除与悬空指针相关的程序错误的风险。此外，没有堆碎片化，内存清理更容易。这些变量是自动变量，这意味着它们会自动清理。无需手动释放内存，这消除了内存泄漏或意外多次释放内存的风险。通常，通过简单地将变量放在堆栈上，可以消除大多数与不正确的内存使用相关的难以调试的错误。
- en: The data on the stack can be allocated and accessed very quickly compared to
    dynamic memory. For the allocation there is no need to go through complex data
    structures that manage the available memory. There is also no need to ensure mutual
    exclusion from other threads because each thread has its own stack. Also, the
    stack data can usually be accessed quickly because that memory is used often and
    you usually have it in the cache memory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态内存相比，堆栈上的数据可以快速分配和访问。在分配时无需通过复杂的数据结构管理可用内存。也无需确保与其他线程的互斥，因为每个线程都有自己的堆栈。此外，堆栈数据通常可以快速访问，因为该内存经常被使用，并且通常在高速缓存中。
- en: However, a drawback of using the stack is that it is limited. Compared to the
    heap memory, it is very small (depending on your build settings regarding stack
    size, maybe just a few KB). If you put too much data on the stack, you cause a
    stack overflow, which usually results in a crashing program. The problem is that
    you don’t know how much stack memory you have left. Depending on how much stack
    memory is already used by the functions that you called, you might have only a
    little left. You have to make sure that the data you put on the stack is not too
    large, and you have to know its size in advance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用堆栈的一个缺点是它的限制性。与堆内存相比，堆栈内存非常有限（取决于堆栈大小的构建设置，可能只有几KB）。如果你在堆栈上放置了太多数据，就会导致堆栈溢出，通常会导致程序崩溃。问题在于你无法知道剩余的堆栈内存有多少。根据已调用的函数已使用的堆栈内存量，你可能只剩下很少的内存。你必须确保放置在堆栈上的数据不要太大，并且必须提前知道其大小。
- en: Programming errors related to buffers on the stack can be major security issues.
    If you produce a buffer overflow on the stack, then attackers can easily exploit
    that to overwrite some other data on the stack. If attackers manage to overwrite
    the address your code returns to after processing the function, then the attackers
    can execute any code they want.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与堆栈上缓冲区相关的编程错误可能会导致重大安全问题。如果在堆栈上产生缓冲区溢出，攻击者可以轻松利用它来覆盖堆栈上的其他数据。如果攻击者成功覆盖了函数处理后返回的地址，那么攻击者可以执行任何他们想要的代码。
- en: Also, having the data on the stack will not suit all your needs. If you have
    to return large data like the content of a file or the buffer to some network
    message to the caller, then you cannot simply return the address of some array
    on the stack because that variable will be cleaned up once you return from your
    function. For returning large data, other approaches have to be used.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在堆栈上存储数据并不适合满足所有需求。如果你需要返回大量数据，比如文件内容或缓冲区的网络消息给调用者，那么你不能简单地返回堆栈上某个数组的地址，因为一旦从函数返回，该变量就会被清除。为了返回大量数据，必须使用其他方法。
- en: Known Uses
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知的用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: Nearly every C program stores something on the stack. In most programs, you’ll
    find storage on the stack as default because it is the easiest solution.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎每个C程序都会在堆栈上存储一些东西。在大多数程序中，默认情况下会使用堆栈存储，因为这是最简单的解决方案。
- en: The `auto` storage-class specifier of C, which specifies that the variable is
    an automatic variable and that it goes on the stack, is the default storage-class
    specifier (and is usually omitted in the code because it is the default anyway).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C语言的`auto`存储类说明符指定变量是自动变量并放在堆栈上，是默认的存储类说明符（通常在代码中省略，因为它默认为这种方式）。
- en: 'The book *Small Memory Software: Patterns for Systems with Limited Memory*
    by James Noble and Charles Weir (Addison-Wesley, 2000) describes in its Memory
    Allocation pattern that among the choices of where to put the memory, you should
    go for the simplest one, which is the stack for C programmers.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《小内存软件：有限内存系统的模式》（Addison-Wesley，2000）一书中由James Noble和Charles Weir描述了其内存分配模式，对于内存放置的选择，应该选择最简单的方式，也就是对于C程序员来说使用堆栈。
- en: Applied to Running Example
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'Well, that was simple. You now put the memory that you need for storing the
    text on the stack and provide that memory to your Caesar cipher function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这很简单。你现在将需要用于存储文本的内存放在堆栈上，并将该内存提供给你的凯撒密码函数：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This was a very easy solution. You did not have to cope with dynamic memory
    allocation. There is no need to clean up the memory because once the `text` runs
    out of scope, it is automatically cleaned up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的解决方案。你不必处理动态内存分配。也不需要清理内存，因为一旦`text`超出作用域，它就会自动清理。
- en: Next, you want to encrypt a larger text. That’s not easy with your current solution
    because the memory resides on the stack and you usually don’t have a lot of stack
    memory. Depending on your platform, it could be just a few KB. Still, you want
    to make it possible to also encrypt larger texts. To avoid coping with dynamic
    memory, you decide to give Eternal Memory a try.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想加密一个较大的文本。使用当前解决方案并不容易，因为内存存储在堆栈上，而且通常堆栈内存不多。根据你的平台，可能只有几KB。尽管如此，你仍然希望能够加密更大的文本。为了避免处理动态内存，你决定尝试使用永久内存。
- en: Eternal Memory
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永久内存
- en: Context
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You have large amounts of data with fixed size that you need for a longer time
    in your program.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序中需要长时间使用固定大小的大量数据，那么堆栈存储是一个合适的选择。
- en: Problem
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**Holding large amounts of data and transporting it between function calls
    is difficult because you have to make sure that the memory for the data is large
    enough and that the lifetime extends across your function calls.**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**持有大量数据并在函数调用之间传输数据是困难的，因为您必须确保数据的内存足够大且生命周期跨越函数调用。**'
- en: Using the stack would be handy because it would do all the memory cleanup work
    for you. But putting the data on the stack is not a solution for you because it
    does not allow you to pass large data between functions. It would also be an inefficient
    way because passing data to a function means copying that data. The alternative
    of manually allocating the memory at each place in the program where you need
    it and deallocating it as soon as it is not required anymore would work, but it
    is cumbersome and error prone. In particular, keeping an overview of the lifetime
    of all data and knowing where and when the data is being freed is a complicated
    task.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆栈会很方便，因为它会为您处理所有内存清理工作。但将数据放入堆栈上并不适合您，因为这不允许您在函数之间传递大数据。这也是一种低效的方式，因为将数据传递给函数意味着复制数据。在程序的每个需要它的地方手动分配内存并在不再需要时释放它的替代方法是可行的，但这很繁琐且容易出错。特别是要掌握所有数据的生命周期并知道何时以及何处释放数据是一项复杂的任务。
- en: If you operate in an environment like safety-critical applications, where you
    must be sure that there is memory available, then neither using memory from the
    stack nor using dynamic memory is a good option because both could run out of
    memory and you cannot easily know beforehand. But in other applications there
    might also be parts of your code for which you want to make sure to not run out
    of memory. For example, for your error logging code you definitely want to be
    sure that the required memory is available because otherwise you cannot rely on
    your logging information, which makes pinpointing bugs difficult.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在像安全关键应用这样的环境中操作，那么既不使用堆栈中的内存，也不使用动态内存是一个好选择，因为两者都可能耗尽内存，并且您无法事先轻松知道。但在其他应用程序中，您可能也有代码部分，您希望确保不会耗尽内存。例如，对于错误日志代码，您肯定希望确保所需的内存可用，否则您无法依赖于您的日志信息，这使得查找错误变得困难。
- en: Solution
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Put your data into memory that is available throughout the whole lifetime
    of your program.**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**将您的数据放入在整个程序生命周期内可用的内存中。**'
- en: 'The most common way to do this is to use the static memory. Either mark your
    variable with the `static` storage-class specifier, or if you want the variable
    to have larger scope, declare it outside any function (but only do that if you
    really need the larger scope). Static memory is allocated at startup of your program
    and is available all through your program’s lifetime. The following code gives
    an example of this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的方法是使用静态内存。要么用`static`存储类说明符标记您的变量，要么如果您希望变量具有更大的作用域，则将其声明在任何函数之外（但只有在确实需要更大的作用域时才这样做）。静态内存在程序启动时分配，并在整个程序生命周期内可用。以下代码提供了一个示例：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As an alternative to using static variables, on program startup you could call
    an initialization function that allocates the memory and by the end of your program
    call a deinitialization function that deallocates that memory. That way you’d
    also have the memory available all through the lifetime of your program, but you’d
    have to cope with allocation and deallocation yourself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用静态变量的替代方法，在程序启动时，您可以调用一个初始化函数来分配内存，并在程序结束时调用一个去初始化函数来释放该内存。这样，您在整个程序的生命周期内都可以使用这些内存，但您必须自己处理分配和释放的问题。
- en: No matter whether you allocate the memory at program startup on your own or
    whether you use static memory, you have to be careful when accessing this memory.
    As it is not on the stack, you don’t have a separate copy of that memory per thread.
    In the case of multithreading, you have to use synchronization mechanisms when
    accessing that memory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在程序启动时自己分配内存还是使用静态内存，访问此内存时都必须小心。因为它不在堆栈上，所以在每个线程中没有单独的内存副本。在多线程情况下，访问该内存时必须使用同步机制。
- en: Your data has fixed size. Compared to memory dynamically allocated at runtime,
    the size of your Eternal Memory cannot be changed at runtime.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据具有固定大小。与运行时动态分配的内存相比，您的永久内存的大小在运行时不能更改。
- en: Consequences
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: 'You don’t have to worry about lifetime and the right place for manually deallocating
    memory. The rules are simple: let the memory live throughout your whole program
    lifetime. Using static memory even takes the whole burden of allocation and deallocation
    from you.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必担心内存的生命周期和手动释放内存的位置。规则很简单：让内存在整个程序生命周期内保持活动状态。甚至使用静态内存可以完全摆脱你的分配和释放负担。
- en: You can now store large amounts of data in that memory and even pass it along
    to other functions. Compared to using Stack First, you can now even provide data
    to the callers of your function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在那段内存中存储大量数据，甚至将其传递给其他函数。与首次使用堆栈相比，你现在甚至可以向函数的调用者提供数据。
- en: However, you have to know at compile time, or startup time at the latest, how
    much memory you need because you allocate it at program startup. For memory of
    unknown size or for memory that will be expanded during runtime, Eternal Memory
    is not the best choice and heap memory should be used instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你必须在编译时或最迟在启动时知道需要多少内存，因为你在程序启动时分配它。对于大小未知的内存或在运行时将扩展的内存，永久内存并不是最好的选择，应该使用堆内存。
- en: With Eternal Memory, starting the program will take longer because all the memory
    has to be allocated at that time. But this pays off once you have that memory
    because there is no allocation necessary during runtime anymore.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用永久内存，启动程序会花费更长的时间，因为所有的内存都必须在那时分配。但一旦你拥有了那段内存，就会有所回报，因为在运行时不再需要分配内存。
- en: Allocating and accessing static memory do not need any complex data structures
    maintained by your operating system or runtime environment for managing the heap.
    Thus, the memory is used more efficiently. Another huge advantage of Eternal Memory
    is that you don’t fragment the heap because you don’t allocate and deallocate
    memory all the time. But not doing that has the drawback of blocking memory that
    you, depending on your application, might not need all the time. A more flexible
    solution that helps avoid memory fragmentation would be to use a Memory Pool.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 分配和访问静态内存不需要由操作系统或运行时环境维护的复杂数据结构来管理堆。因此，内存使用效率更高。永久内存的另一个巨大优势是你不会使堆碎片化，因为你不会一直分配和释放内存。但是不这样做的缺点是阻塞内存，这取决于你的应用程序，可能并不总是需要。一个更灵活的避免内存碎片化的解决方案将是使用内存池。
- en: One issue with Eternal Memory is that you don’t have a copy of it for each of
    your threads (if you use static variables). So you have to make sure that the
    memory is not accessed by multiple threads at the same time. Although, in the
    special case of an Immutable Instance this would not be much of an issue.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 永久内存的一个问题是你的每个线程没有其自己的副本（如果你使用静态变量）。因此，你必须确保内存不会同时被多个线程访问。尽管在不可变实例的特殊情况下，这并不是一个大问题。
- en: Known Uses
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知的应用
- en: 'The following examples show applications of this pattern:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这种模式的应用：
- en: The game NetHack uses static variables to store data that is required during
    the whole lifetime of the game. For example, the information about artifacts found
    in the game is stored in the static array `artifact_names`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏 NetHack 使用静态变量来存储在游戏整个生命周期中所需的数据。例如，游戏中发现的神器信息存储在静态数组`artifact_names`中。
- en: The code of the Wireshark network sniffer uses a static buffer in its function
    `cf_open_error_message` for storing error message information. In general, many
    programs use static memory or memory allocated at program startup for their error-logging
    functionality. This is because in case of errors, you want to be sure that at
    least that part works and does not run out of memory.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark 网络嗅探器的代码在其函数`cf_open_error_message`中使用静态缓冲区来存储错误消息信息。一般来说，许多程序在其错误记录功能中使用静态内存或在程序启动时分配的内存。这是因为在发生错误时，你希望至少该部分工作正常，并且不会耗尽内存。
- en: The OpenSSL code uses the static array `OSSL_STORE_str_reasons` to hold error
    information about error situations that can occur when working with certificates.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL 代码使用静态数组`OSSL_STORE_str_reasons`来保存有关在处理证书时可能发生的错误情况的错误信息。
- en: Applied to Running Example
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'Your code pretty much stayed the same. The only thing that changed is that
    you added the `static` keyword before the variable declaration of `text` and you
    increased the size of the text:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码基本上保持不变。唯一改变的是，在变量`text`的声明前加入了`static`关键字，并增加了文本的大小：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now your text is not stored on the stack, but instead it resides in the static
    memory. When doing this you should remember that it also means the variable only
    exists once and remains its value (even when entering the function multiple times).
    That could be an issue for multithreaded systems because then you’d have to ensure
    mutual exclusion when accessing the variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的文本不存储在堆栈上，而是驻留在静态内存中。在执行此操作时，您应记住这意味着变量只存在一次并保留其值（即使在多次进入函数时也是如此）。对于多线程系统来说，这可能是一个问题，因为在访问该变量时必须确保互斥。
- en: 'You currently don’t have a multithreaded system. However, the requirements
    for your system change: now you want to make it possible to read the text from
    a file, encrypt it, and show the encrypted text. You don’t know how long the text
    will be, and it could be quite long. So you decide to use dynamic allocation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您目前没有多线程系统。但是，您的系统需求发生了变化：现在您希望能够从文件中读取文本，对其进行加密并显示加密后的文本。您不知道文本的长度可能有多长。因此，您决定使用动态分配：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But how should that code continue? You allocated the text on the heap. But
    how would you clean that memory up? As a very first step, you realize that cleaning
    up that memory could be done by somebody else completely: the operating system.
    So you go for Lazy Cleanup.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，该如何继续编写代码呢？您在堆上分配了文本。但是如何清理这些内存？作为第一步，您意识到完全可以由其他人来清理该内存：操作系统。因此，您选择了懒惰的清理。
- en: Lazy Cleanup
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰的清理
- en: Context
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You want to store some data in your program, and that data is large (and maybe
    you don’t even know its size beforehand). The size of the data does not change
    often during runtime, and the data is needed throughout almost the whole lifetime
    of the program. Your program is short-lived (does not run for many days without
    restart).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在程序中存储一些数据，这些数据很大（也许您甚至事先不知道其大小）。数据的大小在运行时很少改变，并且在程序的几乎整个生命周期中都需要这些数据。您的程序是短暂的（不会长时间运行而不重新启动）。
- en: Problem
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**Having dynamic memory is required if you need large amounts of memory and
    memory where you don’t know the required size beforehand. However, handling cleanup
    of dynamic memory is a hassle and is the source of many programming errors.**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果需要大量内存和预先不知道所需大小的内存，则需要动态内存。然而，处理动态内存的清理是一件麻烦事，并且是许多编程错误的根源。**'
- en: In many situations—for example, if you have large data of unknown size—you cannot
    put the data on the stack or in static memory. So you have to use dynamic memory
    and cope with allocating it. Now the question arises of how to clean that data
    up. Cleaning it up is a major source of programming errors. You could accidentally
    free the memory too early, causing a dangling pointer. You could accidentally
    free the same memory twice. Both of these programming errors can lead to undefined
    program behavior, for example, a program crash at some later point in time. Such
    errors are very difficult to debug, and C programmers spend way too much of their
    time troubleshooting such situations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下——例如，如果您有未知大小的大数据——您不能将数据放在堆栈或静态内存中。因此，您必须使用动态内存并处理其分配。现在问题是如何清理这些数据。清理这些数据是程序错误的主要来源。您可能会意外地过早释放内存，导致悬空指针。您可能会意外地两次释放相同的内存。这些编程错误都可能导致未定义的程序行为，例如在以后的某个时间点程序崩溃。这些错误非常难以调试，C
    程序员花费了太多时间来解决这些情况。
- en: Luckily, most kinds of memory come with some kind of automatic cleanup. The
    stack memory is automatically cleaned up when returning from a function. The static
    memory and the heap memory are automatically cleaned up on program termination.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数类型的内存都带有某种自动清理机制。返回函数时，堆栈内存会自动清理。静态内存和堆内存在程序终止时会自动清理。
- en: Solution
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Allocate dynamic memory and let the operating system cope with deallocation
    by the end of your program.**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**分配动态内存并让操作系统在程序结束时处理清理。**'
- en: 'When your program ends and the operating system cleans up your process, most
    modern operating systems also clean up any memory that you allocated and didn’t
    deallocate. Take advantage of that and let the operating system do the entire
    job of keeping track of which memory still needs cleanup and then actually cleaning
    it up, as done in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的程序结束并且操作系统清理您的进程时，大多数现代操作系统还会清理您分配但未释放的任何内存。利用这一点，让操作系统完全负责跟踪哪些内存仍然需要清理，然后实际清理它，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach looks very brutal at first sight. You deliberately create memory
    leaks. However, that’s the style of coding you’d also use in other programming
    languages that have a garbage collector. You could even include some garbage collector
    library in C to use that style of coding with the benefit of automatic memory
    cleanup (and the drawback of less predictable timing behavior).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法乍一看似乎很粗暴。你故意制造内存泄漏。然而，这种编码风格在其他具有垃圾回收器的编程语言中也是常用的。你甚至可以在C语言中包含一些垃圾收集库，以便在自动内存清理的同时使用这种编码风格（尽管会导致时间行为不太可预测）。
- en: Deliberately having memory leaks might be an option for some applications, particularly
    those that don’t run for a very long time and that don’t allocate very often.
    But for other applications it will not be an option and you’ll need Dedicated
    Ownership of memory and also to cope with its deallocation. An easy way to clean
    the memory up if you previously had Lazy Cleanup is to use an Allocation Wrapper
    and to then have one function that by the end of your program cleans up all the
    allocated memory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 故意制造内存泄漏可能是一些应用的选择，尤其是那些不运行很长时间且不经常分配内存的应用。但对于其他应用程序来说，这将不是一个选择，你需要专门的内存所有权并处理其释放。如果你之前使用了懒惰的清理，一种简单的方法来清理内存就是使用分配包装器，并且在程序结束时有一个函数来清理所有分配的内存。
- en: Consequences
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: The obvious advantage here is that you can benefit from using dynamic memory
    without having to cope with freeing the memory. That makes life a lot easier for
    a programmer. Also, you don’t waste any processing time on freeing memory and
    that can speed up the shutdown procedure of your program.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的优势在于，你可以享受动态内存的好处，而无需处理内存释放。这对程序员来说使生活变得轻松得多。此外，你不会浪费任何处理时间在释放内存上，这可以加快程序关闭过程的速度。
- en: However, this comes at the cost of other running processes that might need the
    memory that you do not release. Maybe you cannot even allocate any new memory
    yourself because there is not much left and you didn’t free the memory that you
    could have freed. In particular, if you allocate very often, this becomes a major
    issue and not cleaning up the memory will not be a good solution for you. Instead,
    you should Dedicate Ownership and also free the memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是以其他运行进程的代价为代价的，它们可能需要你没有释放的内存。也许你甚至无法再分配任何新的内存，因为没有剩下多少了，而你却没有释放本应该释放的内存。特别是如果你经常分配内存，这将成为一个主要问题，不清理内存将不是一个好的解决方案。相反，你应该专注于所有权，并释放内存。
- en: With this pattern, you accept that you are deliberately creating memory leaks
    and you do accept it. While that might be OK with you, it might not be OK with
    other people calling your functions. If you write a library that can be used by
    others, having memory leaks in that code will not be an option. Also, if you yourself
    want to stay very clean in some other part of the code and, for example, use a
    memory debugging tool like *valgrind* to detect memory leaks, you’d have problems
    with interpreting the results of the tool if some other part of your program is
    messy and does not free its memory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种模式，你接受你故意制造内存泄漏并且接受它。虽然这可能对你来说没问题，但对其他人调用你的函数可能不可接受。如果你编写的库可以供他人使用，那么在其中存在内存泄漏是不可接受的。此外，如果你希望在代码的其他部分保持非常干净，并且例如使用类似于*valgrind*的内存调试工具来检测内存泄漏，那么如果程序的其他部分混乱并且不释放其内存，你将难以解释工具的结果。
- en: This pattern can easily be used as an excuse for not implementing proper memory
    cleanup, even in cases where you should do that. So you should double check whether
    you are really in a context where you deliberately do not need to free your memory.
    If it is likely that in the future your program code evolves and will have to
    clean up the memory, then it is best not to start with Lazy Cleanup, but instead
    have Dedicated Ownership for cleaning up the memory properly right from the start.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式很容易被用作不实现正确内存清理的借口，即使在应该这样做的情况下也是如此。因此，你应该仔细检查你是否真的处于一个不需要释放内存的上下文中。如果未来你的程序代码可能会发展并且需要清理内存，那么最好不要从懒惰的清理开始，而是从一开始就正确地进行内存的专门所有权。
- en: Known Uses
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知的用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: The Wireshark function `pcap_free_datalinks` does under certain circumstances
    deliberately not free all memory. The reason is that part of the Wireshark code
    might have been built with a different compiler and different C runtime libraries.
    Freeing memory that was allocated by such code might result in a crash. Therefore,
    the memory is explicitly not freed at all.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark 函数 `pcap_free_datalinks` 在某些情况下故意不释放所有内存。原因是 Wireshark 代码的一部分可能是使用不同编译器和不同的
    C 运行时库构建的。释放由这样的代码分配的内存可能导致崩溃。因此，该内存明确地不被释放。
- en: The device drivers of the company B&R’s Automation Runtime operating system
    usually don’t have any functionality for deinitializing. All memory they allocate
    is never freed because these drivers are never unloaded at runtime. If a different
    driver should be used, the whole system reboots. That makes explicitly freeing
    the memory unnecessary.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司 B&R 的 Automation Runtime 操作系统的设备驱动程序通常没有卸载功能。它们分配的所有内存永远不会被释放，因为这些驱动程序在运行时不会被卸载。如果应该使用不同的驱动程序，则整个系统将重新启动。这使得显式释放内存变得不必要。
- en: The code of the NetDRMS data management system, which is used to store images
    of the sun for scientific processing, does not explicitly free all memory in error
    situations. For example, if an error occurs, the function `EmptyDir` does not
    clean up all memory or other resources related to accessing files because such
    an error would lead to a more severe error and program abort anyway.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储太阳图像进行科学处理的 NetDRMS 数据管理系统的代码，在错误情况下并没有显式释放所有内存。例如，如果发生错误，则函数 `EmptyDir`
    不会清理所有与访问文件相关的内存或其他资源，因为这样的错误会导致更严重的错误和程序中止。
- en: Any C code that uses garbage collection library applies this pattern and conquers
    its drawbacks of memory leaks with explicit garbage collection.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用垃圾回收库的任何 C 代码都应用了这种模式，并通过显式垃圾回收克服了内存泄漏的缺点。
- en: Applied to Running Example
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'In your code, you simply omit using any `free` function call. Also, you restructured
    the code to have the file access functionality in separate functions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，您简单地省略了使用任何 `free` 函数调用。此外，您重构了代码，使文件访问功能分开到不同的函数中：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You do allocate the memory, but you don’t call `free` to deallocate it. Instead,
    you let the pointers to the memory run out of scope and have a memory leak. However,
    it’s not a problem because your program ends right afterwards anyway, and the
    operating system cleans up the memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您分配了内存，但是没有调用 `free` 来释放它。相反，您让指向内存的指针超出作用域，并且有一个内存泄漏。然而，这不是问题，因为您的程序在之后立即结束，并且操作系统会清理内存。
- en: That approach seems quite unrefined, but in a few cases it is completely acceptable.
    If you need the memory throughout the lifetime of your program, or if your program
    is short-lived and you are sure that your code is not going to evolve or be reused
    somewhere else, then simply not having to cope with cleaning the memory up can
    be a solution that makes life very simple for you. Still, you have to be very
    careful that your program does not evolve and become long-lived. In that case,
    you’d definitely have to find another approach.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那种方法似乎相当粗糙，但在一些情况下完全可以接受。如果您需要在程序的整个生命周期内保持内存，或者如果您的程序生命周期很短，并且您确信您的代码不会在其他地方进化或被重用，那么简单地不必处理内存清理可能是一种能极大简化您生活的解决方案。但是，您必须非常小心，确保您的程序不会发展并变得长寿。在这种情况下，您肯定需要找到另一种方法。
- en: And that is exactly what you’ll do next. You want to encrypt more than one file.
    You want to encrypt all files from the current directory. You quickly realize
    that you have to allocate more often and that not deallocating any of the memory
    in the meantime is not an option anymore because you’d use up a lot of memory.
    This could be a problem for your program or other programs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是您接下来要做的。您希望加密多个文件。您希望加密当前目录中的所有文件。您很快意识到，您必须更频繁地分配内存，并且在此期间不释放任何内存不再是一个选项，因为这可能成为您的程序或其他程序的问题。
- en: The question comes up of where in the code your memory should be deallocated.
    Who is responsible for doing that? You definitely need Dedicated Ownership.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在代码中内存应该在哪里被释放。谁负责做这件事？您肯定需要专用所有权。
- en: Dedicated Ownership
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专用所有权
- en: Context
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You have large data of previously unknown size in your program and you use dynamic
    memory to store it. You don’t need that memory for the whole lifetime of the program
    and you have to allocate memory of different size often, so you cannot afford
    to use Lazy Cleanup.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中有大量未知大小的数据，并且你使用动态内存来存储它。你不需要整个程序的生命周期都使用该内存，并且你经常需要分配不同大小的内存，因此不能使用惰性清理。
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**The great power of using dynamic memory comes with the great responsibility
    of having to properly clean that memory up. In larger programs, it becomes difficult
    to make sure that all dynamic memory is cleaned up properly.**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用动态内存的巨大力量伴随着必须妥善清理内存的巨大责任。在较大的程序中，确保所有动态内存得到正确清理变得困难。**'
- en: There are many pitfalls when cleaning up dynamic memory. You might clean it
    up too soon and somebody else afterwards still wants to access that memory (dangling
    pointer). Or you might accidentally free the memory too often. Both of these programming
    errors lead to unexpected program behavior, like a crash of the program at some
    later point in time, and such errors are security issues and could be exploited
    by an attacker. Also, such errors are extremely difficult to debug.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 清理动态内存时存在许多陷阱。你可能会太早清理它，而之后其他人仍然希望访问该内存（悬空指针）。或者你可能意外地频繁释放内存。这些编程错误都会导致意外的程序行为，比如在以后某个时间点程序崩溃，并且这些错误是安全问题，可能会被攻击者利用。此外，这些错误非常难以调试。
- en: Yet you do have to clean up the memory, because over time, you’d use up too
    much memory if you allocate new memory without freeing it. Then your program or
    other processes would run out of memory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你确实需要清理内存，因为随着时间推移，如果分配新的内存而不释放它，你会使用太多内存。然后你的程序或其他进程会因为内存不足而运行失败。
- en: Solution
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Right at the time when you implement memory allocation, clearly define and
    document where it’s going to be cleaned up and who is going to do that.**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**在实现内存分配时，立即定义并记录它将在何处进行清理，并记录谁将执行清理。**'
- en: It should be clearly documented in the code who owns the memory and how long
    it’s going to be valid. Best case, even before writing your first `malloc`, you
    should have asked yourself where that memory will be freed. You should have also
    written some comments in the function declarations to make clear if memory buffers
    are passed along by that function and if so, who is responsible for cleaning it
    up.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中明确记录谁拥有内存以及它将有效多长时间是非常重要的。最好的情况是，在写下你的第一个`malloc`之前，你应该问自己那些内存将会被释放。你还应该在函数声明中写一些注释，明确表明如果内存缓冲区由该函数传递，那么谁负责清理它。
- en: In other programming languages, like C++, you have the option to use code constructs
    for documenting this. Pointer constructs like `unique_ptr` or `shared_ptr` make
    it possible to see from the function declarations who is responsible for cleaning
    the memory up. As there are no such constructs in C, extra care has to be taken
    to document this responsibility in the form of code comments.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言（如C++）中，你可以使用代码结构来记录这一点。指针结构如`unique_ptr`或`shared_ptr`使得可以从函数声明中看到谁负责清理内存。由于C语言中没有这样的结构，必须格外小心地在代码注释中记录这一责任。
- en: 'If possible, make the same function responsible for allocation and deallocation,
    just as it is with Object-Based Error Handling in which you have exactly one point
    in the code for calling constructor- and destructor-like functions for allocation
    and deallocation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，同一个函数负责分配和释放，就像在基于对象的错误处理中一样，代码中有一个确切的调用点用于调用类似构造函数和析构函数的分配和释放：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the responsibility for allocation and deallocation is spread across the
    code and if ownership of memory is transferred, it gets complicated. In some cases,
    this will be necessary, for example, if only the allocating function knows the
    size of the data and that data is needed in other functions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配和释放的责任分散在代码中，如果内存的所有权被转移，情况就变得复杂。在某些情况下，这是必要的，例如，如果只有分配函数知道数据的大小，并且其他函数需要该数据：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_memory_management_CO2-1)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_memory_management_CO2-1)'
- en: The callee allocates some memory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者分配一些内存。
- en: '[![2](assets/2.png)](#co_memory_management_CO2-2)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_memory_management_CO2-2)'
- en: The caller is responsible for cleaning up the memory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者负责清理内存。
- en: If possible, avoid putting the responsibility for allocation and deallocation
    in different functions. But in any case, document who is responsible for cleanup
    to make that clear.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，请避免将分配和释放内存的责任放在不同的函数中。但无论如何，请记录谁负责清理工作，以便明确。
- en: Other patterns that describe more specific situations related to memory ownership
    are the Caller-Owned Buffer or the Caller-Owned Instance in which the caller is
    responsible for allocating and deallocating memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 描述与内存所有权相关的更具体情况的其他模式是调用者拥有缓冲区或调用者拥有实例，在这些模式中，调用者负责分配和释放内存。
- en: Consequences
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Finally, you can allocate memory and properly handle its cleanup. That gives
    you flexibility. You can temporarily use large amounts of memory from the heap
    and at a later point in time let others use that memory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以分配内存并正确处理其清理。这使您具有灵活性。您可以临时从堆中使用大量内存，稍后再让其他人使用该内存。
- en: But of course that benefit comes at some additional cost. You have to cope with
    cleaning up the memory and that makes your programming work harder. Even when
    having Dedicated Ownership, memory-related programming errors can occur and lead
    to hard-to-debug situations. Also, it takes some time to free the memory. Explicitly
    documenting where memory will be cleaned helps to prevent some of these errors
    and in general makes the code easier to understand and maintain. To further avoid
    memory-related programming errors, you can also use an Allocation Wrapper and
    Pointer Check.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，这种好处伴随着额外的成本。您必须处理内存的清理工作，这使得您的编程工作更加困难。即使具有专用所有权，也可能出现与内存相关的编程错误，并导致难以调试的情况。此外，释放内存需要一些时间。明确记录内存将被清理的位置有助于防止其中一些错误，并且通常使代码更易于理解和维护。为了进一步避免与内存相关的编程错误，您还可以使用分配包装器和指针检查。
- en: With the allocation and deallocation of dynamic memory, the problems of heap
    fragmentation and increased time for allocating and accessing the memory come
    up. For some applications that might not be an issue at all, but for other applications
    these topics are very serious. In that case, a Memory Pool can help.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随着动态内存的分配和释放，堆碎片化和分配和访问内存所需的时间增加的问题浮出水面。对于某些应用程序，这可能根本不是问题，但对于其他应用程序，这些话题非常严重。在这种情况下，内存池可以提供帮助。
- en: Known Uses
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: The book *Extreme C* by Kamran Amini (Packt, 2019) suggests that the function
    that allocated memory should also be responsible for freeing it and that the function
    or object that owns the memory should be documented as comments. Of course that
    concept also holds true if you have wrapper functions. Then the function that
    calls the allocation wrapper should be the one that calls the cleanup wrapper.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kamran Amini（Packt，2019）的书《Extreme C》建议，分配内存的函数也应负责释放它，并且应将拥有内存的函数或对象作为注释进行文档化。当然，如果您有包装函数，则调用分配包装器的函数应该调用清理包装器。
- en: The implementation of the function `mexFunction` of the numeric computing environment
    MATLAB clearly documents which memory it owns and will free.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值计算环境MATLAB的函数`mexFunction`的实现清楚地记录了它拥有并将释放的内存。
- en: The NetHack game explicitly documents for the callers of the functions if they
    have to free some memory. For example, the function `nh_compose_ascii_screenshot`
    allocates and returns a string that has to be freed by the caller.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetHack游戏明确为函数的调用者文档化了是否必须释放某些内存。例如，函数`nh_compose_ascii_screenshot`分配并返回一个字符串，调用者必须释放它。
- en: The Wireshark dissector for “Community ID flow hashes” clearly documents for
    its functions who is responsible for freeing memory. For example, the function
    `communityid_calc` allocates some memory and requires the caller to free it.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于“Community ID流哈希”Wireshark解析器的功能清楚地记录了谁负责释放内存。例如，函数`communityid_calc`分配了一些内存，并要求调用者释放它。
- en: Applied to Running Example
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'The functionality of `encryptCaesarFile` did not change. The only thing you
    changed is that you now also call `free` to deallocate the memory, and you now
    clearly document in the code comments who is responsible for cleaning up which
    memory. Also, you implemented the function `encryptDirectoryContent` that encrypts
    all files in the current working directory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`encryptCaesarFile`函数的功能没有改变。您唯一改变的是现在也调用`free`来释放内存，并且您现在在代码注释中清楚地记录了谁负责清理哪些内存。此外，您还实现了`encryptDirectoryContent`函数，该函数加密当前工作目录中的所有文件：'
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code prints the Caesar-encrypted content of all files of the current directory.
    Note that the code only works on UNIX systems and that for reasons of simplicity,
    no specific error handling is implemented if the files in the directory don’t
    have the expected content.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码打印当前目录所有文件的凯撒加密内容。请注意，该代码仅适用于UNIX系统，并且由于简化起见，如果目录中的文件没有预期的内容，则未实现特定的错误处理。
- en: The memory is now also cleaned up when it is not required anymore. Note that
    not all the memory that the program requires during its runtime is allocated at
    the same time. The most memory allocated at any time throughout the program is
    the memory required for one of the files. That makes the memory footprint of the
    program significantly smaller, particularly if the directory contains many files.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要内存时，现在也清理内存。请注意，程序在运行时期间所需的所有内存并非同时分配。在程序中运行时任何时候分配的最大内存是文件中所需的内存之一。这使得程序的内存占用明显较小，尤其是如果目录包含许多文件。
- en: The preceding code does not cope with error handling. For example, what happens
    if no more memory is available? The code would simply crash. You want to have
    some kind of error handling for such situations, but checking the pointers returned
    from `malloc` at each and every point where you allocate memory can be cumbersome.
    What you need is an Allocation Wrapper.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码未处理错误处理。例如，如果没有更多可用内存会发生什么？代码将会崩溃。您希望对此类情况进行某种形式的错误处理，但在每个分配内存的点上检查`malloc`返回的指针可能会很麻烦。您需要的是一个分配包装器。
- en: Allocation Wrapper
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配包装器
- en: Context
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You allocate dynamic memory at several places in your code, and you want to
    react to error situations such as running out of memory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您在代码中的多个地方分配动态内存，并且希望在内存耗尽等错误情况下作出反应。
- en: Problem
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**Each allocation of dynamic memory might fail, so you should check allocations
    in your code to react accordingly. This is cumbersome because you have many places
    for such checks in your code.**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**每次动态内存分配都可能失败，因此您应该在代码中检查分配情况以做出相应反应。这很麻烦，因为您的代码中有许多地方需要进行这样的检查。**'
- en: The `malloc` function returns `NULL` if the requested memory is not available.
    On the one hand, not checking the return value of `malloc` would cause your program
    to crash if no memory is available and you access a `NULL` pointer. On the other
    hand, checking the return value at each and every place where you allocate makes
    your code more complicated and thus harder to read and maintain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的内存不可用，`malloc`函数会返回`NULL`。一方面，如果不检查`malloc`的返回值，如果没有可用内存并且访问了`NULL`指针，您的程序将崩溃。另一方面，在每个分配位置检查返回值会使您的代码更复杂，因此更难阅读和维护。
- en: If you distribute such checks across your codebase and later on want to change
    your behavior in case of allocation errors, then you’d have to touch code at many
    different places. Also, simply adding an error check to existing functions violates
    the single-responsibility principle, which says that one function should be responsible
    for only one thing (and not for multiple things like allocation and program logic).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将这些检查分布到代码库中的各个位置，稍后想要在分配错误的情况下更改行为，则必须在许多不同的地方触及代码。此外，简单地向现有函数添加错误检查违反了单一责任原则，该原则规定一个函数应该只负责一件事情（而不是多个事情，如分配和程序逻辑）。
- en: Also, if you want to change the method of allocation later on, maybe to explicitly
    initialize all allocated memory, then having many calls to allocation functions
    distributed all over your code makes that very hard.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果以后想要更改分配方法，也许是显式初始化所有分配的内存，则在代码中广泛调用分配函数会使这一过程变得非常困难。
- en: Solution
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Wrap the allocation and deallocation calls, and implement error handling
    or additional memory management organization in these wrapper functions.**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装分配和释放调用，并在这些包装函数中实现错误处理或额外的内存管理组织。**'
- en: 'Implement a wrapper function for the `malloc` and `free` calls, and for memory
    allocation and deallocation only call these wrapper functions. In the wrapper
    function, you can implement error handling at one central point. For example,
    you can check the allocated pointer (see Pointer Check) and in case of error abort
    the program as shown in the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为`malloc`和`free`调用实现一个包装函数，并且仅在这些包装函数中调用内存分配和释放。在包装函数中，您可以在一个中心点实现错误处理。例如，您可以检查分配的指针（参见指针检查），并在错误情况下中止程序，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As an alternative to aborting the program, you can Log Errors. For logging
    the debug information, using a macro instead of a wrapper function can make life
    even easier. You could then without any effort for the caller log the filename,
    the function name, or the code line number where the error occurred. With that
    information, it is very easy for the programmer to pinpoint the part of the code
    where the error occurred. Also, having a macro instead of a wrapper function saves
    you the additional function call of the wrapper function (but in most cases that
    doesn’t matter, or the compiler would inline the function anyway). With macros
    for allocation and deallocation you could even build a constructor-like syntax:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为中止程序的替代方法，你可以**记录错误**。对于记录调试信息，使用宏而不是包装函数可以更加方便。这样一来，你可以毫不费力地记录文件名、函数名或错误发生的代码行号。有了这些信息，程序员可以很容易地确定代码中出现错误的部分。此外，使用宏而不是包装函数还可以避免额外的函数调用（不过在大多数情况下这不重要，或者编译器会内联该函数）。使用分配和释放的宏甚至可以构建类似构造函数的语法：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In addition to handling error situations in the wrapper functions, you could
    also do other things. For example, you could keep track of which memory your program
    allocated and store that information along with the code file and code line number
    in a list (for that you’d also need a wrapper for `free`, like in the preceding
    example). That way you can easily print debug information if you want to see which
    memory is currently allocated (and which of it you might have forgotten to free).
    But if you are looking for such information, you could also simply use a memory
    debugging tool like valgrind. Furthermore, by keeping track of which memory you
    allocated, you could implement a function to free all your memory—this might be
    an option to make your program cleaner if you previously used Lazy Cleanup.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在包装器函数中处理错误情况之外，您还可以做其他事情。例如，您可以跟踪程序分配的内存，并将其信息存储在列表中，连同代码文件和代码行号一起（为此，您还需要像前面的示例中那样的`free`包装器）。这样，如果您想查看当前分配的内存（以及您可能忘记释放的部分），则可以轻松地打印调试信息。但如果您需要此信息，您也可以简单地使用像valgrind这样的内存调试工具。此外，通过跟踪分配的内存，您还可以实现一个释放所有内存的函数——如果您以前使用惰性清理，这可能是使程序更清洁的选项。
- en: Having everything in one place will not always be a solution for you. Maybe
    there are noncritical parts of your application for which you do not want the
    whole application to abort if an allocation error occurs there. In that case,
    having multiple Allocation Wrappers could work for you. One wrapper could still
    assert on error and could be used for the critical allocations that are mandatory
    for your application to work. Another wrapper for the noncritical part of your
    application could Return Status Codes on error to make it possible to gracefully
    handle that error situation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一个地方并不总是解决方案。也许您的应用程序有一些非关键部分，您不希望整个应用程序在发生分配错误时中止。在这种情况下，拥有多个分配包装器可能适合您。一个包装器仍然可以在错误发生时断言，并且可以用于应用程序必须正常工作的关键分配。另一个用于应用程序的非关键部分的包装器，在错误发生时可能会返回状态码，以便优雅地处理该错误情况。
- en: Consequences
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Error handling and other memory handling are now in one central place. At the
    places in the code where you need to allocate memory, you now simply call the
    wrapper and there is no need to explicitly handle errors at that point in the
    code. But that only works for some kinds of error handling. It works very well
    if you abort the program in case of errors, but if you react to errors by continuing
    the program with some degraded functionality, then you still have to return some
    error information from the wrapper and react to it. For that, the Allocation Wrapper
    does not make life easier. However, in such a scenario, there could still be some
    logging functionality implemented in the wrapper to improve the situation for
    you.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理和其他内存处理现在集中在一个地方。在需要分配内存的代码处，现在只需调用包装函数，无需在代码中显式处理错误。但这仅适用于某些类型的错误处理。如果在错误发生时中止程序效果很好，但如果您对错误做出反应并继续以降低的功能继续运行程序，则仍需从包装器返回一些错误信息，并对其做出反应。对于这种情况，分配包装器不能让生活更轻松。但是，在这种情况下，包装器中仍然可以实现一些日志功能以改善您的情况。
- en: The wrapper function brings advantages for testing because you have one central
    point for changing the behavior of your memory allocation function. In addition,
    you can mock the wrapper (replace the wrapper calls with some other test function)
    while still leaving other calls to `malloc` (maybe from third-party code) untouched.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包装函数对于测试带来了优势，因为你可以有一个中心点来改变你的内存分配函数的行为。此外，你可以模拟这个包装器（用其他测试函数替换包装器调用），同时仍然保留对`malloc`（可能来自第三方代码）的其他调用。
- en: Separating the error-handling part from the calling code with a wrapper function
    is good practice because then the caller is not tempted to implement error handling
    directly inside the code that handles other programing logic. Having several things
    done in one function (program logic and extensive error handling) would violate
    the single-responsibility principle.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包装函数将错误处理部分与调用代码分离是一个好的实践，因为这样调用者就不会诱惑在处理其他程序逻辑的代码中直接实现错误处理。在一个函数中做几件事情（程序逻辑和广泛的错误处理）将违反单一责任原则。
- en: Having an Allocation Wrapper allows you to consistently handle allocation errors
    and makes it easier for you if you want to change the error-handling behavior
    or memory allocation behavior later on. If you decide that you want to log additional
    information, there is just one place in the code that you’d have to touch. If
    you decide to later on not directly call `malloc` but to use a Memory Pool instead,
    this is a lot easier when having the wrapper.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个分配包装器允许你一致地处理分配错误，并且如果以后你想要改变错误处理行为或内存分配行为，这将更容易。如果你决定想要记录额外的信息，那么只需在代码中的一个地方进行修改。如果以后决定不直接调用`malloc`而是使用内存池，那么有了包装器就容易得多。
- en: Known Uses
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了该模式的应用：
- en: The book *C Interfaces and Implementations* by David R. Hanson (Addison-Wesley,
    1996) uses a wrapper function for allocating memory in an implementation for a
    Memory Pool. The wrappers simply call `assert` to abort the program in case of
    errors.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由David R. Hanson（Addison-Wesley，1996）著作的*C接口与实现*一书，在内存池的实现中使用了一个用于分配内存的包装函数。包装函数简单地调用`assert`来在出现错误时终止程序。
- en: GLib provides the functions `g_malloc` and `g_free` among other memory-related
    functions. The benefit of using `g_malloc` is that in case of error, it aborts
    the program (Samurai Principle). Because of that, there is no need for the caller
    to check the return value of each and every function call for allocating memory.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLib提供了`g_malloc`和`g_free`等内存相关函数。使用`g_malloc`的好处在于，在出现错误时终止程序（武士原则）。因此，调用者不需要检查每个函数调用的返回值来分配内存。
- en: The GoAccess real-time web log analyzer implements the function `xmalloc` to
    wrap `malloc` calls with some error handling.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoAccess实时Web日志分析器实现了函数`xmalloc`来包装带有一些错误处理的`malloc`调用。
- en: 'The Allocation Wrapper is an application of the Decorator pattern, which is
    described in the book *Design Patterns: Elements of Reusable Object-Oriented Software*
    by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Prentice Hall,
    1997).'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配包装器是装饰器模式的一个应用，该模式在*设计模式：可复用面向对象软件的元素*一书中由Erich Gamma、Richard Helm、Ralph Johnson和John
    Vlissides（Prentice Hall，1997）描述。
- en: Applied to Running Example
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'Now, instead of directly calling `malloc` and `free` everywhere in your code,
    you use wrapper functions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在代码中不是直接调用到处的`malloc`和`free`，而是使用包装函数：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_memory_management_CO3-1)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_memory_management_CO3-1)'
- en: If the allocation fails, you adhere to the Samurai Principle and abort the program.
    For applications like yours, this is a valid option. If there is no way for you
    to gracefully handle the error, then directly aborting the program is the right
    and proper choice.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配失败，你要坚持武士原则并终止程序。对于像你的应用程序这样的应用，这是一个有效的选择。如果没有办法优雅地处理错误，那么直接终止程序是正确和合适的选择。
- en: With the Allocation Wrapper you have the advantage that you now have a central
    point for handling allocation errors. There is no need to write lines of code
    for checking the pointer after each allocation in your code. You also have a wrapper
    for freeing the code, which might come in handy in the future if you, for example,
    decide to keep track of which memory is currently allocated by your application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分配包装器的好处是，现在您有一个集中处理分配错误的中心点。您无需在代码中的每个分配后写检查指针的代码行。您还有一个用于释放代码的包装器，在将来可能会派上用场，例如，如果您决定跟踪应用程序当前分配的内存。
- en: After the allocation you now check if the retrieved pointer is valid. After
    that, you don’t check the pointer for validity anymore, and you also trust that
    the pointers you receive across function boundaries are valid. This is fine as
    long as no programming errors sneak in, but if you accidentally access invalid
    pointers, the situation becomes difficult to debug. To improve your code and to
    be on the safe side, you decide to use a Pointer Check.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 分配后，现在您检查检索到的指针是否有效。之后，您不再检查指针的有效性，并且还相信穿越函数边界时收到的指针是有效的。只要没有编程错误潜入，这是可以接受的，但如果意外访问无效指针，则情况变得难以调试。为了改进您的代码并确保安全，您决定使用指针检查。
- en: Pointer Check
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针检查
- en: Context
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: Your program contains many places where you allocate and deallocate memory and
    many places where you access that memory or other resources with pointers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序包含许多地方用于分配和释放内存，以及许多地方用于使用指针访问该内存或其他资源。
- en: Problem
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**Programming errors that lead to accessing an invalid pointer cause uncontrolled
    program behavior, and such errors are difficult to debug. However, because your
    code works with pointers frequently, there is a good chance that you have introduced
    such programming errors.**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**导致访问无效指针的编程错误会导致不受控制的程序行为，这类错误很难调试。但是，由于您的代码经常使用指针，很有可能引入这类编程错误。**'
- en: C programming requires a lot of struggling with pointers, and the more places
    you have in the code that work with pointers, the more places you have in the
    code where you could introduce programming errors. Using a pointer that was already
    freed or using an uninitialized pointer would lead to error situations that are
    hard to debug.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: C编程需要大量与指针的斗争，代码中使用指针的地方越多，引入编程错误的可能性就越多。使用已释放的指针或使用未初始化的指针将导致难以调试的错误情况。
- en: Any such error situation is very severe. It leads to uncontrolled program behavior
    and (if you are lucky) to a program crash. If you are not as lucky, you end up
    with an error that occurs at a later point in time during program execution and
    that takes you a week to pinpoint and debug. You want your program to be more
    robust against such errors. You want to make such errors less severe, and you
    want to make it easier to find the cause of such error situations if they occur
    in your running program.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这类错误情况都非常严重。它导致不受控制的程序行为，（如果您幸运的话）可能导致程序崩溃。如果不够幸运，您将在程序执行期间的后续时间点遇到错误，并且需要花费一周的时间来准确定位和调试。您希望您的程序对这类错误更加健壮。您希望减轻这类错误的严重性，并且希望如果这类错误在运行中发生，能更容易找到其原因。
- en: Solution
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Explicitly invalidate uninitialized or freed pointers and always check pointers
    for validity before accessing them.**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**明确地使未初始化或已释放的指针失效，并且在访问它们之前始终检查指针的有效性。**'
- en: Right at the variable declaration, set pointer variables explicitly to `NULL`.
    Also, right after calling `free`, set them explicitly to `NULL`. If you use an
    Allocation Wrapper that uses a macro for wrapping the `free` function, you could
    directly set the pointer to `NULL` inside the macro to avoid having additional
    lines of code for invalidating the pointer at each deallocation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明时，将指针变量显式设置为`NULL`。同样，在调用`free`后立即将其显式设置为`NULL`。如果您使用的分配包装器使用宏来包装`free`函数，则可以直接在宏内部将指针设置为`NULL`，以避免在每次释放时为使指针失效而添加额外的代码行。
- en: 'Have a wrapper function or a macro that checks a pointer for `NULL` and in
    case of a `NULL` pointer aborts the program and Logs Errors to have some debug
    information. If aborting the program is not an option for you, then in case of
    `NULL` pointers you could instead not perform the pointer access and try to handle
    the error gracefully. This will allow your program to continue with reduced functionality
    as shown in the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包装函数或宏来检查指针是否为`NULL`，并在遇到`NULL`指针时中止程序并记录错误信息，以便进行调试。如果中止程序不适合你，那么在遇到`NULL`指针时，你可以选择不访问指针并尝试优雅地处理错误。这将允许你的程序以降低的功能继续执行，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Consequences
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Your code is a bit more protected against pointer-related programming errors.
    Each such error that can be identified and does not lead to undefined program
    behavior might save you hours and days of debugging effort.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码对于与指针相关的编程错误有了更多的保护。每一个能够被识别且不会导致未定义程序行为的这类错误，都可能为你节省数小时甚至数天的调试工作。
- en: However, this does not come for free. Your code becomes longer and more complicated.
    The strategy you apply here is like having a belt and suspenders. You do some
    extra work to be safer. You have additional checks for each pointer access. This
    makes the code harder to read. For checking the pointer validity before accessing
    it, you’ll have at least one additional line of code. If you do not abort the
    program but instead continue with degraded functionality, then your program becomes
    much more difficult to read, maintain, and test.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是无偿的。你的代码变得更长、更复杂。你在这里应用的策略就像是同时系上腰带和吊裤带。你做了一些额外的工作来更安全。你对每个指针访问都增加了额外的检查。这使得代码更难阅读。在访问指针之前检查其有效性，你至少需要增加一行代码。如果你不中止程序，而是选择以降低的功能继续执行，那么你的程序将变得更加难以阅读、维护和测试。
- en: If you accidentally call `free` on a pointer multiple times, then your second
    call would not lead to an error situation because after the first call you invalidated
    the pointer, and subsequently calling `free` on a `NULL` pointer does no harm.
    Still, you could Log Errors like this to make it possible to pinpoint the root
    cause for the error.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意外地对同一个指针多次调用`free`，那么第二次调用将不会导致错误情况，因为在第一次调用后你使指针无效，随后在`NULL`指针上调用`free`不会造成任何伤害。尽管如此，你仍然可以像这样记录错误信息，以便能够准确定位错误的根本原因。
- en: But even after all that, you are not fully protected against every kind of pointer-related
    error. For example, you could forget to free some memory and produce a memory
    leak. Or you could access a pointer that you did not properly initialize, but
    at least you’d detect that and could react accordingly. A possible drawback here
    is that if you decide to gracefully degrade your program and continue, you might
    obscure error situations that are then hard to find later on.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使这样，你也不能完全防止所有与指针相关的错误。例如，你可能会忘记释放一些内存，导致内存泄漏。或者你可能会访问一个没有正确初始化的指针，但至少你会检测到这一点，并且可以相应地做出反应。这里可能存在的一个缺点是，如果你决定优雅地降低程序的执行，并继续执行，那么你可能会掩盖一些难以在后期找到的错误情况。
- en: Known Uses
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子展示了这种模式的应用：
- en: The implementation for C++ smart pointers invalidates the wrapped raw pointer
    when releasing the smart pointer.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++智能指针的实现在释放智能指针时使封装的原始指针失效。
- en: Cloudy is a program for physical calculations (spectral synthesis). It contains
    some code for interpolation of data (Gaunt factor). This program checks pointers
    for validity before accessing them and explicitly sets the pointers to `NULL`
    after calling `free`.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloudy 是一个用于物理计算（光谱综合）的程序。它包含一些数据插值的代码（Gaunt因子）。该程序在访问指针之前会检查它们的有效性，并在调用`free`后显式将指针设置为`NULL`。
- en: The libcpp of the GNU Compiler Collection (GCC) invalidates the pointers after
    freeing them. For example, the pointers in the implementation file *macro.c* do
    this.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU编译器集合（GCC）的libcpp在释放指针后使其失效。例如，实现文件*macro.c*中的指针就是这样做的。
- en: The function `HB_GARBAGE_FUNC` of the MySQL database management system sets
    the pointer `ph` to `NULL` to avoid accidentally accessing it or freeing it multiple
    times later on.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL数据库管理系统的函数`HB_GARBAGE_FUNC`将指针`ph`设置为`NULL`，以避免在后续的多次访问或释放中意外访问它。
- en: Applied to Running Example
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'You now have the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了以下代码：
- en: '[PRE19]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_memory_management_CO4-1)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_memory_management_CO4-1)'
- en: At places where the pointer is not valid, you explicitly set it to `NULL`—just
    to be on the safe side.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在指针无效的地方，你需要将其显式设置为`NULL`，以防万一。
- en: '[![2](assets/2.png)](#co_memory_management_CO4-2)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_memory_management_CO4-2)'
- en: Before accessing the pointer `text`, you check whether it is valid. If it is
    not valid, you don’t use the pointer (you don’t dereference it).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问指针`text`之前，你检查它是否有效。如果它无效，你不使用该指针（不对其进行解引用）。
- en: Linux Overcommit
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 超配
- en: Beware that having a valid memory pointer does not always mean that you can
    safely access that memory. Modern Linux systems work with the *overcommit* principle.
    This principle provides virtual memory to the program that allocates, but this
    virtual memory has no direct correspondence to physical memory. Whether the required
    physical memory is available is checked once you access that memory. If not enough
    physical memory is available, the Linux kernel shuts down applications that consume
    a lot of memory (and that might be your application). Overcommit brings the advantage
    that it becomes less important to check if allocation worked (because it usually
    does not fail), and you can allocate a lot of memory to be on the safe side, even
    if you only need a little. But overcommit also comes with the big disadvantage
    that even with a valid pointer, you can never be sure that your memory access
    works and will not lead to a crash. Another disadvantage is that you might become
    lazy with checking allocation return values and with figuring out and allocating
    only the amount of memory that you actually need.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，拥有有效的内存指针并不总是意味着可以安全地访问该内存。现代 Linux 系统采用了*超配*原则。这个原则为分配内存的程序提供虚拟内存，但这种虚拟内存与物理内存没有直接对应关系。只有当你访问该内存时，才会检查所需的物理内存是否可用。如果可用的物理内存不足，Linux
    内核会关闭消耗大量内存的应用程序（可能是你的应用程序）。超配的好处在于，不太需要检查分配是否成功（因为通常不会失败），你可以为了安全起见分配大量内存，即使你只需要一点。但超配的缺点是，即使有一个有效的指针，你也不能确定你的内存访问是否有效，并且不会导致崩溃。另一个缺点是，你可能会懒得检查分配返回值，以及弄清楚和分配实际需要的内存量。
- en: Next, you also want to show the Caesar-encrypted filename along with the encrypted
    text. You decide against directly allocating the required memory from the heap
    because you are afraid of memory fragmentation when repeatedly allocating small
    memory chunks (for the filenames) and large memory chunks (for the file content).
    Instead of directly allocating dynamic memory, you implement a Memory Pool.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你还希望显示凯撒加密后的文件名以及加密后的文本。你决定不直接从堆中分配所需的内存，因为你担心重复分配小内存块（用于文件名）和大内存块（用于文件内容）会导致内存碎片化。为了避免直接分配动态内存，你实现了一个内存池。
- en: Memory Pool
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存池
- en: Context
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You frequently allocate and deallocate dynamic memory from the heap in your
    program for elements of roughly the same size. You don’t know at compile time
    or startup time exactly where and when in your program these elements are needed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中，你经常需要从堆中分配和释放动态内存，用于大致相同大小的元素。你在编译时或启动时并不知道这些元素在程序中的具体位置和使用时间。
- en: Problem
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**Frequently allocating and deallocating objects from the heap leads to memory
    fragmentation.**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**频繁从堆中分配和释放对象会导致内存碎片化。**'
- en: When allocating objects, in particular those of strongly varying size, while
    also deallocating some of them, the heap memory becomes fragmented. Even if the
    allocations from your code are roughly the same size, they might be mixed with
    allocations from other programs running in parallel, and you’d end up with allocations
    of greatly varying size and fragmentation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配对象时，特别是那些大小差异很大的对象，同时又释放其中一些时，堆内存会变得碎片化。即使你的代码中的分配大致相同大小，它们可能与并行运行的其他程序的分配混合在一起，导致分配大小差异很大且碎片化。
- en: The `malloc` function can only succeed if there is enough free consecutive memory
    available. That means that even if there is enough free memory available, the
    `malloc` function might fail if the memory is fragmented and no consecutive chunk
    of memory of the required size is available. Memory fragmentation means that the
    memory is not being utilized very well.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc`函数只有在有足够的连续空闲内存可用时才能成功。这意味着，即使有足够的空闲内存可用，如果内存碎片化，并且没有足够大小的连续内存块可用，`malloc`函数也可能失败。内存碎片化意味着内存使用效率不高。'
- en: Fragmentation is a serious issue for long-running systems, like most embedded
    systems. If a system runs for some years and allocates and deallocates many small
    chunks, then it will no longer be possible to allocate a larger chunk of memory.
    This means that you definitely have to tackle the fragmentation issue for such
    systems if you don’t accept that the system has to be rebooted from time to time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间运行的系统（如大多数嵌入式系统），碎片化是一个严重问题。如果系统运行了几年并分配和释放了许多小块，那么将不再能够分配更大的内存块。这意味着对于这样的系统，您一定要解决碎片化问题，如果不接受系统不时需要重启的话。
- en: Another issue when using dynamic memory, particularly in combination with embedded
    systems, is that the allocation of memory from the heap takes some time. Other
    processes try to use the same heap, and thus the allocation has to be interlocked
    and its required time becomes very hard to predict.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用动态内存时（尤其是与嵌入式系统结合使用时），另一个问题是从堆中分配内存需要一些时间。其他进程也尝试使用同一堆，因此分配必须进行互锁，并且其所需的时间变得非常难以预测。
- en: Solution
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Hold a large piece of memory throughout the whole lifetime of your program.
    At runtime, retrieve fixed-size chunks of that memory pool instead of directly
    allocating new memory from the heap.**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**在整个程序生命周期中持有大块内存。在运行时，从该内存池检索固定大小的块，而不是直接从堆中分配新内存。**'
- en: The memory pool can either be placed in static memory or it can be allocated
    from the heap at program startup and freed at the end of the program. Allocation
    from the heap has the advantage that, if needed, additional memory can be allocated
    to increase the size of the memory pool.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 内存池可以放置在静态内存中，或者可以在程序启动时从堆中分配并在程序结束时释放。从堆中分配的优势在于，如果需要，可以分配额外的内存以增加内存池的大小。
- en: 'Implement functions for retrieving and releasing memory chunks of pre-configured
    fixed size from that pool. All of your code that needs memory of that size can
    use these functions (instead of `malloc` and `free`) for acquiring and releasing
    dynamic memory:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 实现函数以从该池中检索和释放预配置的固定大小的内存块。所有需要该大小内存的代码都可以使用这些函数（而不是 `malloc` 和 `free`）来获取和释放动态内存：
- en: '[PRE20]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code shows a simple implementation of a Memory Pool, and there
    would be many ways to improve that implementation. For example, free memory slots
    could be stored in a list to speed up taking such a slot. Also, Mutex or Semaphores
    could be used to make sure that it works in multithreaded environments.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了内存池的简单实现，当然还有许多改进的方法。例如，可以将空闲内存槽存储在列表中以加快获取此类槽的速度。此外，可以使用互斥锁或信号量确保其在多线程环境中工作。
- en: For the Memory Pool, you have to know which kind of data will be stored because
    you have to know the size of the memory chunks before runtime. You could also
    use these chunks to store smaller data, but then you’d waste some of the memory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内存池，您必须知道将存储哪种类型的数据，因为您必须在运行时知道内存块的大小。您也可以使用这些块来存储较小的数据，但这样会浪费一些内存。
- en: As an alternative to having fixed-size memory chunks, you could even implement
    a Memory Pool that allows retrieving variable-size memory chunks. With that alternative
    solution, while you’d better utilize your memory, you’d still end up with the
    same fragmentation problem that you have with the heap memory.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具有固定大小内存块的替代方案，您甚至可以实现一个内存池，允许检索可变大小的内存块。通过这种替代方案，尽管可以更好地利用内存，但最终仍会遇到与堆内存相同的碎片化问题。
- en: Consequences
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: You tackled fragmentation. With the pool of fixed-size memory chunks, you can
    be sure that as soon as you release one chunk, another one will be available.
    However, you have to know which kinds of elements to store in the pool and their
    size beforehand. If you decide to also store smaller elements in the pool, you
    waste memory.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您解决了碎片化问题。使用固定大小内存块池，您可以确保一旦释放一个块，另一个块将可用。但是，您必须事先知道要在池中存储哪些类型的元素及其大小。如果决定在池中存储较小的元素，那么会浪费内存。
- en: When using a pool of variable size, you don’t waste memory for smaller elements,
    but your memory in the pool gets fragmented. This fragmentation situation is still
    a bit better compared to directly using the heap because you are the only user
    of that memory (other processes don’t use the same memory). Also, you don’t fragment
    the memory used by other processes. However, the fragmentation problem is still
    there.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可变大小的池时，你不会为较小的元素浪费内存，但是池中的内存会被碎片化。与直接使用堆相比，这种碎片化情况仍稍微好一些，因为你是该内存的唯一使用者（其他进程不使用相同的内存）。此外，你不会使其他进程使用的内存碎片化。然而，碎片化问题仍然存在。
- en: No matter whether you use variable-sized or fixed-sized chunks in your pool,
    you have performance benefits. Getting memory from the pool is faster compared
    to allocating it from the heap because no mutual exclusion from other processes
    trying to get memory is required. Also, accessing the memory from the pool might
    be a bit faster because all the memory in the pool that your program uses lies
    closely together, which minimizes time overhead due to paging mechanisms from
    the operating system. However, initially creating the pool takes some time and
    will increase the startup time for your program.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在池中使用可变大小还是固定大小的块，都会带来性能上的好处。从池中获取内存比从堆中分配更快，因为不需要与其他进程竞争获取内存。此外，访问池中的内存可能会更快，因为你的程序使用的池中所有内存都紧密相连，这减少了由于操作系统的分页机制而产生的时间开销。然而，初始创建池需要一些时间，并且会增加程序的启动时间。
- en: Within your pool, you release the memory in order to reuse it somewhere else
    in your program. However, your program holds the total pool memory the entire
    time, and that memory will not be available to others. If you don’t need all of
    that memory, you waste it from an overall system perspective.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的池内，释放内存以便在程序的其他地方重用它。但是，你的程序始终持有整个池的内存，并且这些内存对其他程序不可用。如果你不需要所有这些内存，从整体系统的角度来看，你就浪费了它。
- en: If the pool is of initially fixed size, then you might have no more pool memory
    chunks available at runtime, even if there would be enough memory available in
    the heap. If the pool can increase its size at runtime, then you have the drawback
    that the time for retrieving memory from the pool can be increased unexpectedly
    if the pool size has to be increased to retrieve a memory chunk.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果池最初是固定大小的，则在运行时可能无法再获取更多的池内存块，即使堆中可能有足够的内存。如果池在运行时可以增加其大小，则检索内存块时，如果需要增加池的大小，则可能会意外增加检索内存的时间。
- en: Beware of Memory Pools in security- or safety-critical domains. The pool makes
    your code more difficult to test, and it makes it more difficult for code analysis
    tools to find bugs related to accessing that memory. For example, it is difficult
    for tools to detect if by mistake you access memory outside the boundaries of
    an acquired memory chunk of that pool. Your process also owns the other memory
    chunks of the pool that are located directly before and after the chunk you intend
    to access, and that makes it hard for code analysis tools to realize that accessing
    data across the boundary of a Memory Pool chunk is unintentional. Actually, the
    OpenSSL Heartbleed bug could have been prevented by code analysis if the affected
    code was not using a Memory Pool (see David A. Wheeler, “How to Prevent the Next
    Heartbleed,” July 18, 2020 [originally published April 29, 2014], [*https://dwheeler.com/essays/heartbleed.xhtml*](https://dwheeler.com/essays/heartbleed.xhtml)).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全或安全关键领域要注意内存池。池使得你的代码更难以测试，并且使得代码分析工具更难以发现与访问该内存相关的错误。例如，工具难以检测到你是否错误地访问了池的获取内存块边界之外的内存。你的进程还拥有池中那些你打算访问的内存块之前和之后直接位于边界的其他内存块，这使得代码分析工具难以意识到跨越内存池块边界访问数据是无意的。实际上，如果受影响的代码没有使用内存池，OpenSSL
    Heartbleed漏洞可能已通过代码分析进行预防（参见David A. Wheeler，“如何防止下一个Heartbleed”，2020年7月18日[最初发布于2014年4月29日]，[*https://dwheeler.com/essays/heartbleed.xhtml*](https://dwheeler.com/essays/heartbleed.xhtml)）。
- en: Known Uses
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: UNIX systems use a pool of fixed size for their process objects.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIX系统为其进程对象使用固定大小的池。
- en: The book *C Interfaces and Implementations* by David R. Hanson (Addison-Wesley,
    1996) shows an example of a memory pool implementation.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由David R. Hanson编写的书籍*C Interfaces and Implementations*（Addison-Wesley, 1996）展示了一个内存池实现的示例。
- en: 'The Memory Pool pattern is also described in the books *Real-Time Design Patterns:
    Robust Scalable Architecture for Real-Time Systems* by Bruce P. Douglass (Addison-Wesley,
    2002) and *Small Memory Software: Patterns for Systems With Limited Memory* by
    James Noble and Charles Weir (Addison-Wesley, 2000).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存池模式也在Bruce P. Douglass（Addison-Wesley，2002）的书籍《实时设计模式：面向实时系统的稳健可扩展架构》和James
    Noble和Charles Weir（Addison-Wesley，2000）的书籍《小内存软件：限制内存系统的模式》中有描述。
- en: The Android ION memory manager implements memory pools in its file *ion_system_heap.c*.
    On release of memory parts, the caller has the option to actually free that part
    of the memory if it is security-critical.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android ION内存管理器在其文件*ion_system_heap.c*中实现了内存池。在释放内存部分时，调用者可以选择实际释放该部分内存，如果这部分内存对安全至关重要。
- en: 'The smpl discrete event simulation system described in the book *Simulating
    Computer Systems: Techniques and Tools* by H. M. MacDougall (MIT Press, 1987)
    uses a memory pool for events. This is more efficient than allocating and deallocating
    memory for each event, as processing each event takes only a short time and there
    is a large number of events in a simulation.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H. M. MacDougall（MIT Press，1987）的书籍《模拟计算机系统：技术和工具》中描述的smpl离散事件模拟系统使用事件的内存池。这比为每个事件分配和释放内存更有效，因为处理每个事件只需要很短的时间，并且在模拟中有大量事件。
- en: Applied to Running Example
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: To keep things easy, you decide to implement a Memory Pool with fixed maximum
    memory chunk size. You do not have to cope with multithreading and simultaneous
    access to that pool from multiple threads, so you can simply use the exact implementation
    from the Memory Pool pattern.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，您决定实现一个具有固定最大内存块大小的内存池。您不必处理多线程和从多个线程同时访问该池的情况，因此您可以简单地使用内存池模式的确切实现。
- en: 'You end up with the following final code for your Caesar encryption:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您最终得到了以下凯撒加密的最终代码：
- en: '[PRE21]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this final version of your code, you can now perform your Caesar encryption
    without stumbling across the common pitfalls of dynamic memory handling in C.
    You make sure that the memory pointers you use are valid, you assert if no memory
    is available, and you even avoid fragmentation outside of your predefined memory
    area.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的代码的最终版本，您现在可以执行凯撒加密，而无需遇到C语言中动态内存处理的常见陷阱。您确保您使用的内存指针是有效的，如果没有可用内存，您会断言，并且甚至避免在预定义内存区域之外出现碎片化。
- en: Looking at the code, you realize that it has become very complicated. You simply
    want to work with some dynamic memory, and you had to implement dozens of lines
    of code to do that. Keep in mind that most of that code can be reused for any
    other allocation in your codebase. Still, applying one pattern after another did
    not come for free. With each pattern you added some additional complexity. However,
    it is not the aim to apply as many patterns as possible. It is the aim to apply
    only those patterns that solve your problems. If, for example, fragmentation is
    not a big issue for you, then please don’t use a custom Memory Pool. If you can
    keep things simpler, then do so and, for example, directly allocate and deallocate
    the memory using `malloc` or `free`. Or even better, if you have the option, don’t
    use dynamic memory at all.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码，您会意识到它变得非常复杂。您只是想使用一些动态内存，并且不得不实现几十行代码来做到这一点。请记住，您的大部分代码可以在代码库中为任何其他分配重复使用。然而，一个接一个地应用模式并不是免费的。每添加一个模式都会增加一些额外的复杂性。然而，目的并不是应用尽可能多的模式。目的是只应用解决您问题的那些模式。例如，如果碎片化对您来说不是一个大问题，请不要使用自定义内存池。如果可以保持事情简单，那么请直接使用`malloc`或`free`直接分配和释放内存。或者更好的是，如果有选择的话，根本不要使用动态内存。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented patterns on handling memory in C programs. The Stack
    First pattern tells you to put variables on the stack if possible. Eternal Memory
    is about using memory that has the same lifetime as your program in order to avoid
    complicated dynamic allocation and freeing. Lazy Cleanup also makes freeing the
    memory easier for the programmer by suggesting that you simply not cope with it.
    Dedicated Ownership, on the other hand, defines where memory is freed and by whom.
    The Allocation Wrapper provides a central point for handling allocation errors
    and invalidating pointers, and that makes it possible to implement a Pointer Check
    when dereferencing variables. If fragmentation or long allocation times become
    an issue, a Memory Pool helps out.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了处理C程序中内存的模式。首选模式建议尽可能将变量放在堆栈上。永久内存是关于使用与程序生命周期相同的内存，以避免复杂的动态分配和释放。惰性清理还通过建议简单地不处理它来使程序员更轻松地释放内存。专属所有权则定义了内存何时以及由谁释放。分配包装提供了一个处理分配错误和使指针失效的中心点，从而使实现指针检查成为可能。如果碎片化或长时间分配成为问题，内存池则提供了帮助。
- en: With these patterns, the burden of making a lot of detailed design decisions
    on which memory to use and when to clean it up is taken from the programmer. Instead,
    the programmer can simply rely on the guidance from these patterns and can easily
    tackle memory management in C programs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模式，程序员不再需要在内存使用和清理的详细设计决策上花费大量精力。相反，程序员可以简单依赖这些模式的指导，轻松处理C程序中的内存管理。
- en: Further Reading
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Compared to other advanced C programming topics, there is a lot of literature
    out there on the topic of memory management. Most of that literature focuses on
    the basis of the syntax for allocating and freeing memory, but the following books
    also provide some advanced guidance:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他高级C编程主题相比，关于内存管理的文献非常丰富。大多数文献集中于分配和释放内存的语法基础，但以下几本书也提供了一些高级指导：
- en: 'The book *Small Memory Software: Patterns for Systems With Limited Memory*
    by James Noble and Charles Weir (Addison-Wesley, 2000) contains a lot of well-elaborated
    patterns on memory management. For example, the patterns describe the different
    strategies for allocating memory (at startup or during runtime) and also describe
    strategies such as memory pools or garbage collectors. All patterns also provide
    code examples for multiple programming languages.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: James Noble 和 Charles Weir 的书 *小内存软件：有限内存系统的模式*（Addison-Wesley, 2000）包含了许多精心制作的关于内存管理的模式。例如，这些模式描述了不同的内存分配策略（在启动时或运行时）以及诸如内存池或垃圾收集器等策略。所有模式还为多种编程语言提供了代码示例。
- en: The book *Hands-on Design Patterns with *C++** by Fedor G. Pikus (Packt, 2019)
    is as its name says not tailored for C, but the memory management concepts used
    by C and C++ are similar, so there is also relevant guidance on how to manage
    memory in C. It contains a chapter that focuses on memory ownership and explains
    how to use C++ mechanisms (like smart pointers) to make very clear who owns which
    memory.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedor G. Pikus 的书 *C++实用设计模式*（Packt, 2019）并非专门为C编写，但C和C++中使用的内存管理概念相似，因此也提供了相关指导，说明如何在C中管理内存。书中包含了一章专注于内存所有权，并解释如何使用C++机制（如智能指针）明确谁拥有哪些内存。
- en: The book *Extreme C* by Kamran Amini (Packt, 2019) covers many C programming
    topics, like the compilation process, toolchains, unit-testing, concurrency, intra-process
    communication, and also the basic C syntax. There is also a chapter on heap and
    stack memory, and it describes platform-specific details on how these memories
    are represented in the code-, data-, stack-, or heap-segment.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kamran Amini 的书 *Extreme C*（Packt, 2019）涵盖了许多C编程主题，如编译过程、工具链、单元测试、并发、进程内通信以及基本的C语法。书中还有一章讲述堆和栈内存，并描述了这些内存在代码段、数据段、堆栈段或堆段中的特定细节。
- en: 'The book *Real-Time Design Patterns: Robust Scalable Architecture for Real-Time
    Systems* by Bruce P. Douglass (Addison-Wesley, 2002) contains patterns for real-time
    systems. Some of the patterns address allocation and cleanup of memory.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bruce P. Douglass 的书 *实时设计模式：稳健可扩展的实时系统架构*（Addison-Wesley, 2002）包含了针对实时系统的模式。其中一些模式涉及内存的分配和清理。
- en: Outlook
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望
- en: The next chapter gives guidance on how to transport information in general across
    interface boundaries. The chapter presents patterns that elaborate on the kinds
    of mechanisms that C provides for transporting information between functions and
    which of these mechnisms should be used.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将指导如何在一般情况下跨接口边界传输信息。该章节介绍了各种模式，详细阐述了C语言为函数之间传输信息提供的机制类型，以及应该使用哪些机制。
