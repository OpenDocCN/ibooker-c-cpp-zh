- en: Chapter 4\. Returning Data from C Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 返回C函数的数据
- en: Returning data from a function call is a task you are faced with when writing
    any kind of code that is longer than 10 lines and that you intend to be maintainable.
    Returning data is a simple task—you simply have to pass the data you want to share
    between two functions—and in C you only have the option to directly return a value
    or to return data via emulated “by-reference” parameters. There are not many choices
    and there is not much guidance to give—right? Wrong! Even the simple task of returning
    data from C functions is already tricky, and there are many routes you can take
    to structure your program and your function parameters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 返回函数调用的数据是在编写超过10行且需要可维护的任何类型的代码时所面临的任务。返回数据是一个简单的任务——你只需传递你想要在两个函数之间共享的数据——而在C语言中，你只有直接返回一个值或者通过模拟的“按引用传递”参数来返回数据的选项。选择不多，指导也不多，对吧？错！即使是从C函数返回数据的简单任务已经很棘手了，你可以采用多种方式来构造你的程序和函数参数。
- en: 'Especially in C, where you have to manage the memory allocation and deallocation
    on your own, passing complex data between functions becomes tricky because there
    is no destructor or garbage collector to help you clean up the data. You have
    to ask yourself: should the data be put on the stack, or should it be allocated?
    Who should allocate—the caller or the callee?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在C语言中，你必须自行管理内存分配和释放，将复杂数据在函数之间传递变得棘手，因为没有析构函数或垃圾收集器来帮助你清理数据。你必须问自己：数据应该放在堆栈上，还是应该分配？是调用者分配还是被调用者分配？
- en: This chapter provides best practices on how to share data between functions.
    These patterns help C programming beginners to understand techniques for returning
    data in C, and they help advanced C programmers to better understand why these
    different techniques are applied.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了如何在函数之间共享数据的最佳实践。这些模式帮助C编程初学者了解在C语言中返回数据的技术，也帮助高级C程序员更好地理解为什么要应用这些不同的技术。
- en: '[Figure 4-1](#fig_returning_data) shows an overview of the patterns discussed
    in this chapter and their relationships, and [Table 4-1](#tab_returning_data)
    provides a summary of the patterns.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](#fig_returning_data) 展示了本章讨论的模式及其关系的概述，而 [表 4-1](#tab_returning_data)
    提供了这些模式的摘要。'
- en: '![Patterns for Returning Information](assets/fluc_0401.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![返回信息的模式](assets/fluc_0401.png)'
- en: Figure 4-1\. Overview of patterns for returning information
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1\. 返回信息的模式概述
- en: Table 4-1\. Patterns for returning information
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1\. 返回信息的模式
- en: '|  | Pattern name | Summary |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  | 模式名称 | 摘要 |'
- en: '| --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  | Return Value | The function parts you want to split are not independent
    from one another. As usual in procedural programming, some part delivers a result
    that is then needed by some other part. The function parts that you want to split
    need to share some data. Therefore, simply use the one C mechanism intended to
    retrieve information about the result of a function call: the Return Value. The
    mechanism to return data in C copies the function result and provides the caller
    access to this copy. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  | 返回值 | 你想要拆分的函数部分彼此并不独立。通常在过程化编程中，某些部分生成一个结果，然后另一部分需要这个结果。你想要拆分的函数部分需要共享一些数据。因此，简单地使用一个C机制来获取函数调用结果的信息：返回值。在C语言中返回数据的机制会复制函数结果，并允许调用者访问这个副本。
    |'
- en: '|  | Out-Parameters | C only supports returning a single type from a function
    call, which makes it complicated to return multiple pieces of information. Therefore,
    return all the data with a single function call by emulating by-reference arguments
    with pointers. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  | 输出参数 | C只支持从函数调用中返回单一类型，这使得返回多个信息片段变得复杂。因此，通过使用指针模拟按引用参数，通过单个函数调用返回所有数据。
    |'
- en: '|  | Aggregate Instance | C only supports returning a single type from a function
    call, which makes it complicated to return multiple pieces of information. Therefore,
    put all data that is related into a newly defined type. Define this Aggregate
    Instance to contain all the related data that you want to share. Define it in
    the interface of your component to let the caller directly access all the data
    stored in the instance. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  | 聚合实例 | C只支持从函数调用中返回单一类型，这使得返回多个信息片段变得复杂。因此，将所有相关数据放入一个新定义的类型中。定义这个聚合实例以包含你想要共享的所有相关数据。在你组件的接口中定义它，让调用者直接访问存储在实例中的所有数据。
    |'
- en: '|  | Immutable Instance | You want to provide information held in large pieces
    of immutable data from your component to a caller. Therefore, have an instance
    (for example, a `struct`) containing the data to share in static memory. Provide
    this data to users who want to access it and make sure that they cannot modify
    it. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  | 不可变实例 | 您想从您的组件向调用者提供大块不可变数据中保存的信息。因此，有一个实例（例如一个`struct`），其中包含要共享的数据在静态内存中。向希望访问它的用户提供此数据，并确保他们不能修改它。
    |'
- en: '|  | Caller-Owned Buffer | You want to provide complex or large data of known
    size to the caller, and that data is not immutable (it changes at runtime). Therefore,
    require the caller to provide a buffer and its size to the function that returns
    the large, complex data. In the function implementation, copy the required data
    into the buffer if the buffer size is large enough. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  | 调用者拥有的缓冲区 | 您想向调用者提供已知大小的复杂或大数据，并且该数据不是不可变的（在运行时更改）。因此，要求调用者提供一个缓冲区及其大小给返回大型复杂数据的函数。在函数实现中，如果缓冲区大小足够大，则将所需数据复制到缓冲区中。
    |'
- en: '|  | Callee Allocates | You want to provide complex or large data of unknown
    size to the caller, and that data is not immutable (it changes at runtime). Therefore,
    allocate a buffer with the required size inside the function that provides the
    large, complex data. Copy the required data into the buffer and return a pointer
    to that buffer. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  | 被调函数分配 | 您想向调用者提供未知大小的复杂或大数据，并且该数据不是不可变的（在运行时更改）。因此，在提供大型复杂数据的函数内部分配一个具有所需大小的缓冲区。将所需数据复制到缓冲区中，并返回指向该缓冲区的指针。
    |'
- en: Running Example
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'You want to implement the functionality to display diagnostic information for
    an Ethernet driver to the user. First, you simply add this functionality directly
    into the file with the Ethernet driver implementation and directly access the
    variables that contain the required information:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望为用户实现以太网驱动程序的诊断信息显示功能。首先，您直接将此功能添加到包含以太网驱动程序实现的文件中，并直接访问包含所需信息的变量：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Later on, you realize that the functionality to display diagnostic information
    for your Ethernet driver will quite likely grow, so you decide to put it into
    a separate implementation file in order to keep your code clean. Now you need
    some simple way to transport the information from your Ethernet driver component
    to your diagnostics component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，您意识到显示以太网驱动程序诊断信息的功能很可能会增长，因此决定将其放入单独的实现文件中，以保持代码整洁。现在，您需要一些简单的方法来将信息从您的以太网驱动组件传输到诊断组件。
- en: One solution would be to use global variables to transport this information,
    but if you use global variables, then the effort to split the implementation file
    will have been useless. You split the files because you want to show that these
    code parts are not tightly coupled—with global variables you would bring that
    tight coupling back in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是使用全局变量来传输这些信息，但如果使用全局变量，则分割实现文件的努力将是无用的。您将文件分割，因为您希望显示这些代码部分不是紧密耦合的——使用全局变量会重新引入紧密耦合。
- en: 'A much better and very simple solution is the following: let your Ethernet
    component have getter-functions that provide the desired information as a Return
    Value.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的且非常简单的解决方案如下：让您的以太网组件具有getter函数，以返回所需信息作为返回值。
- en: Return Value
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: Context
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You want to split your code into separate functions, as having everything in
    one function and in one implementation file is bad practice because it gets difficult
    to read and to debug the code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将代码拆分为单独的函数，因为将所有内容放在一个函数和一个实现文件中是不良实践，因为这样会使代码难以阅读和调试。
- en: Problem
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**The function parts you want to split are not independent from one another.
    As usual in procedural programming, some part delivers a result that is then needed
    by some other part. The function parts that you want to split need to share some
    data.**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**您希望拆分的函数部分并非彼此独立。与面向过程编程一样，某些部分提供一个结果，然后其他部分需要这个结果。您希望拆分的函数部分需要共享某些数据。**'
- en: You want to have a mechanism for sharing data that makes your code easy to understand.
    You want to make it explicit in your code that data is shared between functions,
    and you want to make sure that functions don’t communicate over side-channels
    not clearly visible in the code. Thus, using global variables to return information
    to a caller is not a good solution for you because global variables can be accessed
    and modified from any other part of the code. Also, it is not clear from the function
    signature which exact global variable is used for returning data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望有一个共享数据的机制，使您的代码易于理解。您希望在代码中明确表示数据在函数之间共享，并确保函数不通过代码中未清晰可见的边路渠道进行通信。因此，对于将信息返回给调用方而言，使用全局变量不是您的良好解决方案，因为全局变量可以从代码的任何其他部分访问和修改。而且，从函数签名中也不清楚使用哪个确切的全局变量来返回数据。
- en: Global variables also have the drawback that they can be used to store state
    information, which could lead to different results for identical function calls.
    This makes the code more difficult to understand. Aside from that, code using
    global variables for returning information would not be reentrant, and it would
    not be safe to use in a multithreaded environment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量还有一个缺点，即它们可以用于存储状态信息，这可能导致相同函数调用的不同结果。这使得代码更难理解。除此之外，使用全局变量返回信息的代码也不具备可重入性，并且在多线程环境中使用也不安全。
- en: Solution
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Simply use the one C mechanism intended to retrieve information about the
    result of a function call: the Return Value. The mechanism to return data in C
    copies the function result and provides the caller access to this copy.**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**只需使用 C 语言中用于检索函数调用结果信息的机制：返回值。在 C 中返回数据的机制复制函数结果并为调用方提供对此副本的访问。**'
- en: '[Figure 4-2](#fig_return_value) and the following code show how to implement
    the Return Value.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#fig_return_value) 和以下代码展示了如何实现返回值。'
- en: '![Return Value Sketch](assets/fluc_0402.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![返回值草图](assets/fluc_0402.png)'
- en: Figure 4-2\. Return Value
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 返回值
- en: '*Caller’s code*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用方代码*'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Callee’s code*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*被调用方代码*'
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Consequences
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: A Return Value allows the caller to retrieve a copy of the function result.
    No other code apart from the function implementation can modify this value, and,
    as it is a copy, this value is solely used by the calling function. Compared to
    using global variables, it is more clearly defined which code influences the data
    retrieved from the function call.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值允许调用方获取函数结果的副本。除了函数实现外，没有其他代码可以修改此值，并且由于它是一个副本，此值仅由调用函数使用。与使用全局变量相比，更清晰地定义了哪些代码影响从函数调用中检索到的数据。
- en: Also, by not using global variables and using the copy of the function result
    instead, the function can be reentrant, and it can safely be used in a multithreaded
    environment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过不使用全局变量而使用函数结果的副本，函数可以是可重入的，并且可以在多线程环境中安全使用。
- en: However, for built-in C types, a function can return only a single object of
    the type specified in the function signature. It is not possible to define a function
    with multiple return types. You cannot, for example, have a function that returns
    three different `int` objects. If you want to return more information than contained
    in just one simple, scalar C type, then you have to use an Aggregate Instance
    or Out-Parameters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于内置的 C 类型，函数只能返回函数签名中指定类型的单个对象。不可能定义返回三个不同 `int` 对象的函数，例如。如果您希望返回的信息比仅包含一个简单的标量
    C 类型更多，则必须使用聚合实例或输出参数。
- en: Also, if you want to return data from an array, then the Return Value is not
    what you want because it does not copy the content of the array, but only the
    pointer to the array. The caller might then end up with a pointer to data that
    ran out of scope. For returning arrays, you have to use other mechanisms like
    a Caller-Owned Buffer or like when the Callee Allocates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您希望从数组返回数据，则返回值不是您想要的，因为它不会复制数组的内容，而只会复制到数组的指针。调用方可能会得到一个指向超出作用域的数据的指针。对于返回数组，您必须使用其他机制，如调用方拥有的缓冲区或被调用方分配。
- en: Remember that whenever the simple Return Value mechanism is sufficient, then
    you should always take this most simple option to return data. You should not
    go for more powerful, but also more complex, patterns like Out-Parameters, Aggregate
    Instance, Caller-Owned Buffer, or Callee Allocates.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每当简单的返回值机制足够时，您应始终选择这种最简单的选项来返回数据。您不应选择更强大但也更复杂的模式，例如输出参数、聚合实例、调用方拥有的缓冲区或被调用方分配。
- en: Known Uses
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知的使用情况
- en: 'The following examples show applications of this pattern:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了此模式的应用：
- en: You can find this pattern everywhere. Any non-`void` function returns data in
    this way.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在任何非`void`函数中找到此模式。以此方式返回数据。
- en: Every C program has a `main` function that already provides a return value to
    its caller (such as the operating system).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个C程序都有一个`main`函数，它已经为其调用者（如操作系统）提供了返回值。
- en: Applied to Running Example
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于正在运行的示例
- en: 'Applying Return Value was simple. Now you have a new diagnostic component in
    an implementation file separate from the Ethernet driver, and this component obtains
    the diagnostic information from the Ethernet driver as shown in the following
    code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用返回值很简单。现在，在一个与以太网驱动程序分离的实现文件中，您有一个新的诊断组件，该组件从以太网驱动程序获取诊断信息，如下面的代码所示：
- en: '*Ethernet driver API*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太网驱动API*'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Caller’s code*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code is easy to read, and if you want to add additional information, you
    can simply add additional functions to obtain this information. And that is exactly
    what you want to do next. You want to show more information about the sent packets.
    You want to show the user how many packets were successfully sent and how many
    failed. Your first attempt is to write the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码易于阅读，如果您想添加额外信息，可以简单地添加额外的函数来获取这些信息。这正是您接下来要做的事情。您希望显示有关发送的数据包的更多信息。您希望向用户显示成功发送了多少数据包以及失败了多少。您的第一次尝试是编写以下代码：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this code, you eventually realize that sometimes, different from what you
    expected, `successfully_sent_packets` plus `failed_sent_packets` results in a
    number higher than `total_sent_packets`. This is because your Ethernet driver
    runs in a separate thread, and between your function calls to obtain the information,
    the Ethernet driver continues working and updates its packet information. So,
    if, for example, the Ethernet driver successfully sends a packet between your
    `ethernetDriverGet​To⁠tal​SentPackets` call and `ethernetDriverGetSuccesscullySentPackets`,
    then the information that you show to the user is not consistent.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，您最终意识到，有时与您预期的不同，`successfully_sent_packets`加上`failed_sent_packets`的结果会高于`total_sent_packets`。这是因为您的以太网驱动程序在一个单独的线程中运行，在您调用获取信息的函数之间，以太网驱动程序继续工作并更新其数据包信息。因此，例如，如果以太网驱动程序在您调用`ethernetDriverGet​To⁠tal​SentPackets`和`ethernetDriverGetSuccesscullySentPackets`之间成功发送一个数据包，则显示给用户的信息不一致。
- en: A possible solution would be to make sure that the Ethernet driver is not working
    while you call the functions to obtain the packet information. You could, for
    example, use a Mutex or a Semaphore to make sure of this, but for such a simple
    task like obtaining packet statistics, you’d expect that you are not the one who
    has to cope with this issue.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是确保在调用函数获取数据包信息时，以太网驱动程序不在工作中。例如，您可以使用互斥锁或信号量来确保这一点，但是对于获取数据包统计信息这样简单的任务，您希望不是您来解决这个问题。
- en: As a much easier alternative, you can return multiple pieces of information
    from one function call by using Out-Parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个更简单的替代方法，您可以使用输出参数在一个函数调用中返回多个信息片段。
- en: Out-Parameters
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出参数
- en: Context
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You want to provide data that represents related pieces of information from
    your component to a caller, and these pieces of information may change between
    separate function calls.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将来自您组件的相关信息数据提供给调用者，这些信息数据可能在不同的函数调用之间发生变化。
- en: Problem
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**C only supports returning a single type from a function call, which makes
    it complicated to return multiple pieces of information.**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**C仅支持从函数调用返回单一类型，这使得返回多个信息片段变得复杂。**'
- en: Using global variables to transport the data representing your pieces of information
    is not a good solution because code using global variables for returning information
    would not be reentrant, and it would not be safe to use in a multithreaded environment.
    Aside from that, global variables can be accessed and modified from any other
    part of the code, and when using global variables, it is not clear from the function
    signature which exact global variables are used for returning the data. Thus,
    global variables would make your code hard to understand and maintain. Also, using
    the Return Values of multiple functions is not a good option because the data
    you want to return is related, so splitting it across multiple function calls
    makes the code less readable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量传递表示信息的数据也不是一个好的解决方案，因为使用全局变量返回信息的代码不可重入，并且在多线程环境中使用是不安全的。此外，全局变量可以从代码的任何其他部分访问和修改，并且在使用全局变量时，从函数签名中不清楚哪些确切的全局变量用于返回数据。因此，全局变量会使您的代码难以理解和维护。此外，使用多个函数的返回值也不是一个好的选择，因为要返回的数据是相关联的，因此将其分割到多个函数调用中会使代码变得不可读。
- en: Because the pieces of data are related, the caller wants to retrieve a consistent
    snapshot of all this data. That becomes an issue when using multiple Return Values
    in a multithreaded environment because the data can change at runtime. In that
    case, you would have to make sure that the data does not change between the caller’s
    multiple function calls. But you cannot know whether the caller already finished
    reading all the data or whether there will be another piece of information that
    the caller wants to retrieve with another function call. Because of that, you
    cannot make sure that the data is not modified between the caller’s function calls.
    If you are using multiple functions to provide related information, then you don’t
    know the timespan during which the data must not change. Thus, with this approach,
    you cannot guarantee that the caller will retrieve a consistent snapshot of the
    information.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据片段相关联，调用者希望检索所有这些数据的一致快照。在多线程环境中使用多个返回值时会出现问题，因为数据可以在运行时更改。在这种情况下，您必须确保数据在调用者多次函数调用之间不会更改。但是，您无法知道调用者是否已经完成了所有数据的读取，或者调用者是否会使用另一个函数调用检索另一条信息。因此，您无法确保数据在调用者的函数调用之间不会修改。如果使用多个函数提供相关信息，则不知道数据不得更改的时间跨度。因此，通过这种方法，您无法保证调用者将检索到信息的一致快照。
- en: Having multiple functions with Return Values also might not be a good solution
    if a lot of preparation work is required for calculating the related pieces of
    data. If, for example, you want to return the home and mobile telephone number
    for a specified person from an address book and you have separate functions to
    retrieve the numbers, you’d have to search through the address book entry of this
    person separately for each of the function calls. This requires unnecessary computation
    time and resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要大量准备工作来计算相关数据片段，则使用多个具有返回值的函数也可能不是一个好的解决方案。例如，如果要从地址簿返回指定人员的家庭和移动电话号码，并且有单独的函数来检索这些号码，则必须分别搜索此人员的地址簿条目以进行每个函数调用。这需要不必要的计算时间和资源。
- en: Solution
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Return all the data with one function call by emulating by-reference arguments
    with pointers.**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过使用指针模拟按引用传递的参数，在一个函数调用中返回所有数据。**'
- en: C does not support returning multiple types using the Return Value, nor does
    C natively support by-reference arguments, but by-reference arguments can be emulated
    as shown in [Figure 4-3](#fig_out) and the following code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: C不支持使用返回值返回多个类型，也不原生支持按引用传递的参数，但可以通过模拟按引用传递的参数来实现，如[图 4-3](#fig_out)和以下代码所示。
- en: '![Out-Parameters Sketch](assets/fluc_0403.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![输出参数草图](assets/fluc_0403.png)'
- en: Figure 4-3\. Out-Parameters
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 输出参数
- en: '*Caller’s code*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Callee’s code*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*被调用者的代码*'
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Have a single function with many pointer arguments. In the function implementation,
    dereference the pointers and copy the data you want to return to the caller into
    the instance pointed to. In the function implementation, make sure that the data
    does not change while copying. This can be achieved by mutual exclusion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单一功能，具有许多指针参数。在函数实现中，解引用指针并将要返回给调用者的数据复制到指向的实例中。在函数实现中，确保在复制时数据不会更改。这可以通过互斥来实现。
- en: Consequences
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Now all data that represents related pieces of information are returned in one
    single function call and can be kept consistent (for example, by copying data
    protected by Mutex or Semaphores). The function is reentrant and can safely be
    used in a multi-threaded environment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有表示相关信息的数据都在一个单一的函数调用中返回，并且可以保持一致（例如通过Mutex或信号量保护数据）。该函数是可重入的，可以安全地在多线程环境中使用。
- en: For each additional data item, an additional pointer is passed to the function.
    This has the drawback that if you want to return a lot of data, the function’s
    parameter list becomes longer and longer. Having many parameters for one function
    is a code smell because it makes the code unreadable. That is why multiple Out-Parameters
    are rarely used for a function and instead, to clean up the code, related pieces
    of information are returned with an Aggregate Instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个额外的数据项，都将额外的指针传递给函数。这样做的缺点是，如果要返回大量数据，函数的参数列表会变得越来越长。一个函数有许多参数是一种代码味道，因为它使得代码难以阅读。这就是为什么很少使用多个Out-Parameters来返回一个函数的原因，而是通过聚合实例返回相关的信息来清理代码。
- en: Also, for each piece of data, the caller has to pass a pointer to the function.
    This means that for each piece of data, an additional pointer has to be put onto
    the stack. If the caller’s stack memory is very limited, that might become an
    issue.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于每个数据片段，调用者必须将指针传递给函数。这意味着对于每个数据片段，都必须在堆栈上放置一个额外的指针。如果调用者的堆栈内存非常有限，这可能会成为一个问题。
- en: Out-Parameters have the disadvantage that when only looking at the function
    signature, they cannot clearly be identified as Out-Parameters. From the function
    signature, callers can only guess whenever they see a pointer that it might be
    an Out-Parameter. But such a pointer parameter could also be an input for the
    function. Thus, it has to be clearly described in the API documentation which
    parameters are for input and which are for output.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Out-Parameters的缺点在于，当仅查看函数签名时，无法明确识别它们作为Out-Parameters。从函数签名中，调用者只能猜测当他们看到一个指针时，它可能是一个Out-Parameter。但是这样的指针参数也可能是函数的输入。因此，必须在API文档中明确描述哪些参数是输入，哪些是输出。
- en: For simple, scalar C types the caller can simply pass the pointer to a variable
    as a function argument. For the function implementation all the information to
    interpret the pointer is specified because of the specified pointer type. To return
    data with complex types, like arrays, either a Caller-Owned Buffer has to be provided,
    or the Callee Allocates and additional information about the data, like its size,
    has to be communicated.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的标量C类型，调用者可以简单地将变量的指针作为函数参数传递。由于指定的指针类型，函数实现中提供了解释指针的所有信息。要返回复杂类型（如数组）的数据，必须提供Caller-Owned
    Buffer，或者Callee Allocates并传达有关数据的额外信息，例如其大小。
- en: Known Uses
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知的使用情况
- en: 'The following examples show applications of this pattern:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: The Windows `RegQueryInfoKey` function returns information about a registry
    key via the function’s Out-Parameters. The caller provides `unsigned long` pointers,
    and the function writes, among other pieces of information, the number of subkeys
    and the size of the key’s value into the `unsigned long` variables being pointed
    to.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows的`RegQueryInfoKey`函数通过函数的Out-Parameters返回有关注册表键的信息。调用者提供`unsigned long`指针，函数将键的子键数和键值的大小等信息写入指向的`unsigned
    long`变量中。
- en: Apple’s Cocoa API for C programs uses an additional `NSError` parameter to store
    errors occurring during the function calls.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple的C程序的Cocoa API使用额外的`NSError`参数来存储在函数调用期间发生的错误。
- en: The function `userAuthenticate` of the real-time operating system VxWorks uses
    Return Values to return information, in this case whether a provided password
    is correct for a provided login name. Additionally, the function takes an Out-Parameter
    to return the user ID associated with the provided login name.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时操作系统VxWorks的函数`userAuthenticate`使用Return Values来返回信息，例如提供的登录名的密码是否正确。此外，该函数采用Out-Parameter来返回与提供的登录名关联的用户ID。
- en: Applied to Running Example
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'By applying Out-Parameters you’ll get the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用Out-Parameters，您将获得以下代码：
- en: '*Ethernet driver API*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太网驱动程序API*'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_returning_data_from_c_functions_CO1-1)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_returning_data_from_c_functions_CO1-1)'
- en: To retrieve information about sent packets, you have only one function call
    to the Ethernet driver, and the Ethernet driver can make sure that the data delivered
    within this call is consistent.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于发送数据包的信息，你只需调用以太网驱动程序的一个函数，并且以太网驱动程序可以确保在此调用中传递的数据是一致的。
- en: '*Caller’s code*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You consider also retrieving the `received_packets` in the same function call
    with the sent packets, but you realize that the one function call becomes more
    and more complicated. Having one function call with three Out-Parameters is already
    complicated to write and read. When calling the functions, the parameter order
    could easily be mixed up. Adding a fourth parameter wouldn’t make the code better.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还考虑在同一个函数调用中检索`received_packets`和发送的数据包，但是你意识到一个函数调用变得越来越复杂。一个带有三个输出参数的函数调用已经很复杂了，写起来和读起来都不容易。在调用函数时，参数的顺序很容易混淆。增加第四个参数并不能使代码变得更好。
- en: To make the code more readable, an Aggregate Instance can be used.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更易读，可以使用一个聚合实例。
- en: Aggregate Instance
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合实例
- en: Context
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You want to provide data that represents related pieces of information from
    your component to a caller, and these pieces of information may change between
    separate function calls.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望向调用者提供从你的组件到调用者的相关信息片段。这些信息片段在不同的函数调用之间可能会发生变化。
- en: Problem
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**C only supports returning a single type from a function call, which makes
    it complicated to return multiple pieces of information.**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**C 只支持从函数调用中返回单一类型，这使得返回多个信息片段变得复杂。**'
- en: Using global variables to transport the data representing your pieces of information
    is not a good solution because code using global variables for returning information
    would not be reentrant, and it would not be safe to use in a multithreaded environment.
    Aside from that, global variables can be accessed and modified from any other
    part of the code, and when using global variables, it is not clear from the function
    signature which exact global variables are used for returning the data. Thus,
    global variables would make your code hard to understand and maintain. Also, using
    the Return Values of multiple functions is not a good option because the data
    you want to return is related, so splitting it across multiple function calls
    makes the code less readable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量传递表示你的信息片段的数据也不是一个好的解决方案，因为使用全局变量返回信息的代码不具备可重入性，并且在多线程环境中使用起来也不安全。除此之外，全局变量可以从代码的任何其他部分访问和修改，在使用全局变量时，从函数签名中无法清楚地知道哪些具体的全局变量用于返回数据。因此，全局变量会使你的代码难以理解和维护。同时，使用多个函数的返回值也不是一个好选择，因为你要返回的数据是相关的，所以将其分散在多个函数调用中会使代码变得不太可读。
- en: Having a single function with many Out-Parameters is also not a good idea because
    if you have many such Out-Parameters, it gets easy to mix them up and your code
    becomes unreadable. Also, you want to show that the parameters are closely related,
    and you might even need the same set of parameters to be provided to or returned
    by other functions. When explicitly doing that with function parameters, you’d
    have to modify each such function in case additional parameters are added later
    on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个输出参数的单个函数也不是一个好主意，因为如果有多个这样的输出参数，很容易混淆，你的代码会变得难以阅读。此外，你想表明这些参数是密切相关的，甚至可能需要将同一组参数提供给或由其他函数返回。如果使用函数参数显式执行此操作，那么在稍后添加额外参数时，必须修改每个这样的函数。
- en: Because the pieces of data are related, the caller wants to retrieve a consistent
    snapshot of all this data. That becomes an issue when using multiple Return Values
    in a multithreaded environment because the data can change at runtime. In that
    case, you would have to make sure that the data does not change between the caller’s
    multiple function calls. But you cannot know whether the caller already finished
    reading all the data or whether there will be another piece of information that
    the caller wants to retrieve with another function call. Because of that, you
    cannot make sure that the data is not modified between the caller’s function calls.
    If you are using multiple functions to provide related information, then you don’t
    know the timespan during which the data must not change. Thus, with this approach,
    you cannot guarantee that the caller will retrieve a consistent snapshot of the
    information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据片段相关联，调用者希望在多线程环境中检索到所有这些数据的一致快照。当使用多返回值时，这就成为一个问题，因为数据可能在运行时更改。在这种情况下，您必须确保数据在调用者的多个函数调用之间不会更改。但您无法知道调用者是否已完成读取所有数据，或者调用者是否会在另一个函数调用中检索另一条信息。因此，您无法确保数据在调用者的函数调用之间不被修改。如果使用多个函数提供相关信息，则不知道数据不得更改的时间跨度。因此，通过这种方法，您无法保证调用者将检索到信息的一致快照。
- en: Having multiple functions with Return Values also might not be a good solution
    if a lot of preparation work is required for calculating the related pieces of
    data. If, for example, you want to return the home and mobile telephone number
    for a specified person from an address book and you have separate functions to
    retrieve the numbers, you’d have to search through the address book entry of this
    person separately for each of the function calls. This requires unnecessary computation
    time and resources.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要大量准备工作来计算相关数据片段，则使用具有返回值的多个函数也可能不是一个好的解决方案。例如，如果您希望从通讯录中为指定的人返回家庭电话和移动电话号码，并且您有单独的函数来检索这些号码，则必须分别搜索该人的通讯录条目。这需要不必要的计算时间和资源。
- en: Solution
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Put all data that is related into a newly defined type. Define this Aggregate
    Instance to contain all the related data that you want to share. Define it in
    the interface of your component to let the caller directly access all the data
    stored in the instance.**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**将所有相关数据放入新定义的类型中。定义此聚合实例以包含您希望共享的所有相关数据。在您组件的接口中定义它，让调用者直接访问实例中存储的所有数据。**'
- en: To implement this, define a `struct` in your header file and define all types
    to be returned from the called function as members of this `struct`. In the function
    implementation, copy the data to be returned into the `struct` members as shown
    in [Figure 4-4](#fig_aggregate). In the function implementation, make sure that
    the data does not change while copying. This can be achieved by mutual exclusion
    via Mutex or Semaphores.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此操作，请在您的头文件中定义一个`struct`，并将从被调用函数返回的所有类型定义为此`struct`的成员。在函数实现中，像在[图 4-4](#fig_aggregate)中展示的那样，将要返回的数据复制到`struct`成员中。在函数实现中，确保在复制数据时数据不会更改。可以通过互斥锁或信号量来实现这一点。
- en: '![Aggregate Instance Sketch](assets/fluc_0404.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![聚合实例草图](assets/fluc_0404.png)'
- en: Figure 4-4\. Aggregate Instance
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 聚合实例
- en: 'To actually return the `struct` to the caller, there are two main options:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`struct`实际返回给调用者，有两个主要选项：
- en: Pass the whole `struct` as a Return Value. C allows not only built-in types
    to be passed as a Return Value of functions but also user-defined types such as
    a `struct`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整个`struct`作为返回值传递。C不仅允许将内置类型作为函数的返回值传递，还允许像`struct`这样的用户定义类型。
- en: Pass a pointer to the `struct` using an Out-Parameter. However, when only passing
    pointers, the issue arises of who provides and owns the memory being pointed to.
    That issue is addressed in Caller-Owned Buffer and Callee Allocates. Instead of
    passing a pointer and letting the caller directly access the Aggregate Instance,
    you could consider hiding the `struct` from the caller by using a Handle.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Out-Parameter传递`struct`的指针。但是，当仅传递指针时，会出现谁提供和拥有所指向内存的问题。这个问题在“调用者拥有缓冲区”和“被调用者分配”中得到了解决。与直接让调用者访问聚合实例的指针相比，您可以考虑通过使用句柄来隐藏`struct`，从而避免这个问题。
- en: 'The following code shows the variant with passing the whole `struct`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了通过传递整个`struct`的变体：
- en: '*Caller’s code*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Callee’s code*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*被调用者的代码*'
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_returning_data_from_c_functions_CO2-1)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_returning_data_from_c_functions_CO2-1)'
- en: When returning, the content of `inst` is copied (even though it is a `struct`),
    and the caller can access the copied content even after `inst` runs out of scope.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 返回时，即使 `inst` 是一个 `struct`，其内容也会被复制，调用者可以在 `inst` 超出范围后访问复制的内容。
- en: Consequences
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Now the caller can retrieve multiple data that represent related pieces of information
    via the Aggregate Instance with a single function call. The function is reentrant
    and can safely be used in a multithreaded environment.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用者可以通过单个函数调用通过聚合实例检索多个表示相关信息的数据。该函数是可重入的，在多线程环境中可以安全使用。
- en: This provides the caller with a consistent snapshot of the related pieces of
    information. It also makes the caller’s code clean because they don’t have to
    call multiple functions or one function with many Out-Parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这为调用者提供了相关信息的一致快照。这也使调用者的代码更清晰，因为他们不必调用多个函数或一个带有多个输出参数的函数。
- en: When passing data between functions without pointers by using Return Values,
    all this data is put on the stack. When passing one `struct` to 10 nested functions,
    this `struct` is on the stack 10 times. In some cases this is not a problem, but
    in other cases it is—especially if the `struct` is too large and you don’t want
    to waste stack memory by copying the whole `struct` onto the stack every time.
    Because of this, quite often instead of directly passing or returning a `struct`,
    a pointer to that `struct` is passed or returned.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用返回值在函数之间传递数据时，所有这些数据都放在堆栈上。将一个 `struct` 传递给 10 个嵌套函数时，这个 `struct` 在堆栈上会出现
    10 次。在某些情况下这不是问题，但在其他情况下是—特别是如果 `struct` 太大，并且您不希望通过每次复制整个 `struct` 来浪费堆栈内存。因此，通常不直接传递或返回
    `struct`，而是传递或返回指向该 `struct` 的指针。
- en: When passing pointers to the `struct`, or if the `struct` contains pointers,
    you have to keep in mind that C does not perform the work of doing a deep copy
    for you. C only copies the pointer values and does not copy the instances they
    point to. That might not be what you want, so you have to keep in mind that as
    soon as pointers come into play, you have to deal with providing and cleaning
    up the memory being pointed to. This issue is addressed in Caller-Owned Buffer
    and Callee Allocates.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当将指向 `struct` 的指针传递给函数时，或者如果 `struct` 包含指针，则必须记住 C 不会为您执行深拷贝的工作。C 只复制指针值，而不复制它们指向的实例。这可能不是您想要的，因此一旦涉及指针，您必须处理提供和清理指向的内存。这个问题在“调用者拥有缓冲区”和“被调用者分配”中得到解决。
- en: Known Uses
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了此模式的应用：
- en: 'The article [“Patterns of Argument Passing”](https://oreil.ly/VlCgm) by Uwe
    Zdun describes this pattern, including C++ examples, as Context Object, and the
    book *Refactoring: Improving the Design of Existing Code* by Martin Fowler (Addison-Wesley,
    1999) describes it as Parameter Object.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '文章 [“Argument Passing Patterns”](https://oreil.ly/VlCgm) 由 Uwe Zdun 描述了这种模式，包括
    C++ 示例，称为上下文对象，以及书籍 *Refactoring: Improving the Design of Existing Code* 由 Martin
    Fowler (Addison-Wesley, 1999) 描述为参数对象。'
- en: The code of the game NetHack stores monster-attributes in Aggregate Instances
    and provides a function for retrieving this information.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏 NetHack 的代码将怪物属性存储在聚合实例中，并提供一个函数来检索此信息。
- en: The implementation of the text editor sam copies `structs` when passing them
    to functions and when returning them from functions in order to keep the code
    simpler.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器 sam 的实现在将 `structs` 传递给函数和从函数返回它们时进行复制，以保持代码简洁。
- en: Applied to Running Example
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'With the Aggregate Instance, you’ll get the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合实例，您将获得以下代码：
- en: '*Ethernet driver API*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太网驱动程序 API*'
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Caller’s code*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you have one single call to the Ethernet driver, and the Ethernet driver
    can make sure that the data delivered within this call is consistent. Also, your
    code looks cleaned up because the data that belongs together is now collected
    in a single `struct`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您只需调用以太网驱动程序一次，以太网驱动程序可以确保在此调用中交付的数据是一致的。此外，您的代码看起来更整洁，因为属于一起的数据现在集中在一个单独的
    `struct` 中。
- en: Next, you want to show more information about the Ethernet driver to your user.
    You want to show the user to which Ethernet interface the packet statistics information
    belongs to, and thus you want to show the driver name including a textual description
    of the driver. Both are contained in a string stored in the Ethernet driver component.
    The string is quite long and you don’t exactly know how long it is. Luckily, the
    string does not change during runtime, so you can access an Immutable Instance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想向用户显示更多有关以太网驱动程序的信息。你想要向用户展示数据包统计信息所属的以太网接口，因此你想要显示包括驱动程序的文本描述在内的驱动程序名称。这两者都包含在存储在以太网驱动程序组件中的字符串中。该字符串相当长，你并不确切知道它的长度。幸运的是，在运行时该字符串不会更改，因此你可以访问一个不可变实例。
- en: Immutable Instance
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变实例
- en: Context
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Your component contains a lot of data, and another component wants to access
    this data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组件包含大量数据，另一个组件想要访问这些数据。
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**You want to provide information held in large pieces of immutable data from
    your component to a caller.**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**你想要将组件中大块不可变数据的信息提供给调用者。**'
- en: Copying the data for each and every caller would be a waste of memory, so providing
    all the data by returning an Aggregate Instance or by copying all the data into
    Out-Parameters is not an option due to stack memory limitations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个调用者复制数据将会浪费内存，因此通过返回聚合实例或将所有数据复制到输出参数中提供所有数据，由于堆栈内存限制而不可行。
- en: Usually, simply returning a pointer to such data is tricky. You’d have the problem
    that with a pointer, such data can be modified, and as soon as multiple callers
    read and write the same data, you have to come up with mechanisms to ensure that
    the data you want to access is consistent and up-to-date. Luckily, in your situation
    the data you want to provide to the caller is fixed at compile time or at boot
    time and does not change at runtime.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仅返回指向此类数据的指针是棘手的。你会面临这样的问题：使用指针，可以修改这些数据，并且当多个调用者读取和写入相同数据时，你必须想出机制来确保你要访问的数据是一致的和最新的。幸运的是，在你的情况下，要提供给调用者的数据在编译时或启动时是固定的，并且在运行时不会改变。
- en: Solution
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Have an instance (for example, a `struct`) containing the data to share in
    static memory. Provide this data to users who want to access it and make sure
    that they cannot modify it.**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**有一个实例（例如一个`struct`），其中包含要共享的数据放在静态内存中。将这些数据提供给想要访问它们的用户，并确保他们不能修改它。**'
- en: Write the data to be contained in the instance at compile time or at boot time
    and do not change it at runtime anymore. You can either directly write the data
    hardcoded in your program, or you can initialize it at program startup (see [“Software-Module
    with Global State”](ch05.xhtml#pattern_software_module_with_global_state) for
    initialization variants and [“Eternal Memory”](ch03.xhtml#pattern_eternal_memory)
    for storage variants). As shown in [Figure 4-5](#fig_immutable), even if multiple
    callers (and multiple threads) access the instance at the same time, they don’t
    have to worry about each other because the instance does not change and is thus
    always in a consistent state and contains the required information.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时或启动时编写要包含在实例中的数据，并且不再在运行时更改它。你可以直接在程序中硬编码写入数据，或者在程序启动时初始化它（参见[“具有全局状态的软件模块”](ch05.xhtml#pattern_software_module_with_global_state)以获取初始化变体和[“永久内存”](ch03.xhtml#pattern_eternal_memory)以获取存储变体）。如图 4-5所示（#fig_immutable），即使多个调用者（和多个线程）同时访问该实例，它们也不必担心对方，因为实例不会更改，因此始终处于一致状态并包含所需信息。
- en: Implement a function that returns a pointer to the data. Alternatively, you
    could even directly make the variable containing the data global and put it into
    your API because the data does not change at runtime anyway. But still, the getter-function
    is better because compared to global variables, it makes writing unit tests easier,
    and in case of future behavior changes of your code (if your data is not immutable
    anymore), you’d not have to change your interface.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个返回数据指针的函数。或者，你甚至可以直接将包含数据的变量作为全局变量放入你的API中，因为数据在运行时不会改变。但是，与全局变量相比，获取函数更好，因为它使编写单元测试更容易，并且在未来代码行为更改的情况下（如果你的数据不再是不可变的），你不必更改接口。
- en: '![Immutable Instance Sketch](assets/fluc_0405.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![不可变实例草图](assets/fluc_0405.png)'
- en: Figure 4-5\. Immutable Instance
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. 不可变实例
- en: 'To make sure that the caller does not modify the data, when returning a pointer
    to the data, make the data being pointed to `const` as shown in the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保调用者不修改数据，在返回数据指针时，使指向的数据为`const`，如下面的代码所示：
- en: '*Caller’s code*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_returning_data_from_c_functions_CO3-1)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_returning_data_from_c_functions_CO3-1)'
- en: The caller obtains a reference but doesn’t get ownership of the memory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者获得引用但不拥有内存。
- en: '*Callee API*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*被调用者 API*'
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Callee Implementation*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*被调用者的实现*'
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Consequences
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The caller can call one simple function to get access to even complex or large
    data and does not have to care about where this data is stored. The caller does
    not have to provide buffers in which this data can be stored, does not have to
    clean up memory, and does not have to care about the lifetime of the data—it simply
    always exists.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以调用一个简单的函数来访问甚至复杂或大型的数据，而无需关心此数据存储在何处。 调用者不必提供用于存储此数据的缓冲区，不必清理内存，并且不必关心数据的生命周期——它始终存在。
- en: The caller can read all data via the retrieved pointer. The simple function
    for retrieving the pointer is reentrant and can safely be used in multithreaded
    environments. Also the data can safely be accessed in multithreaded environments
    because it does not change at runtime, and multiple threads that only read the
    data are no problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以通过检索到的指针读取所有数据。 用于检索指针的简单函数是可重入的，并且可以安全地用于多线程环境中。 此外，由于数据在运行时不会更改，并且只读取数据的多个线程没有问题，因此还可以安全地访问数据。
- en: However, the data cannot be changed at runtime without taking further measures.
    If it is necessary for the caller to be able to change the data, then something
    like copy-on-write can be implemented. If the data in general can change at runtime,
    then an Immutable Instance isn’t an option and instead, for sharing complex and
    large data, a Caller-Owned Buffer has to be used or the Callee Allocates.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在不采取进一步措施的情况下，不能在运行时更改数据。 如果调用者需要能够更改数据，则可以实施类似写时复制的方法。 如果一般情况下数据可以在运行时更改，则不可变实例不是一个选择，而是必须使用调用者拥有的缓冲区或被调用者分配的复杂和大型数据共享。
- en: Known Uses
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: 'In his article [“Patterns in Java: Patterns of Value”](https://oreil.ly/cVY9N),
    Kevlin Henney describes the similar Immutable Object pattern in detail and provides
    C++ code examples.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在他的文章[“Java 中的模式：值模式”](https://oreil.ly/cVY9N)，Kevlin Henney详细描述了类似的不可变对象模式，并提供了C++代码示例。
- en: The code of the game NetHack stores immutable monster-attributes in an Immutable
    Instance and provides a function for retrieving this information.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏 NetHack 的代码将不可变的怪物属性存储在不可变实例中，并提供一个用于检索这些信息的函数。
- en: Applied to Running Example
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'Usually, returning a pointer to access data stored within a component is tricky.
    This is because if multiple callers access (and maybe write) this data, then a
    plain pointer isn’t the solution for you because you never know if the pointer
    you have is still valid and if the data contained in this pointer is consistent.
    But in this case we are lucky because we have an Immutable Instance. The driver
    name and description are both information that is determined at compile time and
    does not change afterwards. Thus, we can simply retrieve a constant pointer to
    this data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，返回指向组件内存储数据的指针是棘手的。 这是因为如果多个调用者访问（甚至可能写入）此数据，则普通指针不是您的解决方案，因为您永远不知道您拥有的指针是否仍然有效以及此指针中包含的数据是否一致。
    但在这种情况下，我们很幸运，因为我们有一个不可变的实例。 驱动程序名称和描述都是在编译时确定的信息，并且之后不会更改。 因此，我们可以简单地检索指向此数据的常量指针：
- en: '*Ethernet driver API*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太网驱动程序 API*'
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Caller’s code*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As a next step, in addition to the name and description of the Ethernet interface,
    you also want to show the user the currently configured IP address and subnet
    mask. The addresses are stored as a string in the Ethernet driver. Both addresses
    are information that might change during runtime, so you cannot simply return
    a pointer to an Immutable Instance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，除了以太网接口的名称和描述外，您还希望向用户显示当前配置的IP地址和子网掩码。 这些地址作为字符串存储在以太网驱动程序中。 这两个地址都是在运行时可能会更改的信息，因此您不能简单地返回一个指向不可变实例的指针。
- en: While it would be possible to have the Ethernet driver pack these strings into
    an Aggregate Instance and simply return this instance (arrays in a `struct` are
    copied when returning the `struct`), such a solution is rather uncommon for large
    amounts of data because it consumes a lot of stack memory. Usually, pointers are
    used instead.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管以太网驱动程序将这些字符串打包到聚合实例中并简单返回此实例（在返回结构体时，结构体中的数组会被复制），但对于大量数据来说，这种解决方案并不常见，因为它会消耗大量堆栈内存。通常使用指针代替。
- en: 'Using pointers is the exact solution you are looking for: use a Caller-Owned
    Buffer.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针是您寻找的确切解决方案：使用**Caller-Owned Buffer**。
- en: Caller-Owned Buffer
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Caller-Owned Buffer
- en: Context
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You have large data that you want to share between different components.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一些大数据想要在不同组件之间共享。
- en: Problem
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**You want to provide complex or large data of known size to the caller, and
    that data is not immutable (it changes at runtime).**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**您想要向调用方提供复杂或大型的已知大小数据，并且该数据不是不可变的（在运行时会发生变化）。**'
- en: Because the data changes at runtime (maybe because you provide the callers with
    functions to write the data), you cannot simply provide the caller with a pointer
    to static data (as is the case with an Immutable Instance). If you simply provide
    the callers with such a pointer, you’d run into the problem that the data one
    caller reads might be inconsistent (partially overwritten) because, in a multithreaded
    environment, another caller might simultaneously write that data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据在运行时发生变化（也许是因为您为调用方提供了写入数据的函数），所以您不能简单地向调用方提供指向静态数据的指针（就像不可变实例的情况）。如果您仅向调用方提供这样的指针，那么您可能会遇到问题，因为在多线程环境中，另一个调用者可能同时写入该数据，导致读取的数据不一致（部分被覆写）。
- en: Simply copying all the data into an Aggregate Instance and passing it via the
    Return Value to the caller is not an option because, as the data is large, it
    cannot be passed via the stack, which only has very limited memory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有数据简单地复制到聚合实例中，并通过返回值传递给调用方并不可行，因为数据量大，无法通过堆栈传递，堆栈内存非常有限。
- en: When instead only returning a pointer to the Aggregate Instance, there would
    be no problem with stack memory limitations anymore, but you have to keep in mind
    that C does not do the work of performing a deep copy for you. C only returns
    the pointer. You have to make sure that the data (stored in an Aggregate Instance
    or in an array) being pointed to is still valid after the function call. For example,
    you cannot store the data in auto-variables within your function and provide a
    pointer to these variables because after the function call, the variables run
    out of scope.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅返回指向聚合实例的指针，则不再有堆栈内存限制的问题，但您必须记住，C语言不会为您执行深度复制的工作。C仅返回指针。您必须确保函数调用后，指向的数据（存储在聚合实例或数组中）仍然有效。例如，您不能将数据存储在函数内的自动变量中，并提供指向这些变量的指针，因为函数调用后，这些变量会超出作用域。
- en: Now the question arises of where the data should be stored. It has to be clarified
    whether the caller or the callee should provide the required memory and which
    one is then responsible for managing and cleaning up the memory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现了一个问题，即数据应该存储在何处。必须澄清调用方或被调用方应提供所需的内存，并由哪一个负责管理和清理内存。
- en: Solution
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Require the caller to provide a buffer and its size to the function that
    returns the large, complex data. In the function implementation, copy the required
    data into the buffer if the buffer size is large enough.**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**要求调用方为函数提供缓冲区及其大小，以便将所需数据复制到缓冲区（如果缓冲区大小足够大）。**'
- en: Make sure that the data does not change while copying. This can be achieved
    by mutual exclusion via Mutex or Semaphores. The caller then has a snapshot of
    the data in the buffer, is the sole owner of this snapshot, and thus can consistently
    access this snapshot even if the original data changes in the meantime.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在复制时数据不会更改。可以通过互斥锁或信号量来实现互斥。这样，调用方就拥有了缓冲区中数据的快照，并且是该快照的唯一所有者，因此即使原始数据在此期间发生更改，也可以一致地访问此快照。
- en: The caller can provide the buffer and its size each as a separate function parameter,
    or the caller can pack the buffer and its size into an Aggregate Instance and
    pass a pointer to the Aggregate Instance to the function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方可以分别将缓冲区及其大小作为单独的函数参数提供，或者调用方可以将缓冲区及其大小打包到聚合实例中，并将聚合实例的指针传递给函数。
- en: As the caller has to provide the buffer and its size to the function, the caller
    has to know the size beforehand. To let the caller know what size the buffer has
    to be, the size requirement has to be present in the API. This can be implemented
    by defining the size as a macro or by defining a `struct` containing a buffer
    of the required size in the API.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调用者必须向函数提供缓冲区及其大小，所以调用者必须事先知道大小。为了让调用者知道缓冲区应有的大小，API中必须包含大小需求。可以通过将大小定义为宏或在API中定义包含所需大小缓冲区的`struct`来实现此目的。
- en: '[Figure 4-6](#fig_caller_buffer) and the following code show the concept of
    a Caller-Owned Buffer.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-6](#fig_caller_buffer)和下面的代码展示了调用者拥有缓冲区的概念。'
- en: '![Caller-Owned Buffer Sketch](assets/fluc_0406.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![调用者拥有的缓冲区示意图](assets/fluc_0406.png)'
- en: Figure 4-6\. Caller-Owned Buffer
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-6\. 调用者拥有的缓冲区
- en: '*Caller’s code*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Callee’s API*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*被调用者的API*'
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Callee’s implementation*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*被调用者的实现*'
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Consequences
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The large, complex data can be consistently provided to the caller with a single
    function call. The function is reentrant and can safely be used in a multithreaded
    environment. Also, the caller can safely access the data in multithreaded environments
    because the caller is the sole owner of the buffer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过单个函数调用向调用者提供大型复杂数据。该函数是可重入的，并且可以安全地在多线程环境中使用。此外，由于调用者是缓冲区的唯一所有者，所以调用者可以在多线程环境中安全地访问数据。
- en: The caller provides a buffer of the expected size and can even decide the kind
    of memory for that buffer. The caller can put the buffer on the stack (see [“Stack
    First”](ch03.xhtml#pattern_stack_first)) and benefit from the advantage that stack
    memory will be cleaned up after the variable runs out of scope. Alternatively,
    the caller can put the memory on the heap to determine the lifetime of the variable
    or to not waste stack memory. Also, the calling function might only have a reference
    to a buffer obtained by its calling function. In this case this buffer can simply
    be passed on and there is no need to have multiple buffers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者提供了一个期望大小的缓冲区，并且甚至可以决定缓冲区的内存类型。调用者可以将缓冲区放在堆栈上（参见[“先入栈”](ch03.xhtml#pattern_stack_first)），并从堆栈内存的优势中受益，变量超出作用域后，堆栈内存将被清理。或者，调用者可以将内存放在堆上，以确定变量的生命周期或避免浪费堆栈内存。此外，调用函数可能仅具有由其调用函数获取的缓冲区的引用。在这种情况下，可以简单地传递此缓冲区，而无需拥有多个缓冲区。
- en: The time-intensive operation of allocating and freeing memory is not performed
    during the function call. The caller can determine when these operations take
    place, and thus the function call becomes quicker and more deterministic.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用期间不执行分配和释放内存的耗时操作。调用者可以确定这些操作何时发生，因此函数调用变得更快更可预测。
- en: From the API it is absolutely clear that the caller has Dedicated Ownership
    of the buffer. The caller has to provide the buffer and clean it up afterwards.
    If the caller allocated the buffer, then the caller is the one responsible for
    freeing it afterwards.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从API中可以清楚地看出，调用者专有缓冲区的所有权。调用者必须提供缓冲区并在使用后进行清理。如果调用者分配了缓冲区，则调用者负责在使用后释放它。
- en: The caller has to know the size of the buffer beforehand and because this size
    is known, the function can safely operate in the buffer. But in some cases the
    caller might not know the exact size required, and it would be better if instead
    the Callee Allocates.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者必须事先知道缓冲区的大小，并且因为已知这个大小，函数可以安全地在缓冲区中操作。但在某些情况下，调用者可能不知道需要的确切大小，如果被调用者分配，则会更好。
- en: Known Uses
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知的使用情况
- en: 'The following examples show applications of this pattern:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子展示了此模式的应用：
- en: The NetHack code uses this pattern to provide the information about a savegame
    to the component that then actually stores the game progress on the disk.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetHack代码使用此模式将保存游戏进度的信息提供给实际将游戏进度存储在磁盘上的组件。
- en: The B&R Automation Runtime operating system uses this pattern for a function
    to retrieve the IP address.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B&R自动化运行时操作系统在函数中使用此模式来检索IP地址。
- en: The C stdlib function `fgets` reads input from a stream and stores it in a provided
    buffer.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C标准库函数`fgets`从流中读取输入并将其存储在提供的缓冲区中。
- en: Applied to Running Example
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'You now provide a Caller-Owned Buffer to the Ethernet driver function, and
    the function copies its data into this buffer. You have to know beforehand how
    large the buffer has to be. In the case of obtaining the IP address string, this
    is not a problem because the string has a fixed size. So you can simply put the
    buffer for the IP address on the stack and provide this stack variable to the
    Ethernet driver. Alternatively, it would have been possible to allocate the buffer
    on the heap, but in this case that is not required because the size of the IP
    address is known and the size of the data is small enough to fit on the stack:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你向以太网驱动函数提供一个由调用者拥有的缓冲区，并且函数将其数据复制到这个缓冲区中。你必须事先知道缓冲区的大小。在获取IP地址字符串的情况下，这不是问题，因为字符串有固定大小。所以你可以简单地将IP地址的缓冲区放在堆栈上，并将这个堆栈变量提供给以太网驱动程序。或者，也可以在堆上分配缓冲区，但在这种情况下并不需要，因为IP地址的大小是已知的，并且数据的大小足够小，可以适应堆栈：
- en: '*Ethernet driver API*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太网驱动程序API*'
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Caller’s code*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, you want to extend your diagnostic component to also print a dump of the
    last received packet. This is now a piece of information that is too large to
    put on the stack, and because Ethernet packets have variable size, you cannot
    know beforehand how large the buffer for the packet has to be. Therefore, Caller-Owned
    Buffer isn’t an option for you.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要扩展你的诊断组件，以便打印最后接收到的数据包的转储。现在，这是一条信息，太大了不能放在堆栈上，因为以太网数据包大小可变，你事先不知道数据包的缓冲区大小。因此，对于你来说，调用者拥有的缓冲区不是一个选择。
- en: You could, of course, simply have functions `EthernetDriverGetPacketSize()`
    and `EthernetDriverGetPacket(buffer)`, but here again you’d have the problem that
    you’d have to call two functions. Between the two function calls the Ethernet
    driver could receive another packet, which would make your data inconsistent.
    Also, this solution is not very elegant because you’d have to call two different
    functions to achieve one purpose. Instead, it is much easier if the Callee Allocates.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以简单地有函数 `EthernetDriverGetPacketSize()` 和 `EthernetDriverGetPacket(buffer)`，但在这里，你将会遇到一个问题，即在两个函数调用之间，以太网驱动程序可能会接收到另一个数据包，这会使你的数据不一致。此外，这种解决方案并不太优雅，因为你需要调用两个不同的函数来实现一个目的。相反，如果被调用者分配会更容易。
- en: Callee Allocates
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被调用者分配
- en: Context
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You have large data that you want to share between different components.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你有大量数据希望在不同的组件之间共享。
- en: Problem
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**You want to provide complex or large data of unknown size to the caller,
    and that data is not immutable (it changes at runtime).**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**你希望向调用者提供复杂或大量数据的大小未知，并且这些数据在运行时不是不可变的。**'
- en: The data changes at runtime (maybe because you provide the callers with functions
    to write the data), so you cannot simply provide the caller with a pointer to
    static data (as is the case with an Immutable Instance). If you simply provide
    the callers with such a pointer, you’d run into the problem that the data one
    caller reads might be inconsistent (partially overwritten) because, in a multithreaded
    environment, another caller might simultaneously write that data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在运行时会发生变化（也许是因为你提供给调用者写数据的函数），因此你不能简单地提供一个指向静态数据的指针给调用者（这就是不可变实例的情况）。如果你简单地向调用者提供这样一个指针，你会遇到一个问题，即一个调用者读取的数据可能是不一致的（部分被覆盖），因为在多线程环境下，另一个调用者可能同时写入该数据。
- en: Simply copying all the data into an Aggregate Instance and passing it via the
    Return Value to the caller is not an option. With the Return Value you can only
    pass data of known size, and because the data is large, it cannot be passed via
    the stack, which only has very limited memory.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将所有数据复制到聚合实例中，并通过返回值传递给调用者不是一个选择。通过返回值，你只能传递已知大小的数据，并且因为数据很大，不能通过堆栈传递，堆栈的内存非常有限。
- en: When instead only returning a pointer to the Aggregate Instance, there would
    be no problem with stack memory limitations anymore, but you have to keep in mind
    that C does not do the work of performing a deep copy for you. C only returns
    the pointer. You have to make sure that the data (stored in an Aggregate Instance
    or in an array) being pointed to is still valid after the function call. For example,
    you cannot store the data in auto-variables within your function and provide a
    pointer to these variables because after the function call, the variables run
    out of scope and are being cleaned up.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅返回指向聚合实例的指针，则不再存在堆栈内存限制的问题，但必须记住 C 不会为您执行深度复制的工作。C 只返回指针。您必须确保在函数调用后，指向的数据（存储在聚合实例或数组中）仍然有效。例如，您不能将数据存储在函数内的自动变量中，并提供指向这些变量的指针，因为在函数调用后，这些变量会超出作用域并被清理。
- en: Now the problem arises of where the data should be stored. It has to be clarified
    whether the caller or the callee should provide the required memory and which
    one is then responsible for managing and cleaning up the memory.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现了数据应存储在何处的问题。必须澄清是调用者还是被调用者应提供所需的内存，以及哪个部分负责管理和清理内存。
- en: The amount of data you want to provide is not fixed at compile time. For example,
    you want to return a string of previously unknown size. That makes using a Caller-Owned
    Buffer impractical because the caller does not know the size of the buffer beforehand.
    The caller could beforehand ask for the required buffer size (for example, with
    a `getRequiredBufferSize()` function), but that is also impractical because in
    order to retrieve one piece of data, the caller would have to make multiple function
    calls. Also, the data you want to provide could potentially change between those
    function calls, and then the caller would again provide a buffer of the wrong
    size.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您要提供的数据量在编译时不是固定的。例如，您希望返回先前未知大小的字符串。这使得使用调用者拥有的缓冲区变得不切实际，因为调用者事先不知道缓冲区的大小。调用者可以事先询问所需的缓冲区大小（例如，使用
    `getRequiredBufferSize()` 函数），但这也是不切实际的，因为为了检索一个数据片段，调用者必须进行多次函数调用。此外，在这些函数调用之间，您要提供的数据可能会发生变化，然后调用者再次提供错误大小的缓冲区。
- en: Solution
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Allocate a buffer with the required size inside the function that provides
    the large, complex data. Copy the required data into the buffer and return a pointer
    to that buffer.**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**在提供大型复杂数据的函数内部分配所需大小的缓冲区。将所需数据复制到缓冲区中并返回指向该缓冲区的指针。**'
- en: Provide the pointer to the buffer and its size to the caller as Out-Parameters.
    After the function call, the caller can operate on the buffer, knows its size,
    and has the sole ownership of the buffer. The caller determines its lifetime and
    thus is responsible for cleaning it up as shown in [Figure 4-7](#fig_callee_allocates)
    and the following code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将缓冲区的指针和大小作为输出参数提供给调用者。在函数调用后，调用者可以操作缓冲区，知道其大小，并独占缓冲区所有权。调用者决定其生命周期，因此负责清理，如
    [图 4-7](#fig_callee_allocates) 和接下来的代码所示。
- en: '![Callee Allocates Sketch](assets/fluc_0407.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Callee Allocates Sketch](assets/fluc_0407.png)'
- en: Figure 4-7\. Callee Allocates
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-7\. 被调用者分配
- en: '*Caller’s code*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Callee’s code*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*被调用者的代码*'
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_returning_data_from_c_functions_CO4-1)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_returning_data_from_c_functions_CO4-1)'
- en: When copying the data into that buffer, make sure that it does not change in
    the meantime. This can be achieved by mutual exclusion via Mutex or Semaphores.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据复制到该缓冲区时，请确保其在此期间不会更改。这可以通过互斥锁或信号量来实现。
- en: Alternatively, the pointer to the buffer and the size can be put into an Aggregate
    Instance provided as a Return Value. To make it clearer for the caller that there
    is a pointer in the Aggregate Instance that has to be freed, the API can provide
    an additional function for cleaning it up. When also providing a function to clean
    up, the API already looks very similar to an API with a Handle, which would bring
    the additional benefit of flexibility while maintaining API compatibility.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将缓冲区的指针和大小放入作为返回值提供的聚合实例中。为了让调用者更清楚地知道在聚合实例中有一个需要释放的指针，API 可以提供一个额外的清理函数。同时提供清理函数时，API
    看起来已经非常类似于具有句柄的 API，这样既保持了 API 的兼容性，又带来了灵活性的额外好处。
- en: No matter whether the called function provides the buffer via an Aggregate Instance
    or via Out-Parameters, it has to be made clear to the caller that the caller owns
    the buffer and is responsible for freeing it. That Dedicated Ownership has to
    be well documented in the API.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 无论被调用函数是通过聚合实例还是通过输出参数提供缓冲区，都必须向调用者明确表明，调用者拥有缓冲区并负责释放它。这种专有所有权必须在API中得到很好的文档记录。
- en: Consequences
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: The caller can retrieve the buffer of previously unknown size with a single
    function call. The function is reentrant, can safely be used in multithreaded
    environments, and provides the caller with consistent information about the buffer
    and its size. Knowing the size, the caller can safely operate on the data. For
    example, the caller can even handle unterminated strings transported via such
    buffers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以通过单个函数调用检索以前未知大小的缓冲区。该函数是可重入的，可以安全地在多线程环境中使用，并为调用者提供有关缓冲区及其大小的一致信息。知道大小后，调用者可以安全地操作数据。例如，调用者甚至可以处理通过这些缓冲区传输的未终止字符串。
- en: The caller has ownership of the buffer, determines its lifetime, and is responsible
    for freeing it (just like would be the case with a Handle). From looking at the
    interface, it has to be made very clear that the caller has to do this. One way
    of making this clear is to document it in the API. Another approach is to have
    an explicit cleanup function to make it more obvious that something has to be
    cleaned up. Such a cleanup function has the additional advantage that the same
    component that allocates the memory also frees it. This is important if the two
    involved components are compiled with different compilers or if they run on different
    platforms—in such cases the functions for allocating and freeing memory could
    differ between the components, which makes it mandatory that the same component
    that allocates also frees.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者拥有缓冲区，确定其生命周期，并负责释放它（就像使用句柄一样）。从接口上看，必须非常明确地指出调用者必须这样做。使这一点变得清晰的一种方法是在API中记录它。另一种方法是有一个显式的清理函数，以使需要清理的内容更加明显。这样的清理函数还有额外的优势，即分配内存的组件也负责释放它。如果两个相关组件使用不同的编译器或在不同平台上运行，这一点非常重要——在这种情况下，分配和释放内存的函数可能在组件之间不同，这使得分配和释放的组件必须是同一个。
- en: The caller cannot determine which kind of memory should be used for the buffer—that
    would have been possible with a Caller-Owned Buffer. Now the caller must use the
    kind of memory that is allocated inside the function call.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者无法确定缓冲区应使用哪种类型的内存——这在拥有调用者缓冲区时是可能的。现在调用者必须使用在函数调用内部分配的内存类型。
- en: Allocating takes time, which means that compared to Caller-Owned Buffer, the
    function call becomes slower and less deterministic.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 分配需要时间，这意味着与拥有调用者缓冲区相比，函数调用变得更慢且不太可预测。
- en: Known Uses
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了此模式的应用：
- en: The `malloc` function does exactly that. It allocates some memory and provides
    it to the caller.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc`函数正是如此。它分配一些内存并将其提供给调用者。'
- en: The `strdup` function takes a string as input, allocates the duplicated string,
    and returns it.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strdup`函数接受字符串作为输入，分配重复的字符串并返回它。'
- en: The `getifaddrs` Linux function provides information about configured IP addresses.
    The data holding this information is stored in a buffer allocated by the function.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getifaddrs` Linux函数提供有关配置的IP地址信息。存储此信息的数据存储在函数分配的缓冲区中。'
- en: The NetHack code uses this pattern to retrieve buffers.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetHack代码使用此模式来检索缓冲区。
- en: Applied to Running Example
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'The following final code of your diagnostic component retrieves the packet
    data in a buffer that the Callee Allocates:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您的诊断组件的最终代码检索由被调用方分配的缓冲区中的数据包数据：
- en: '*Ethernet driver API*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太网驱动程序API*'
- en: '[PRE26]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Caller’s code*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者的代码*'
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this final version of the diagnostic component, we can see all the presented
    ways of how to retrieve information from another function. Mixing all these ways
    in one piece of code might not be what you actually want to do because it gets
    a bit confusing to have one piece of data on the stack and another piece of data
    on the heap. As soon as you allocate buffers, you don’t want to mix different
    approaches, so using Caller-Owned Buffer and Callee Allocates in a single function
    might not be what you want to do. Instead, pick the one approach that suits all
    your needs and stick to that within one function or component. This makes your
    code more uniform and easier to understand.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个最终版本的诊断组件，我们可以看到如何从另一个函数中获取信息的所有展示方式。将所有这些方式混合在一段代码中可能不是您实际想做的，因为在栈上有一个数据片段，而在堆上有另一个数据片段会让人有些困惑。一旦分配了缓冲区，您不希望混合不同的方法，因此在单个函数中同时使用**调用方拥有缓冲区**和**被调用者分配**可能不是您想要的。相反，选择一个适合所有需求的方法，并在一个函数或组件中坚持使用它。这样可以使您的代码更统一且更易于理解。
- en: However, if you have to obtain just a single piece of data from another component
    and you have the choice to use the easier alternatives to retrieve data (the patterns
    covered earlier in this chapter), then always do that to keep your code simple.
    For example, if you have the option of putting buffers on the stack, then do that,
    because it saves you the effort to free the buffer.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您只需从另一个组件获取单个数据片段，并且可以选择使用本章早期介绍的更简单的替代方法来检索数据，那么请始终这样做，以保持代码简洁。例如，如果可以选择将缓冲区放在栈上，请这样做，因为这样可以省去释放缓冲区的工作。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter showed different ways of how to return data from functions and
    how to handle buffers in C. The simplest way is to use Return Value to return
    a single piece of data, but if multiple pieces of related data have to be returned,
    then instead use Out-Parameters or, even better, Aggregate Instance. If the data
    to be returned does not change at runtime, Immutable Instance can be used. When
    returning data in a buffer, Caller-Owned Buffer can be used if the size of the
    buffer is known beforehand, and Callee Allocates can be used if the size is unknown
    beforehand.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了在 C 语言中如何从函数返回数据以及如何处理缓冲区的不同方法。最简单的方式是使用**返回值**返回单个数据片段，但如果需要返回多个相关数据片段，那么应该使用**输出参数**或者更好的**聚合实例**。如果返回的数据在运行时不会改变，可以使用**不可变实例**。在返回缓冲区中的数据时，如果缓冲区的大小事先已知，可以使用**调用方拥有缓冲区**；如果大小事先不知道，则可以使用**被调用者分配**。
- en: With the patterns from this chapter, a C programmer has some basic tools and
    guidance on how to transport data between functions and how to cope with returning,
    allocating, and freeing buffers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的模式，C 程序员可以掌握一些基本工具和指导，用于在函数之间传输数据以及处理返回、分配和释放缓冲区。
- en: Outlook
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望
- en: The next chapter covers how larger programs are organized into software-modules
    and how lifetime and ownership of data is handled by these software-modules. These
    patterns give an overview of the building blocks that are used to construct larger
    pieces of C code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何将较大的程序组织成软件模块，并且讨论这些软件模块如何处理数据的生命周期和所有权。这些模式概述了用于构建较大 C 代码片段的基本组成部分。
