- en: Chapter 1\. The Art of Software Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 软件设计的艺术
- en: What is software design? And why should you care about it? In this chapter,
    I will set the stage for this book on software design. I will explain software
    design in general, help you understand why it is vitally important for the success
    of a project, and why it is the one thing you should get right. But you will also
    see that software design is complicated. Very complicated. In fact, it is the
    most complicated part of software development. Therefore, I will also explain
    several software design principles that will help you to stay on the right path.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计是什么？为什么你应该关注它？在本章中，我将为本书的软件设计设定舞台。我将总结软件设计的一般概念，帮助你理解它对项目成功的至关重要性，以及为什么这是你应该做到的一件事。但你也会看到，软件设计是复杂的。非常复杂。事实上，它是软件开发中最复杂的部分。因此，我还将解释几个软件设计原则，这些原则将帮助你保持在正确的道路上。
- en: 'In [“Guideline 1: Understand the Importance of Software Design”](#understand_the_importance_of_software_design),
    I will focus on the big picture and explain that software is expected to change.
    Consequently, software should be able to cope with change. However, that is much
    easier said than done, since in reality, coupling and dependencies make our life
    as a developer so much harder. That problem is addressed by software design. I
    will introduce software design as the art of managing dependencies and abstractions—an
    essential part of software engineering.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 1：理解软件设计的重要性”](#understand_the_importance_of_software_design)中，我将专注于宏观视角并解释软件的预期变更。因此，软件应能够应对变更。然而，说起来容易做起来难，因为现实中的耦合和依赖使得作为开发者的生活变得更加困难。软件设计正是应对这一问题的方法。我将介绍软件设计作为管理依赖和抽象的艺术——软件工程的一个重要组成部分。
- en: 'In [“Guideline 2: Design for Change”](#design_for_change), I will explicitly
    address coupling and dependencies and help you understand how to design for change
    and how to make software more adaptable. For that purpose, I will introduce both
    the *Single-Responsibility Principle (SRP)* and the *Don’t Repeat Yourself (DRY)*
    principle, which help you to achieve this goal.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 2：为变更设计”](#design_for_change)中，我将明确讨论耦合和依赖，并帮助你理解如何为变更设计，以及如何使软件更具适应性。为此，我将介绍*单一责任原则（SRP）*和*不重复自己原则（DRY）*，这些原则将帮助你实现这一目标。
- en: 'In [“Guideline 3: Separate Interfaces to Avoid Artificial Coupling”](#separate_interfaces_to_avoid_artificial_coupling),
    I will expand the discussion about coupling and specifically address coupling
    via interfaces. I will also introduce the *Interface Segregation Principle (ISP)*
    as a means to reduce artificial coupling induced by interfaces.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 3：避免人为耦合的接口分离”](#separate_interfaces_to_avoid_artificial_coupling)中，我将扩展有关耦合的讨论，并特别讨论通过接口进行的耦合。我还将介绍*接口隔离原则（ISP）*作为减少接口引发的人为耦合的手段。
- en: 'In [“Guideline 4: Design for Testability”](#design_for_testability), I will
    focus on testability issues that arise as a result of artificial coupling. In
    particular, I will raise the question of how to test a private member function
    and demonstrate that the one true solution is a consequent application of separation
    of concerns.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“测试性设计指南 4”](#design_for_testability)中，我将专注于由人为耦合导致的测试性问题。特别是，我将提出如何测试私有成员函数的问题，并展示唯一真正的解决方案是关注责任分离的连贯应用。
- en: 'In [“Guideline 5: Design for Extension”](#design_for_extension), I will address
    an important kind of change: extensions. Just as code should be easy to change,
    it should also be easy to extend. I will give you an idea how to achieve that
    goal, and I will demonstrate the value of the *Open-Closed Principle (OCP)*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 5：为扩展设计”](#design_for_extension)中，我将讨论一种重要的变更类型：扩展。就像代码应该易于更改一样，它也应该易于扩展。我将为你提供如何实现这一目标的想法，并展示*开闭原则（OCP）*的价值。
- en: 'Guideline 1: Understand the Importance of Software Design'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南 1：理解软件设计的重要性
- en: 'If I were to ask you which code properties are most important to you, you would,
    after some thinking, probably say things like readability, testability, maintainability,
    extensibility, reusability, and scalability. And I would completely agree. But
    now, if I were to ask you how to achieve these goals, there is a good chance that
    you would start to list some C++ features: RAII, algorithms, lambdas, modules,
    and so on.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我问你最重要的代码属性是什么，经过一番思考，你可能会说像可读性、测试性、可维护性、可扩展性、可重用性和可伸缩性等。我完全同意。但是，如果现在我问你如何实现这些目标，你很可能会开始列出一些C++特性：RAII、算法、lambda、模块等等。
- en: Features Are Not Software Design
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性不是软件设计。
- en: 'Yes, C++ offers a lot of features. A lot! Approximately half of the almost
    2,000 pages of the printed C++ standard are devoted to explaining language mechanics
    and features.^([1](ch01.xhtml#idm45043124162128)) And since the release of C++11,
    there is the explicit promise that there will be more: every three years, the
    C++ standardization committee blesses us with a new C++ standard that ships with
    additional, brand-new features. Knowing that, it doesn’t come as a big surprise
    that in the C++ community there’s a very strong emphasis on features and language
    mechanics. Most books, talks, and blogs are focused on features, new libraries,
    and language details.^([2](ch01.xhtml#idm45043137738976))'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，C++提供了很多特性。非常多！几乎2,000页的印刷C++标准中大约一半用于解释语言机制和特性。^([1](ch01.xhtml#idm45043124162128))
    自C++11发布以来，还有一个明确的承诺：每三年，C++标准化委员会会为我们提供一个新的C++标准，附带全新的特性。知道这一点，不难理解为什么在C++社区中特性和语言机制的重视如此之高。大多数书籍、讲座和博客都专注于特性、新库和语言细节。^([2](ch01.xhtml#idm45043137738976))
- en: 'It almost feels as if features are the most important thing about programming
    in C++, and crucial for the success of a C++ project. But honestly, they are not.
    Neither the knowledge about all the features nor the choice of the C++ standard
    is responsible for the success of a project. No, you should not expect features
    to save your project. On the contrary: a project can be very successful even if
    it uses an older C++ standard, and even if only a subset of the available features
    are used. Leaving aside the human aspects of software development, much more important
    for the question about success or failure of a project is the overall *structure*
    of the software. It is the structure that is ultimately responsible for maintainability:
    how easy is it to change code, extend code, and test code? Without the ability
    to easily change code, add new functionality, and have confidence in its correctness
    due to tests, a project is at the end of its lifecycle. The structure is also
    responsible for the scalability of a project: how large can the project grow before
    it collapses under its own weight? How many people can work on realizing the vision
    of the project before they step on one another’s toes?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎感觉特性是C++编程中最重要的事情，对C++项目的成功至关重要。但老实说，它们并不是。无论是所有特性的知识还是选择C++标准都不能为项目的成功负责。不，你不应该期望特性来拯救你的项目。相反：即使使用旧的C++标准，即使只使用可用特性的一个子集，项目也可以非常成功。撇开软件开发的人文因素不谈，对于项目成功或失败的问题，更为重要的是软件的总体*结构*。最终是结构决定了可维护性：修改代码、扩展代码和测试代码有多容易？如果不能轻松修改代码、添加新功能，并且由于测试的正确性而对其有信心，那么项目就接近其生命周期的末尾。结构也决定了项目的可扩展性：在项目的愿景实现之前，项目可以增长到多大程度，以至于它不能支撑自身的重量？多少人能够在项目中工作，而不会互相干扰？
- en: The overall structure is the design of a project. The design plays a much more
    central role in the success of a project than any feature could ever do. Good
    software is not primarily about the proper use of any feature; rather, it is about
    solid architecture and design. Good software design can tolerate some bad implementation
    decisions, but bad software design cannot be saved by the heroic use of features
    (old or new) alone.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 总体结构是项目的设计。设计在项目成功中起到比任何特性更为核心的作用。优秀的软件并不主要是关于正确使用任何特性；相反，它关乎坚实的架构和设计。优秀的软件设计可以容忍一些糟糕的实现决策，但糟糕的软件设计不能仅仅通过英雄般地使用特性（无论是旧的还是新的）来拯救。
- en: 'Software Design: The Art of Managing Dependencies and Abstractions'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件设计：管理依赖和抽象的艺术。
- en: 'Why is software design so important for the quality of a project? Well, assuming
    everything works perfectly right now, as long as nothing changes in your software
    and as long as nothing needs to be added, you are fine. However, that state will
    likely not last for long. It’s reasonable to expect that something will change.
    After all, the one constant in software development is change. Change is the driving
    force behind all our problems (and also most of our solutions). That’s why software
    is called *soft*ware: because in comparison to hardware, it is soft and malleable.
    Yes, *soft*ware is expected to be easily adapted to the ever-changing requirements.
    But as you may know, in reality this expectation might not always be true.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么软件设计对项目质量如此重要呢？嗯，假设现在一切都完美无缺，只要你的软件没有任何变化，也没有需要添加的内容，那么一切都好。然而，这种状态可能不会持续太久。可以合理地预期，会有一些变化发生。毕竟，软件开发中唯一不变的是变化。变化是我们所有问题（也是大多数解决方案）的驱动力。这就是为什么软件被称为*软*件：因为与硬件相比，它是柔软和可塑的。是的，*软*件预计应该容易适应不断变化的需求。但正如你可能知道的那样，现实中这种期望可能并不总是成立。
- en: To illustrate this point, let’s imagine that you select an issue from your issue
    tracking system that the team has rated with an expected effort of 2. Whatever
    a 2 means in your own project(s), it most certainly does not sound like a big
    task, so you are confident that this will be done quickly. In good faith, you
    first take some time to understand what is expected, and then you start by making
    a change in some entity `A`. Because of immediate feedback from your tests (you
    are lucky to have tests!), you are quickly reminded that you also have to address
    the issue in entity `B`. That is surprising! You did not expect that `B` was involved
    at all. Still, you go ahead and adapt `B` anyway. However, again unexpectedly,
    the nightly build reveals that this causes `C` and `D` to stop working. Before
    continuing, you now investigate the issue a little deeper and find that the roots
    of the issue are spread through a large portion of the codebase. The small, initially
    innocent-looking task has evolved into a large, potentially risky code modification.^([3](ch01.xhtml#idm45043125488704))
    Your confidence in resolving the issue quickly is gone. And your plans for the
    rest of the week are as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们假设你从问题追踪系统中选择了一个被团队评估为需要2单位的问题。在你自己的项目中，无论2单位意味着什么，它肯定听起来不像是一个大任务，所以你相信这将很快完成。怀着善意，你首先花了些时间理解预期的内容，然后开始在某个实体`A`上做出改变。由于测试的即时反馈（你很幸运有测试！），你很快就被提醒还需要解决实体`B`上的问题。这让你感到惊讶！你根本没想到`B`也会牵扯其中。尽管如此，你还是继续适应了`B`。然而，令人意外的是，夜间构建显示这导致`C`和`D`停止工作。在继续之前，你现在深入调查了一下问题，发现问题的根源遍布代码库的大部分区域。这个最初看起来无辜的小任务已经演变成了一个大的、潜在风险的代码修改。^([3](ch01.xhtml#idm45043125488704))
    你解决问题的信心已经消失。你这周剩下的计划也一样。
- en: 'Maybe this story sounds familiar to you. Maybe you can even contribute a few
    war stories of your own. Indeed, most developers have similar experiences. And
    most of these experiences have the same source of trouble. Usually the problem
    can be reduced to a single word: *dependencies*. As Kent Beck has expressed in
    his book on test-driven development:^([4](ch01.xhtml#idm45043123493296))'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事也许对你来说很熟悉。也许你甚至可以贡献一些自己的战斗经历。事实上，大多数开发者都有类似的经历。而且这些经历的大多数都源于同一个麻烦的根源。通常问题可以归结为一个词：*依赖*。正如肯特·贝克在他关于测试驱动开发的书中所表达的那样：^([4](ch01.xhtml#idm45043123493296))
- en: Dependency is the key problem in software development at all scales.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在各个层面上，依赖性是软件开发的关键问题。
- en: Dependencies are the bane of every software developer’s existence. “But of course
    there are dependencies,” you argue. “There will always be dependencies. How else
    should different pieces of code work together?” And of course, you are correct.
    Different pieces of code need to work together, and this interaction will always
    create some form of coupling. However, while there are necessary, unavoidable
    dependencies, there are also artificial dependencies that we accidentally introduce
    because we lack an understanding of the underlying problem, don’t have a clear
    idea of the bigger picture, or just don’t pay enough attention. Needless to say,
    these artificial dependencies hurt. They make it harder to understand our software,
    change software, add new features, and write tests. Therefore, one of the primary
    tasks, if not *the* primary task, of a software developer is to keep artificial
    dependencies at a minimum.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖性是每个软件开发人员的梦魇。你可能会争辩说：“当然会有依赖性。不同的代码片段怎样才能协同工作呢？”当然，你是正确的。不同的代码片段需要协同工作，这种交互总会创建某种形式的耦合。然而，虽然有必要的、不可避免的依赖关系，但也存在我们因为缺乏对底层问题的理解、没有明确的大局观或者没有足够注意而无意中引入的人为依赖关系。不用说，这些人为依赖关系是有害的。它们使我们更难理解软件、改变软件、添加新功能和编写测试。因此，软件开发人员的首要任务，如果不是唯一的任务，就是尽量将人为依赖关系降到最低。
- en: This minimization of dependencies is the goal of software architecture and design.
    To state it in the words of Robert C. Martin:^([5](ch01.xhtml#idm45043126004560))
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 减少依赖性是软件架构和设计的目标。用罗伯特·C·马丁的话来说：^([5](ch01.xhtml#idm45043126004560))
- en: The goal of software architecture is to minimize the human resources required
    to build and maintain the required system.
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 软件架构的目标是尽量减少构建和维护所需系统所需的人力资源。
- en: Architecture and design are the tools needed to minimize the work effort in
    any project. They deal with dependencies and reduce the complexity via abstractions.
    In my own words:^([6](ch01.xhtml#idm45043124440192))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 架构和设计是任何项目中减少工作量的必要工具。它们处理依赖关系，并通过抽象降低复杂性。用我的话来说：^([6](ch01.xhtml#idm45043124440192))
- en: Software design is the art of managing interdependencies between software components.
    It aims at minimizing artificial (technical) dependencies and introduces the necessary
    abstractions and compromises.
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 软件设计是管理软件组件之间相互依赖的艺术。它旨在最小化人为（技术性）依赖关系，并引入必要的抽象和妥协。
- en: Yes, software design is an art. It’s not a science, and it doesn’t come with
    a set of easy and clear answers.^([7](ch01.xhtml#idm45043124165840)) Too often
    the big picture of design eludes us, and we are overwhelmed by the complex interdependencies
    of software entities. But we are trying to deal with this complexity and reduce
    it by introducing the right kind of abstractions. This way, we keep the level
    of detail at a reasonable level. However, too often individual developers on the
    team may have a different idea of the architecture and the design. We might not
    be able to implement our own vision of a design and be forced to make compromises
    in order to move forward.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，软件设计是一门艺术。它不是一门科学，也没有一套简单清晰的答案。^([7](ch01.xhtml#idm45043124165840)) 设计的整体图景往往容易使我们困惑，我们被软件实体的复杂相互依赖所压倒。但我们试图通过引入适当类型的抽象来处理这种复杂性并将其减少。这样一来，我们将详细程度保持在合理的水平。然而，在团队中，个别开发人员对架构和设计可能有不同的理解。我们可能无法实现自己对设计的愿景，不得不妥协以继续前进。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The term *abstraction* is used in different contexts. It’s used for the organization
    of functionality and data items into data types and functions. But it’s also used
    to describe the modeling of common behavior and the representation of a set of
    requirements and expectations. In this book on software design, I will primarily
    use the term for the latter (see in particular [Chapter 2](ch02.xhtml#the_art_of_building_abstractions)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “抽象”这个术语在不同的上下文中使用。它用于将功能和数据项组织成数据类型和函数。但它也用于描述共同行为的建模以及一组需求和期望的表示。在本书中关于软件设计，我主要用这个术语来指代后者（特别是见[第2章](ch02.xhtml#the_art_of_building_abstractions)）。
- en: Note that the words *architecture* and *design* can be interchanged in the preceding
    quotes, since they’re very similar and share the same goals. Yet they aren’t the
    same. The similarities, but also differences, become clear if you take a look
    at the three levels of software development.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的引用中，“架构”和“设计”这两个词可以互换，因为它们非常相似并且具有相同的目标。然而它们并不相同。如果您看看软件开发的三个层次，这些相似之处和差异将变得清晰。
- en: The Three Levels of Software Development
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件开发的三个层次
- en: '*Software Architecture* and *Software Design* are just two of the three levels
    of software development. They are complemented by the level of *Implementation
    Details*. [Figure 1-1](#fig_level_overview) gives an overview of these three levels.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件架构* 和 *软件设计* 只是软件开发的三个层次之一。它们还包括 *实施细节* 的层次。[图 1-1](#fig_level_overview)
    概述了这三个层次。'
- en: 'To give you a feeling for these three levels, let’s start with a real-world
    example of the relationship among architecture, design, and implementation details.
    Consider yourself to be in the role of an architect. And no, please don’t picture
    yourself in a comfy chair in front of a computer with a hot coffee next to you,
    but picture yourself outside at a construction site. Yes, I’m talking about an
    architect for buildings.^([8](ch01.xhtml#idm45043123335424)) As such an architect,
    you would be in charge of all the important properties of a house: its integration
    into the neighborhood, its structural integrity, the arrangement of rooms, plumbing,
    etc. You would also take care of a pleasing appearance and functional qualities—perhaps
    a large living room, easy access between the kitchen and the dining room, and
    so on. In other words, you would be taking care of the overall architecture, the
    things that would be hard to change later, but you would also deal with the smaller
    design aspects concerning the building. However, it’s hard to tell the difference
    between the two: the boundary between architecture and design appears to be fluid
    and is not clearly separated.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您对这三个层次有所了解，让我们从一个关于架构、设计和实施细节之间关系的现实世界例子开始。想象您是一名建筑师。不，不要想象自己坐在电脑前的舒适椅子上，旁边放着一杯热咖啡，而是想象自己在一个建筑工地外面。是的，我说的是建筑师。^([8](ch01.xhtml#idm45043123335424))
    作为这样的建筑师，您将负责房屋的所有重要属性：它与社区的融合、结构完整性、房间的布置、管道等等。您还将关注它的外观和功能特性——也许是一个大客厅，厨房和餐厅之间的便捷通道等等。换句话说，您将负责整体架构，这些事情稍后难以改变，但您也会处理关于建筑的更小设计方面。然而，很难区分二者：架构和设计之间的边界看起来模糊且不明确分开。
- en: '![cpsd 0101](assets/cpsd_0101.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![cpsd 0101](assets/cpsd_0101.png)'
- en: 'Figure 1-1\. The three levels of software development: *Software Architecture*,
    *Software Design*, and *Implementation Details*. *Idioms* can be design or implementation
    patterns.'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 软件开发的三个层次：*软件架构*、*软件设计* 和 *实施细节*。*惯用语* 可以是设计或实施模式。
- en: These decisions would be the end of your responsibility, however. As an architect,
    you wouldn’t worry about where to place the refrigerator, the TV, or other furniture.
    You wouldn’t deal with all the nifty details about where to place pictures and
    other pieces of decoration. In other words, you wouldn’t handle the details; you
    would just make sure that the homeowner has the necessary structure to live well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些决定将是您责任的终点。作为一名架构师，您不必担心冰箱、电视或其他家具的摆放位置。您不会处理所有关于放置图片和其他装饰品的巧妙细节。换句话说，您不会处理细节；您只需确保业主拥有良好生活所需的结构。
- en: The furniture and other “nifty details” in this metaphor correspond to the lowest
    and most concrete level of software development, the implementation details. This
    level handles how a solution is implemented. You choose the necessary (and available)
    C++ standard or any subset of it, as well as the appropriate features, keywords,
    and language specifics to use, and deal with aspects such as memory acquisition,
    exception safety, performance, etc. This is also the level of *implementation
    patterns*, such as `std::make_unique()` as a *factory function*, `std::enable_if`
    as a recurring solution to explicitly benefit from SFINAE, etc.^([9](ch01.xhtml#idm45043130422608))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个隐喻中，家具和其他“巧妙细节”对应于软件开发的最低和最具体的层次，即实现细节。这一层次处理解决方案如何实现。你选择必要的（和可用的）C++标准或其任何子集，以及使用适当的特性、关键字和语言细节，并处理诸如内存获取、异常安全性、性能等方面。这也是*实现模式*的层次，例如`std::make_unique()`作为*工厂函数*，`std::enable_if`作为显式受益于SFINAE的经常性解决方案等。^([9](ch01.xhtml#idm45043130422608))
- en: In software design, you start to focus on the big picture. Questions about maintainability,
    changeability, extensibility, testability, and scalability are more pronounced
    on this level. Software design primarily deals with the interaction of software
    entities, which in the previous metaphor are represented by the arrangement of
    rooms, doors, pipes, and cables. At this level, you handle the physical and logical
    dependencies of components (classes, function, etc.).^([10](ch01.xhtml#idm45043124605168))
    It’s the level of design patterns such as Visitor, Strategy, and Decorator that
    define a dependency structure among software entities, as explained in [Chapter 3](ch03.xhtml#the_purpose_of_design_patterns).
    These patterns, which usually are transferable from language to language, help
    you break down complex things into digestible pieces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计中，你开始关注整体图景。关于可维护性、可变性、可扩展性、可测试性和可伸缩性的问题在这个层次上更加突出。软件设计主要涉及软件实体之间的交互，这些实体在前面的隐喻中由房间、门、管道和电缆的布置表示。在这个层次上，你处理组件（类、函数等）的物理和逻辑依赖关系。^([10](ch01.xhtml#idm45043124605168))
    这是Visitor、Strategy和Decorator等设计模式的层次，它们定义了软件实体之间的依赖结构，如第[3章](ch03.xhtml#the_purpose_of_design_patterns)中所述。这些通常可以从一种语言转移到另一种语言，帮助你将复杂的事物分解为易于理解的部分。
- en: '*Software Architecture* is the fuzziest of the three levels, the hardest to
    put into words. This is because there is no common, universally accepted definition
    of software architecture. While there may be many different views on what exactly
    an architecture is, there is one aspect that everyone seems to agree on: architecture
    usually entails the big decisions, the aspects of your software that are among
    the hardest things to change in the future:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件架构*是三个层次中最模糊、最难以用语言表达的层次。这是因为没有普遍公认的软件架构定义。虽然对于架构的确切定义可能有很多不同看法，但有一点是所有人似乎都同意的：架构通常涉及到你的软件中最难以在未来改变的重要决策：'
- en: Architecture is the decisions that you wish you could get right early in a project,
    but that you are not necessarily more likely to get them right than any other.^([11](ch01.xhtml#idm45043123295968))
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 架构是那些你希望在项目早期就能正确选择的决策，但实际上并不比其他决策更容易做对。^([11](ch01.xhtml#idm45043123295968))
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ralph Johnson
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ralph Johnson
- en: In Software Architecture, you use architectural patterns such as *client-server
    architecture*, *microservices*, and so on.^([12](ch01.xhtml#idm45043124008192))
    These patterns also deal with the question of how to design systems, where you
    can change one part without affecting any other parts of your software. Similar
    to *Software design* patterns, they define and address the structure and interdependencies
    among software entities. In contrast to design patterns, though, they usually
    deal with the key players, the big entities of your software (e.g., modules and
    components instead of classes and functions).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件架构中，你会使用诸如*客户端-服务器架构*、*微服务*等架构模式。^([12](ch01.xhtml#idm45043124008192)) 这些模式也涉及到如何设计系统，即你可以修改其中的一部分而不影响软件的其他部分。与*软件设计*模式类似，它们定义并处理软件实体之间的结构和相互依赖关系。然而，与设计模式不同的是，它们通常处理的是软件中的关键角色，即你的软件中的大实体（例如模块和组件），而不是类和函数。
- en: From this perspective, Software Architecture represents the overall strategy
    of your software approach, whereas Software Design is the tactics to make the
    strategy work. The problem with this picture is that there is no definition of
    “big.” Especially with the advent of microservices, it becomes more and more difficult
    to draw a clear line between small and big entities.^([13](ch01.xhtml#idm45043130766672))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，软件架构代表了你的软件方法的整体战略，而软件设计则是使战略生效的战术。这个图景的问题在于没有对“大”的定义。特别是随着微服务的出现，越来越难以明确划分小和大的实体。^([13](ch01.xhtml#idm45043130766672))
- en: Thus, architecture is often described as what expert developers in a project
    perceive as the key decisions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，架构通常被描述为项目中的专家开发者认为的关键决策。
- en: What makes the separation between architecture, design, and details a little
    more difficult is the concept of an *idiom*. An *idiom* is a commonly used but
    language-specific solution for a recurring problem. As such, an idiom also represents
    a pattern, but it could be either an *implementation pattern* or a *design pattern*.^([14](ch01.xhtml#idm45043131054400))
    More loosely speaking, C++ idioms are the best practices of the C++ community
    for either design or implementation. In C++, most idioms fall into the category
    of implementation details. For instance, there is the [*copy-and-swap idiom*](https://oreil.ly/hioCd)
    that you may know from the implementation of a copy assignment operator, and the
    [*RAII idiom*](https://oreil.ly/55blq) (Resource Acquisition Is Initialization—you
    should definitely be familiar with this; if not, please see your second-favorite
    C++ book^([15](ch01.xhtml#idm45043125635792))). None of these idioms introduce
    an abstraction, and none of them help to decouple. Still, they are indispensable
    to implement good C++ code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让架构、设计和细节之间的分离变得更加困难的是“惯用语”的概念。惯用语是常用的但与语言相关的解决方案，用于解决重复出现的问题。因此，惯用语也代表一种模式，但可以是实现模式或设计模式中的任何一种。^([14](ch01.xhtml#idm45043131054400))
    更宽泛地说，C++惯用语是C++社区的最佳实践，无论是设计还是实现。在C++中，大多数惯用语属于实现细节的范畴。例如，有[*拷贝并交换惯用语*](https://oreil.ly/hioCd)，你可能从拷贝赋值操作符的实现中了解到，以及[*RAII惯用语*](https://oreil.ly/55blq)（资源获取即初始化——如果你还不熟悉，请参阅你的第二喜欢的C++书籍^([15](ch01.xhtml#idm45043125635792))）。这些惯用语都不引入抽象，也不帮助解耦。但它们对于实现良好的C++代码至关重要。
- en: 'I hear you ask, “Could you be a little more specific, please? Isn’t RAII also
    providing some form of decoupling? Doesn’t it decouple resource management from
    business logic?” You’re correct: RAII separates resource management and business
    logic. However, it doesn’t achieve this by means of decoupling, i.e., abstraction,
    but by means of encapsulation. Both abstraction and encapsulation help you make
    complex systems easier to understand and change, but while abstraction solves
    the problems and issues that arise at the Software Design level, encapsulation
    solves the problems and issues that arise at the Implementation Details level.
    To quote [Wikipedia](https://oreil.ly/BeFXr):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我听到你问：“能不能再具体一点？RAII也提供某种形式的解耦吗？它不是将资源管理与业务逻辑分离吗？”你说得对：RAII将资源管理和业务逻辑分离。但它不是通过解耦（即抽象）来实现这一点，而是通过封装。抽象和封装都有助于使复杂系统更易于理解和修改，但抽象解决的是软件设计层面上出现的问题和问题，而封装则解决实现细节层面上出现的问题和问题。引用[Wikipedia](https://oreil.ly/BeFXr)的话：
- en: The advantages of RAII as a resource management technique are that it provides
    encapsulation, exception safety […], and locality […]. Encapsulation is provided
    because resource management logic is defined once in the class, not at each call
    site.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RAII作为一种资源管理技术的优势在于它提供了封装、异常安全性[...]和局部性[...]。封装是因为资源管理逻辑在类中定义一次，而不是在每个调用点上定义。
- en: 'While most idioms fall into the category of Implementation Details, there are
    also idioms that fall into the category of Software Design. Two examples are the
    *Non-Virtual Interface (NVI) idiom* and the *Pimpl idiom*. These two idioms are
    based on two classic design patterns: the *Template Method* design pattern and
    the *Bridge* design pattern, respectively.^([16](ch01.xhtml#idm45043123823504))
    They introduce an abstraction and help decouple and design for change and extensions.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数惯用语属于实现细节的范畴，但也有属于软件设计范畴的惯用语。两个例子是*非虚拟接口（NVI）惯用语*和*Pimpl惯用语*。这两个惯用语基于两个经典的设计模式：*模板方法*设计模式和*桥接*设计模式。^([16](ch01.xhtml#idm45043123823504))
    它们引入了抽象，并帮助解耦和设计以便变更和扩展。
- en: The Focus on Features
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注功能
- en: If software architecture and software design are of such importance, then why
    are we in the C++ community focusing so strongly on features? Why do we create
    the illusion that C++ standards, language mechanics, and features are decisive
    for a project? I think there are three strong reasons for that. First, because
    there are so many features, with sometimes complex details, we need to spend a
    lot of time talking about how to use all of them properly. We need to create a
    common understanding on which use is good and which use is bad. We as a community
    need to develop a sense of idiomatic C++.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件架构和软件设计如此重要，那么为什么我们在 C++ 社区如此强调功能？为什么我们制造了一个假象，即 C++ 标准、语言机制和功能对项目至关重要？我认为有三个很强的理由。首先，因为有如此多的功能，有时候还带有复杂的细节，我们需要花费大量时间讨论如何正确使用它们。我们需要形成一个共识，哪种用法是好的，哪种用法是不好的。作为一个社区，我们需要发展出一种习惯用法的
    C++ 的感觉。
- en: The second reason is that we might put the wrong expectations on features. As
    an example, let’s consider C++20 modules. Without going into details, this feature
    may indeed be considered the biggest technical revolution since the beginning
    of C++. Modules may at last put the questionable and cumbersome practice of including
    header files into source files to an end.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是我们可能对功能设置了错误的期望。例如，让我们考虑一下 C++20 模块。不详细讨论，这个功能确实可能被认为是自 C++ 开始以来最大的技术革新。模块最终可能会结束将头文件包含到源文件中的可疑和繁琐做法。
- en: 'Due to this potential, the expectations for that feature are enormous. Some
    people even expect modules to save their project by fixing their structural issues.
    Unfortunately, modules will have a hard time satisfying these expectations: modules
    don’t improve the structure or design of your code but can merely represent the
    current structure and design. Modules don’t repair your design issues, but they
    may be able to make the flaws visible. Thus, modules simply cannot save your project.
    So indeed, we may be putting too many or the wrong expectations on features.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种潜力，对该功能的期望是巨大的。有些人甚至期望模块通过修复其结构性问题来拯救他们的项目。不幸的是，模块很难满足这些期望：模块并不改善代码的结构或设计，而只能表示当前的结构和设计。模块不能修复您的设计问题，但它们可能能够显现出缺陷。因此，模块根本不能拯救您的项目。因此，我们可能确实给功能设置了太多或错误的期望。
- en: And last, but not least, the third reason is that despite the huge amount of
    features and their complexity, in comparison to the complexity of software design,
    the complexity of C++ features is small. It’s much easier to explain a given set
    of rules for features, regardless of how many special cases they contain, than
    it is to explain the best way to decouple software entities.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，尽管功能非常多且复杂，与软件设计的复杂性相比，C++ 功能的复杂性是小的。解释功能的一组规则（无论它们包含多少特殊情况）要容易得多，比解释如何最佳地解耦软件实体要容易得多。
- en: 'While there is usually a good answer to all feature-related questions, the
    common answer in software design is “It depends.” That answer might not even be
    evidence of inexperience, but of the realization that the best way to make code
    more maintainable, changeable, extensible, testable, and scalable heavily depends
    on many project-specific factors. The decoupling of the complex interplay between
    many entities may indeed be one of the most challenging endeavors that mankind
    has ever faced:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与功能相关的问题通常都有一个很好的答案，但在软件设计中，常见的答案是“这取决于”。这个答案甚至可能不是经验不足的证据，而是意识到使代码更易维护、更易变更、更易扩展、更易测试和更易扩展的最佳方法在很大程度上取决于许多项目特定因素之间复杂的相互作用解耦，可能是人类有史以来最具挑战性的事业之一：
- en: Design and programming are human activities; forget that and all is lost.^([17](ch01.xhtml#idm45043123657936))
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设计和编程是人类活动；忘记这一点，一切都将失去。^([17](ch01.xhtml#idm45043123657936))
- en: To me, a combination of these three reasons is why we focus on features so much.
    But please, don’t get me wrong. That’s not to say that features are not important.
    On the contrary, features *are* important. And yes, it’s necessary to talk about
    features and learn how to use them correctly, but once again, they alone do not
    save your project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这三个原因的结合是为什么我们如此关注功能。但请不要误解。这并不是说功能不重要。相反，功能 *是* 重要的。是的，有必要讨论功能，并学习如何正确使用它们，但再次强调，单靠它们无法拯救您的项目。
- en: The Focus on Software Design and Design Principles
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注软件设计和设计原则
- en: While features are important, and while it is of course good to talk about them,
    software design is more important. Software design is essential. I would even
    argue that it’s the foundation of the success of our projects. Therefore, in this
    book I will make the attempt to truly focus on software design and design principles
    instead of features. Of course I will still show good and up-to-date C++ code,
    but I won’t force the use of the latest and greatest language additions.^([18](ch01.xhtml#idm45043123631872))
    I *will* make use of some new features when it is reasonable and beneficial, such
    as C++20 concepts, but I will *not* pay attention to `noexcept`, or use `constexpr`
    everywhere.^([19](ch01.xhtml#idm45043124608352)) Instead I will try to tackle
    the difficult aspects of software. I will, for the most part, focus on software
    design, the rationale behind design decisions, design principles, managing dependencies,
    and dealing with abstractions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然功能很重要，当然也很好谈论它们，但软件设计更为重要。软件设计是至关重要的。我甚至会认为它是我们项目成功的基础。因此，在本书中，我将尝试真正专注于软件设计和设计原则，而不是功能。当然，我仍会展示良好且最新的C++代码，但我不会强迫使用最新和最优语言的补充。^([18](ch01.xhtml#idm45043123631872))
    当然，当合理且有益时，我会使用一些新功能，例如C++20的概念，但我不会在到处使用`noexcept`，或者使用`constexpr`。^([19](ch01.xhtml#idm45043124608352))
    相反，我将尝试解决软件的困难问题。我将大部分时间专注于软件设计，设计决策的理由，设计原则，管理依赖关系和处理抽象化。
- en: In summary, software design is the critical part of writing software. Software
    developers should have a good understanding of software design to write good,
    maintainable software. Because after all, good software is low-cost, and bad software
    is expensive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，软件设计是编写软件的关键部分。软件开发人员应该对软件设计有很好的理解，以编写良好、可维护的软件。毕竟，好的软件成本低廉，而糟糕的软件则代价高昂。
- en: 'Guideline 2: Design for Change'
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准则 2：为变更设计
- en: 'One of the essential expectations for good software is its ability to change
    easily. This expectation is even part of the word *soft*ware. *Soft*ware, in contrast
    to *hard*ware, is expected to be able to adapt easily to changing requirements
    (see also [“Guideline 1: Understand the Importance of Software Design”](#understand_the_importance_of_software_design)).
    However, from your own experience you may be able to tell that often it is not
    easy to change code. On the contrary, sometimes a seemingly simple change turns
    out to be a week-long endeavor.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于良好软件的一个基本期望是它能够轻松变更。这个期望甚至是软件这个词的一部分。与硬件相比，软件预期能够轻松适应不断变化的需求（另见[“准则 1：理解软件设计的重要性”](#understand_the_importance_of_software_design)）。然而，从你自己的经验中，你可能能够说出，修改代码通常并不容易。相反，有时一个看似简单的变更可能成为一个持续一周的努力。
- en: Separation of Concerns
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注分离
- en: One of the best and proven solutions to reduce artificial dependencies and simplify
    change is to separate concerns. The core of the idea is to split, segregate, or
    extract pieces of functionality:^([20](ch01.xhtml#idm45043124044208))
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 减少人为依赖关系并简化变更的最佳且经验证的解决方案之一是关注分离。这个思想的核心是分割、隔离或提取功能的片段。^([20](ch01.xhtml#idm45043124044208))
- en: Systems that are broken up into small, well-named, understandable pieces enable
    faster work.
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将系统分解为小而明确命名的可理解部件使工作更快。
- en: The intent behind separation of concerns is to better understand and manage
    complexity and thus design more modular software. This idea is probably as old
    as software itself and hence has been given many different names. For instance,
    the same idea is called *orthogonality* by the Pragmatic Programmers.^([21](ch01.xhtml#idm45043123834288))
    They advise separating orthogonal aspects of software. Tom DeMarco calls it *cohesion*:^([22](ch01.xhtml#idm45043123832000))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关注关注分离背后的意图是更好地理解和管理复杂性，从而设计更模块化的软件。这个思想可能和软件本身一样古老，因此已经被赋予了许多不同的名称。例如，同样的思想被《实用程序员》称为*正交性*。^([21](ch01.xhtml#idm45043123834288))
    他们建议分离软件的正交方面。Tom DeMarco称之为*内聚性*。^([22](ch01.xhtml#idm45043123832000))
- en: Cohesion is a measure of the strength of association of the elements inside
    a module. A highly cohesive module is a collection of statements and data items
    that should be treated as a whole because they are so closely related. Any attempt
    to divide them up would only result in increased coupling and decreased readability.
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 内聚性是模块内部元素关联强度的度量。高度内聚的模块是由语句和数据项组成的集合，应该作为一个整体来处理，因为它们关系密切。任何试图将它们分开的尝试只会导致耦合增加和可读性降低。
- en: 'In the *SOLID* principles,^([23](ch01.xhtml#idm45043124286736)) one of the
    most established sets of design principles, the idea is known as the *Single-Responsibility
    Principle (SRP)*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在*SOLID*原则中，^([23](ch01.xhtml#idm45043124286736))这是最为成熟的设计原则集之一，这个理念被称为*单一责任原则（SRP）*：
- en: A class should have only one reason to change.^([24](ch01.xhtml#idm45043123403072))
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个类应该只有一个变化的理由。^([24](ch01.xhtml#idm45043123403072))
- en: 'Although the concept is old and is commonly known under many names, many attempts
    to explain separation of concerns raise more questions than answers. This is particularly
    true for the SRP. The name of this design principle alone raises questions: what
    is a responsibility? And what is a *single* responsibility? A common attempt to
    clarify the vagueness about SRP is the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个概念很古老，并且以许多名称广为人知，但许多试图解释关注点分离的尝试更多地提出问题而非回答。对于SRP来说尤其如此。单单这个设计原则的名字就引发了问题：什么是一个责任？什么是“单一”的责任？为了澄清关于SRP的模糊性，一个常见的尝试是以下内容：
- en: Everything should do just one thing.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一切事物应该只做一件事。
- en: Unfortunately this explanation is hard to outdo in terms of vagueness. Just
    as the word *responsibility* doesn’t carry a lot of meaning, *just one thing*
    doesn’t help to shed any more light on it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个解释在含糊性方面很难超越。就像“责任”这个词并没有多少含义一样，“只做一件事”并不能更多地阐明它。
- en: 'Irrespective of the name, the idea is always the same: group only those things
    that truly belong together, and separate everything that does not strictly belong.
    Or in other words: separate those things that change for different reasons. By
    doing this, you reduce artificial coupling between different aspects of your code
    and it helps you make your software more adaptable to change. In the best case,
    you can change a particular aspect of your software in exactly one place.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不管名字如何，理念始终如一：只把真正应该放在一起的东西放在一起，把不严格属于同一类的东西分开。换句话说：分开那些因不同原因而变化的东西。通过这样做，你可以减少代码不同方面之间的人为耦合，帮助你使软件更能适应变化。在最好的情况下，你可以在精确一个地方改变软件的特定方面。
- en: An Example of Artificial Coupling
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个人为耦合的例子
- en: 'Let’s shed some light on separation of concerns by means of a code example.
    And I do have a great example indeed: I present to you the abstract `Document`
    class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来阐明关注点分离。我确实有一个很好的例子：我向你展示抽象的`Document`类：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This sounds like a very useful base class for all kinds of documents, doesn’t
    it? First, there is the `exportToJSON()` function ([![1](assets/1.png)](#code_g2_1)).
    All deriving classes will have to implement the `exportToJSON()` function in order
    to produce a [JSON file](https://oreil.ly/YWrsw) from the document. That will
    prove to be pretty useful: without having to know about a particular kind of document
    (and we can imagine that we will eventually have PDF documents, Word documents,
    and many more), we can always export in JSON format. Nice! Second, there is a
    `serialize()` function ([![2](assets/2.png)](#code_g2_2)). This function lets
    you transform a `Document` into bytes via a `ByteStream`. You can store these
    bytes in some persistent system, like a file or a database. And of course we can
    expect that there are many other, useful functions available that will allow us
    to pretty much use this document for everything.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是各种文档的一个非常有用的基类，不是吗？首先，有`exportToJSON()`函数（[![1](assets/1.png)](#code_g2_1)）。所有派生类都必须实现`exportToJSON()`函数，以便从文档生成[JSON文件](https://oreil.ly/YWrsw)。这将非常有用：不需要了解特定类型的文档（我们可以想象最终会有PDF文档、Word文档等），我们总是可以导出为JSON格式。很棒！其次，有一个`serialize()`函数（[![2](assets/2.png)](#code_g2_2)）。这个函数让你可以通过`ByteStream`把一个`Document`转换成字节。你可以把这些字节存储在一些持久系统中，比如文件或数据库。当然，我们可以期待还有许多其他有用的函数，可以让我们几乎可以为这个文档做任何事情。
- en: 'However, I can see the frown on your face. No, you don’t look particularly
    convinced that this is good software design. It may be because you’re just very
    suspicious about this example (it simply looks too good to be true). Or it may
    be that you’ve learned the hard way that this kind of design eventually leads
    to trouble. You may have experienced that using the common object-oriented design
    principle to bundle the data and the functions that operate on them may easily
    lead to unfortunate coupling. And I agree: despite the fact that this base class
    looks like a great all-in-one package, and even looks like it has everything that
    we might ever need, this design will soon lead to trouble.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我可以看出你脸上的皱眉。不，你看起来并不确信这是一个好的软件设计。这可能是因为你对这个例子非常怀疑（看起来太美好以至于不真实）。或者可能是因为你从艰难的经验中学到，这种设计最终会带来麻烦。你可能已经经历过，使用常见的面向对象设计原则将数据和操作数据的函数捆绑在一起可能会很容易导致不幸的耦合。我同意：尽管这个基类看起来像一个完美的整体包，甚至看起来像它拥有我们可能需要的一切，但这种设计很快就会带来麻烦。
- en: This is bad design because it contains many dependencies. Of course there are
    the obvious, direct dependencies, as for instance the dependency on the `ByteStream`
    class. However, this design also favors the introduction of artificial dependencies,
    which will make subsequent changes harder. In this case, there are three kinds
    of artificial dependencies. Two of these are introduced by the `exportToJSON()`
    function, and one by the `serialize()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是糟糕的设计，因为它包含许多依赖关系。当然，存在明显的直接依赖，比如对`ByteStream`类的依赖。然而，这种设计也倾向于引入人为依赖，这会使后续的更改变得更加困难。在这种情况下，存在三种类型的人为依赖。其中两种是由`exportToJSON()`函数引入的，另一种是由`serialize()`函数引入的。
- en: 'First, `exportToJSON()` needs to be implemented in the derived classes. And
    yes, there is no choice, because it is a [pure virtual function](https://oreil.ly/1u9at)
    (denoted by the sequence `= 0`, the so-called *pure specifier*). Since derived
    classes will very likely not want to carry the burden of implementing JSON exports
    manually, they will rely on an external, third-party JSON library: [*json*](https://oreil.ly/MqB03),
    [*rapidjson*](https://oreil.ly/jNMsz), or [*simdjson*](https://oreil.ly/5dBzC).
    Whatever library you choose for that purpose, because of the `exportToJSON()`
    member function, deriving documents would suddenly depend on this library. And,
    very likely, all deriving classes would depend on the same library, for consistency
    reasons alone. Thus, the deriving classes are not really independent; they are
    artificially coupled to a particular design decision.^([25](ch01.xhtml#idm45043123603040))
    Also, the dependency on a specific JSON library would definitely limit the reusability
    of the hierarchy, because it would no longer be lightweight. And switching to
    another library would cause a major change because all deriving classes would
    have to be adapted.^([26](ch01.xhtml#idm45043124305408))'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`exportToJSON()`需要在派生类中实现。是的，没有选择，因为它是一个[纯虚函数](https://oreil.ly/1u9at)（用`=
    0`序列表示，所谓的*纯指示符*）。由于派生类很可能不想承担手动实现JSON导出的负担，它们会依赖于外部的第三方JSON库：[*json*](https://oreil.ly/MqB03)、[*rapidjson*](https://oreil.ly/jNMsz)或[*simdjson*](https://oreil.ly/5dBzC)。无论你选择哪个库，由于`exportToJSON()`成员函数的存在，派生文档突然依赖于这个库。很可能，所有派生类由于一致性原因会依赖于同一个库。因此，派生类并不是真正独立的；它们与特定的设计决策人为耦合在一起。^([25](ch01.xhtml#idm45043123603040))
    另外，对特定JSON库的依赖性肯定会限制层次结构的可重用性，因为它将不再是轻量级的。而切换到另一个库将会导致重大变化，因为所有派生类都必须进行适应。^([26](ch01.xhtml#idm45043124305408))
- en: Of course, the same kind of artificial dependency is introduced by the `serialize()`
    function. It’s likely that `serialize()` will also be implemented in terms of
    a third-party library, such as [protobuf](https://oreil.ly/z6Kgr) or [Boost.serialization](https://oreil.ly/ySJLk).
    This considerably worsens the dependency situation because it introduces a coupling
    between two orthogonal, unrelated design aspects (i.e., JSON export and serialization).
    A change to one aspect might result in changes to the other aspect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`serialize()`函数也引入了相同类型的人为依赖。很可能`serialize()`也会基于第三方库来实现，比如[protobuf](https://oreil.ly/z6Kgr)或[Boost.serialization](https://oreil.ly/ySJLk)。这显著恶化了依赖情况，因为它在两个正交、不相关的设计方面（即JSON导出和序列化）之间引入了耦合。一个方面的变化可能导致另一个方面的变化。
- en: In the worst case, the `exportToJSON()` function might introduce a second dependency.
    The arguments expected in the `exportToJSON()` call might accidentally reflect
    some of the implementation details of the chosen JSON library. In that case, eventually
    switching to another library might result in a change of the signature of the
    `exportToJSON()` function, which would subsequently cause changes in all callers.
    Thus, the dependency on the chosen JSON library might accidentally be far more
    widespread than intended.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，`exportToJSON()` 函数可能会引入第二个依赖。在 `exportToJSON()` 调用中期望的参数可能会意外地反映出所选
    JSON 库的一些实现细节。在这种情况下，最终切换到另一个库可能会导致 `exportToJSON()` 函数签名的变更，随后导致所有调用者的变更。因此，对所选
    JSON 库的依赖可能会意外地比预期更广泛。
- en: The third kind of dependency is introduced by the `serialize()` function. Due
    to this function, the classes deriving from `Document` depend on global decisions
    on how documents are serialized. What format do we use? Do we use little endian
    or big endian? Do we have to add the information that the bytes represent a PDF
    file or a Word file? If yes (and I assume that is very likely), how do we represent
    such a document? By means of an integral value? For instance, we could use an
    enumeration for this purpose:^([27](ch01.xhtml#idm45043128374128))
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialize()` 函数引入了第三种依赖。由于这个函数，从 `Document` 派生的类依赖于关于如何序列化文档的全局决策。我们使用什么格式？我们使用小端还是大端？我们是否需要添加这些字节表示一个
    PDF 文件还是 Word 文件的信息？如果是的话（我认为这很可能），我们如何表示这样的文档？通过一个整数值吗？例如，我们可以为此目的使用一个枚举值：^([27](ch01.xhtml#idm45043128374128))'
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This approach is very common for serialization. However, if this low-level document
    representation is used within the implementations of the `Document` classes, we
    would accidentally couple all the different kinds of documents. Every deriving
    class would implicitly know about all the other `Document` types. As a result,
    adding a new kind of document would directly affect all existing document types.
    That would be a serious design flaw, since, again, it will make change harder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在序列化中非常常见。然而，如果在 `Document` 类的实现中使用这种低级文档表示，我们会意外地耦合所有不同类型的文档。每个派生类都会隐含地知道所有其他
    `Document` 类型。因此，添加新类型的文档将直接影响所有现有的文档类型。这将是一个严重的设计缺陷，因为这会使更改变得更加困难。
- en: 'Unfortunately, the `Document` class promotes many different kinds of coupling.
    So no, the `Document` class is not a great example of good class design, since
    it isn’t easy to change. On the contrary, it is hard to change and thus a great
    example of a violation of the SRP: the classes deriving from `Document` and users
    of the `Document` class change for many reasons because we have created a strong
    coupling between several orthogonal, unrelated aspects. To summarize, deriving
    classes and users of documents may change for any of the following reasons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`Document` 类促进了许多不同种类的耦合。因此，`Document` 类不是一个良好类设计的好例子，因为它不容易改变。相反，它很难改变，因此是
    SRP 的一个违反的很好例子：因为我们已经在几个正交但无关的方面之间创建了强耦合，所以从 `Document` 派生的类和文档的使用者可能因以下任一原因而改变：
- en: The implementation details of the `exportToJSON()` function change because of
    a direct dependency on the used JSON library
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exportToJSON()` 函数的实现细节因为直接依赖于所使用的 JSON 库而改变。'
- en: The signature of the `exportToJSON()` function changes because the underlying
    implementation changes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exportToJSON()` 函数的签名因底层实现的改变而改变。'
- en: The `Document` class and the `serialize()` function change because of a direct
    dependency on the `ByteStream` class
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Document` 类和 `serialize()` 函数因为直接依赖于 `ByteStream` 类而改变。'
- en: The implementation details of the `serialize()` function change because of a
    direct dependency on the implementation details
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize()` 函数的实现细节因为直接依赖于实现细节而改变。'
- en: All types of documents change because of the direct dependency on the `DocumentType`
    enumeration
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型的文档都因对 `DocumentType` 枚举的直接依赖而改变。
- en: Obviously, this design promotes more changes, and every single change would
    be harder. And of course, in the general case, there is the danger that additional
    orthogonal aspects are artificially coupled inside documents, which would further
    increase the complexity of making a change. In addition, some of these changes
    are definitely not restricted to a single place in the codebase. In particular,
    changes to the implementation details of `exportToJSON()` and `serialize()` would
    not be restricted to only one class, but likely all kinds of documents (PDF, Word,
    and so on). Therefore, a change would affect a significant number of places all
    over the codebase, which poses a maintenance risk.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种设计促进了更多的变化，每一次变更都会变得更加困难。当然，在一般情况下，还存在着附加的正交方面被人为地耦合在文档内部的风险，这会进一步增加进行更改的复杂性。此外，其中一些更改显然不仅限于代码库中的单一位置。特别是，对
    `exportToJSON()` 和 `serialize()` 的实现细节的更改不仅限于单个类，而可能影响所有类型的文档（如 PDF、Word 等）。因此，一次更改将影响代码库中多个地方，这带来了维护风险。
- en: Logical Versus Physical Coupling
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑耦合与物理耦合
- en: 'The coupling isn’t limited to logical coupling but also extends to physical
    coupling. [Figure 1-2](#fig_srp_strong_coupling) illustrates that coupling. Let’s
    assume that there is a `User` class on the low level of our architecture that
    needs to use documents that reside on a higher level of the architecture. Of course
    the `User` class depends directly on the `Document` class, which is a necessary
    dependency—an intrinsic dependency of the given problem. Thus, it should not be
    a concern for us. However, the (potential) physical dependency of `Document` on
    the selected JSON library and the direct dependency on the `ByteStream` class
    cause an indirect, transitive dependency of `User` to the JSON library and `ByteStream`,
    which reside on the highest level of our architecture. In the worst case, this
    means that changes to the JSON library or the `ByteStream` class have an effect
    on `User`. Hopefully it’s easy to see that this is an artificial, not an intentional,
    dependency: a `User` shouldn’t have to depend on JSON or serialization.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合不仅限于逻辑耦合，还延伸到物理耦合。[图 1-2](#fig_srp_strong_coupling) 说明了这种耦合。假设我们的架构低层存在一个需要使用高层文档的
    `User` 类。当然，`User` 类直接依赖于 `Document` 类，这是给定问题的必要依赖——一个内在的依赖，因此这不应成为我们的关注点。然而，`Document`
    对所选的 JSON 库的（潜在）物理依赖性以及对 `ByteStream` 类的直接依赖性会导致 `User` 对 JSON 库和 `ByteStream`
    的间接、传递依赖性，而这些在我们架构的最高层。在最坏的情况下，这意味着对 JSON 库或 `ByteStream` 类的更改会影响到 `User`。希望很容易看出，这是一种人为的、非故意的依赖关系：`User`
    不应该依赖于 JSON 或序列化。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I should explicitly state that there is a *potential* physical dependency of
    `Document` on the select JSON library. If the `<Document.h>` header file includes
    any header from the JSON library of choice (as indicated in the code snippet at
    the beginning of [“An Example of Artificial Coupling”](#example_of_artificial_coupling)),
    for instance because the `exportToJSON()` function expects some arguments based
    on that library, then there is a clear dependency on that library. However, if
    the interface can properly abstract from these details and the `<Document.h>`
    header doesn’t include anything from the JSON library, the physical dependency
    might be avoided. Thus, it depends on how well the dependencies can be (and are)
    abstracted.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我应明确指出，`Document` 可能会对所选的 JSON 库存在*潜在*的物理依赖性。如果 `<Document.h>` 头文件包含来自所选 JSON
    库的任何头文件（如在 [“人工耦合示例”](#example_of_artificial_coupling) 中的代码片段中所示），例如因为 `exportToJSON()`
    函数期望基于该库的某些参数，则存在对该库的明确依赖关系。然而，如果接口能够适当地抽象这些细节，并且 `<Document.h>` 头文件没有包含任何来自 JSON
    库的内容，则可以避免物理依赖性。因此，这取决于依赖关系能够（并且是如何）被抽象化。
- en: '![cpsd 0102](assets/cpsd_0102.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![cpsd 0102](assets/cpsd_0102.png)'
- en: Figure 1-2\. The strong transitive, physical coupling between `User` and orthogonal
    aspects like JSON and serialization.
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. `User` 和 JSON、序列化等正交方面之间强传递的物理耦合。
- en: '“High level, low level—now I’m confused,” you complain. Yes, I know that these
    two terms usually cause some confusion. So before we move on, let’s agree on the
    terminology for high level and low level. The origin of these two terms relates
    to the way we draw diagrams in the [*Unified Modeling Language (UML)*](https://oreil.ly/s0ID2):
    functionality that we consider to be stable appears on the top, on a high level.
    Functionality that changes more often and is therefore considered to be volatile
    or malleable appears on the bottom, the low level. Unfortunately, when we draw
    architectures, we often try to show how things build on one another, so the most
    stable parts appear at the bottom of an architecture. That, of course, causes
    some confusion. Independent of how things are drawn, just remember these terms:
    *high level* refers to stable parts of your architecture, and *low level* refers
    to the aspects that change more often or are more likely to change.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: “高级别、低级别——我现在搞混了”，你抱怨道。是的，我知道这两个术语通常会引起一些混淆。因此，在我们继续之前，让我们就高级别和低级别的术语达成一致。这两个术语的起源与我们在[*统一建模语言（UML）*](https://oreil.ly/s0ID2)中绘制图表的方式有关：我们认为稳定的功能出现在顶部，即高级别。那些更频繁变化，因此被认为是不稳定或可塑性更大的功能出现在底部，即低级别。不幸的是，当我们绘制架构图时，我们通常试图展示事物如何彼此依赖，因此最稳定的部分出现在架构的底部。这当然会造成一些混淆。无论事物如何被绘制，只要记住这些术语：*高级别*指的是你架构中稳定的部分，而*低级别*指的是更频繁变化或更有可能变化的方面。
- en: 'Back to the problem: the SRP advises that we should separate concerns and the
    things that do not truly belong, i.e., the noncohesive (adhesive) things. In other
    words, it advises us to separate the things that change for different reasons
    into *variation points*. [Figure 1-3](#fig_srp_weak_coupling) shows the coupling
    situation if we isolate the JSON and serialization aspects into separate concerns.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回到问题本身：SRP建议我们应该分离关注点和那些不真正属于其中的事物，即非内聚的（粘合的）事物。换句话说，它建议我们将因不同原因而变化的事物分离成*变化点*。[图 1-3](#fig_srp_weak_coupling)
    显示了如果我们将JSON和序列化方面分离出来，则耦合情况如何。
- en: '![cpsd 0103](assets/cpsd_0103.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![cpsd 0103](assets/cpsd_0103.png)'
- en: Figure 1-3\. Adherence to the *SRP* resolves the artificial coupling between
    `User` and JSON and serialization.
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. 遵循*SRP*可以解决`User`与JSON和序列化之间的人为耦合。
- en: 'Based on this advice, the `Document` class is refactored in the following way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些建议，`Document`类被按照以下方式重构：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The JSON and serialization aspects are just not part of the fundamental pieces
    of functionality of a `Document` class. The `Document` class should merely represent
    the very basic operations of different kinds of documents. All orthogonal aspects
    should be separated. This will make changes considerably easier. For instance,
    by isolating the JSON aspect into a separate variation point and into the new
    `JSON` component, switching from one JSON library to another will affect only
    this one component. The change could be done in exactly one place and would happen
    in isolation from all the other, orthogonal aspects. It would also be easier to
    support the JSON format by means of several JSON libraries. Additionally, any
    change to how documents are serialized would affect only one component in the
    code: the new `Serialization` component. Also, `Serialization` would act as a
    variation point that enables isolated, easy change. That would be the optimal
    situation.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和序列化方面并不是`Document`类基本功能的一部分。`Document`类应该仅仅表示不同种类文档的基本操作。所有正交的方面应该被分离开来。这将使得修改变得更加容易。例如，通过将JSON方面隔离为一个独立的变化点并成为新的`JSON`组件，从一个JSON库切换到另一个库只会影响到这一个组件。修改可以在一个地方完成，并且与所有其他正交方面隔离开来。同时，通过多个JSON库支持JSON格式也会更加容易。此外，任何关于文档序列化方式的改变只会影响到代码中的一个组件：新的`Serialization`组件。同样，`Serialization`将作为一个变化点，促使隔离和简单的改变。这将是最优的情况。
- en: 'After your initial disappointment with the `Document` example, I can see you’re
    looking happier again. Perhaps there’s even an “I knew it!” smile on your face.
    However, you’re not entirely satisfied yet: “Yes, I agree with the general idea
    of separating concerns. But how do I have to structure my software to separate
    concerns? What do I have to do to make it work?” That is an excellent question,
    but one with many answers that I’ll address in the upcoming chapters. The first
    and most important point, however, is the identification of a variation point,
    i.e., some aspect in your code where changes are expected. These variation points
    should be extracted, isolated, and wrapped, such that there are no longer any
    dependencies on these variations. That will ultimately help make changes easier.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在您对 `Document` 示例的初步失望之后，我看到您再次变得更加快乐。也许您的脸上甚至露出了“我知道了！”的微笑。然而，您仍然不完全满意：“是的，我同意分离关注点的一般想法。但我该如何组织我的软件来分离关注点呢？我该做什么才能让它起作用？”这是一个很好的问题，但是有很多答案，我将在接下来的章节中详细讨论。然而，第一个也是最重要的一点是识别变化点，即您的代码中预期变化的某个方面。这些变化点应该被提取、隔离和包装，以便不再依赖于这些变化。这最终将有助于使变更变得更容易。
- en: '“But that is still only superficial advice!” I hear you say. And you’re correct.
    Unfortunately, there is no single answer and there is no simple answer. It depends.
    But I promise to give many concrete answers for how to separate concerns in the
    upcoming chapters. After all, this is a book on software design, i.e., a book
    on managing dependencies. As a little teaser, in [Chapter 3](ch03.xhtml#the_purpose_of_design_patterns)
    I will introduce a general and practical approach to this problem: design patterns.
    With this general idea in mind, I will show you how to separate concerns using
    different design patterns. For instance, the *Visitor*, *Strategy*, and *External
    Polymorphism* design patterns come to mind. All of these patterns have different
    strengths and weaknesses, but they share the property of introducing some kind
    of abstraction to help you to reduce dependencies. Additionally, I promise to
    take a close look at how to implement these design patterns in modern C++.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: “但这仍然只是表面的建议！”我听到你说。你说得对。不幸的是，没有单一的答案，也没有简单的答案。这取决于情况。但我承诺在接下来的章节中会提供许多关于如何分离关注点的具体答案。毕竟，这是一本关于软件设计的书，即一本关于管理依赖关系的书。作为一个小小的引子，在[第 3
    章](ch03.xhtml#the_purpose_of_design_patterns) 中，我将介绍解决这个问题的一个通用而实用的方法：设计模式。在这个总体思路下，我将展示如何使用不同的设计模式来分离关注点。例如，*访问者*、*策略*
    和 *外部多态性* 设计模式让人想起。所有这些模式都有不同的优缺点，但它们共享一个特性，即引入某种抽象以帮助您减少依赖关系。此外，我承诺将仔细研究如何在现代
    C++ 中实现这些设计模式。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'I will introduce the Visitor design pattern in [“Guideline 16: Use Visitor
    to Extend Operations”](ch04.xhtml#use_visitors_to_extend_operations), and the
    Strategy design pattern in [“Guideline 19: Use Strategy to Isolate How Things
    Are Done”](ch05.xhtml#use_strategy_to_isolate_how_things_are_done). The External
    Polymorphism design pattern will be the topic of [“Guideline 31: Use External
    Polymorphism for Nonintrusive Runtime Polymorphism”](ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[“指南 16：使用访问者扩展操作”](ch04.xhtml#use_visitors_to_extend_operations) 中介绍访问者设计模式，并在[“指南 19：使用策略来隔离操作方式”](ch05.xhtml#use_strategy_to_isolate_how_things_are_done)
    中介绍策略设计模式。外部多态性设计模式将是[“指南 31：使用外部多态性进行非侵入式运行时多态性”](ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism)
    的主题。
- en: Don’t Repeat Yourself
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: 'There is a second, important aspect to changeability. To explain this aspect,
    I will introduce another example: a hierarchy of items. [Figure 1-4](#fig_simple_item_hierarchy)
    gives an impression of this hierarchy.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的变更性方面是有一个第二个方面。为了解释这一点，我将引入另一个例子：项目层次结构。[图 1-4](#fig_simple_item_hierarchy)
    给出了这个层次结构的印象。
- en: '![cpsd 0104](assets/cpsd_0104.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![cpsd 0104](assets/cpsd_0104.png)'
- en: Figure 1-4\. The `Item` class hierarchy.
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. `Item` 类层次结构。
- en: 'At the top of that hierarchy is the `Item` base class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次结构的顶部是`Item`基类：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Item` base class represents an abstraction for any kind of item that has
    a price tag (represented by the `Money` class). Via the `price()` function, you
    can query for that price. Of course there are many possible items, but for illustration
    purposes, we restrict ourselves to `CppBook` and `ConferenceTicket`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item` 基类代表具有价格标签（由 `Money` 类表示）的任何类型的项目的抽象。通过 `price()` 函数，您可以查询该价格。当然，有许多可能的项目，但为了说明目的，我们限制在
    `CppBook` 和 `ConferenceTicket`：'
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The constructor of the `CppBook` class expects a title and author in the form
    of strings and a price in the form of `Money` ([![3](assets/3.png)](#code_g2_3)).^([28](ch01.xhtml#idm45043129091136))
    Apart from that, it only allows you to access the title, the author, and the price
    with the `title()`, `author()`, and `price()` functions ([![4](assets/4.png)](#code_g2_4),
    [![5](assets/5.png)](#code_g2_5), and [![6](assets/6.png)](#code_g2_6)). However,
    the `price()` function is a little special: obviously, books are subject to taxes.
    Therefore, the original price of the book needs to be adapted according to a given
    tax rate. In this example, I assume an imaginary tax rate of 15%.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`CppBook` 类的构造函数需要以字符串形式提供书名和作者，并以 `Money` 形式提供价格（[![3](assets/3.png)](#code_g2_3))。^([28](ch01.xhtml#idm45043129091136))
    除此之外，你只能通过 `title()`、`author()` 和 `price()` 函数来访问书名、作者和价格（[![4](assets/4.png)](#code_g2_4),
    [![5](assets/5.png)](#code_g2_5) 和 [![6](assets/6.png)](#code_g2_6))。然而，`price()`
    函数有点特殊：显然，书籍是需要交税的。因此，书籍的原价需要根据给定的税率进行调整。在这个例子中，假设一个虚构的税率为 15%。'
- en: 'The `ConferenceTicket` class is the second example of an `Item`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConferenceTicket` 类是 `Item` 的第二个示例：'
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`ConferenceTicket` is very similar to the `CppBook` class, but expects only
    the name of the conference and the price in the constructor ([![7](assets/7.png)](#code_g2_7)).
    Of course, you can access the name and the price with the `name()` and `price()`
    functions, respectively. Most importantly, however, the price for a C++ conference
    is also subject to taxes. Therefore, we again adapt the original price according
    to the imaginary tax rate of 15%.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConferenceTicket` 类与 `CppBook` 类非常相似，但构造函数只需提供会议名称和价格（[![7](assets/7.png)](#code_g2_7))。当然，你可以通过
    `name()` 和 `price()` 函数分别访问会议名称和价格。然而，对于 C++ 会议，价格也需要纳税。因此，我们再次根据虚构的税率 15% 调整原始价格。'
- en: 'With this functionality available, we can go ahead and create a couple of `Item`s
    in the `main()` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个功能，我们可以在 `main()` 函数中继续创建一些 `Item`：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `main()`, we create a couple of items (two books and three conferences) and
    compute the total price of all items.^([29](ch01.xhtml#idm45043128523184)) The
    total price will, of course, include the imaginary tax rate of 15%.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 中，我们创建了一些物品（两本书和三个会议票），并计算了所有物品的总价格。^([29](ch01.xhtml#idm45043128523184))
    总价格当然包括虚构的 15% 税率。
- en: 'That sounds like a good design. We have separated the specific kinds of items
    and are able to change how the price of each item is computed in isolation. It
    seems that we have fulfilled the SRP and extracted and isolated the variation
    points. And of course, there are more items. Many more. And all of them will make
    sure that the applicable tax rate is properly taken into account. Great! Now,
    while this `Item` hierarchy will make us happy for some time, the design unfortunately
    has a significant flaw. We might not realize it today, but there’s always a looming
    shadow in the distance, the nemesis of problems in software: change.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来是一个不错的设计。我们已经分离了特定种类的物品，并能够在隔离环境中改变每个物品的价格计算方式。看起来我们已经实现了 SRP，并提取和隔离了变化点。当然，还有更多的物品。很多很多。而且所有这些物品都将确保适用的税率被正确考虑。太棒了！然而，尽管这个
    `Item` 层次结构将在一段时间内让我们感到满意，但这个设计不幸地有一个显著的缺陷。我们可能今天意识不到，但在软件问题的背后，总有一个潜在的问题在遥远的阴影中：变化。
- en: 'What happens if for some reason the tax rate changes? What if the 15% tax rate
    is lowered to 12%? Or raised to 16%? I can still hear the arguments from the day
    the initial design was committed into the codebase: “No, that will never happen!”
    Well, even the most unexpected thing may happen. For instance, in Germany, the
    tax rate was lowered from 19% to 16% for half a year in 2021\. This, of course,
    would mean that we have to change the tax rate in our codebase. Where do we apply
    the change? In the current situation, the change would pretty much affect every
    class deriving from the `Item` class. The change would be all over the codebase!'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某些原因税率发生变化会怎么样？如果 15% 的税率降低到 12% 呢？或者提高到 16% 呢？我仍然能听到当初设计被提交到代码库时的争论声：“不，那绝不会发生！”然而，最意想不到的事情可能会发生。例如，在德国，税率在
    2021 年的半年内从 19% 降低到 16%。当然，这意味着我们需要在代码库中改变税率。我们在哪里应用这个改变？在目前的情况下，这个改变几乎会影响到每一个继承自
    `Item` 类的类。这个改变会遍布整个代码库！
- en: Just as much as the SRP advises separating variation points, we should take
    care not to duplicate information throughout the codebase. As much as everything
    should have a single responsibility (a single reason to change), every responsibility
    should exist only once in the system. This idea is commonly called the *Don’t
    Repeat Yourself* (DRY) principle. This principle advises us to not duplicate some
    key information in many places—but to design the system such that we can make
    the change in only one place. In the optimal case, the tax rate(s) should be represented
    in exactly one place to enable you to make an easy change.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如SRP建议分离变化点一样，我们应该注意不要在代码库中重复信息。尽管每件事都应该有一个单一责任（一个变更的唯一原因），但每个责任在系统中应该只存在一次。这个思想通常称为“不要重复自己”（DRY）原则。该原则建议我们不要在许多地方重复一些关键信息，而是设计系统使我们只需在一个地方进行更改。在最佳情况下，税率应该在确切的一个地方表示，以便您可以轻松地进行更改。
- en: 'Usually the SRP and the DRY principles work together very nicely. Adhering
    the SRP will often lead to adhering to DRY as well, and vice versa. However, sometimes
    adhering to both requires some extra steps. I know you’re eager to learn what
    these extra steps are and how to solve the problem, but at this point, it’s sufficient
    to point out the general idea of SRP and DRY. I promise to revisit this problem
    and to show you how to solve it (see [“Guideline 35: Use Decorators to Add Customization
    Hierarchically”](ch09.xhtml#use_decorators_to_add_customization_hierarchically)).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，SRP和DRY原则可以非常好地配合。遵循SRP通常也会导致遵循DRY，反之亦然。然而，有时遵循这两个原则需要额外的步骤。我知道你渴望了解这些额外步骤及如何解决问题，但在这一点上，指出SRP和DRY的一般思想已足够。我承诺会重新审视这个问题，并向您展示如何解决它（参见[“指南35：使用装饰器分层地添加定制”](ch09.xhtml#use_decorators_to_add_customization_hierarchically)）。
- en: Avoid Premature Separation of Concerns
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免过早地分离关注点。
- en: At this point, I’ve hopefully convinced you that adhering to SRP and DRY is
    a very reasonable idea. You might even be so committed that you plan to separate
    everything—all classes and functions—into the most tiny units of functionality.
    After all, that’s the goal, right? If this is what you’re thinking right now,
    please stop! Take a deep breath. And one more. And then please listen carefully
    to the wisdom of Katerina Trajchevska:^([30](ch01.xhtml#idm45043128758896))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，希望我已经说服你遵循SRP和DRY是非常合理的想法。你甚至可能如此坚定，计划将所有东西——所有类和函数——分离成最微小的功能单元。毕竟，这是目标，对吧？如果你现在正这么想，请停下！深呼吸。再深一口。然后请仔细听凯特里娜·特拉杰夫斯卡的智慧：^([30](ch01.xhtml#idm45043128758896))
- en: Don’t try to achieve SOLID, use SOLID to achieve maintainability.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要试图实现SOLID原则，而是利用SOLID来实现可维护性。
- en: 'Both SRP and DRY are your tools for achieving better maintainability and simplifying
    change. They are not your goals. While both are of utmost importance in the long
    run, it can be very counterproductive to separate entities without a clear idea
    about what kind of change will affect you. Designing for change usually favors
    one specific kind of change but might unfortunately make other kinds of change
    harder. This philosophy is part of the commonly known [*YAGNI* principle](https://oreil.ly/Gu7u9)
    (You Aren’t Gonna Need It), which warns you about overengineering (see also [“Guideline
    5: Design for Extension”](#design_for_extension)). If you have a clear plan, if
    you know what kind of change to expect, then apply SRP and DRY to make that kind
    of change simple. However, if you don’t know what kind of change to expect, then
    don’t guess—just wait. Wait until you have a clear idea about what kind of change
    to expect and then refactor to make the change as easy as possible.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SRP和DRY都是实现更好可维护性和简化变更的工具。它们不是你的目标。虽然长远来看两者都非常重要，但在没有清晰想法的情况下分离实体可能会非常适得其反。为变更而设计通常会偏向于特定类型的变更，但不幸的是可能会使其他类型的变更变得更加困难。这种哲学是众所周知的“你不会需要它”（YAGNI）原则的一部分，该原则警告你不要过度设计（也请参阅[“指南5：设计用于扩展”](#design_for_extension)）。如果有明确的计划，如果你知道可以预期什么样的变化，那么就应用SRP和DRY使这种变化变得简单。然而，如果你不知道可以预期什么样的变化，那么不要猜测——只需等待。等到你对可以预期什么样的变化有了清晰的想法，然后重构以尽可能地简化变化。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Just don’t forget that one aspect of easily changing things is having unit tests
    in place that give you confirmation that the change did not break the expected
    behavior.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了轻松修改事物的一个方面是拥有单元测试，这些测试可以确认修改没有破坏预期的行为。
- en: In summary, change is expected in *soft*ware and therefore it’s vital to design
    for change. Separate concerns and minimize duplication to enable you to easily
    change things without being afraid to break other, orthogonal aspects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Guideline 3: Separate Interfaces to Avoid Artificial Coupling'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s revisit the `Document` example from [“Guideline 2: Design for Change”](#design_for_change).
    I know, by now you probably feel like you’ve seen enough documents, but believe
    me, we’re not done yet. There’s still an important coupling aspect to address.
    This time we don’t focus on the individual functions in the `Document` class but
    on the interface as a whole:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Segregate Interfaces to Separate Concerns
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Document` requires deriving classes to handle both JSON exports and serialization.
    While, from the point of view of a document, this may seem reasonable (after all,
    *all* documents should be exportable into JSON and serializable), it unfortunately
    causes another kind of coupling. Imagine the following user code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `exportDocument()` function is solely interested in exporting a given document
    to JSON. In other words, the `exportDocument()` function is *not* concerned with
    serializing a document or with any other aspect that `Document` has to offer.
    Still, as a result of the definition of the `Document` interface, due to coupling
    many orthogonal aspects together, the `exportDocument()` function depends on much
    more than just the JSON export. All of these dependencies are unnecessary and
    artificial. Changing any of these—for instance, the `ByteStream` class or the
    signature of the `serialize()` function—has an effect on *all* users of `Document`,
    even those that do not require serialization. For any change, *all* the users,
    including the `exportDocument()` function, would need to be recompiled, retested,
    and, in the worst case, redeployed (for instance, if delivered in a separate library).
    The same thing happens, however, if the `Document` class is extended by another
    function—for instance, an export to another document type. The problem gets bigger
    the more orthogonal functionality is coupled in `Document`: any change carries
    the risk of causing a rippling effect throughout the codebase. Which is sad indeed,
    as interfaces should help to decouple, not introduce artificial coupling.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'This coupling is caused by a violation of the Interface Segregation Principle
    (ISP), which is the *I* in the *SOLID* acronym:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Clients should not be forced to depend on methods that they do not use.^([31](ch01.xhtml#idm45043123066176))
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The ISP advises separating concerns by segregating (decoupling) interfaces.
    In our case, there should be two separate interfaces representing the two orthogonal
    aspects of JSON export and serialization:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This separation does not make the `Document` class obsolete. On the contrary,
    the `Document` class still represents the requirements posed on all documents.
    However, this separation of concerns now enables you to minimize dependencies
    to only the set of functions that is actually required:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this form, by depending only on the segregated `JSONExportable` interface,
    the `exportDocument()` function no longer depends on the serialization functionality
    and thus no longer depends on the `ByteStream` class. Thus, the segregation of
    interfaces has helped to reduce coupling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '“But isn’t that just a separation of concerns?” you ask. “Isn’t that just another
    example of the SRP?” Yes, indeed it is. I agree that we’ve essentially identified
    two orthogonal aspects, separated them, and thus applied the SRP to the `Document`
    interface. Therefore, we could say that ISP and SRP are the same. Or at least
    that ISP is a special case of the SRP because of the focus of the ISP on interfaces.
    This attitude seems to be the common opinion in the community, and I agree. However,
    I still consider it valuable to talk about ISP. Despite the fact that ISP may
    only be a special case, I would argue that it’s an important special case. Unfortunately,
    it is often very tempting to aggregate unrelated, orthogonal aspects into an interface.
    It might even happen to *you* that you couple separate aspects into an interface.
    Of course, I would never imply that you did this on purpose, but unintentionally,
    accidentally. We often do not pay enough attention to these details. Of course,
    you argue, “I would never do that.” However, in [“Guideline 19: Use Strategy to
    Isolate How Things Are Done”](ch05.xhtml#use_strategy_to_isolate_how_things_are_done),
    you’ll see an example that might convince you how easily this can happen. Since
    changing interfaces later may be extremely difficult, I believe it pays off to
    raise awareness of this problem with interfaces. For that reason, I didn’t drop
    the ISP but included it as an important and noteworthy case of the SRP.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing Requirements of Template Arguments
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although it appears as if the ISP is applicable only to base classes, and although
    the ISP is mostly introduced by means of object-oriented programming, the general
    idea of minimizing the dependencies introduced by interfaces can also be applied
    to templates. Consider the `std::copy()` function, for instance:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In C++20, we could apply *concepts* to express the requirements:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`std::copy()` expects a pair of input iterators as the range to copy from,
    and an output iterator to the target range. It explicitly requires input iterators
    and output iterators, since it does not need any other operation. Thus, it minimizes
    the requirements on the passed arguments.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that `std::copy()` requires `std::forward_iterator` instead of
    `std::input_iterator` and `std::output_iterator`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This would unfortunately limit the usefulness of the `std::copy()` algorithm.
    We would no longer be able to copy from input streams, since they don’t generally
    provide the multipass guarantee and do not enable us to write. That would be unfortunate.
    However, focusing on dependencies, `std::copy()` would now depend on operations
    and requirements it doesn’t need. And iterators passed to `std::copy()` would
    be forced to provide additional operations, so `std::copy()` would force dependencies
    on them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: This is only a hypothetical example, but it illustrates how important the separation
    of concerns in interfaces is. Obviously, the solution is the realization that
    input and output capabilities are separate aspects. Thus, after separating concerns
    and after applying the ISP, the dependencies are significantly reduced.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Guideline 4: Design for Testability'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in [“Guideline 1: Understand the Importance of Software Design”](#understand_the_importance_of_software_design),
    *soft*ware changes. It’s expected to change. But every time you change something
    in your software, you run the risk of breaking something. Of course, not intentionally
    but accidentally, despite your best efforts. The risk is always there. As an experienced
    developer, however, you don’t lose any sleep over that. Let there be risk—you
    don’t care. You have something that protects you from accidentally breaking things,
    something that keeps the risk at a minimum: your tests.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of having tests is to be able to assert that all of your software
    functionality still works, despite constantly changing things. So obviously, tests
    are your protection layer, your life vest. Tests are essential! However, first
    of all, you have to write the tests. And in order to write tests and set up this
    protective layer, your software needs to be testable: your software must be written
    in a way that it is possible, and in the best case even *easily* possible, to
    add tests. Which brings us to the heart of this guideline: software should be
    designed for testability.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: How to Test a Private Member Function
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Of course I have tests,” you argue. “Everyone should have tests. That’s common
    knowledge, isn’t it?” I completely agree. And I believe you that your codebase
    is equipped with a reasonable test suite.^([32](ch01.xhtml#idm45043122620688))
    But surprisingly, despite everyone agreeing to the need for tests, not every piece
    of software is written with this awareness in mind.^([33](ch01.xhtml#idm45043122618256))
    In fact, a lot of code is hard to test. And sometimes this is simply because the
    code is not designed to be tested.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea, I have a challenge for you. Take a look at the following
    `Widget` class. `Widget` holds a collection of `Blob` objects, which once in a
    while need to be updated. For that purpose, `Widget` provides the `updateCollection()`
    member function, which we now assume is so important that we need to write a test
    for it. And this is my challenge: how would you test the `updateCollection()`
    member function?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I assume that you immediately see the real challenge: the `updateCollection()`
    member function is declared in the private section of the class. This means that
    there is no direct access from the outside and therefore no direct way of testing
    it. So take a few seconds to think about this…'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '“It’s private, yes, but this is still not much of a challenge. There are multiple
    ways I can do that,” you say. I agree, there are multiple ways you could try.
    So please, go ahead. You weigh your options, then you come up with your first
    idea: “Well, the easiest approach would be to test the function via some other,
    public member function that internally calls the `updateCollection()` function.”
    That sounds like an interesting first idea. Let’s assume that the collection needs
    to be updated when a new `Blob` is added to it. Calling the `addBlob()` member
    function would trigger the `updateCollection()` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Although this sounds like a reasonable thing to do, it’s also something you
    should avoid if possible. What you are suggesting is a so-called *white box test*.
    A white box test knows about the internal implementation details of some function
    and tests based on that knowledge. This introduces a dependency of the test code
    on the implementation details of your production code. The problem with this approach
    is that software changes. Code changes. Details change. For instance, at some
    point in the future, the `addBlob()` function might be rewritten so it does not
    have to update the collection anymore. If this happens, your test no longer performs
    the task it was written to do. You would lose your `updateCollection()` test,
    potentially without even realizing it. Therefore, a white box test poses a risk.
    Just as much as you should avoid and reduce dependencies in your production code
    (see [“Guideline 1: Understand the Importance of Software Design”](#understand_the_importance_of_software_design)),
    you should also avoid dependencies between your tests and the details of your
    production code.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: What we really need is a *black box test*. A black box test does not make any
    assumptions about internal implementation details, but tests only for expected
    behavior. Of course, this kind of test can also break if you change something,
    but it shouldn’t break if some implementation details change—only if the expected
    behavior changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: “OK, I get your point,” you say. “But you don’t suggest making the `update​Col⁠lec⁠tion()`
    function public, do you?” No, rest assured that isn’t what I’m suggesting. Of
    course, sometimes this may be a reasonable approach. But in our case, I doubt
    that this would be a wise move. The `updateCollection()` function should not be
    called just for fun. It should be called only for a good reason, only at the right
    time, and probably to preserve some kind of invariant. This is something we should
    not entrust a user with. So no, I don’t think that the function would be a good
    candidate for the `public` section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '“OK, good, just checking. Then let’s simply make the test a `friend` of the
    `Widget` class. This way it would have full access and could call the `private`
    member function unhindered”:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Yes, we could add a `friend`. Let’s assume that there is the `TestWidget` test
    fixture, containing all the tests for the `Widget` class. We could make this test
    fixture a `friend` of the `Widget` class. Although this may sound like another
    reasonable approach, I unfortunately have to be the spoilsport again. Yes, technically
    this would solve the problem, but from a design perspective, we’ve just introduced
    an artificial dependency again. By actively changing the production code to introduce
    the `friend` declaration, the production code now knows about the test code. And
    while the test code should of course know about the production code (that’s the
    point of the test code), the production code should not have to know about the
    test code. This introduces a cyclic dependency, which is an unfortunate and artificial
    dependency.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: “You sound like this is the worst thing in the world. Is it really that bad?”
    Well, sometimes this may actually be a reasonable solution. It definitely is a
    simple and quick solution. However, since right now we have the time to discuss
    all of our options, there definitely must be something better than adding a `friend`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I don’t want to make things worse, but in C++ we don’t have a lot of `friend`s.
    Yes, I know, this sounds sad and lonely, but of course I mean the keyword `friend`:
    in C++, `friend` is not your friend. The reason is that `friend`s introduce coupling,
    mostly artificial coupling, and we should avoid coupling. Of course, exceptions
    can be made for the good `friend`s, the ones you cannot live without, such as
    [hidden friends](https://oreil.ly/Lu6rq), or idiomatic uses of `friend`, such
    as the [*Passkey idiom*](https://oreil.ly/qEN0m). A test is more like a friend
    on social media, so declaring a test a `friend` does not sound like a good choice.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '“OK, then let’s switch from `private` to `protected` and make the test derive
    from the `Widget` class,” you suggest. “This way, the test would gain full access
    to the `updateCollection()` function”:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Well, I have to admit that technically this approach would work. However, the
    fact that you’re suggesting inheritance to solve this issue tells me that we definitely
    have to talk about the meaning of inheritance and how to use it properly. To quote
    the two pragmatic programmers:^([34](ch01.xhtml#idm45043122277712))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is rarely the answer.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since we’ll be focusing on this topic fairly soon, let me just say that it feels
    like we’re abusing inheritance for the sole reason of gaining access to nonpublic
    member functions. I’m pretty certain this isn’t why inheritance was invented.
    Using inheritance to gain access to the `protected` section of a class is like
    the bazooka approach to something that should be very simple. It is, after all,
    almost identical to making the function `public`, because everyone can easily
    gain access. It seems we really haven’t designed the class to be easily testable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '“Come on, what else could we do? Or do you really want me to use the preprocessor
    and define all `private` labels as `public`?”:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: OK, let’s take a deep breath. Although this last approach may seem funny, keep
    in mind that we have now left the range of reasonable arguments.^([35](ch01.xhtml#idm45043122228608))
    If we seriously consider using the preprocessor to hack our way into the `private`
    section of the `Widget` class, then all is lost.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The True Solution: Separate Concerns'
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '“OK then, what *should* I do to test the `private` member function? You have
    already discarded all the options.” No, not all the options. We have not yet discussed
    the one design approach that I highlighted in [“Guideline 2: Design for Change”](#design_for_change):
    separation of concerns. My approach would be to extract the `private` member function
    from the class and make it a separate entity in our codebase. My preferred solution
    in this case is to extract the member function as a free function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All calls to the previous member function could be replaced with a call to
    the free `updateCollection()` function by just adding `blobs_` as the first function
    argument. Alternatively, if there is some state attached to the function, we extract
    it in the form of another class. Either way, we design the resulting code such
    that it’s easy, perhaps even trivial, to test:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '“You cannot be serious!” you exclaim. “Isn’t this the worst of all options?
    Aren’t we artificially separating two things that belong together? And isn’t the
    SRP telling us that we should keep the things that belong together close to one
    another?” Well, I don’t think so. On the contrary, I firmly believe that only
    now are we adhering to the SRP: the SRP states that we should isolate the things
    that do not belong together, the things that can change for different reasons.
    Admittedly, at first sight, it may appear as if `Widget` and `updateCollection()`
    belong together, since after all, the `blob_` data member needs to be updated
    once in a while. However, the fact that the `update​Col⁠lection()` function isn’t
    properly testable is a clear indication that the design does not fit yet: if anything
    that needs explicit testing can’t be tested, something is amiss. Why make our
    lives so much harder and hide the function to test in the `private` section of
    the `Widget` class? Since testing plays a vital role in the presence of change,
    testing represents just another way to help decide which things belong together.
    If the `updateCollection()` function is important enough that we want to test
    it in isolation, then apparently it changes for a reason other than `Widget`.
    This indicates that `Widget` and `updateCollection()` do not belong together.
    Based on the SRP, the `updateCollection()` function should be extracted from the
    class.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '“But isn’t this against the idea of encapsulation?” you ask. “And don’t you
    dare wave away encapsulation. I consider encapsulation to be very important!”
    I agree, it is very important, fundamentally so! However, encapsulation is just
    one more reason to separate concerns. As Scott Meyers claims in his book, *Effective
    C++*, extracting functions from a class is a step toward increasing encapsulation.
    According to Meyers, you should generally prefer nonmember non-`friend` functions
    to member functions.⁠^([36](ch01.xhtml#idm45043121978352)) This is because every
    member function has full access to every member of a class, even the `private`
    members. However, in the extracted form, the `updateCollection()` function is
    restricted to just the `public` interface of the `Widget` class and is not able
    to access the `private` members. Therefore, these `private` members become a little
    more encapsulated. Note that the same argument holds true for extracting the `BlobCollection`
    class: the `BlobCollection` class is not able to touch the nonpublic members of
    the `Widget` class, and therefore `Widget` also becomes a little more encapsulated.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'By separating concerns and extracting this piece of functionality, you now
    gain several advantages. First, as just discussed, the `Widget` class becomes
    more encapsulated. Fewer members can access the `private` members. Second, the
    extracted `update​Col⁠lection()` function is easily, even trivially, testable.
    You don’t even need a `Widget` for that but instead can either pass `std::vector<Blob>`
    as the first argument (not the implicit first argument of any member function,
    the `this` pointer) or call the `public` member function. Third, you don’t have
    to change any other aspect in the `Widget` class: you simply pass the `blobs_`
    member to the `updateCollection()` function whenever you need to update the collection.
    No need to add any other `public` getter. And, probably most importantly, you
    can now change the function in isolation, without having to deal with `Widget`.
    This indicates that you have reduced dependencies. While in the initial setup
    the `updateCollection()` function was tightly coupled to the `Widget` class (yes,
    the `this` pointer), we have now severed these ties. The `updateCollection()`
    function is now a separate service that might even be reused.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: I can see that you still have questions. Maybe you’re concerned that this means
    you shouldn’t have any member functions anymore. No, to be clear, I did not suggest
    that you should extract each and every member function from your classes. I merely
    suggested you take a closer look at those functions that need to be tested but
    are placed in the `private` section of your class. Also, you might wonder how
    this works with virtual functions, which cannot be extracted in the form of a
    free function. Well, there’s no quick answer for that, but it’s something that
    we will deal with in many different ways throughout this book. My objective will
    always be to reduce coupling and to increase testability, even by separating virtual
    functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In summary, do not hinder your design and testability with artificial coupling
    and artificial boundaries. Design for testability. Separate concerns. Free your
    functions!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Guideline 5: Design for Extension'
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an important aspect about changing software that I haven’t highlighted
    yet: extensibility. Extensibility should be one of the primary goals of your design.
    Because, frankly speaking, if you’re no longer able to add new functionality to
    your code then your code has reached the end of its lifetime. Thus, adding new
    functionality—extending the codebase—is of fundamental interest. For that reason,
    extensibility should indeed be one of your primary goals and a driving factor
    for good software design.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The Open-Closed Principle
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Design for extension is unfortunately not something that just falls into your
    lap or magically materializes. No, you will have to explicitly take extensibility
    into account when designing software. We’ve already seen an example of a naive
    approach of serializing documents in [“Guideline 2: Design for Change”](#design_for_change).
    In that context, we used a `Document` base class with a pure virtual `serialize()`
    function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since `serialize()` is a pure virtual function, it needs to be implemented
    by all deriving classes, including the `PDF` class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So far, so good. The interesting question is: how do we implement the `serialize()`
    member function? One requirement is that at a later point in time we are able
    to convert the bytes back into a `PDF` instance (we want to deserialize bytes
    back to a PDF). For that purpose, it is essential to store the information that
    the bytes represent. In [“Guideline 2: Design for Change”](#design_for_change),
    we accomplished this with an enumeration:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This enumeration can now be used by all derived classes to put the type of
    the document at the beginning of the byte stream. This way, during deserialization,
    it’s easy to detect which kind of document is stored. Sadly, this design choice
    turns out to be an unfortunate decision. With that enumeration, we have accidentally
    coupled all kinds of document: the `PDF` class knows about the Word format. And
    of course the corresponding `Word` class would know about the PDF format. Yes,
    you are correct—they don’t know about the implementation details, but they are
    still aware of each other.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This coupling situation is illustrated in [Figure 1-5](#fig_ocp_strong_coupling).
    From an architectural point of view, the `DocumentType` enumeration resides on
    the same level as the `PDF` and `Word` classes. Both types of documents use (and
    thus depend on) the `DocumentType` enumeration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![cpsd 0105](assets/cpsd_0105.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Figure 1-5\. Artificial coupling of different document types via the `DocumentType`
    enumeration.
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The problem with this becomes obvious if we try to extend the functionality.
    Next to PDF and Word, we now also want to support a plain XML format. Ideally,
    all we should have to do is add the `XML` class as deriving from the `Document`
    class. But, unfortunately, we also have to adapt the `DocumentType` enumeration:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This change will at least cause all the other document types (PDF, Word, etc.)
    to recompile. Now you may just shrug your shoulders and think, “Oh well! It just
    needs to recompile.” Well, note that I said *at least*. In the worst case, this
    design has significantly limited others to extend the code—i.e., to add new kinds
    of documents—because not everyone is able to extend the `DocumentType` enumeration.
    No, this kind of coupling just doesn’t feel right: `PDF` and `Word` should be
    entirely unaware of the new `XML` format. They shouldn’t see or feel a thing,
    not even a recompilation.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The problem in this example can be explained as a violation of the Open-Closed
    Principle (OCP). The OCP is the second of the SOLID principles. It advises us
    to design software such that it is easy to make the necessary extensions:^([37](ch01.xhtml#idm45043121676880))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Software artifacts (classes, modules, functions, etc.) should be open for extension,
    but closed for modification.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The OCP tells us that we should be able to extend our software (open for extension).
    However, the extension should be easy and, in the best case, possible by just
    adding new code. In other words, we shouldn’t have to modify existing code (closed
    for modification).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, the extension should be easy: we should only have to add the new
    derived class `XML`. This new class alone would not require any modifications
    in any other piece of code. Unfortunately, the `serialize()` function artificially
    couples the different kinds of documents and requires a modification of the `DocumentType`
    enumeration. This modification, in turn, has an impact on the other types of `Document`,
    which is exactly what the OCP advises against.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we’ve already seen a solution for how to achieve that for the `Document`
    example. In this case, the right thing to do is to separate concerns (see [Figure 1-6](#fig_ocp_weak_coupling)).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: By separating concerns, by grouping the things that truly belong together, the
    accidental coupling between different kinds of documents is gone. All code dealing
    with serialization is now properly grouped inside the `Serialization` component,
    which can logically reside on another level of the architecture. `Serialization`
    depends on all types of documents (PDF, Word, XML, etc.), but none of the document
    types depend on `Serialization`. In addition, none of the documents are aware
    of any other type of document (as it should be).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![cpsd 0106](assets/cpsd_0106.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Figure 1-6\. Separation of concerns resolves the violation of the OCP
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: “Wait a second!” you say. “In the code for the serialization, we still need
    the enumeration, don’t we? How else would I store the information about what the
    stored bytes represent?” I’m glad you’re making this observation. Yes, inside
    the `Serialization` component we will still (very likely) need something like
    the `DocumentType` enumeration. However, by separating concerns, we have properly
    resolved this dependency problem. None of the different types of documents depends
    on the `DocumentType` enumeration anymore. All dependency arrows now go from the
    low level (the `Serialization` component) to the high level (`PDF` and `Word`).
    And that property is essential for a proper, good architecture.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: “But what about adding a new type of document? Doesn’t that require a modification
    in the `Serialization` component?” Again, you are absolutely correct. Still, this
    is not a violation of OCP, which advises that we should not have to modify existing
    code on the same architectural level or on higher levels. However, there is no
    way you can control or prevent modifications on the lower levels. `Serialization`
    *must* depend on all types of documents and therefore *must* be adapted for every
    new type of document. For that reason, `Serialization` must reside on a lower
    level (think *depending* level) of our architecture.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'As also discussed in [“Guideline 2: Design for Change”](#design_for_change),
    the solution in this example is the separation of concerns. Thus, it appears as
    if the real solution is to adhere to the SRP. For that reason, there are some
    critical voices that don’t consider the OCP a separate principle but the same
    as the SRP. I admit that I understand this reasoning. Very often the separation
    of concerns already leads to the desired extensibility. It’s something we will
    experience multiple times throughout this book, in particular when we talk about
    design patterns. Thus, it stands to reason that SRP and OCP are related or even
    the same.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, in this example we have seen that there are some specific,
    architectural considerations about the OCP that we didn’t take into account while
    talking about the SRP. Also, as we will experience in [“Guideline 15: Design for
    the Addition of Types or Operations”](ch04.xhtml#design_for_the_addition_of_types_or_operations),
    we will often have to make explicit decisions about what we want to extend and
    how we want to extend it. That decision can significantly influence how we apply
    the SRP and the way we design our software. Therefore, the OCP seems to be more
    about the awareness of extensions and conscious decisions about extensions than
    the SRP. As such, it is perhaps a little more than just an afterthought of the
    SRP. Or perhaps it just depends.^([38](ch01.xhtml#idm45043121655248))'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Either way, this example indisputably demonstrates that extensibility should
    be explicitly considered during software design, and that the desire for extending
    our software in a specific way is an excellent indication for the need to separate
    concerns. It is important to understand how software will be extended, to identify
    such *customization points*, and to design so that this kind of extension can
    be performed easily.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Compile-Time Extensibility
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Document` example may give the impression that all of these design considerations
    apply to runtime polymorphism. No, absolutely not: the same considerations and
    the same arguments also apply to compile-time problems. To illustrate this, I
    now reach for a couple of examples from the Standard Library. Of course, it is
    of utmost interest that you’re able to extend the Standard Library. Yes, you’re
    supposed to *use* the Standard Library, but you are also encouraged to build on
    it and add your own pieces of functionality. For that reason, the Standard Library
    is designed for extensibility. But interestingly, it isn’t using base classes
    for that purpose, but primarily builds on function overloading, templates, and
    (class) template specialization.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'An excellent example of extension by function overloading is the `std::swap()`
    algorithm. Since C++11, `std::swap()` has been defined in this way:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Due to the fact that `std::swap()` is defined as a function template, you can
    use it for any type: fundamental types like `int` and `double`, Standard Library
    types like `std::string`, and, of course, your own types. However, there may be
    some types that require special attention, some types that cannot or should not
    be swapped by means of `std::swap()` (for instance, because they cannot be efficiently
    moved) but could still be swapped efficiently by different means. But still, it’s
    expected that value types can be swapped, as it is also expressed by [Core Guideline
    C.83](https://oreil.ly/Peqhm):^([39](ch01.xhtml#idm45043121526144))'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: For value-like types, consider providing a `noexcept` swap function.
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In such a case, you can overload `std::swap()` for your own type:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If `swap()` is used correctly, this custom function will perform a special kind
    of swap operation on two instances of `CustomType`:^([40](ch01.xhtml#idm45043121480288))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Obviously, `std::swap()` is designed as a *customization point*, allowing you
    to plug in new custom types and behavior. The same is true of all algorithms in
    the Standard Library. Consider, for instance, `std::find()` and `std::find_if()`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By means of the template parameters, and implicitly, the corresponding concepts,
    `std::find()` and `std::find_if()` (just as all other algorithms) enable you to
    use your own (iterator) types to perform a search. In addition, `std::find_if()`
    allows you to customize how the comparison of elements is handled. Thus, these
    functions are definitely designed for extension and customization.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The last kind of *customization point* is template specialization. This approach
    is, for instance, used by the `std::hash` class template. Assuming the `CustomType`
    from the `std::swap()` example, we can specialize `std::hash` explicitly:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The design of `std::hash` puts you in a position to adapt its behavior for any
    custom type. Most noteworthy, you are not required to modify any existing code;
    it’s enough to provide this separate specialization to adapt to special requirements.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Almost the entire Standard Library is designed for extension and customization.
    This shouldn’t come as a surprise, however, because the Standard Library is supposed
    to represent one of the highest levels in your architecture. Thus, the Standard
    Library cannot depend on anything in your code, but you depend entirely on the
    Standard Library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Premature Design for Extension
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++ Standard Library is a great example of designing for extension. Hopefully
    it gives you a feeling for how important extensibility really is. However, although
    extensibility is important, this doesn’t mean that you should automatically, without
    reflection, reach for either base classes or templates for every possible implementation
    detail just to guarantee extensibility in the future. Just as you shouldn’t prematurely
    separate concerns, you should also not prematurely design for extension. Of course,
    if you have a good idea about how your code will evolve, then by all means, go
    ahead and design it accordingly. However, remember the YAGNI principle: if you
    do not know how the code will evolve, then it may be wise to wait, instead of
    anticipating an extension that will never happen. Perhaps the next extension will
    give you an idea about future extensions, which puts you in a position to refactor
    the code such that subsequent extensions are easy. Otherwise you might run into
    the problem that favoring one kind of extension makes other kinds of extensions
    much more difficult (see, for instance, [“Guideline 15: Design for the Addition
    of Types or Operations”](ch04.xhtml#design_for_the_addition_of_types_or_operations)).
    That is something you should avoid, if possible.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: In summary, designing for extension is an important part of design for change.
    Therefore, explicitly keep an eye out for pieces of functionality that are expected
    to be extended and design the code so that extension is easy.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch01.xhtml#idm45043124162128-marker)) But of course you would never even
    try to print the current C++ standard. You would either use a PDF of the [official
    C++ standard](https://oreil.ly/bZUDd) or use the [current working draft](https://oreil.ly/r46ta).
    For most of your daily work, however, you might want to refer to [the C++ reference
    site](https://oreil.ly/z0tKS).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch01.xhtml#idm45043137738976-marker)) Unfortunately, I can’t present any
    numbers, as I can hardly say that I have a complete overview of the vast realm
    of C++. On the contrary, I might not even have a complete overview of the sources
    I’m aware of! So please consider this as my personal impression and the way I
    perceive the C++ community. You may have a different impression.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch01.xhtml#idm45043125488704-marker)) Whether or not the code modification
    is risky may very much depend on your test coverage. A good test coverage may
    actually absorb some of the damage bad software design may cause.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch01.xhtml#idm45043123493296-marker)) Kent Beck, *Test-Driven Development:
    By Example* (Addison-Wesley, 2002).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch01.xhtml#idm45043126004560-marker)) Robert C. Martin, *Clean Architecture*
    (Addison-Wesley, 2017).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch01.xhtml#idm45043124440192-marker)) These are indeed my own words, as
    there is no single, common definition of software design. Consequently, you may
    have your own definition of what software design entails and that is perfectly
    fine. However, note that this book, including the discussion of design patterns,
    is based on my definition.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '^([7](ch01.xhtml#idm45043124165840-marker)) Just to be clear: computer science
    is a science (it’s in the name). Software *engineering* appears to be a hybrid
    form of science, craft, and art. And one aspect of the latter is software *design*.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch01.xhtml#idm45043123335424-marker)) With this metaphor, I’m not trying
    to imply that architects for buildings work at the construction site all day.
    Very likely, such an architect spends as much time in a comfy chair and in front
    of a computer as people like you and me. But I think you get the point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '^([9](ch01.xhtml#idm45043130422608-marker)) Substitution Failure Is Not An
    Error (SFINAE) is a basic template mechanism commonly used as a substitute for
    C++20 concepts to constrain templates. For an explanation of SFINAE and `std::enable_if`
    in particular, refer to your favorite textbook about C++ templates. If you don’t
    have any, a great choice is the C++ template bible: David Vandevoorde, Nicolai
    Josuttis, and Douglas Gregor’s *C++ Templates: The Complete Guide* (Addison-Wesley).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '^([10](ch01.xhtml#idm45043124605168-marker)) For a lot more information on
    physical and logical dependency management, see John Lakos’s “dam” book, *Large-Scale
    C++ Software Development: Process and Architecture* (Addison-Wesley).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch01.xhtml#idm45043123295968-marker)) Martin Fowler, “Who Needs an Architect?”
    *IEEE Software*, 20, no. 5 (2003), 11–13, [*https://doi.org/10.1109/MS.2003.1231144*](https://doi.org/10.1109/MS.2003.1231144).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '^([12](ch01.xhtml#idm45043124008192-marker)) A very good introduction to microservices
    can be found in Sam Newman’s book [*Building Microservices: Designing Fine-Grained
    Systems*](https://learning.oreilly.com/library/view/building-microservices-2nd/9781492034018/),
    2nd ed. (O’Reilly).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '^([13](ch01.xhtml#idm45043130766672-marker)) Mark Richards and Neal Ford, [*Fundamentals
    of Software Architecture: An Engineering Approach*](https://learning.oreilly.com/library/view/fundamentals-of-software/9781492043447/)
    (O’Reilly, 2020).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch01.xhtml#idm45043131054400-marker)) The term *implementation pattern*
    was first used in Kent Beck’s book *Implementation Patterns* (Addison-Wesley).
    In this book, I’m using that term to provide a clear distinction from the term
    *design pattern*, since the term *idiom* may refer to a pattern on either the
    Software Design level or the Implementation Details level. I will use the term
    consistently to refer to commonly used solutions on the Implementation Details
    level.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '^([15](ch01.xhtml#idm45043125635792-marker)) Second-favorite after this one,
    of course. If this is your only book, then you might refer to the classic *Effective
    C++: 55 Specific Ways to Improve Your Programs and Designs*, 3rd ed., by Scott
    Meyers (Addison-Wesley).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '^([16](ch01.xhtml#idm45043123823504-marker)) The Template Method and Bridge
    design patterns are 2 of the 23 classic design patterns introduced in the so-called
    Gang of Four (GoF) book by Erich Gamma et al., *Design Patterns: Elements of Reusable
    Object-Oriented Software*. I won’t go into detail about the Template Method in
    this book, but you’ll find good explanations in various textbooks, including the
    GoF book itself. I will, however, explain the Bridge design pattern in [“Guideline
    28: Build Bridges to Remove Physical Dependencies”](ch07.xhtml#build_bridges_to_remove_physical_dependencies).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch01.xhtml#idm45043123657936-marker)) Bjarne Stroustrup, *The C++ Programming
    Language*, 3rd ed. (Addison-Wesley, 2000).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '^([18](ch01.xhtml#idm45043123631872-marker)) Kudos to John Lakos, who argues
    similarly and uses C++98 in his book, *Large-Scale C++ Software Development: Process
    and Architecture* (Addison-Wesley).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: ^([19](ch01.xhtml#idm45043124608352-marker)) Yes, Ben and Jason, you have read
    correctly, I will not `constexpr` ALL the things. See Ben Deane and Jason Turner,
    [“constexpr ALL the things”](https://oreil.ly/Pazfb), CppCon 2017.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: ^([20](ch01.xhtml#idm45043124044208-marker)) Michael Feathers, *Working Effectively
    with Legacy Code* (Addison-Wesley, 2013).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '^([21](ch01.xhtml#idm45043123834288-marker)) David Thomas and Andrew Hunt,
    *The Pragmatic Programmer: Your Journey to Mastery*, 20th Anniversary Edition
    (Addison Wesley, 2019).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: ^([22](ch01.xhtml#idm45043123832000-marker)) Tom DeMarco, *Structured Analysis
    and System Specification* (Prentice Hall, 1979).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '^([23](ch01.xhtml#idm45043124286736-marker)) SOLID is an acronym of acronyms,
    an abbreviation of the five principles described in the next few guidelines: SRP,
    OCP, LSP, ISP, and DIP.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '^([24](ch01.xhtml#idm45043123403072-marker)) The first book on the SOLID principles
    was Robert C. Martin’s *Agile Software Development: Principles, Patterns, and
    Practices* (Pearson). A newer and much cheaper alternative is *Clean Architecture*,
    also from Robert C. Martin (Addison-Wesley).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: ^([25](ch01.xhtml#idm45043123603040-marker)) Don’t forget that the design decisions
    taken by that external library may impact your own design, which would obviously
    increase the coupling.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: ^([26](ch01.xhtml#idm45043124305408-marker)) That includes the classes that
    other people may have written, i.e., classes that you do not control. And no,
    the other people won’t be happy about the change. Thus, the change may be *really*
    difficult.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: ^([27](ch01.xhtml#idm45043128374128-marker)) An enumeration seems to be an obvious
    choice, but of course there are other options as well. In the end, we need an
    agreed-upon set of values that represent the different document formats in the
    byte representation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: ^([28](ch01.xhtml#idm45043129091136-marker)) You might be wondering about the
    explicit use of the `explicit` keyword for this constructor. Then you might also
    be aware that [Core Guideline C.46](https://oreil.ly/1DPsA) advises using `explicit`
    by default for single-argument constructors. This is really good and highly recommended
    advice, as it prevents unintentional, potentially undesirable conversions. While
    not as valuable, the same advice is also reasonable for all the other constructors,
    except for the copy and move constructors, which don’t perform a conversion. At
    least it doesn’t hurt.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '^([29](ch01.xhtml#idm45043128523184-marker)) You might realize I’ve picked
    the names of the three conferences I regularly attend: [CppCon](https://cppcon.org),
    [Meeting C++](http://meetingcpp.com), and [C++ on Sea](https://cpponsea.uk). There
    are many more C++ conferences, though. To give a few examples: [ACCU](https://accu.org/conf-main/main),
    [Core C++](https://corecpp.org), [pacific++](https://www.pacificplusplus.com),
    [CppNorth](https://cppnorth.ca), [emBO++](https://www.embo.io), and [CPPP](https://cppp.fr).
    Conferences are a great and fun way to stay up to date with C++. Make sure to
    check out [the Standard C++ Foundation home page](https://isocpp.org) for any
    upcoming conferences.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: ^([30](ch01.xhtml#idm45043128758896-marker)) Katerina Trajchevska, [“Becoming
    a Better Developer by Using the SOLID Design Principles”](https://oreil.ly/cwo8Y),
    Laracon EU, August 30–31, 2018.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '^([31](ch01.xhtml#idm45043123066176-marker)) Robert C. Martin, *Agile Software
    Development: Principles, Patterns, and Practices*.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '^([32](ch01.xhtml#idm45043122620688-marker)) If you don’t have a test suite
    in place, then you have work to do. Seriously. A very coherent reference to get
    started is Ben Saks’s talk on unit tests, [“Back to Basics: Unit Tests”](https://oreil.ly/VBo9X),
    from CppCon 2020\. A second, very good reference to wrap your mind around the
    whole topic of testing and test-driven development in particular is Jeff Langr’s
    book, [*Modern C{plus}{plus} Programming with Test-Driven Development*](https://learning.oreilly.com/library/view/modern-c-programming/9781941222423/)
    (O’Reilly).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: ^([33](ch01.xhtml#idm45043122618256-marker)) I know, “everyone agrees” is unfortunately
    far from reality. If you need proof that the seriousness of tests has not yet
    reached every project and every developer, take a look at [this issue](https://oreil.ly/NuEua)
    from the OpenFOAM issue tracker.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '^([34](ch01.xhtml#idm45043122277712-marker)) David Thomas and Andrew Hunt,
    *The Pragmatic Programmer: Your Journey to Mastery*.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: ^([35](ch01.xhtml#idm45043122228608-marker)) We may even have entered the scary
    realm of undefined behavior.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: ^([36](ch01.xhtml#idm45043121978352-marker)) You can find this compelling argument
    in item 23 of Scott Meyers’s *Effective C++*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: ^([37](ch01.xhtml#idm45043121676880-marker)) Bertrand Meyer, *Object-Oriented
    Software Construction*, 2nd ed. (Pearson, 2000).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: ^([38](ch01.xhtml#idm45043121655248-marker)) The answer “It depends!” will of
    course satisfy even the strongest critics of the OCP.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: ^([39](ch01.xhtml#idm45043121526144-marker)) The [C++ Core Guidelines](https://oreil.ly/PGze4)
    are a community effort to collect and agree on a set of guidelines for writing
    good C++ code. They best represent the common sense of what idiomatic C++ is.
    You can find these guidelines on [GitHub](https://oreil.ly/PGze4).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: ^([40](ch01.xhtml#idm45043121480288-marker)) The abbreviation ADL refers to
    Argument Dependent Lookup. See the [CppReference](https://oreil.ly/lRSZD) or my
    [CppCon 2020 talk](https://oreil.ly/3f7Zo) for an introduction.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
