["```cpp\n//#include <some_json_library.h>  // Potential physical dependency \nclass Document\n{\n public:\n   // ...\n   virtual ~Document() = default;\n\n   virtual void exportToJSON( /*...*/ ) const = 0;  ![1](assets/1.png)\n   virtual void serialize( ByteStream&, /*...*/ ) const = 0;  ![2](assets/2.png)\n   // ... };\n\n```", "```cpp\nenum class DocumentType\n{\n   pdf,\n   word,\n   // ... Potentially many more document types\n};\n```", "```cpp\nclass Document\n{\n public:\n   // ...\n   virtual ~Document() = default;\n\n   // No more 'exportToJSON()' and 'serialize()' functions.\n   // Only the very basic document operations, that do not\n   // cause strong coupling, remain.\n   // ...\n};\n```", "```cpp\n//---- <Money.h> ----------------\n\nclass Money { /*...*/ };\n\nMoney operator*( Money money, double factor );\nMoney operator+( Money lhs, Money rhs );\n\n//---- <Item.h> ----------------\n\n#include <Money.h>\n\nclass Item\n{\n public:\n   virtual ~Item() = default;\n   virtual Money price() const = 0;\n};\n```", "```cpp\n//---- <CppBook.h> ---------------- \n#include <Item.h>\n#include <Money.h>\n#include <string>\n\nclass CppBook : public Item\n{\n public:\n   explicit CppBook( std::string title, std::string author, Money price )  ![3](assets/3.png)\n      : title_( std::move(title) )\n      , author_( std::move(author) )\n      , priceWithTax_( price * 1.15 )  // 15% tax rate\n   {}\n\n   std::string const& title() const { return title_; }     ![4](assets/4.png)\n   std::string const& author() const { return author_; }   ![5](assets/5.png)\n\n   Money price() const override { return priceWithTax_; }  ![6](assets/6.png)\n\n private:\n   std::string title_;\n   std::string author_;\n   Money priceWithTax_;\n};\n\n```", "```cpp\n//---- <ConferenceTicket.h> ---------------- \n#include <Item.h>\n#include <Money.h>\n#include <string>\n\nclass ConferenceTicket : public Item\n{\n public:\n   explicit ConferenceTicket( std::string name, Money price )  ![7](assets/7.png)\n      : name_( std::move(name) )\n      , priceWithTax_( price * 1.15 )  // 15% tax rate\n   {}\n\n   std::string const& name() const { return name_; }\n\n   Money price() const override { return priceWithTax_; }\n\n private:\n   std::string name_;\n   Money priceWithTax_;\n};\n\n```", "```cpp\n#include <CppBook.h>\n#include <ConferenceTicket.h>\n#include <algorithm>\n#include <cstdlib>\n#include <memory>\n#include <vector>\n\nint main()\n{\n   std::vector<std::unique_ptr<Item>> items{};\n\n   items.emplace_back( std::make_unique<CppBook>(\"Effective C++\", 19.99) );\n   items.emplace_back( std::make_unique<CppBook>(\"C++ Templates\", 49.99) );\n   items.emplace_back( std::make_unique<ConferenceTicket>(\"CppCon\", 999.0) );\n   items.emplace_back( std::make_unique<ConferenceTicket>(\"Meeting C++\", 699.0) );\n   items.emplace_back( std::make_unique<ConferenceTicket>(\"C++ on Sea\", 499.0) );\n\n   Money const total_price =\n      std::accumulate( begin(items), end(items), Money{},\n         []( Money accu, auto const& item ){\n            return accu + item->price();\n         } );\n\n   // ...\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\nclass Document\n{\n public:\n   // ...\n   virtual ~Document() = default;\n\n   virtual void exportToJSON( /*...*/ ) const = 0;\n   virtual void serialize( ByteStream& bs, /*...*/ ) const = 0;\n   // ...\n};\n```", "```cpp\nvoid exportDocument( Document const& doc )\n{\n   // ...\n   doc.exportToJSON( /* pass necessary arguments */ );\n   // ...\n}\n```", "```cpp\nclass JSONExportable\n{\n public:\n   // ...\n   virtual ~JSONExportable() = default;\n\n   virtual void exportToJSON( /*...*/ ) const = 0;\n   // ...\n};\n\nclass Serializable\n{\n public:\n   // ...\n   virtual ~Serializable() = default;\n\n   virtual void serialize( ByteStream& bs, /*...*/ ) const = 0;\n   // ...\n};\n\nclass Document\n   : public JSONExportable\n   , public Serializable\n{\n public:\n   // ...\n};\n```", "```cpp\nvoid exportDocument( JSONExportable const& exportable )\n{\n   // ...\n   exportable.exportToJSON( /* pass necessary arguments */ );\n   // ...\n}\n```", "```cpp\ntemplate< typename InputIt, typename OutputIt >\nOutputIt copy( InputIt first, InputIt last, OutputIt d_first );\n```", "```cpp\ntemplate< std::input_iterator InputIt, std::output_iterator OutputIt >\nOutputIt copy( InputIt first, InputIt last, OutputIt d_first );\n```", "```cpp\ntemplate< std::forward_iterator ForwardIt, std::forward_iterator ForwardIt >\nOutputIt copy( ForwardIt first, ForwardIt last, ForwardIt d_first );\n```", "```cpp\nclass Widget\n{\n   // ...\n private:\n   void updateCollection( /* some arguments needed to update the collection */ );\n\n   std::vector<Blob> blobs_;\n   /* Potentially other data members */\n};\n```", "```cpp\nclass Widget\n{\n public:\n   // ...\n   void addBlob( Blob const& blob, /*...*/ )\n   {\n      // ...\n      updateCollection( /*...*/ );\n      // ...\n   }\n\n private:\n   void updateCollection( /* some arguments needed to update the collection */ );\n\n   std::vector<Blob> blobs_;\n   /* Potentially other data members */\n};\n```", "```cpp\nclass Widget\n{\n   // ...\n private:\n   friend class TestWidget;\n\n   void updateCollection( /* some arguments needed to update the collection */ );\n\n   std::vector<Blob> blobs_;\n   /* Potentially other data members */\n};\n```", "```cpp\nclass Widget\n{\n   // ...\n protected:\n   void updateCollection( /* some arguments needed to update the collection */ );\n\n   std::vector<Blob> blobs_;\n   /* Potentially other data members */\n};\n\nclass TestWidget : private Widget\n{\n   // ...\n};\n```", "```cpp\n#define private public\n\nclass Widget\n{\n   // ...\n private:\n   void updateCollection( /* some arguments needed to update the collection */ );\n\n   std::vector<Blob> blobs_;\n   /* Potentially other data members */\n};\n```", "```cpp\nvoid updateCollection( std::vector<Blob>& blobs\n                     , /* some arguments needed to update the collection */ );\n\nclass Widget\n{\n   // ...\n private:\n   std::vector<Blob> blobs_;\n   /* Potentially other data members */\n};\n```", "```cpp\nnamespace widgetDetails {\n\nclass BlobCollection\n{\n public:\n   void updateCollection( /* some arguments needed to update the collection */ );\n\n private:\n   std::vector<Blob> blobs_;\n};\n\n} // namespace widgetDetails\n\nclass Widget\n{\n   // ...\n private:\n   widgetDetails::BlobCollection blobs_;\n   /* Other data members */\n};\n```", "```cpp\nclass Document\n{\n public:\n   // ...\n   virtual ~Document() = default;\n\n   virtual void serialize( ByteStream& bs, /*...*/ ) const = 0;\n   // ...\n};\n```", "```cpp\nclass PDF : public Document\n{\n public:\n   // ...\n   void serialize( ByteStream& bs, /*...*/ ) const override;\n   // ...\n};\n```", "```cpp\nenum class DocumentType\n{\n   pdf,\n   word,\n   // ... Potentially many more document types\n};\n```", "```cpp\nenum class DocumentType\n{\n   pdf,\n   word,\n   xml,   // The new type of document\n   // ... Potentially many more document types\n};\n```", "```cpp\nnamespace std {\n\ntemplate< typename T >\nvoid swap( T& a, T& b )\n{\n   T tmp( std::move(a) );\n   a = std::move(b);\n   b = std::move(tmp);\n}\n\n} // namespace std\n```", "```cpp\nnamespace custom {\n\nclass CustomType\n{\n   /* Implementation that requires a special form of swap */\n};\n\nvoid swap( CustomType& a, CustomType& b )\n{\n   /* Special implementation for swapping two instances of type 'CustomType' */\n}\n\n} // namespace custom\n```", "```cpp\ntemplate< typename T >\nvoid some_function( T& value )\n{\n   // ...\n   T tmp( /*...*/ );\n\n   using std::swap;     // Enable the compiler to consider std::swap for the\n                        // subsequent call\n   swap( tmp, value );  // Swap the two values; thanks to the unqualified call\n                        // and thanks to ADL this would call 'custom::swap()'\n   // ...               // in case 'T' is 'CustomType'\n}\n```", "```cpp\ntemplate< typename InputIt, typename T >\nconstexpr InputIt find( InputIt first, InputIt last, T const& value );\n\ntemplate< typename InputIt, typename UnaryPredicate >\nconstexpr InputIt find_if( InputIt first, InputIt last, UnaryPredicate p );\n```", "```cpp\ntemplate<>\nstruct std::hash<CustomType>\n{\n   std::size_t operator()( CustomType const& v ) const noexcept\n   {\n      return /*...*/;\n   }\n};\n```"]