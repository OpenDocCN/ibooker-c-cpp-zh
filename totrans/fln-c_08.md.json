["```cpp\nfor (i=0; i<MAX_ARRAY_SIZE; i++)\n{\n  doSomethingWith(my_array[i]);\n}\n```", "```cpp\nstruct ACCOUNT\n{\n  char loginname[MAX_NAME_LENGTH];\n  char password[MAX_PWD_LENGTH];\n};\nstruct ACCOUNT accountData[MAX_USERS];\n```", "```cpp\nvoid accessData()\n{\n  char* loginname;\n\n  loginname = accountData[0].loginname;\n  /* do something with loginname */\n\n  loginname = accountData[1].loginname;\n  /* do something with loginname */\n}\n```", "```cpp\nvoid* element;\n\nelement = getElement(1);\n/* operate on element 1 */\n\nelement = getElement(2);\n/* operate on element 2 */\n```", "```cpp\n#define MAX_ELEMENTS 42\n\n/* Retrieve one single element identified by the provided 'index' */\nvoid* getElement(int index);\n```", "```cpp\nchar* getLoginName(int index)\n{\n  return accountData[index].loginname;\n}\n```", "```cpp\nbool anyoneWithX()\n{\n  int i;\n  for(i=0; i<MAX_USERS; i++)\n  {\n    char* loginName = getLoginName(i);\n    if(loginName[0] == 'X')\n    {\n      return true;\n    }\n  }\n  return false;\n}\n```", "```cpp\nstruct ACCOUNT_NODE\n{\n  char loginname[MAX_NAME_LENGTH];\n  char password[MAX_PWD_LENGTH];\n  struct ACCOUNT_NODE* next;\n};\n\nstruct ACCOUNT_NODE* accountList;\n\nstruct ACCOUNT_NODE* getFirst()\n{\n  return accountList;\n}\n\nstruct ACCOUNT_NODE* getNext(struct ACCOUNT_NODE* current)\n{\n  return current->next;\n}\n\nvoid accessData()\n{\n  struct ACCOUNT_NODE* account = getFirst();\n  char* loginname = account->loginname;\n  account = getNext(account);\n  loginname = account->loginname;\n  ...\n}\n```", "```cpp\nvoid* element;\nITERATOR* it = createIterator();\n\nwhile(element = getNext(it))\n{\n  /* operate on element */\n}\n\ndestroyIterator(it);\n```", "```cpp\n/* Creates an iterator and moves it to the first element */\nITERATOR* createIterator();\n\n/* Returns the element currently pointed to and sets the iterator to the\n next element. Returns NULL if the element does not exist. */\nvoid* getNext(ITERATOR* iterator);\n\n/* Cleans up an iterator created with the function createIterator() */\nvoid destroyIterator(ITERATOR* iterator),\n```", "```cpp\nstruct ITERATOR\n{\n  char buffer[MAX_NAME_LENGTH];\n  struct ACCOUNT_NODE* element;\n};\n\nstruct ITERATOR* createIterator()\n{\n  struct ITERATOR* iterator = malloc(sizeof(struct ITERATOR));\n  iterator->element = getFirst();\n  return iterator;\n}\n\nchar* getNextLoginName(struct ITERATOR* iterator)\n{\n  if(iterator->element != NULL)\n  {\n    strcpy(iterator->buffer, iterator->element->loginname);\n    iterator->element = getNext(iterator->element);\n    return iterator->buffer;\n  }\n  else\n  {\n    return NULL;\n  }\n}\n\nvoid destroyIterator(struct ITERATOR* iterator)\n{\n  free(iterator);\n}\n```", "```cpp\nbool anyoneWithX()\n{\n  char* loginName;\n  struct ITERATOR* iterator = createIterator();\n  while(loginName = getNextLoginName(iterator)) ![1](assets/1.png)\n  {\n    if(loginName[0] == 'X')\n    {\n      destroyIterator(iterator); ![2](assets/2.png)\n      return true;\n    }\n  }\n  destroyIterator(iterator); ![2](assets/2.png)\n  return false;\n}\n```", "```cpp\nvoid myCallback(void* element, void* arg)\n{\n  /* operate on element */\n}\n\nvoid doIteration()\n{\n  iterate(myCallback, NULL);\n}\n```", "```cpp\n/* Callback for the iteration to be implemented by the caller. */\ntypedef void (*FP_CALLBACK)(void* element, void* arg);\n\n/* Iterates over all elements and calls callback(element, arg)\n on each element. */\nvoid iterate(FP_CALLBACK callback, void* arg);\n```", "```cpp\ntypedef void (*FP_CALLBACK)(char* loginName, void* arg);\n\nvoid iterateLoginNames(FP_CALLBACK callback, void* arg)\n{\n  struct ACCOUNT_NODE* account = getFirst(accountList);\n  while(account != NULL)\n  {\n    callback(account->loginname, arg);\n    account = getNext(account);\n  }\n}\n```", "```cpp\nvoid findX(char* loginName, void* arg)\n{\n  bool* found = (bool*) arg;\n  if(loginName[0] == 'X')\n  {\n    *found = true;\n  }\n}\n\nvoid countY(char* loginName, void* arg)\n{\n  int* count = (int*) arg;\n  if(loginName[0] == 'Y')\n  {\n    (*count)++;\n  }\n}\n\nbool anyoneWithX()\n{\n  bool found=false;\n  iterateLoginNames(findX, &found); ![1](assets/1.png)\n  return found;\n}\n\nint numberOfUsersWithY()\n{\n  int count=0;\n  iterateLoginNames(countY, &count); ![1](assets/1.png)\n  return count;\n}\n```"]