<html><head></head><body>
<div id="sbo-rt-content"><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. The Art of Software Design" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_art_of_software_design">
<h1><span class="label">Chapter 1. </span>The Art of Software Design</h1>
<p>What<a data-primary="software design" data-secondary="basic guidelines for" data-type="indexterm" id="SDbasic01"/> is software design? And why should you care about it? In this chapter,
I will set the stage for this book on software design. I will explain software
design in general, help you understand why it is vitally important for the
success of a project, and why it is the one thing you should get right.
But you will also see that software design is complicated. Very complicated.
In fact, it is the most complicated part of software development. Therefore, I
will also explain several software design principles that will help
you to stay on the right path.</p>
<p>In <a data-type="xref" href="#understand_the_importance_of_software_design">“Guideline 1: Understand the Importance of 
<span class="keep-together">Software Design</span>”</a>, I will focus on the big
picture and explain that software is expected to change. Consequently,
software should be able to cope with change. However, that is much easier
said than done, since in reality, coupling and dependencies make our life as a
developer so much harder. That problem is addressed by software design. I will
introduce software design as the art of managing dependencies and abstractions—an essential part of software engineering.</p>
<p>In <a data-type="xref" href="#design_for_change">“Guideline 2: Design for Change”</a>, I will explicitly address coupling and dependencies
and help you understand how to design for change and how to make software more
adaptable. For that purpose, I will introduce both the <em>Single-Responsibility
Principle (SRP)</em> and the <em>Don’t Repeat Yourself (DRY)</em> principle, which help
you to achieve this goal.</p>
<p>In <a data-type="xref" href="#separate_interfaces_to_avoid_artificial_coupling">“Guideline 3: Separate Interfaces to Avoid 
<span class="keep-together">Artificial Coupling</span>”</a>, I will expand the
discussion about coupling and specifically address coupling via interfaces.
I will also introduce the <em>Interface Segregation Principle (ISP)</em> as a means
to reduce artificial coupling induced by interfaces.</p>
<p class="less_space pagebreak-before">In <a data-type="xref" href="#design_for_testability">“Guideline 4: Design for Testability”</a>, I will focus on testability issues that arise
as a result of artificial coupling. In particular, I will raise the question of
how to test a private member function and demonstrate that the one true solution
is a consequent application of separation of concerns.</p>
<p>In <a data-type="xref" href="#design_for_extension">“Guideline 5: Design for Extension”</a>, I will address an important kind of change:
extensions. Just as code should be easy to change, it should also be easy
to extend. I will give you an idea how to achieve that goal, and I will
demonstrate the value of the <em>Open-Closed Principle (OCP)</em>.</p>
<section data-pdf-bookmark="Guideline 1: Understand the Importance of &#10;Software Design" data-type="sect1"><div class="sect1" id="understand_the_importance_of_software_design">
<h1>Guideline 1: Understand the Importance of 
<span class="keep-together">Software Design</span></h1>
<p>If I were to ask you which code properties are most important to you,
you would, after some thinking, probably say things like readability, testability, maintainability, extensibility, reusability, and scalability.
And I would completely agree. But now, if I were to ask you how to achieve
these goals, there is a good chance that you would start to list some
C++ features: RAII, algorithms, lambdas, modules, and so on.</p>
<section data-pdf-bookmark="Features Are Not Software Design" data-type="sect2"><div class="sect2" id="idm45043124281808">
<h2>Features Are Not Software Design</h2>
<p>Yes, C++ offers a lot of features. A lot! Approximately<a data-primary="software design" data-secondary="basic guidelines for" data-tertiary="features versus design" data-type="indexterm" id="idm45043124280512"/><a data-primary="features" data-secondary="design versus features" data-type="indexterm" id="idm45043127351008"/> half of the
almost 2,000 pages of the printed C++ standard are devoted to explaining
language mechanics and features.<sup><a data-type="noteref" href="ch01.xhtml#idm45043124162128" id="idm45043124162128-marker">1</a></sup>
And since the release of C++11, there is the explicit promise that there
will be more: every three years, the C++ standardization committee blesses
us with a new 
<span class="keep-together">C++</span> standard that ships with additional, brand-new features.
Knowing that, it doesn’t come as a big surprise that in the C++
community there’s a very strong emphasis on features and language mechanics.
Most books, talks, and blogs are focused on features, new libraries, and language
details.<sup><a data-type="noteref" href="ch01.xhtml#idm45043137738976" id="idm45043137738976-marker">2</a></sup></p>
<p>It almost feels as if features are the most important thing about programming
in 
<span class="keep-together">C++</span>, and crucial for the success of a C++ project. But
honestly, they are not. Neither the knowledge about all the features nor the choice
of the C++ standard is responsible for the success of a project. No,
you should not expect features to save your project. On the contrary: a project
can be very successful even if it uses an older C++ standard, and even
if only a subset of the available features are used. Leaving aside the human aspects
of software development, much more important for the question about success or
failure of a project is the<a data-primary="change, designing for" data-secondary="importance of code structure in" data-type="indexterm" id="idm45043123611424"/> overall <em>structure</em> of the software. It is the structure
that is ultimately responsible for maintainability: how easy is it to change code, extend code, and test code? Without the ability to easily change code, add
new functionality, and have confidence in its correctness due to tests, a project
is at the end of its lifecycle. The structure is also responsible for the
scalability of a project: how large can the project grow before it collapses
under its own weight? How many people can work on realizing the vision of the
project before they step on one another’s toes?</p>
<p>The overall structure is the design of a project. The design plays a much more
central role in the success of a project than any feature could ever do. Good
software is not primarily about the proper use of any feature; rather, it is about
solid architecture and design. Good software design can tolerate some bad
implementation decisions, but bad software design cannot be saved by the heroic use of features (old or new) alone.</p>
</div></section>
<section data-pdf-bookmark="Software Design: The Art of Managing Dependencies &#10;and Abstractions" data-type="sect2"><div class="sect2" id="idm45043138320960">
<h2>Software Design: The Art of Managing Dependencies 
<span class="keep-together">and Abstractions</span></h2>
<p>Why<a data-primary="dependencies" data-secondary="basic guidelines for managing" data-type="indexterm" id="Dbasicguide01"/><a data-primary="software design" data-secondary="basic guidelines for" data-tertiary="dependencies and abstractions" data-type="indexterm" id="idm45043123848560"/><a data-primary="abstractions" data-secondary="basic guidelines for managing" data-type="indexterm" id="ABguide01"/> is software design so important for the quality of a project? Well, assuming
everything works perfectly right now, as long as nothing changes in your software
and as long as nothing needs to be added, you are fine.
However, that state will likely not last for long. It’s reasonable to expect
that something will change. After all, the one constant in software
development is change. Change is the driving force behind all our problems (and
also most of our solutions). That’s why software is called <em>soft</em>ware: because
in comparison to hardware, it is soft and malleable. Yes, <em>soft</em>ware is
expected to be easily adapted to the ever-changing requirements. But as you may
know, in reality this expectation might not always be true.</p>
<p>To illustrate this point, let’s imagine that you select an issue from
your issue tracking system that the team has rated with an expected effort of 2.
Whatever a 2 means in your own project(s), it most certainly does not sound
like a big task, so you are confident that this will be done quickly.
In good faith, you first take some time to understand
what is expected, and then you start by making a change in some entity <code>A</code>.
Because of immediate feedback from your tests (you are lucky to have tests!), you
are quickly reminded that you also have to address the issue in entity <code>B</code>.
That is surprising! You did not expect that <code>B</code> was involved at all. Still, you go
ahead and adapt <code>B</code> anyway. However, again unexpectedly, the nightly build reveals
that this causes <code>C</code> and <code>D</code> to stop working. Before continuing, you now investigate
the issue a little deeper and find that the roots of the issue are spread
through a large portion of the codebase. The small, initially innocent-looking task has evolved into a large, potentially risky code modification.<sup><a data-type="noteref" href="ch01.xhtml#idm45043125488704" id="idm45043125488704-marker">3</a></sup> Your confidence in resolving the issue quickly is gone. And
your plans for the rest of the week are as well.</p>
<p>Maybe this story sounds familiar to you. Maybe you can even contribute a few
war stories of your own. Indeed, most developers have similar experiences. And
most of these experiences have the same source of trouble. Usually the problem can be
reduced to a single word: <em>dependencies</em>. As Kent Beck has expressed in his book on
test-driven development:<sup><a data-type="noteref" href="ch01.xhtml#idm45043123493296" id="idm45043123493296-marker">4</a></sup></p>
<blockquote>
<p>Dependency is the key problem in software development at all scales.</p></blockquote>
<p>Dependencies are the bane of every software developer’s existence. “But of course there
are dependencies,” you argue. “There will always be dependencies. How else should
different pieces of code work together?” And of course, you are correct. Different
pieces of code need to work together, and this interaction will always create some
form of coupling. However, while there are necessary, unavoidable dependencies,
there are also artificial dependencies that we
accidentally introduce because we lack an understanding of the underlying problem,
don’t have a clear idea of the bigger picture, or just don’t
pay enough attention. Needless to say, these artificial dependencies hurt. They make
it harder to understand our software, change software, add new features, and write tests.
Therefore, one of the primary tasks, if not <em>the</em> primary task, of a software
developer is to keep artificial dependencies at a minimum.</p>
<p>This minimization of dependencies is the goal of software architecture and design.
To state it in the words of Robert C. Martin:<sup><a data-type="noteref" href="ch01.xhtml#idm45043126004560" id="idm45043126004560-marker">5</a></sup></p>
<blockquote>
<p>The goal of software architecture is to minimize the human resources required to
build and maintain the required system.</p></blockquote>
<p>Architecture and design are the tools needed to minimize the work effort in any project.
They deal with dependencies and reduce the complexity via abstractions. In my own words:<sup><a data-type="noteref" href="ch01.xhtml#idm45043124440192" id="idm45043124440192-marker">6</a></sup></p>
<blockquote>
<p>Software design<a data-primary="software design" data-secondary="definition of" data-type="indexterm" id="idm45043124167488"/> is the art of managing interdependencies between software components.
It aims at minimizing artificial (technical) dependencies and introduces the necessary
abstractions and compromises.</p></blockquote>
<p>Yes, software design is an art. It’s not a science, and it doesn’t come with a set
of easy and clear answers.<sup><a data-type="noteref" href="ch01.xhtml#idm45043124165840" id="idm45043124165840-marker">7</a></sup> Too often the
big picture of design eludes us, and we are overwhelmed by the complex interdependencies
of software entities. But we are trying to deal with this complexity and reduce it by
introducing the right kind of abstractions. This way, we keep the level of detail at
a reasonable level. However, too often individual developers on the team may have a
different idea of the architecture and the design. We might not be
able to implement our own vision of a design and be forced to make
compromises in order to move forward.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The term <em>abstraction</em> is used in different contexts. It’s used for the organization
of functionality and data items into data types and functions. But it’s also used
to describe the modeling of common behavior and the representation of a set of requirements
and expectations. In this book on software design, I will primarily use the term for the
latter (see in particular <a data-type="xref" href="ch02.xhtml#the_art_of_building_abstractions">Chapter 2</a>).</p>
</div>
<p>Note that the words <em>architecture</em> and <em>design</em> can be interchanged in the preceding quotes, since they’re very similar and share the same goals. Yet they aren’t the same.
The similarities, but also differences, become clear if you take a look at the three
levels of software development.<a data-primary="" data-startref="ABguide01" data-type="indexterm" id="idm45043131321936"/><a data-primary="" data-startref="Dbasicguide01" data-type="indexterm" id="idm45043131320960"/></p>
</div></section>
<section data-pdf-bookmark="The Three Levels of Software Development" data-type="sect2"><div class="sect2" id="idm45043138320464">
<h2>The Three Levels of Software Development</h2>
<p><em>Software Architecture</em> and <em>Software Design</em> are<a data-primary="Software Architecture level" data-type="indexterm" id="idm45043124280032"/><a data-primary="software development, levels of" data-type="indexterm" id="SDlevels01"/><a data-primary="software design" data-secondary="basic guidelines for" data-tertiary="development levels" data-type="indexterm" id="idm45043124278416"/><a data-primary="development levels" data-type="indexterm" id="devlev01"/><a data-primary="Implementation Details level" data-type="indexterm" id="idm45043123828864"/> just two of the three levels of
software development. They are complemented by the level of <em>Implementation
Details</em>. <a data-type="xref" href="#fig_level_overview">Figure 1-1</a> gives an overview of these three levels.</p>
<p>To give you a feeling for these three levels, let’s start with a real-world
example of the relationship among architecture, design, and implementation
details. Consider yourself to be in the role of an architect.
And no, please don’t picture yourself in a comfy chair in front of a computer
with a hot coffee next to you, but picture yourself outside at a construction
site. Yes, I’m talking about an architect for buildings.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123335424" id="idm45043123335424-marker">8</a></sup> As such an architect, you would be in charge of
all the important properties of a house: its integration into the neighborhood,
its structural integrity, the
arrangement of rooms, plumbing, etc. You would also take care of a pleasing appearance
and functional qualities—perhaps a large living room, easy access between
the kitchen and the dining room, and so on. In other words, you would be taking care
of the overall 
<span class="keep-together">architecture</span>, the things that would be hard to change later,
but you would also deal with the smaller design aspects concerning the building. However, it’s hard to tell the difference between the two: the boundary between architecture
and design appears to be fluid and is not clearly separated.</p>
<figure><div class="figure" id="fig_level_overview">
<img alt="cpsd 0101" height="621" src="assets/cpsd_0101.png" width="1442"/>
<h6><span class="label">Figure 1-1. </span>The three levels of software development: <em>Software Architecture</em>, <em>Software Design</em>, and <em>Implementation Details</em>. <em>Idioms</em> can be design or implementation patterns.</h6>
</div></figure>
<p>These decisions would be the end of your responsibility, however. As an architect,
you wouldn’t worry about where to place the refrigerator, the TV, or other
furniture. You wouldn’t deal with all the nifty details about where to place
pictures and other pieces of decoration. In other words, you wouldn’t handle
the details; you would just make sure that the homeowner has the necessary
structure to live well.</p>
<p>The furniture and other “nifty details” in this metaphor
correspond to the lowest and most concrete level of software development, the
implementation details. This level handles how a solution is implemented. You
choose the necessary (and available) 
<span class="keep-together">C++</span> standard or any subset of it, as well as the appropriate
features, keywords, and language specifics to use, and deal with aspects such
as memory acquisition, exception safety, performance, etc. This<a data-primary="implementation patterns" data-secondary="idioms as" data-type="indexterm" id="idm45043123727360"/><a data-primary="design patterns" data-secondary="idioms as" data-type="indexterm" id="idm45043123726384"/> is also the level
of <em>implementation patterns</em>, such as <code>std::make_unique()</code> as<a data-primary="factory functions" data-type="indexterm" id="idm45043123858128"/> a <em>factory function</em>,
<code>std::enable_if</code> as a recurring solution to explicitly benefit from<a data-primary="Substitution Failure Is Not An Error (SFINAE)" data-type="indexterm" id="idm45043123856400"/><a data-primary="SFINAE (Substitution Failure Is Not An Error)" data-type="indexterm" id="idm45043130423408"/> SFINAE,
etc.<sup><a data-type="noteref" href="ch01.xhtml#idm45043130422608" id="idm45043130422608-marker">9</a></sup></p>
<p class="less_space pagebreak-before">In software design, you start to focus on the big picture. Questions about
maintainability, changeability, extensibility, testability, and scalability are
more pronounced on this level. Software design primarily deals with the interaction of software entities, which
in the previous metaphor are represented by the arrangement of rooms, doors, pipes,
and cables. At this level, you handle the physical and logical dependencies of components
(classes, function, etc.).<sup><a data-type="noteref" href="ch01.xhtml#idm45043124605168" id="idm45043124605168-marker">10</a></sup> It’s the level of design patterns such as Visitor, Strategy, and Decorator that define a dependency structure among
software entities, as explained in <a data-type="xref" href="ch03.xhtml#the_purpose_of_design_patterns">Chapter 3</a>. These patterns,
which usually are transferable from language to language, help you break down complex
things into digestible pieces.</p>
<p><em>Software Architecture</em><a data-primary="Software Architecture level" data-type="indexterm" id="idm45043124602736"/> is the fuzziest of the three levels, the hardest to put into
words. This is because there is no common, universally accepted definition of
software architecture. While there may be many different views on what exactly
an architecture is, there is one aspect that everyone seems to agree on: architecture
usually entails the big decisions, the aspects of your software that are among the
hardest things to change in the future:</p>
<blockquote>
<p>Architecture is the decisions that you wish you could get right early in a project,
but that you are not necessarily more likely to get them right than any other.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123295968" id="idm45043123295968-marker">11</a></sup></p>
<p data-type="attribution">Ralph Johnson</p>
</blockquote>
<p>In Software Architecture, you use<a data-primary="architectural patterns" data-type="indexterm" id="idm45043123575616"/> architectural patterns such<a data-primary="client-server architecture" data-type="indexterm" id="idm45043124010560"/><a data-primary="microservices" data-type="indexterm" id="idm45043124009824"/> as
<em>client-server architecture</em>, <em>microservices</em>, and so on.<sup><a data-type="noteref" href="ch01.xhtml#idm45043124008192" id="idm45043124008192-marker">12</a></sup>
These patterns also deal with the question of how to design systems, where you
can change one part without affecting any other parts of your software. Similar
to <em>Software design</em> patterns, they define and address the structure and
interdependencies among software entities. In contrast to design patterns, though,
they usually deal with the key players, the big entities of your software (e.g.,
modules and components instead of classes and functions).</p>
<p>From this perspective,
Software Architecture represents the overall strategy of your software approach,
whereas Software Design is the tactics to make the strategy work. The problem with
this picture is that there is no definition of “big.” Especially with the advent of
microservices, it becomes more and more difficult to draw a clear line between
small and big entities.<sup><a data-type="noteref" href="ch01.xhtml#idm45043130766672" id="idm45043130766672-marker">13</a></sup></p>
<p>Thus, architecture is often described as what expert developers
in a project perceive as the key decisions.</p>
<p>What<a data-primary="idioms" data-secondary="purpose of" data-type="indexterm" id="idm45043130770816"/> makes the separation between architecture, design, and details a little
more difficult is the concept of an <em>idiom</em>. An <em>idiom</em> is a commonly used but
language-specific solution for a recurring problem. As such, an idiom also
represents a pattern, but it could be either an <em>implementation pattern</em> or
a <em>design pattern</em>.<sup><a data-type="noteref" href="ch01.xhtml#idm45043131054400" id="idm45043131054400-marker">14</a></sup> More loosely speaking, C++ idioms are the
best practices of the C++ community for either design or implementation.
In C++, most idioms fall into the category of implementation details.
For instance, there<a data-primary="idioms" data-secondary="copy-and-swap" data-type="indexterm" id="idm45043124265184"/><a data-primary="copy-and-swap idiom" data-type="indexterm" id="idm45043124264272"/> is the
<a href="https://oreil.ly/hioCd"><em>copy-and-swap idiom</em></a>
that you may know from the implementation of a copy assignment operator, and the<a data-primary="RAII idiom" data-type="indexterm" id="idm45043123743424"/><a data-primary="idioms" data-secondary="RAII" data-type="indexterm" id="idm45043123742752"/>
<a href="https://oreil.ly/55blq"><em>RAII idiom</em></a>
(Resource<a data-primary="Resource Acquisition Is Initialization (RAII)" data-type="indexterm" id="idm45043125637360"/><a data-primary="RAII (Resource Acquisition Is Initialization)" data-type="indexterm" id="idm45043125636624"/> Acquisition Is Initialization—you should definitely
be familiar with this; if not, please see your second-favorite C++
book<sup><a data-type="noteref" href="ch01.xhtml#idm45043125635792" id="idm45043125635792-marker">15</a></sup>). None of these idioms
introduce an abstraction, and none of them help to decouple. Still, they are
indispensable to implement good 
<span class="keep-together">C++</span> code.</p>
<p>I hear you ask, “Could you be a little more specific, please? Isn’t RAII also providing some form of
decoupling? Doesn’t it decouple resource management from business logic?” You’re correct: RAII separates resource management and business logic. However,
it doesn’t achieve this by means of decoupling, i.e., abstraction, but by means of
encapsulation. Both abstraction and encapsulation help you make complex systems
easier to understand and change, but while abstraction solves the problems and issues
that arise at the Software Design level, encapsulation solves the problems and
issues that arise at the Implementation Details level. To quote
<a href="https://oreil.ly/BeFXr">Wikipedia</a>:</p>
<blockquote>
<p>The advantages of RAII as a resource management technique are that it provides
encapsulation, exception safety […], and locality […]. Encapsulation is provided
because resource management logic is defined once in the class, not at each call site.</p></blockquote>
<p>While most idioms fall into the category of Implementation Details, there are also
idioms that fall into the category of Software Design. Two<a data-primary="idioms" data-secondary="Non-Virtual Interface (NVI)" data-type="indexterm" id="idm45043125085408"/><a data-primary="Non-Virtual Interface (NVI) idiom" data-type="indexterm" id="idm45043125084464"/><a data-primary="idioms" data-secondary="Pimpl" data-type="indexterm" id="idm45043125083824"/><a data-primary="Pimpl idiom" data-type="indexterm" id="idm45043125082880"/> examples are the
<em>Non-Virtual Interface (NVI) idiom</em> and the <em>Pimpl idiom</em>. These
two idioms are based on two classic design patterns: the<a data-primary="design patterns" data-secondary="Template Method" data-type="indexterm" id="idm45043123243760"/><a data-primary="Template Method design pattern" data-type="indexterm" id="idm45043123242784"/> <em>Template Method</em> design
pattern and the <em>Bridge</em> design pattern<a data-primary="Bridge design pattern" data-secondary="idioms based on" data-type="indexterm" id="idm45043123824640"/>, respectively.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123823504" id="idm45043123823504-marker">16</a></sup> They introduce an abstraction
and help decouple and design for change and extensions.<a data-primary="" data-startref="devlev01" data-type="indexterm" id="idm45043123470208"/><a data-primary="" data-startref="SDlevels01" data-type="indexterm" id="idm45043123469264"/></p>
</div></section>
<section data-pdf-bookmark="The Focus on Features" data-type="sect2"><div class="sect2" id="idm45043123355968">
<h2>The Focus on Features</h2>
<p>If<a data-primary="software design" data-secondary="basic guidelines for" data-tertiary="features" data-type="indexterm" id="idm45043124004144"/><a data-primary="features" data-secondary="reasons for focus on" data-type="indexterm" id="idm45043124002864"/> software architecture and software design are of such importance, then why are
we in the C++ community focusing so strongly on features? Why do we create
the illusion that C++ standards, language mechanics, and features are decisive
for a project? I think there are three strong reasons for that. First, because there
are so many features, with sometimes complex details, we need to spend a lot of time
talking about how to use all of them properly. We need to create a common understanding
on which use is good and which use is bad. We as a community need to develop a sense of
idiomatic C++.</p>
<p>The second reason is that we might put the wrong expectations on features. As
an example, let’s consider C++20 modules. Without going into details,
this feature may indeed be considered the biggest technical revolution since
the beginning of C++. Modules may at last put the questionable
and cumbersome practice of including header files into source files to an end.</p>
<p>Due to this potential, the expectations for that feature are enormous. Some
people even expect modules to save their project by fixing their
structural issues. Unfortunately, modules will have
a hard time satisfying these expectations: modules don’t improve
the structure or design of your code but can merely represent the current
structure and design. Modules don’t repair your design issues, but they may be
able to make the flaws visible. Thus, modules simply cannot save your project.
So indeed, we may be putting too many or the wrong expectations on features.</p>
<p>And last, but not least, the third reason is that despite the huge amount of
features and their complexity, in comparison to the complexity of software
design, the complexity of C++ features is small. It’s much easier
to explain a given set of rules for features, regardless of how many special
cases they contain, than it is to explain the best way to decouple software entities.</p>
<p>While there is usually a good answer to all feature-related questions, the
common answer in software design is “It depends.” That answer might not even
be evidence of inexperience, but of the realization that the best way to make
code more maintainable, changeable, extensible, testable, and scalable
heavily depends on many project-specific factors. The decoupling of the complex
interplay between many entities may indeed be one of the most challenging
endeavors that mankind has ever faced:</p>
<blockquote>
<p>Design and programming are human activities; forget that and all is lost.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123657936" id="idm45043123657936-marker">17</a></sup></p></blockquote>
<p>To me, a combination of these three reasons is why we focus on features
so much. But please, don’t get me wrong. That’s not to say that features
are not important. On the contrary, features <em>are</em> important. And yes,
it’s necessary to talk about features and learn how to use them correctly,
but once again, they alone do not save your project.</p>
</div></section>
<section data-pdf-bookmark="The Focus on Software Design and Design Principles" data-type="sect2"><div class="sect2" id="idm45043123655264">
<h2>The Focus on Software Design and Design Principles</h2>
<p>While<a data-primary="software design" data-secondary="basic guidelines for" data-tertiary="design principles" data-type="indexterm" id="idm45043123653808"/><a data-primary="design principles" data-secondary="reasons for focus on" data-type="indexterm" id="idm45043123632944"/> features are important, and while it is of course good to talk about
them, software design is more important. Software design is essential.
I would even argue that it’s the foundation of
the success of our projects. Therefore, in this book I will make the
attempt to truly focus on software design and design principles instead
of features. Of course I will still show good and up-to-date C++
code, but I won’t force the use of the latest and
greatest language additions.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123631872" id="idm45043123631872-marker">18</a></sup> I <em>will</em> make use of
some new features when it is reasonable and beneficial, such as
C++20 concepts, but I will <em>not</em> pay attention to <code>noexcept</code>,
or use <code>constexpr</code> everywhere.<sup><a data-type="noteref" href="ch01.xhtml#idm45043124608352" id="idm45043124608352-marker">19</a></sup> Instead I will try to
tackle the difficult aspects of software. I will, for the most part,
focus on software design, the rationale behind design decisions, design
principles, managing dependencies, and dealing with abstractions.</p>
<p>In summary, software design is the critical part of writing software. Software
developers should have a good understanding of software design to write good, maintainable software. Because after all, good
software is low-cost, and bad software is expensive.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043123988912">
<h5>Guideline 1: Understand the Importance of Software Design</h5>
<ul>
<li>
<p>Treat software design as an essential part of writing software.</p>
</li>
<li>
<p>Focus less on C++ language details and more on software design.</p>
</li>
<li>
<p>Avoid unnecessary coupling and dependencies to make software more adaptable to frequent changes.</p>
</li>
<li>
<p>Understand software design as the art of managing dependencies and 
<span class="keep-together">abstractions</span>.</p>
</li>
<li>
<p>Consider the boundary between software design and software architecture as fluid.<a data-primary="" data-startref="SDbasic01" data-type="indexterm" id="idm45043123588288"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 2: Design for Change" data-type="sect1"><div class="sect1" id="design_for_change">
<h1>Guideline 2: Design for Change</h1>
<p>One<a data-primary="change, designing for" data-type="indexterm" id="CHdesing01"/><a data-primary="software design" data-secondary="change" data-type="indexterm" id="SDchange01"/> of the essential expectations for good software is its ability to change easily.
This expectation is even part of the word <em>soft</em>ware. <em>Soft</em>ware, in contrast to
<em>hard</em>ware, is expected to be able to adapt easily to changing requirements (see also
<a data-type="xref" href="#understand_the_importance_of_software_design">“Guideline 1: Understand the Importance of 
<span class="keep-together">Software Design</span>”</a>). However, from your own experience you
may be able to tell that often it is not easy to change code. On the contrary, sometimes
a seemingly simple change turns out to be a week-long endeavor.</p>
<section data-pdf-bookmark="Separation of Concerns" data-type="sect2"><div class="sect2" id="idm45043126329808">
<h2>Separation of Concerns</h2>
<p>One<a data-primary="change, designing for" data-secondary="separation of concerns" data-type="indexterm" id="idm45043126328112"/><a data-primary="software design" data-secondary="change" data-tertiary="separation of concerns" data-type="indexterm" id="idm45043126327104"/><a data-primary="separation of concerns" data-secondary="designing for change" data-type="indexterm" id="idm45043124389744"/><a data-primary="concerns, separation of" data-secondary="designing for change" data-type="indexterm" id="idm45043124388800"/><a data-primary="dependencies" data-secondary="reducing artificial" data-type="indexterm" id="idm45043124387856"/> of the best and proven solutions to reduce artificial dependencies and simplify
change is to separate concerns. The core of the idea is to split, segregate, or extract
pieces of functionality:<sup><a data-type="noteref" href="ch01.xhtml#idm45043124044208" id="idm45043124044208-marker">20</a></sup></p>
<blockquote>
<p>Systems that are broken up into small, well-named, understandable pieces enable
faster work.</p></blockquote>
<p>The intent behind separation of concerns
is to better understand and manage complexity and thus design more modular software.
This idea is probably as old as software itself and hence has been given many different
names. For instance, the same idea is called<a data-primary="orthogonality" data-type="indexterm" id="idm45043124041840"/> <em>orthogonality</em> by the Pragmatic
Programmers.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123834288" id="idm45043123834288-marker">21</a></sup>
They advise separating orthogonal aspects of software. Tom DeMarco<a data-primary="cohesion" data-type="indexterm" id="idm45043123833184"/> calls it
<em>cohesion</em>:<sup><a data-type="noteref" href="ch01.xhtml#idm45043123832000" id="idm45043123832000-marker">22</a></sup></p>
<blockquote>
<p>Cohesion is a measure of the strength of association of the elements inside a module.
A highly cohesive module is a collection of statements and data items that should be
treated as a whole because they are so closely related. Any attempt to divide them up
would only result in increased coupling and decreased readability.</p></blockquote>
<p>In<a data-primary="SOLID (SRP, OCP, LSP, ISP, and DIP) principles" data-type="indexterm" id="idm45043124288896"/><a data-primary="design principles" data-secondary="SOLID (SRP, OCP, LSP, ISP, and DIP) principles" data-type="indexterm" id="idm45043124288192"/> the <em>SOLID</em> principles,<sup><a data-type="noteref" href="ch01.xhtml#idm45043124286736" id="idm45043124286736-marker">23</a></sup> one of the most established sets of design principles,
the idea is known as the<a data-primary="Single-Responsibility Principle (SRP)" data-type="indexterm" id="idm45043123406416"/><a data-primary="SRP (Single-Responsibility Principle)" data-type="indexterm" id="idm45043123405776"/><a data-primary="design principles" data-secondary="Single-Responsibility Principle (SRP)" data-type="indexterm" id="idm45043123405136"/> <em>Single-Responsibility Principle (SRP)</em>:</p>
<blockquote>
<p>A class should have only one reason to change.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123403072" id="idm45043123403072-marker">24</a></sup></p></blockquote>
<p>Although the concept is old and is commonly known under many names,
many attempts to explain separation of concerns raise more questions than answers. This is particularly true for the SRP. The name of this design
principle alone raises questions: what is a responsibility? And what is a <em>single</em>
responsibility? A common attempt to clarify the vagueness about SRP is the
following:</p>
<blockquote>
<p>Everything should do just one thing.</p></blockquote>
<p>Unfortunately this explanation is hard to outdo in terms of vagueness. Just as
the word <em>responsibility</em> doesn’t carry a lot of meaning, <em>just one thing</em>
doesn’t help to shed any more light on it.</p>
<p>Irrespective of the name, the idea is always the same: group only those things
that truly belong together, and separate everything that does not strictly
belong. Or in other words: separate those things that change for different
reasons. By doing this, you reduce<a data-primary="artificial coupling" data-secondary="reducing" data-type="indexterm" id="idm45043123368160"/><a data-primary="coupling" data-secondary="reducing artificial" data-type="indexterm" id="idm45043123367184"/> artificial coupling between different aspects
of your code and it helps you make your software more adaptable to change.
In the best case, you can change a particular aspect of your software in exactly
one place.</p>
</div></section>
<section data-pdf-bookmark="An Example of Artificial Coupling" data-type="sect2"><div class="sect2" id="example_of_artificial_coupling">
<h2>An Example of Artificial Coupling</h2>
<p>Let’s<a data-primary="coupling" data-secondary="example of artificial" data-type="indexterm" id="idm45043123784400"/><a data-primary="artificial coupling" data-secondary="example of" data-type="indexterm" id="ACexample01"/><a data-primary="change, designing for" data-secondary="artificial coupling" data-type="indexterm" id="idm45043123782176"/><a data-primary="software design" data-secondary="change" data-tertiary="artificial coupling" data-type="indexterm" id="idm45043123819520"/> shed some light on separation of concerns by means of a code example. And
I do have a great example indeed: I present to you the abstract <code>Document</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//#include &lt;some_json_library.h&gt;  // Potential physical dependency
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Document</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Document</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g2_1" id="code_g2_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g2_2" id="code_g2_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>This sounds like a very useful base class for all kinds of documents,
doesn’t it? First, there is the <code>exportToJSON()</code> function
(<a class="co" href="#code_g2_1" id="para_g2_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
All deriving classes will have to implement the <code>exportToJSON()</code> function in order
to produce a <a href="https://oreil.ly/YWrsw">JSON file</a> from the document. That
will prove to be pretty useful: without having to know about a particular kind
of document (and we can imagine that we will eventually have PDF documents, Word
documents, and many more), we can always export in JSON format. Nice! Second, there
is a <code>serialize()</code> function
(<a class="co" href="#code_g2_2" id="para_g2_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
This function lets you transform a <code>Document</code> into bytes via a <code>ByteStream</code>. You
can store these bytes in some persistent system, like a file or a database.
And of course we can expect that there are many other, useful functions available
that will allow us to pretty much use this document for 
<span class="keep-together">everything.</span></p>
<p>However, I can see the frown on your face. No, you don’t look particularly
convinced that this is good software design. It may be because you’re just
very suspicious about this example (it simply looks too good to be true).
Or it may be that you’ve learned the hard way that this kind of design
eventually leads to trouble. You<a data-primary="object-oriented programming (OOP)" data-secondary="strengths and weaknesses of" data-type="indexterm" id="idm45043124054704"/> may have experienced that using the
common object-oriented design principle to bundle the data and the
functions that operate on them may easily lead to unfortunate coupling.
And I agree: despite the fact that this base class looks like a great
all-in-one package, and even looks like it has everything that we might
ever need, this design will soon lead to trouble.</p>
<p>This<a data-primary="dependencies" data-secondary="reducing artificial" data-type="indexterm" id="idm45043125518016"/> is bad design because it contains many dependencies. Of course there are the obvious, direct dependencies, as for instance the dependency on the <code>ByteStream</code> class. However, this design also favors the introduction of artificial dependencies, which will make subsequent changes harder. In
this case, there are three kinds of artificial dependencies. Two of these
are introduced by the <code>exportToJSON()</code> function, and one by the <code>serialize()</code>
function.</p>
<p>First, <code>exportToJSON()</code> needs to be implemented in the derived classes. And yes,
there is no choice, because it is a
<a href="https://oreil.ly/1u9at">pure virtual function</a>
(denoted by the sequence <code>= 0</code>, the so-called <em>pure specifier</em>). Since derived
classes will very likely not want to carry the burden of implementing JSON exports
manually, they will rely on an external, third-party JSON library:
<a href="https://oreil.ly/MqB03"><em>json</em></a>,
<a href="https://oreil.ly/jNMsz"><em>rapidjson</em></a>, or
<a href="https://oreil.ly/5dBzC"><em>simdjson</em></a>.
Whatever library you choose for that purpose, because of the <code>exportToJSON()</code>
member function, deriving documents would suddenly depend on this library. And,
very likely, all deriving classes would depend on the same library, for
consistency reasons alone. Thus, the deriving classes are not really independent;
they are artificially coupled to a particular design decision.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123603040" id="idm45043123603040-marker">25</a></sup> Also, the
dependency on a specific JSON library would definitely limit the reusability
of the hierarchy, because it would no longer be lightweight. And switching to
another library would cause a major change because all deriving classes
would have to be adapted.<sup><a data-type="noteref" href="ch01.xhtml#idm45043124305408" id="idm45043124305408-marker">26</a></sup></p>
<p>Of course, the same kind of artificial dependency is introduced by the <code>serialize()</code> function. It’s likely that <code>serialize()</code> will also be implemented in terms of a third-party library, such as <a href="https://oreil.ly/z6Kgr">protobuf</a> or <a href="https://oreil.ly/ySJLk">Boost.serialization</a>. This considerably worsens the dependency situation because it introduces a coupling between two orthogonal, unrelated design aspects (i.e., JSON export and serialization). A change to one aspect might result in changes to the other aspect.</p>
<p>In the worst case, the <code>exportToJSON()</code> function might introduce
a second dependency. The arguments expected in the <code>exportToJSON()</code> call
might accidentally reflect some of the implementation details of the chosen
JSON library. In that case, eventually switching to another library might
result in a change of the signature of the <code>exportToJSON()</code> function, which
would subsequently cause changes in all callers. Thus, the dependency on the
chosen JSON library might accidentally be far more widespread than intended.</p>
<p>The third kind of dependency is introduced by the <code>serialize()</code> function. Due
to this function, the classes deriving from <code>Document</code> depend on global
decisions on how documents are serialized. What format do we use? Do we use
little endian or big endian? Do we have to add the information that the bytes
represent a PDF file or a Word file? If yes (and I assume that is very likely),
how do we represent such a document? By means of an integral value? For
instance, we could use an enumeration for this purpose:<sup><a data-type="noteref" href="ch01.xhtml#idm45043128374128" id="idm45043128374128-marker">27</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">enum</code><code class="w"> </code><code class="k">class</code><code class="w"> </code><code class="nc">DocumentType</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">pdf</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="n">word</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Potentially many more document types</code>
<code class="p">};</code><code class="w"/></pre>
<p>This approach is very common for serialization. However, if this low-level
document representation is used within the implementations of the
<code>Document</code> classes, we would accidentally couple all the different kinds of
documents. Every deriving class would implicitly know about all the other
<code>Document</code> types. As a result, adding a new kind of document would
directly affect all existing document types. That would be a serious
design flaw, since, again, it will make change harder.</p>
<p>Unfortunately, the <code>Document</code> class promotes many different kinds of
coupling. So no, the <code>Document</code> class is not a great example of good
class design, since it isn’t easy to change. On the contrary, it is
hard to change and thus a great example of a violation of the SRP:
the classes deriving from <code>Document</code> and users of the <code>Document</code> class
change for many reasons because we have created a strong coupling
between several orthogonal, unrelated aspects. To summarize, deriving
classes and users of documents may change for any of the following reasons:</p>
<ul>
<li>
<p>The implementation details of the <code>exportToJSON()</code>
function change because of a direct dependency on the used
JSON library</p>
</li>
<li>
<p>The signature of the <code>exportToJSON()</code> function changes
because the underlying implementation changes</p>
</li>
<li>
<p>The <code>Document</code> class and the <code>serialize()</code> function change because of a direct dependency on the <code>ByteStream</code> class</p>
</li>
<li>
<p>The implementation details of the <code>serialize()</code> function
change because of a direct dependency on the implementation
details</p>
</li>
<li>
<p>All types of documents change because of the direct dependency on the <code>DocumentType</code> enumeration</p>
</li>
</ul>
<p>Obviously, this design promotes more changes, and every single change
would be harder. And of course, in the general case, there is the danger that additional orthogonal aspects are artificially coupled
inside documents, which would further increase the complexity of
making a change. In addition, some of these changes are definitely
not restricted to a single place in the codebase. In particular,
changes to the implementation details of <code>exportToJSON()</code> and
<code>serialize()</code> would not be restricted to only one class, but likely
all kinds of documents (PDF, Word, and so on). Therefore, a change
would affect a significant number of places all over the codebase, which poses a maintenance risk.<a data-primary="" data-startref="ACexample01" data-type="indexterm" id="idm45043127966768"/></p>
</div></section>
<section data-pdf-bookmark="Logical Versus Physical Coupling" data-type="sect2"><div class="sect2" id="idm45043123785936">
<h2>Logical Versus Physical Coupling</h2>
<p>The<a data-primary="change, designing for" data-secondary="logical versus physical coupling" data-type="indexterm" id="idm45043128171488"/><a data-primary="software design" data-secondary="change" data-tertiary="logical versus physical coupling" data-type="indexterm" id="idm45043126700208"/><a data-primary="coupling" data-secondary="logical versus physical" data-type="indexterm" id="Clogical01"/> coupling isn’t limited to logical coupling but also extends
to physical coupling. <a data-type="xref" href="#fig_srp_strong_coupling">Figure 1-2</a> illustrates that
coupling. Let’s assume that there is a <code>User</code> class on the
low level of our architecture that needs to use documents that
reside on a higher level of the architecture. Of course
the <code>User</code> class depends directly on the <code>Document</code> class, which is a necessary
dependency—an intrinsic dependency of the given problem. Thus, it
should not be a concern for us. However, the (potential) physical
dependency of <code>Document</code> on the
selected JSON library and the direct dependency on the <code>ByteStream</code>
class cause an indirect, transitive dependency of <code>User</code> to the
JSON library and <code>ByteStream</code>, which reside on the highest level of
our architecture. In the worst case, this means that changes to the JSON library or
the <code>ByteStream</code> class have an effect on <code>User</code>. Hopefully it’s easy to see that this is an artificial, not an intentional, dependency: a <code>User</code> shouldn’t have to depend on
JSON or serialization.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>I should explicitly state that there is
a <em>potential</em> physical dependency of <code>Document</code> on the select
JSON library. If the <code>&lt;Document.h&gt;</code> header file includes any
header from the JSON library of choice (as indicated in the code
snippet at the beginning of <a data-type="xref" href="#example_of_artificial_coupling">“An Example of Artificial Coupling”</a>), for instance because the <code>exportToJSON()</code> function
expects some arguments based on that library, then there is a clear
dependency on that library. However, if the interface can properly
abstract from these details and the 
<span class="keep-together"><code>&lt;Document.h&gt;</code></span> header doesn’t
include anything from the JSON library, the physical dependency might
be avoided. Thus, it depends on how well the dependencies can be (and
are) abstracted.</p>
</div>
<figure><div class="figure" id="fig_srp_strong_coupling">
<img alt="cpsd 0102" height="602" src="assets/cpsd_0102.png" width="1305"/>
<h6><span class="label">Figure 1-2. </span>The strong transitive, physical coupling between <code>User</code> and orthogonal aspects like JSON and serialization.</h6>
</div></figure>
<p>“High level, low level—now I’m confused,” you complain. Yes, I know that
these two terms usually cause some confusion. So before we move on, let’s
agree on the terminology for high level and low level. The<a data-primary="Unified Modeling Language (UML)" data-type="indexterm" id="idm45043126608080"/> origin of these
two terms relates to the way we draw diagrams in the
<a href="https://oreil.ly/s0ID2"><em>Unified Modeling Language (UML)</em></a>:
functionality that we consider to be stable appears on the top, on a high level.
Functionality that changes more often and is therefore considered to be volatile or
malleable appears on the bottom, the low level. Unfortunately, when we draw
architectures, we often try to show how things build on one another, so the most
stable parts appear at the bottom of an architecture. That, of course, causes
some confusion. Independent of how things are drawn, just remember these terms:
<em>high level</em> refers to stable parts of your architecture, and <em>low level</em> refers to the
aspects that change more often or are more likely to change.</p>
<p>Back to the problem: the SRP advises that we should separate concerns
and the things that do not truly belong, i.e., the noncohesive
(adhesive) things. In<a data-primary="variation points" data-secondary="separating according to SRP" data-type="indexterm" id="idm45043126605280"/> other words, it advises us to separate the things
that change for different reasons into <em>variation points</em>.
<a data-type="xref" href="#fig_srp_weak_coupling">Figure 1-3</a> shows the coupling situation
if we isolate the JSON and serialization aspects into separate concerns.</p>
<figure><div class="figure" id="fig_srp_weak_coupling">
<img alt="cpsd 0103" height="381" src="assets/cpsd_0103.png" width="1393"/>
<h6><span class="label">Figure 1-3. </span>Adherence to the <em>SRP</em> resolves the artificial coupling between <code>User</code> and JSON and serialization.</h6>
</div></figure>
<p>Based on this advice, the <code>Document</code> class is refactored in the following
way:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Document</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Document</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="c1">// No more 'exportToJSON()' and 'serialize()' functions.</code>
<code class="w">   </code><code class="c1">// Only the very basic document operations, that do not</code>
<code class="w">   </code><code class="c1">// cause strong coupling, remain.</code>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>The JSON and serialization aspects are just not part of the fundamental
pieces of functionality of a <code>Document</code> class. The <code>Document</code> class should
merely represent the very basic operations of different kinds of documents.
All orthogonal aspects should be separated. This will make changes
considerably easier. For instance, by isolating the JSON aspect into a
separate variation point and into the new <code>JSON</code> component, switching
from one JSON library to another will affect only this one component.
The change could be done in exactly one place and would happen in
isolation from all the other, orthogonal aspects. It would also be easier
to support the JSON format by means of several JSON libraries. Additionally,
any change to how documents are serialized would affect only one component
in the code: the new <code>Serialization</code> component. Also, <code>Serialization</code> would
act as a variation point that enables isolated, easy change. That would
be the optimal situation.</p>
<p class="less_space pagebreak-before">After your initial disappointment with the <code>Document</code> example, I
can see you’re looking happier again. Perhaps there’s even an
“I knew it!” smile on your face. However, you’re not entirely
satisfied yet: “Yes, I agree with the general idea of separating
concerns. But how do I have to structure my software to separate
concerns? What do I have to do to make it work?” That is an
excellent question, but one with many answers that I’ll address in the upcoming chapters. The first and most important point,
however, is the identification of a variation point, i.e., some
aspect in your code where changes are expected. These variation points
should be extracted, isolated, and wrapped, such that there are no
longer any dependencies on these variations. That will ultimately
help make changes easier.</p>
<p>“But that is still only superficial advice!” I hear you say.
And you’re correct. Unfortunately, there is no single answer and
there is no simple answer. It depends. But I promise to give many
concrete answers for how to separate concerns in the upcoming chapters.
After all, this is a book on software design, i.e., a book on managing
dependencies. As a little teaser, in <a data-type="xref" href="ch03.xhtml#the_purpose_of_design_patterns">Chapter 3</a>
I will introduce a general and practical approach to this problem: design
patterns. With this general idea in mind, I will show you how to separate
concerns using different design patterns. For instance, the
<em>Visitor</em>, <em>Strategy</em>, and <em>External Polymorphism</em> design patterns
come to mind.
All of these patterns have different strengths and weaknesses,
but they share the property of introducing some kind of abstraction
to help you to reduce dependencies. Additionally, I promise to take a
close look at how to implement these design patterns in modern C++.</p>
<div data-type="tip"><h6>Tip</h6>
<p>I will introduce the Visitor design pattern in
<a data-type="xref" href="ch04.xhtml#use_visitors_to_extend_operations">“Guideline 16: Use Visitor to Extend Operations”</a>, and the
Strategy design pattern in
<a data-type="xref" href="ch05.xhtml#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>.
The External Polymorphism design pattern will be the topic of
<a data-type="xref" href="ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism">“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”</a>.<a data-primary="" data-startref="Clogical01" data-type="indexterm" id="idm45043126543424"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Don’t Repeat Yourself" data-type="sect2"><div class="sect2" id="idm45043128187504">
<h2>Don’t Repeat Yourself</h2>
<p>There<a data-primary="change, designing for" data-secondary="Don't Repeat Yourself (DRY)" data-type="indexterm" id="idm45043126540624"/><a data-primary="software design" data-secondary="change" data-tertiary="Don't Repeat Yourself (DRY)" data-type="indexterm" id="idm45043126506048"/><a data-primary="Don't Repeat Yourself (DRY) principle" data-type="indexterm" id="DRY01"/> is a second, important aspect to changeability. To explain this aspect, I will introduce another example:
a hierarchy of items. <a data-type="xref" href="#fig_simple_item_hierarchy">Figure 1-4</a>
gives an impression of this hierarchy.</p>
<figure><div class="figure" id="fig_simple_item_hierarchy">
<img alt="cpsd 0104" height="438" src="assets/cpsd_0104.png" width="856"/>
<h6><span class="label">Figure 1-4. </span>The <code>Item</code> class hierarchy.</h6>
</div></figure>
<p>At the top of that hierarchy is the <code>Item</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Money.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Money</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="n">Money</code><code class="w"> </code><code class="k">operator</code><code class="o">*</code><code class="p">(</code><code class="w"> </code><code class="n">Money</code><code class="w"> </code><code class="n">money</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">factor</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="n">Money</code><code class="w"> </code><code class="k">operator</code><code class="o">+</code><code class="p">(</code><code class="w"> </code><code class="n">Money</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Money</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">);</code><code class="w"/>


<code class="c1">//---- &lt;Item.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Money.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Item</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Item</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="n">Money</code><code class="w"> </code><code class="nf">price</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>The <code>Item</code> base class represents an abstraction for any kind
of item that has a price tag (represented by the <code>Money</code> class).
Via the <code>price()</code> function, you can query for that price. Of course
there are many possible items, but for illustration purposes, we
restrict ourselves to <code>CppBook</code> and <code>ConferenceTicket</code>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;CppBook.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Item.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Money.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">CppBook</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Item</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">CppBook</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">title</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">author</code><code class="p">,</code><code class="w"> </code><code class="n">Money</code><code class="w"> </code><code class="n">price</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g2_3" id="code_g2_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">title_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">title</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">author_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">author</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">priceWithTax_</code><code class="p">(</code><code class="w"> </code><code class="n">price</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mf">1.15</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><code class="c1">// 15% tax rate
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">title</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">title_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">     </code><a class="co" href="#para_g2_4" id="code_g2_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">author</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">author_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">   </code><a class="co" href="#para_g2_5" id="code_g2_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Money</code><code class="w"> </code><code class="n">price</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">priceWithTax_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g2_6" id="code_g2_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">title_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">author_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Money</code><code class="w"> </code><code class="n">priceWithTax_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The constructor of the <code>CppBook</code> class expects a title and author
in the form of strings and a price in the form of <code>Money</code>
(<a class="co" href="#code_g2_3" id="para_g2_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>).<sup><a data-type="noteref" href="ch01.xhtml#idm45043129091136" id="idm45043129091136-marker">28</a></sup>
Apart from that, it only allows you to access the title, the author, and
the price with the <code>title()</code>, <code>author()</code>, and <code>price()</code> functions
(<a class="co" href="#code_g2_4" id="para_g2_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>,
<a class="co" href="#code_g2_5" id="para_g2_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>, and
<a class="co" href="#code_g2_6" id="para_g2_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).
However, the <code>price()</code> function is a little special: obviously, books are subject
to taxes. Therefore, the original price of the book needs to be adapted according to a given tax rate. In this example, I assume an imaginary tax rate of 15%.</p>
<p>The <code>ConferenceTicket</code> class is the second example of an <code>Item</code>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;ConferenceTicket.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Item.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Money.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ConferenceTicket</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Item</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">ConferenceTicket</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">Money</code><code class="w"> </code><code class="n">price</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g2_7" id="code_g2_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">name_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">priceWithTax_</code><code class="p">(</code><code class="w"> </code><code class="n">price</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mf">1.15</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><code class="c1">// 15% tax rate
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">name</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">name_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Money</code><code class="w"> </code><code class="n">price</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">priceWithTax_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">name_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Money</code><code class="w"> </code><code class="n">priceWithTax_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p><code>ConferenceTicket</code> is very similar to the <code>CppBook</code> class, but
expects only the name of the conference and the price in the constructor
(<a class="co" href="#code_g2_7" id="para_g2_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).
Of course, you can access the name and the price with the
<code>name()</code> and <code>price()</code> functions, respectively. Most importantly,
however, the price for a C++ conference is also subject
to taxes. Therefore, we again adapt the original price according to the imaginary
tax rate of 15%.</p>
<p>With this functionality available, we can go ahead and create a couple of
<code>Item</code>s in the <code>main()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;CppBook.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;ConferenceTicket.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;algorithm&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;vector&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="n">items</code><code class="p">{};</code><code class="w"/>

<code class="w">   </code><code class="n">items</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">CppBook</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"Effective C++"</code><code class="p">,</code><code class="w"> </code><code class="mf">19.99</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">items</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">CppBook</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"C++ Templates"</code><code class="p">,</code><code class="w"> </code><code class="mf">49.99</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">items</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">ConferenceTicket</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"CppCon"</code><code class="p">,</code><code class="w"> </code><code class="mf">999.0</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">items</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">ConferenceTicket</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"Meeting C++"</code><code class="p">,</code><code class="w"> </code><code class="mf">699.0</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">items</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">ConferenceTicket</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"C++ on Sea"</code><code class="p">,</code><code class="w"> </code><code class="mf">499.0</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">Money</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">total_price</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">accumulate</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">items</code><code class="p">),</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">items</code><code class="p">),</code><code class="w"> </code><code class="n">Money</code><code class="p">{},</code><code class="w"/>
<code class="w">         </code><code class="p">[](</code><code class="w"> </code><code class="n">Money</code><code class="w"> </code><code class="n">accu</code><code class="p">,</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="p">){</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="n">accu</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">item</code><code class="o">-&gt;</code><code class="n">price</code><code class="p">();</code><code class="w"/>
<code class="w">         </code><code class="p">}</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In <code>main()</code>, we create a couple of items (two books and three conferences)
and compute the total price of all items.<sup><a data-type="noteref" href="ch01.xhtml#idm45043128523184" id="idm45043128523184-marker">29</a></sup> The total price will, of course, include
the imaginary tax rate of 15%.</p>
<p>That sounds like a good design. We have separated the specific
kinds of items and are able to change how the price of each
item is computed in isolation. It seems that we have fulfilled
the SRP and extracted and isolated the variation points.
And of course, there are more items. Many more. And all of
them will make sure that the applicable tax rate is
properly taken into account. Great! Now, while this <code>Item</code>
hierarchy will make us happy for some time, the design
unfortunately has a significant flaw. We might not realize
it today, but there’s always a looming shadow in the
distance, the nemesis of problems in software: change.</p>
<p>What happens if for some reason the tax rate changes? What
if the 15% tax rate is lowered to 12%? Or raised to 16%? I can
still hear the arguments from the day the initial design was
committed into the codebase: “No, that will never happen!”
Well, even the most unexpected thing may happen. For instance,
in Germany, the tax rate was lowered from 19% to 16% for half
a year in 2021. This, of course, would mean that we
have to change the tax rate in our codebase. Where do we
apply the change? In the current situation, the change
would pretty much affect every class deriving from the <code>Item</code>
class. The change would be all over the codebase!</p>
<p>Just as much as the SRP advises separating variation points,
we should take care not to duplicate information throughout
the codebase. As much as everything should have a
single responsibility (a single reason to change),
every responsibility should exist only once in the
system. This idea is commonly called the <em>Don’t Repeat Yourself</em>
(DRY) principle. This principle advises us to
not duplicate some key information in many places—but to
design the system such that we can make the change in only
one place. In the optimal case, the tax rate(s) should be
represented in exactly one place to enable you to make an
easy change.</p>
<p>Usually the SRP and the DRY principles work together very nicely. Adhering the SRP will often lead to adhering
to DRY as well, and vice versa. However, sometimes adhering to both requires
some extra steps. I know you’re eager to learn what these
extra steps are and how to solve the problem, but at this point,
it’s sufficient to point out the general idea of SRP
and DRY. I promise to revisit this problem and to show you
how to solve it (see
<a data-type="xref" href="ch09.xhtml#use_decorators_to_add_customization_hierarchically">“Guideline 35: Use Decorators to Add Customization Hierarchically”</a>).<a data-primary="" data-startref="DRY01" data-type="indexterm" id="idm45043128765856"/></p>
</div></section>
<section data-pdf-bookmark="Avoid Premature Separation of Concerns" data-type="sect2"><div class="sect2" id="idm45043128764624">
<h2>Avoid Premature Separation of Concerns</h2>
<p>At<a data-primary="change, designing for" data-secondary="premature separation of concerns" data-type="indexterm" id="idm45043128763120"/><a data-primary="software design" data-secondary="change" data-tertiary="premature separation of concerns" data-type="indexterm" id="idm45043128762144"/><a data-primary="separation of concerns" data-secondary="premature" data-type="indexterm" id="idm45043128760912"/><a data-primary="concerns, separation of" data-secondary="premature" data-type="indexterm" id="idm45043128759968"/> this point, I’ve hopefully convinced you that adhering to
SRP and DRY is a very reasonable idea. You might even be
so committed that you plan to separate everything—all classes and functions—into the most tiny units of
functionality. After all, that’s the goal, right? If this is
what you’re thinking right now, please stop! Take a deep
breath. And one more. And then please listen carefully to the
wisdom of Katerina Trajchevska:<sup><a data-type="noteref" href="ch01.xhtml#idm45043128758896" id="idm45043128758896-marker">30</a></sup></p>
<blockquote>
<p>Don’t try to achieve SOLID, use SOLID to achieve maintainability.</p></blockquote>
<p>Both SRP and DRY are your tools for achieving better
maintainability and simplifying change. They are not
your goals. While both are of utmost importance in the long
run, it can be very counterproductive to separate entities
without a clear idea about what kind of change will affect
you. Designing for change usually favors one specific kind
of change but might unfortunately make other kinds of change
harder. This<a data-primary="YAGNI (You Aren’t Gonna Need It) principle" data-type="indexterm" id="idm45043128756592"/><a data-primary="design principles" data-secondary="YAGNI (You Aren’t Gonna Need It) principle" data-type="indexterm" id="idm45043128755920"/> philosophy is part of the commonly known
<a href="https://oreil.ly/Gu7u9"><em>YAGNI</em> principle</a>
(You Aren’t Gonna Need It), which warns
you about overengineering (see also <a data-type="xref" href="#design_for_extension">“Guideline 5: Design for Extension”</a>).
If you have a clear plan, if you know what kind of change to expect,
then apply SRP and DRY to make that kind of change simple.
However, if you don’t know what kind of change to expect,
then don’t 
<span class="keep-together">guess—just</span> wait. Wait until you have a
clear idea about what kind of change to expect and then refactor
to make the change as easy as possible.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Just don’t forget that one aspect of easily changing things is
having<a data-primary="unit tests" data-type="indexterm" id="idm45043128751376"/> unit tests in place that give you confirmation that the
change did not break the expected behavior.</p>
</div>
<p>In summary, change is expected in <em>soft</em>ware and therefore it’s vital to design for change. Separate concerns and minimize
duplication to enable you to easily change things without being
afraid to break other, orthogonal aspects.</p>
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043128749328">
<h5>Guideline 2: Design for Change</h5>
<ul>
<li>
<p>Expect change in <em>soft</em>ware.</p>
</li>
<li>
<p>Design for easy change and make software more adaptable.</p>
</li>
<li>
<p>Avoid combining unrelated, orthogonal aspects to prevent coupling.</p>
</li>
<li>
<p>Understand that coupling increases the likelihood for change and makes changes harder.</p>
</li>
<li>
<p>Adhere to the Single-Responsibility Principle (SRP) to separate concerns.</p>
</li>
<li>
<p>Follow the Don’t Repeat Yourself (DRY) principle to minimize duplication.</p>
</li>
<li>
<p>Avoid premature abstraction if you are not sure about the next change.<a data-primary="" data-startref="SDchange01" data-type="indexterm" id="idm45043128741168"/><a data-primary="" data-startref="CHdesing01" data-type="indexterm" id="idm45043128740192"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 3: Separate Interfaces to Avoid &#10;Artificial Coupling" data-type="sect1"><div class="sect1" id="separate_interfaces_to_avoid_artificial_coupling">
<h1>Guideline 3: Separate Interfaces to Avoid 
<span class="keep-together">Artificial Coupling</span></h1>
<p>Let’s<a data-primary="artificial coupling" data-secondary="avoiding" data-type="indexterm" id="ACavoiding01"/><a data-primary="software design" data-secondary="separating interfaces" data-type="indexterm" id="SDinter01"/><a data-primary="coupling" data-secondary="avoiding artificial" data-type="indexterm" id="Cavoiding01"/> revisit the <code>Document</code> example from <a data-type="xref" href="#design_for_change">“Guideline 2: Design for Change”</a>. I know, by now
you probably feel like you’ve seen enough documents, but believe me, we’re not done yet.
There’s still an important coupling aspect to address. This time we don’t focus
on the individual functions in the <code>Document</code> class but on the interface as a
whole:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Document</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Document</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<section data-pdf-bookmark="Segregate Interfaces to Separate Concerns" data-type="sect2"><div class="sect2" id="idm45043123201024">
<h2>Segregate Interfaces to Separate Concerns</h2>
<p>The<a data-primary="software design" data-secondary="separating interfaces" data-tertiary="separating concerns" data-type="indexterm" id="idm45043123199456"/><a data-primary="interfaces, separating" data-secondary="separating concerns" data-type="indexterm" id="ISconcern01"/><a data-primary="concerns, separation of" data-secondary="separating interfaces" data-type="indexterm" id="CSOinterface01"/><a data-primary="separation of concerns" data-secondary="separating interfaces" data-type="indexterm" id="SOCinter01"/> <code>Document</code> requires deriving classes to handle both JSON exports and
serialization. While, from the point of view of a document, this may seem reasonable (after all, <em>all</em> documents should be exportable into JSON and
serializable), it unfortunately causes another kind of coupling. Imagine
the following user code:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">exportDocument</code><code class="p">(</code><code class="w"> </code><code class="n">Document</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">doc</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">doc</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>exportDocument()</code> function is solely interested in exporting a given
document to JSON. In other words, the <code>exportDocument()</code> function is <em>not</em>
concerned with serializing a document or with any other aspect that <code>Document</code>
has to offer. Still, as a result of the definition of the <code>Document</code> interface,
due to coupling many orthogonal aspects together, the <code>exportDocument()</code>
function depends on much more than just the JSON export. All of these dependencies
are unnecessary and artificial. Changing any of these—for instance, the <code>ByteStream</code> class or the signature of the <code>serialize()</code> function—has an effect on <em>all</em> users of <code>Document</code>, even those that do
not require serialization. For any change, <em>all</em> the users, including the
<code>exportDocument()</code> function, would need to be recompiled, retested, and, in the
worst case, redeployed (for instance, if delivered in a separate library).
The same thing happens, however, if the <code>Document</code> class is extended
by another function—for instance, an export to another document type. The problem gets bigger the more orthogonal functionality is coupled
in 
<span class="keep-together"><code>Document</code>:</span> any change carries the risk of causing a rippling effect
throughout the codebase. Which is sad indeed, as interfaces should help to
decouple, not introduce artificial coupling.</p>
<p>This<a data-primary="Interface Segregation Principle (ISP)" data-type="indexterm" id="idm45043123069888"/><a data-primary="ISP (Interface Segregation Principle)" data-type="indexterm" id="idm45043123069280"/><a data-primary="design principles" data-secondary="Interface Segregation Principle (ISP)" data-type="indexterm" id="idm45043123068672"/> coupling is caused by a violation of the Interface Segregation
Principle (ISP), which is the <em>I</em> in the <em>SOLID</em> acronym:</p>
<blockquote>
<p>Clients should not be forced to depend on methods that they do not use.<sup><a data-type="noteref" href="ch01.xhtml#idm45043123066176" id="idm45043123066176-marker">31</a></sup></p></blockquote>
<p>The ISP advises separating concerns by segregating (decoupling)
interfaces. In our case, there should be two separate interfaces representing
the two orthogonal aspects of JSON export and serialization:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">JSONExportable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">JSONExportable</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Serializable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Serializable</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Document</code><code class="w"/>
<code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">JSONExportable</code><code class="w"/>
<code class="w">   </code><code class="p">,</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Serializable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>This separation does not make the <code>Document</code> class obsolete. On the contrary,
the 
<span class="keep-together"><code>Document</code></span> class still represents the requirements posed on all documents.
However, this separation of concerns now enables you to minimize dependencies
to only the set of functions that is actually required:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">exportDocument</code><code class="p">(</code><code class="w"> </code><code class="n">JSONExportable</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">exportable</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">exportable</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
<p>In this form, by depending only on the segregated <code>JSONExportable</code> interface,
the <code>exportDocument()</code> function no longer depends on the serialization
functionality and thus no longer depends on the <code>ByteStream</code> class. Thus,
the segregation of interfaces has helped to reduce coupling.</p>
<p>“But isn’t that just a separation of concerns?” you ask. “Isn’t that
just another example of the SRP?” Yes, indeed
it is. I agree that we’ve essentially identified two
orthogonal aspects, separated them, and thus applied the SRP to the <code>Document</code>
interface. Therefore, we could say that ISP and SRP are the same. Or
at least that ISP is a special case of the SRP because of the focus
of the ISP on interfaces. This attitude seems to be the common opinion
in the community, and I agree. However, I still consider it 
<span class="keep-together">valuable</span> to
talk about ISP. Despite the fact that ISP may only be a special case,
I would argue that it’s an important special case. Unfortunately, it is
often very tempting to aggregate unrelated, orthogonal aspects into
an interface. It might even happen to <em>you</em> that you couple separate aspects into an interface. Of course, I would never imply that you did this on
purpose, but unintentionally, accidentally. We often do not pay enough
attention to these details. Of course, you argue, “I would never do that.”
However, in <a data-type="xref" href="ch05.xhtml#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>,
you’ll see an example that might convince you how easily this can happen.
Since changing interfaces later may be extremely difficult, I believe
it pays off to raise awareness of this problem with interfaces. For
that reason, I didn’t drop the ISP but included it as an important and
noteworthy case of the SRP.<a data-primary="" data-startref="ISconcern01" data-type="indexterm" id="idm45043122833600"/><a data-primary="" data-startref="CSOinterface01" data-type="indexterm" id="idm45043122832752"/><a data-primary="" data-startref="SOCinter01" data-type="indexterm" id="idm45043122831904"/></p>
</div></section>
<section data-pdf-bookmark="Minimizing Requirements of Template Arguments" data-type="sect2"><div class="sect2" id="idm45043122830928">
<h2>Minimizing Requirements of Template Arguments</h2>
<p>Although<a data-primary="template arguments" data-secondary="minimizing requirements of" data-type="indexterm" id="idm45043122829360"/><a data-primary="interfaces, separating" data-secondary="template arguments" data-type="indexterm" id="idm45043122828512"/><a data-primary="software design" data-secondary="separating interfaces" data-tertiary="template arguments" data-type="indexterm" id="idm45043122827664"/> it appears as if the ISP is applicable only to base classes, and
although the ISP is mostly introduced by means of object-oriented programming,
the general idea of minimizing the dependencies introduced by interfaces can
also be applied to templates. Consider the <code>std::copy()</code> function, for instance:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">InputIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">OutputIt</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">OutputIt</code><code class="w"> </code><code class="n">copy</code><code class="p">(</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">OutputIt</code><code class="w"> </code><code class="n">d_first</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>In C++20, we could apply <em>concepts</em> to express the requirements:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">input_iterator</code><code class="w"> </code><code class="n">InputIt</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">output_iterator</code><code class="w"> </code><code class="n">OutputIt</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">OutputIt</code><code class="w"> </code><code class="n">copy</code><code class="p">(</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">OutputIt</code><code class="w"> </code><code class="n">d_first</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p><code>std::copy()</code> expects a pair of input iterators as the range to copy
from, and an output iterator to the target range. It explicitly requires
input iterators and output iterators, since it does not need any other
operation. Thus, it minimizes the requirements on the passed arguments.</p>
<p>Let’s assume that <code>std::copy()</code> requires <code>std::forward_iterator</code>
instead of <code>std::input_iterator</code> and <code>std::output_iterator</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">forward_iterator</code><code class="w"> </code><code class="n">ForwardIt</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">forward_iterator</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">OutputIt</code><code class="w"> </code><code class="n">copy</code><code class="p">(</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">d_first</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>This would unfortunately limit the usefulness of the <code>std::copy()</code>
algorithm. We would no longer be able to copy from input streams, since they don’t generally provide the multipass guarantee and do not enable us to write.
That would be unfortunate. However, focusing on dependencies, <code>std::copy()</code> would
now depend on operations and requirements it doesn’t need. And iterators
passed to <code>std::copy()</code> would be forced to provide additional operations,
so <code>std::copy()</code> would force dependencies on them.</p>
<p>This is only a hypothetical example, but it illustrates how
important the separation of concerns in interfaces is. Obviously, the solution
is the realization that input and output capabilities are separate aspects.
Thus, after separating concerns and after applying the ISP, the dependencies are
significantly reduced.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043122640736">
<h5>Guideline 3: Separate Interfaces to Avoid Artificial Coupling</h5>
<ul>
<li>
<p>Be aware that coupling also affects interfaces.</p>
</li>
<li>
<p>Adhere to the Interface Segregation Principle (ISP) to separate concerns in 
<span class="keep-together">interfaces</span>.</p>
</li>
<li>
<p>Consider the ISP as a special case of the Single-Responsibility Principle (SRP).</p>
</li>
<li>
<p>Understand that the ISP helps for both inheritance hierarchies and templates.<a data-primary="" data-startref="SDinter01" data-type="indexterm" id="idm45043122636160"/><a data-primary="" data-startref="ACavoiding01" data-type="indexterm" id="idm45043122635312"/><a data-primary="" data-startref="Cavoiding01" data-type="indexterm" id="idm45043122634464"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 4: Design for Testability" data-type="sect1"><div class="sect1" id="design_for_testability">
<h1>Guideline 4: Design for Testability</h1>
<p>As<a data-primary="software design" data-secondary="testability" data-type="indexterm" id="SDtest01"/><a data-primary="testability" data-secondary="basic guidelines for" data-type="indexterm" id="Tbasic01"/> discussed in <a data-type="xref" href="#understand_the_importance_of_software_design">“Guideline 1: Understand the Importance of 
<span class="keep-together">Software Design</span>”</a>, <em>soft</em>ware changes.
It’s expected to change. But every time you change something in your software, you
run the risk of breaking something. Of course, not intentionally but accidentally,
despite your best efforts. The risk is always there.
As an experienced developer, however, you don’t lose any sleep over that. Let there be

<span class="keep-together">risk—you</span> don’t care. You have something that protects you from accidentally
breaking things, something that keeps the risk at a minimum: your tests.</p>
<p>The purpose of having tests is to be able to assert that all of your software functionality
still works, despite constantly changing things. So obviously, tests are your protection
layer, your life vest. Tests are essential! However, first of all, you have to write the tests.
And in order to write tests and set up this protective layer, your software
needs to be testable: your software must be written in a way that it is possible,
and in the best case even <em>easily</em> possible, to add tests. Which brings us to the heart of
this guideline: software should be designed for testability.</p>
<section data-pdf-bookmark="How to Test a Private Member Function" data-type="sect2"><div class="sect2" id="idm45043122626288">
<h2>How to Test a Private Member Function</h2>
<p>“Of course I have tests,” you argue. “Everyone should have tests. That’s<a data-primary="software design" data-secondary="testability" data-tertiary="private member functions" data-type="indexterm" id="idm45043122623840"/><a data-primary="testability" data-secondary="basic guidelines for" data-tertiary="private member functions" data-type="indexterm" id="idm45043122622752"/><a data-primary="private member functions" data-type="indexterm" id="prmemfunc01"/> common knowledge, isn’t it?” I completely agree. And I believe you that your codebase is equipped with a reasonable test suite.<sup><a data-type="noteref" href="ch01.xhtml#idm45043122620688" id="idm45043122620688-marker">32</a></sup> But surprisingly, despite everyone agreeing to the need
for tests, not every piece of software is written with this awareness in mind.<sup><a data-type="noteref" href="ch01.xhtml#idm45043122618256" id="idm45043122618256-marker">33</a></sup>
In fact, a lot of code is hard to test. And sometimes this is simply because the code is not
designed to be tested.</p>
<p>To give you an idea, I have a challenge for you. Take a look at the
following <code>Widget</code> class. <code>Widget</code> holds a collection of <code>Blob</code> objects, which once in a
while need to be updated. For that purpose, <code>Widget</code> provides the <code>updateCollection()</code>
member function, which we now assume is so important that we need to write a test for
it. And this is my challenge: how would you test the <code>updateCollection()</code> member function?</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">updateCollection</code><code class="p">(</code><code class="w"> </code><code class="cm">/* some arguments needed to update the collection */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">Blob</code><code class="o">&gt;</code><code class="w"> </code><code class="n">blobs_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Potentially other data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>I assume that you immediately see the real challenge: the <code>updateCollection()</code> member
function is declared in the private section of the class. This means that there is no
direct access from the outside and therefore no direct way of testing it.
So take a few seconds to think about this…</p>
<p>“It’s private, yes, but this is still not much of a challenge. There are multiple ways
I can do that,” you say. I agree, there are multiple ways you could try. So please,
go ahead. You weigh your options, then you come up with your first idea: “Well,
the easiest approach would be to test the function via some other, public member
function that internally calls the <code>updateCollection()</code> function.” That sounds like
an interesting first idea. Let’s assume that the collection needs to be updated
when a new <code>Blob</code> is added to it. Calling the <code>addBlob()</code> member function would
trigger the 
<span class="keep-together"><code>updateCollection()</code></span> function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">addBlob</code><code class="p">(</code><code class="w"> </code><code class="n">Blob</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">blob</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">      </code><code class="n">updateCollection</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">updateCollection</code><code class="p">(</code><code class="w"> </code><code class="cm">/* some arguments needed to update the collection */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">Blob</code><code class="o">&gt;</code><code class="w"> </code><code class="n">blobs_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Potentially other data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>Although this sounds like a reasonable thing to do, it’s also something you should
avoid if possible. What<a data-primary="white box tests" data-type="indexterm" id="idm45043122541520"/><a data-primary="testability" data-secondary="basic guidelines for" data-tertiary="white box tests" data-type="indexterm" id="idm45043122454672"/> you are suggesting is a so-called <em>white box test</em>. A white box
test knows about the internal implementation details of some function
and tests based on that knowledge. This introduces a dependency of the
test code on the implementation details of your production code. The problem with this approach
is that software changes. Code changes. Details change. For instance, at some point in the
future, the <code>addBlob()</code> function might be rewritten so it does not have to update the collection
anymore. If this happens, your test no longer performs the task it was written to do. You
would lose your <code>updateCollection()</code> test, potentially without even realizing it. Therefore,
a white box test poses a risk. Just as much as you should avoid and reduce dependencies in
your production code (see <a data-type="xref" href="#understand_the_importance_of_software_design">“Guideline 1: Understand the Importance of 
<span class="keep-together">Software Design</span>”</a>), you should also
avoid dependencies between your tests and the details of your production code.</p>
<p>What<a data-primary="black box tests" data-type="indexterm" id="idm45043122430096"/><a data-primary="testability" data-secondary="basic guidelines for" data-tertiary="black box tests" data-type="indexterm" id="idm45043122429488"/> we really need is a <em>black box test</em>. A black box test does not make
any assumptions about internal implementation details, but tests only for expected
behavior. Of course, this kind of test can also break if you change something, but it
shouldn’t break if some implementation details change—only if the expected behavior
changes.</p>
<p>“OK, I get your point,” you say. “But you don’t suggest making the <code>update​Col⁠lec⁠tion()</code>
function public, do you?” No, rest assured that isn’t what I’m suggesting. Of course,
sometimes this may be a reasonable approach. But in our case, I doubt that this would be
a wise move. The <code>updateCollection()</code> function should not be called just for
fun. It should be called only for a good reason, only at the right time, and probably
to preserve some kind of invariant. This is something we should not entrust a user with. So
no, I don’t think that the function would be a good candidate for the <code>public</code> section.</p>
<p>“OK, good, just checking. Then let’s simply make the test a <code>friend</code> of the <code>Widget</code> class.
This way it would have full access and could call the <code>private</code> member function unhindered”:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="k">class</code><code class="w"> </code><code class="nc">TestWidget</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">updateCollection</code><code class="p">(</code><code class="w"> </code><code class="cm">/* some arguments needed to update the collection */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">Blob</code><code class="o">&gt;</code><code class="w"> </code><code class="n">blobs_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Potentially other data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>Yes, we could add a <code>friend</code>. Let’s assume that there is the <code>TestWidget</code>
test fixture, containing all the tests for the <code>Widget</code> class. We could make this test
fixture a <code>friend</code> of the <code>Widget</code> class. Although this may sound like another reasonable
approach, I unfortunately have to be the spoilsport again. Yes, technically this would solve
the problem, but from a design perspective, we’ve just introduced an artificial dependency
again. By actively changing the production code to introduce the <code>friend</code> declaration, the
production code now knows about the test code. And while the test code should of course know
about the production code (that’s the point of the test code), the production code should
not have to know about the test code. This introduces a cyclic dependency, which is an unfortunate and artificial dependency.</p>
<p>“You sound like this is the worst thing in the world. Is it really that bad?” Well,
sometimes this may actually be a reasonable solution. It definitely is a simple and quick
solution. However,
since right now we have the time to discuss all of our options, there definitely must
be something better than adding a <code>friend</code>.</p>
<div class="note1" data-type="note" epub:type="note"><h6>Note</h6>
<p>I don’t want to make things worse, but in C++ we don’t have a lot of
<code>friend</code>s. Yes, I know, this sounds sad and lonely, but of course I mean the keyword
<code>friend</code>: in C++, <code>friend</code> is not your friend. The reason is that <code>friend</code>s
introduce coupling, mostly artificial coupling, and we should avoid coupling. Of course,
exceptions can be made for the good <code>friend</code>s, the ones you cannot live without, such as
<a href="https://oreil.ly/Lu6rq">hidden friends</a>, or
idiomatic uses of <code>friend</code>, such as the
<a href="https://oreil.ly/qEN0m"><em>Passkey idiom</em></a>. A test is more like a friend
on social media, so declaring a test a <code>friend</code> does not sound like a good choice.</p>
</div>
<p>“OK, then let’s switch from <code>private</code> to <code>protected</code> and make the test derive from 
<span class="keep-together">the
<code>Widget</code></span> class,” you suggest. “This way, the test would gain full access to the

<span class="keep-together"><code>updateCollection()</code></span> function”:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w"> </code><code class="k">protected</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">updateCollection</code><code class="p">(</code><code class="w"> </code><code class="cm">/* some arguments needed to update the collection */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">Blob</code><code class="o">&gt;</code><code class="w"> </code><code class="n">blobs_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Potentially other data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">TestWidget</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">private</code><code class="w"> </code><code class="n">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>Well, I have to admit that technically this approach would work. However,
the fact that you’re suggesting inheritance to solve this issue tells me that
we definitely have to talk about the meaning of inheritance and how to use it properly.
To quote the two pragmatic programmers:<sup><a data-type="noteref" href="ch01.xhtml#idm45043122277712" id="idm45043122277712-marker">34</a></sup></p>
<blockquote>
<p>Inheritance is rarely the answer.</p></blockquote>
<p>Since we’ll be focusing on this topic fairly soon, let me just say that it feels like
we’re abusing inheritance for the sole reason of gaining access to nonpublic member

<span class="keep-together">functions</span>. I’m pretty certain this isn’t why inheritance was invented. Using
inheritance to gain access to the <code>protected</code> section of a class is like the bazooka
approach to something that should be very simple. It is, after all, almost identical to
making the function <code>public</code>, because everyone can easily gain access. It seems we
really haven’t designed the class to be easily testable.</p>
<p>“Come on, what else could we do? Or do you really want me to use the preprocessor and
define all <code>private</code> labels as <code>public</code>?”:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#define private public</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">updateCollection</code><code class="p">(</code><code class="w"> </code><code class="cm">/* some arguments needed to update the collection */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">Blob</code><code class="o">&gt;</code><code class="w"> </code><code class="n">blobs_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Potentially other data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>OK, let’s take a deep breath. Although this last approach may
seem funny, keep in mind that we have now left the range of reasonable
arguments.<sup><a data-type="noteref" href="ch01.xhtml#idm45043122228608" id="idm45043122228608-marker">35</a></sup>
If we seriously consider using the preprocessor to hack our way into the
<code>private</code> section of the <code>Widget</code> class, then all is lost.</p>
</div></section>
<section data-pdf-bookmark="The True Solution: Separate Concerns" data-type="sect2"><div class="sect2" id="idm45043122625376">
<h2>The True Solution: Separate Concerns</h2>
<p>“OK<a data-primary="software design" data-secondary="testability" data-tertiary="separating concerns" data-type="indexterm" id="idm45043122216528"/><a data-primary="testability" data-secondary="basic guidelines for" data-tertiary="separating concerns" data-type="indexterm" id="idm45043122215248"/><a data-primary="concerns, separation of" data-secondary="designing for testability" data-type="indexterm" id="CSOtest01"/><a data-primary="separation of concerns" data-secondary="designing for testability" data-type="indexterm" id="SOCtest01"/> then, what <em>should</em> I do to test the <code>private</code> member function? You
have already discarded all the options.” No, not all the options. We have not yet discussed
the one design approach that I highlighted in <a data-type="xref" href="#design_for_change">“Guideline 2: Design for Change”</a>: separation of
concerns. My approach would be to extract the <code>private</code> member function from the class
and make it a separate entity in our codebase. My preferred solution in this case is to
extract the member function as a free function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">updateCollection</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">Blob</code><code class="o">&gt;&amp;</code><code class="w"> </code><code class="n">blobs</code><code class="w"/>
<code class="w">                     </code><code class="p">,</code><code class="w"> </code><code class="cm">/* some arguments needed to update the collection */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">Blob</code><code class="o">&gt;</code><code class="w"> </code><code class="n">blobs_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Potentially other data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>All calls to the previous member function could be replaced with a call to the free
<code>updateCollection()</code> function by just adding <code>blobs_</code> as the first function argument.
Alternatively, if there is some state attached to the function, we extract it in the form
of another class. Either way, we design the resulting code such that it’s easy, perhaps
even trivial, to test:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">namespace</code><code class="w"> </code><code class="nn">widgetDetails</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">BlobCollection</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">updateCollection</code><code class="p">(</code><code class="w"> </code><code class="cm">/* some arguments needed to update the collection */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">Blob</code><code class="o">&gt;</code><code class="w"> </code><code class="n">blobs_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="p">}</code><code class="w"> </code><code class="c1">// namespace widgetDetails</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">widgetDetails</code><code class="o">::</code><code class="n">BlobCollection</code><code class="w"> </code><code class="n">blobs_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Other data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>“You cannot be serious!” you exclaim. “Isn’t this the worst of all options?
Aren’t we artificially separating two things that belong together? And isn’t the
SRP telling us that we should keep the things that
belong together close to one another?” Well, I don’t think so. On the contrary, I firmly
believe that only now are we adhering to the SRP: the SRP states that we should
isolate the things that do not belong together, the things that can change for different
reasons. Admittedly, at first sight, it may appear as if <code>Widget</code> and <code>updateCollection()</code>
belong together, since after all, the <code>blob_</code> data member needs to be updated once in a
while. However, the fact that the <code>update​Col⁠lection()</code> function isn’t properly testable
is a clear indication that the design does not fit yet: if anything that needs explicit
testing can’t be tested, something is amiss. Why make our lives so much harder and hide
the function to test in the 
<span class="keep-together"><code>private</code></span> section of the <code>Widget</code> class? Since testing plays
a vital role in the presence of change, testing represents just another way to help
decide which things belong together. If the <code>updateCollection()</code>
function is important enough that we want to test it in isolation, then apparently it
changes for a reason other than 
<span class="keep-together"><code>Widget</code></span>. This indicates that <code>Widget</code> and
<code>updateCollection()</code> do not belong together. Based on the SRP, the <code>updateCollection()</code>
function should be extracted from the class.</p>
<p>“But isn’t this against the idea of encapsulation?” you ask. “And don’t you
dare wave away encapsulation. I consider encapsulation to be very important!” I agree,
it is very important, fundamentally so! However, encapsulation<a data-primary="encapsulation" data-type="indexterm" id="idm45043121980912"/>
is just one more reason to separate concerns. As Scott Meyers claims in his book,
<em>Effective C++</em>, extracting 
<span class="keep-together">functions</span> from a class is a step toward increasing
encapsulation. According to Meyers, you should generally prefer nonmember non-<code>friend</code>
functions to member functions.⁠<sup><a data-type="noteref" href="ch01.xhtml#idm45043121978352" id="idm45043121978352-marker">36</a></sup> This is because every member function has full access to every member of a class, even the <code>private</code>
members. However, in the extracted form, the 
<span class="keep-together"><code>updateCollection()</code></span> function is restricted to
just the <code>public</code> interface of the <code>Widget</code> class and is not able to access the <code>private</code>
members. Therefore, these <code>private</code> members become a little more encapsulated. Note that the same
argument holds true for extracting the <code>BlobCollection</code> class: the <code>BlobCollection</code> class
is not able to touch the nonpublic members of the <code>Widget</code> class, and therefore <code>Widget</code>
also becomes a little more encapsulated.</p>
<p>By separating concerns and extracting this piece of functionality, you now gain several
advantages. First, as just discussed, the <code>Widget</code> class becomes more encapsulated.
Fewer members can access the <code>private</code> members. Second, the extracted
<code>update​Col⁠lection()</code> function is easily, even trivially, testable. You don’t even
need a <code>Widget</code> for that but instead can either pass <code>std::vector&lt;Blob&gt;</code> as the first
argument (not the implicit first argument of any member function, the <code>this</code> pointer)
or call the <code>public</code> member function. Third, you don’t have to change any other
aspect in the 
<span class="keep-together"><code>Widget</code></span> class: you simply pass the <code>blobs_</code> member to the <code>updateCollection()</code>
function whenever you need to update the collection. No need to
add any other <code>public</code> getter. And, probably most importantly, you can now change
the function in isolation, without having to deal with <code>Widget</code>. This indicates
that you have reduced dependencies. While in the initial setup the <code>updateCollection()</code>
function was tightly coupled to the <code>Widget</code> class (yes, the <code>this</code> pointer), we have
now severed these ties. The 
<span class="keep-together"><code>updateCollection()</code></span> function is now a separate service that
might even be reused.</p>
<p>I can see that you still have questions. Maybe you’re concerned that this means
you shouldn’t have any member functions anymore. No, to be clear, I did not suggest
that you should extract each and every member function from your classes. I merely
suggested you take a closer look at those functions that need to be tested but are
placed in the <code>private</code> section of your class. Also, you might wonder how this works
with virtual functions, which cannot be extracted in the form of a free function. Well,
there’s no quick answer for that, but it’s something that we will deal with in many
different ways throughout this book. My objective will always be to reduce coupling
and to increase testability, even by separating virtual functions.</p>
<p>In summary, do not hinder your design and testability with artificial coupling and
artificial boundaries. Design for testability. Separate concerns. Free your functions!</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043121964144">
<h5>Guideline 4: Design for Testability</h5>
<ul>
<li>
<p>Understand that tests are your protection layer against accidentally breaking things.</p>
</li>
<li>
<p>Keep in mind that tests are essential, and so is testability.</p>
</li>
<li>
<p>Separate concerns for the sake of testability.</p>
</li>
<li>
<p>Consider <code>private</code> member functions that need testing to be misplaced.</p>
</li>
<li>
<p>Prefer nonmember non-<code>friend</code> functions to member functions.<a data-primary="" data-startref="SDtest01" data-type="indexterm" id="idm45043121958304"/><a data-primary="" data-startref="prmemfunc01" data-type="indexterm" id="idm45043121957456"/><a data-primary="" data-startref="Tbasic01" data-type="indexterm" id="idm45043121956608"/><a data-primary="" data-startref="SOCtest01" data-type="indexterm" id="idm45043121955760"/><a data-primary="" data-startref="CSOtest01" data-type="indexterm" id="idm45043121954912"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 5: Design for Extension" data-type="sect1"><div class="sect1" id="design_for_extension">
<h1>Guideline 5: Design for Extension</h1>
<p>There<a data-primary="software design" data-secondary="extension" data-type="indexterm" id="SDext01"/><a data-primary="extensions, designing for" data-type="indexterm" id="EXdesign01"/> is an important aspect about changing software that I haven’t
highlighted yet: extensibility. Extensibility should be one of the primary
goals of your design. Because, frankly speaking, if you’re no longer
able to add new functionality to your code then your code has reached
the end of its lifetime. Thus, adding new functionality—extending the
codebase—is of fundamental interest. For that reason, extensibility
should indeed be one of your primary goals and a driving factor for
good software design.</p>
<section data-pdf-bookmark="The Open-Closed Principle" data-type="sect2"><div class="sect2" id="idm45043121950000">
<h2>The Open-Closed Principle</h2>
<p>Design<a data-primary="extensions, designing for" data-secondary="Open-Closed Principle (OCP)" data-type="indexterm" id="idm45043121947824"/><a data-primary="software design" data-secondary="extension" data-tertiary="Open-Closed Principle (OCP)" data-type="indexterm" id="idm45043121946976"/><a data-primary="Open-Closed Principle (OCP)" data-type="indexterm" id="OCP01"/><a data-primary="design principles" data-secondary="Open-Closed Principle (OCP)" data-type="indexterm" id="DPopen01"/><a data-primary="OCP (Open-Closed Principle)" data-type="indexterm" id="OCPring01"/> for extension is unfortunately not something that just falls into your lap or magically materializes. No,
you will have to explicitly take extensibility into account when
designing software. We’ve already seen
an example of a naive approach of serializing documents in
<a data-type="xref" href="#design_for_change">“Guideline 2: Design for Change”</a>. In that context, we used a <code>Document</code> base
class with a pure virtual <code>serialize()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Document</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Document</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>Since <code>serialize()</code> is a pure virtual function, it needs to be
implemented by all deriving classes, including the <code>PDF</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">PDF</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Document</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>So far, so good. The interesting question is: how do we implement the
<code>serialize()</code> member function? One requirement is that at a later point
in time we are able to convert the bytes back into a <code>PDF</code> instance (we want to deserialize bytes back to a PDF). For that purpose, it is
essential to store the information that the bytes represent. In
<a data-type="xref" href="#design_for_change">“Guideline 2: Design for Change”</a>, we accomplished this with an 
<span class="keep-together">enumeration:</span></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">enum</code><code class="w"> </code><code class="k">class</code><code class="w"> </code><code class="nc">DocumentType</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">pdf</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="n">word</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Potentially many more document types</code>
<code class="p">};</code><code class="w"/></pre>
<p>This enumeration can now be used by all derived classes to put the type
of the document at the beginning of the byte stream. This way, during
deserialization, it’s easy to detect which kind of document is stored.
Sadly, this design choice turns out to be an unfortunate decision.
With that enumeration, we have accidentally coupled all kinds of
document: the <code>PDF</code> class knows
about the Word format. And of course the corresponding <code>Word</code> class would
know about the PDF format. Yes, you are correct—they don’t know about
the implementation details, but they are still aware of each other.</p>
<p>This coupling situation is illustrated in <a data-type="xref" href="#fig_ocp_strong_coupling">Figure 1-5</a>.
From an architectural point of view, the <code>DocumentType</code> enumeration
resides on the same level as the <code>PDF</code> and <code>Word</code> classes. Both
types of documents use (and thus depend on) the <code>DocumentType</code>
<span class="keep-together">enumeration.</span></p>
<figure><div class="figure" id="fig_ocp_strong_coupling">
<img alt="cpsd 0105" height="380" src="assets/cpsd_0105.png" width="1393"/>
<h6><span class="label">Figure 1-5. </span>Artificial coupling of different document types via the <code>DocumentType</code>
<span class="keep-together">enumeration</span>.</h6>
</div></figure>
<p>The problem with this becomes obvious if we try to extend the functionality.
Next to PDF and Word, we now also want to support a plain XML format. Ideally, all we should have to do is add the <code>XML</code> class as deriving from the <code>Document</code> class. But, unfortunately, we also
have to adapt the <code>DocumentType</code> enumeration:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">enum</code><code class="w"> </code><code class="k">class</code><code class="w"> </code><code class="nc">DocumentType</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">pdf</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="n">word</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="n">xml</code><code class="p">,</code><code class="w">   </code><code class="c1">// The new type of document</code>
<code class="w">   </code><code class="c1">// ... Potentially many more document types</code>
<code class="p">};</code><code class="w"/></pre>
<p>This change will at least cause all the other document types (PDF,
Word, etc.) to recompile. Now you may just shrug your shoulders and think, “Oh well! It just needs to recompile.” Well, note that I said <em>at least</em>. In the worst case, this design has significantly limited others to extend the code—i.e., to add new kinds of documents—because not everyone is able to extend the <code>DocumentType</code> enumeration. No, this kind of coupling just doesn’t feel right: <code>PDF</code> and <code>Word</code> should be entirely unaware of the new <code>XML</code> format. They shouldn’t see
or feel a thing, not even a recompilation.</p>
<p>The problem in this example can be explained as a violation of the
Open-Closed Principle (OCP). The OCP is the second of the SOLID
principles. It advises us to design software such that it is
easy to make the necessary extensions:<sup><a data-type="noteref" href="ch01.xhtml#idm45043121676880" id="idm45043121676880-marker">37</a></sup></p>
<blockquote>
<p>Software artifacts (classes, modules, functions, etc.) should be open for
extension, but closed for modification.</p></blockquote>
<p>The OCP tells us that we should be able to extend our software (open
for extension). However, the extension should be easy and, in the best case,
possible by just adding new code. In other words, we shouldn’t have to
modify existing code (closed for modification).</p>
<p>In theory, the extension should be easy: we should only have to add the
new derived class <code>XML</code>. This new class alone would not require any
modifications in any other piece of code. Unfortunately, the
<code>serialize()</code> function artificially couples the different kinds of
documents and requires a modification of the <code>DocumentType</code> enumeration.
This modification, in turn, has an impact on the other types of <code>Document</code>,
which is exactly what the OCP advises against.</p>
<p>Luckily, we’ve already seen a solution for how to achieve that for the
<code>Document</code> example. In this case, the right thing to do is to separate
concerns (see <a data-type="xref" href="#fig_ocp_weak_coupling">Figure 1-6</a>).</p>
<p>By separating concerns, by grouping the things that truly belong together,
the accidental coupling between different kinds of documents is gone. All
code dealing with serialization is now properly grouped inside the
<code>Serialization</code> component, which can logically reside on another level of
the architecture. <code>Serialization</code> depends on all types of documents (PDF,
Word, XML, etc.), but none of the document types depend on
<code>Serialization</code>. In addition, none of the documents are aware of
any other type of document (as it should be).</p>
<figure><div class="figure" id="fig_ocp_weak_coupling">
<img alt="cpsd 0106" height="665" src="assets/cpsd_0106.png" width="1393"/>
<h6><span class="label">Figure 1-6. </span>Separation of concerns resolves the violation of the OCP</h6>
</div></figure>
<p>“Wait a second!” you say. “In the code for the serialization, we still
need the enumeration, don’t we? How else would I store the information
about what the stored bytes represent?” I’m glad you’re making this
observation. Yes, inside the 
<span class="keep-together"><code>Serialization</code></span> component we will still (very
likely) need something like the <code>DocumentType</code> enumeration. However, by separating concerns, we have properly resolved this dependency problem. None
of the different types of documents depends on the <code>DocumentType</code> enumeration
anymore. All dependency arrows now go from the low level (the 
<span class="keep-together"><code>Serialization</code></span>
component) to the high level (<code>PDF</code> and <code>Word</code>). And that property is essential
for a proper, good architecture.</p>
<p>“But what about adding a new type of document? Doesn’t that require a
modification in the <code>Serialization</code> component?” Again, you are absolutely
correct. Still, this is not a violation of OCP, which advises that we
should not have to modify existing code on the same architectural level or
on higher levels. However, there is no way you can control or prevent
modifications on the lower levels. <code>Serialization</code> <em>must</em> depend on all
types of documents and therefore <em>must</em> be adapted for every new type of
document. For that reason, <code>Serialization</code> must
reside on a lower level (think <em>depending</em> level) of our architecture.</p>
<p>As also discussed in <a data-type="xref" href="#design_for_change">“Guideline 2: Design for Change”</a>, the solution in this example
is the separation of concerns. Thus, it appears as if the real solution is
to adhere to the SRP. For that reason,
there are some critical voices that don’t consider the OCP a separate
principle but the same as the SRP. I admit that I
understand this reasoning. Very often the separation of concerns already
leads to the desired extensibility. It’s something we will experience
multiple times throughout this book, in 
<span class="keep-together">particular</span> when we talk about
design patterns. Thus, it stands to reason that SRP and OCP are related
or even the same.</p>
<p>On the other hand, in this example we have seen that there are
some specific, architectural considerations about the OCP that we didn’t
take into account while talking about the SRP. Also, as we will
experience in <a data-type="xref" href="ch04.xhtml#design_for_the_addition_of_types_or_operations">“Guideline 15: Design for the Addition of 
<span class="keep-together">Types or Operations</span>”</a>, we will
often have to make explicit decisions about what we want to extend and
how we want to extend it. That decision can significantly influence how we apply the SRP and the way we design our software. Therefore, the OCP seems to be more about the
awareness of extensions and conscious decisions about extensions than
the SRP. As such, it is perhaps a little more than just an
afterthought of the SRP. Or perhaps it just depends.<sup><a data-type="noteref" href="ch01.xhtml#idm45043121655248" id="idm45043121655248-marker">38</a></sup></p>
<p>Either way, this example indisputably demonstrates that extensibility
should be explicitly considered during software design, and that the desire
for extending our software in a specific way is an excellent indication for
the need to separate concerns. It is important to understand how software
will be extended, to identify such<a data-primary="customization points" data-type="indexterm" id="idm45043121654224"/> <em>customization points</em>, and to design
so that this kind of extension can be performed easily.<a data-primary="" data-startref="OCP01" data-type="indexterm" id="idm45043121652976"/><a data-primary="" data-startref="EXdesign01" data-type="indexterm" id="idm45043121652000"/><a data-primary="" data-startref="DPopen01" data-type="indexterm" id="idm45043121651056"/><a data-primary="" data-startref="OCPring01" data-type="indexterm" id="idm45043121650112"/></p>
</div></section>
<section data-pdf-bookmark="Compile-Time Extensibility" data-type="sect2"><div class="sect2" id="idm45043121949088">
<h2>Compile-Time Extensibility</h2>
<p>The<a data-primary="software design" data-secondary="extension" data-tertiary="compile-time extensibility" data-type="indexterm" id="idm45043121647904"/><a data-primary="extensions, designing for" data-secondary="compile-time extensibility" data-type="indexterm" id="idm45043121646656"/><a data-primary="compile-time extensibility" data-type="indexterm" id="comtimex01"/> <code>Document</code> example may give the impression that all of these design
considerations apply to runtime polymorphism. No, absolutely
not: the same considerations and the same arguments also apply to compile-time
problems. To illustrate this, I now reach for a couple
of examples from the Standard Library. Of course, it is of utmost interest
that you’re able to extend the Standard Library. Yes, you’re supposed to
<em>use</em> the Standard Library, but you are also encouraged to build on it and
add your own pieces of functionality. For that reason, the Standard Library
is designed for extensibility. But interestingly, it isn’t using base classes
for that purpose, but primarily builds on function overloading, templates,
and (class) template specialization.</p>
<p>An excellent example of extension by function overloading is the
<code>std::swap()</code> algorithm. Since C++11, <code>std::swap()</code> has been defined
in this way:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">namespace</code><code class="w"> </code><code class="nn">std</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="o">&amp;</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="o">&amp;</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">T</code><code class="w"> </code><code class="nf">tmp</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">a</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">b</code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">tmp</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="p">}</code><code class="w"> </code><code class="c1">// namespace std</code></pre>
<p>Due to the fact that <code>std::swap()</code> is defined as a function template,
you can use it for any type: fundamental types like <code>int</code> and <code>double</code>,
Standard Library types like <code>std::string</code>, and, of course, your own
types. However, there may be some types that require special attention,
some types that cannot or should not be swapped by means of <code>std::swap()</code>
(for instance, because they cannot be efficiently moved) but could still
be swapped efficiently by different means. But still, it’s expected that
value types can be swapped, as it is also expressed by
<a href="https://oreil.ly/Peqhm">Core Guideline C.83</a>:<sup><a data-type="noteref" href="ch01.xhtml#idm45043121526144" id="idm45043121526144-marker">39</a></sup></p>
<blockquote>
<p>For value-like types, consider providing a <code>noexcept</code> swap function.</p></blockquote>
<p>In such a case, you can overload <code>std::swap()</code> for your own type:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">namespace</code><code class="w"> </code><code class="nn">custom</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">CustomType</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Implementation that requires a special form of swap */</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">swap</code><code class="p">(</code><code class="w"> </code><code class="n">CustomType</code><code class="o">&amp;</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">CustomType</code><code class="o">&amp;</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Special implementation for swapping two instances of type 'CustomType' */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="p">}</code><code class="w"> </code><code class="c1">// namespace custom</code></pre>
<p>If <code>swap()</code> is used correctly, this custom function will perform a
special kind of swap operation on two instances of <code>CustomType</code>:<sup><a data-type="noteref" href="ch01.xhtml#idm45043121480288" id="idm45043121480288-marker">40</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">some_function</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="o">&amp;</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">T</code><code class="w"> </code><code class="nf">tmp</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">swap</code><code class="p">;</code><code class="w">     </code><code class="c1">// Enable the compiler to consider std::swap for the</code>
<code class="w">                        </code><code class="c1">// subsequent call</code>
<code class="w">   </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">tmp</code><code class="p">,</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">);</code><code class="w">  </code><code class="c1">// Swap the two values; thanks to the unqualified call</code>
<code class="w">                        </code><code class="c1">// and thanks to ADL this would call 'custom::swap()'</code>
<code class="w">   </code><code class="c1">// ...               // in case 'T' is 'CustomType'</code>
<code class="p">}</code><code class="w"/></pre>
<p>Obviously, <code>std::swap()</code> is designed as a<a data-primary="customization points" data-type="indexterm" id="idm45043121384592"/> <em>customization point</em>, allowing
you to plug in new custom types and behavior. The same is true of all
algorithms in the Standard Library. Consider, for instance, <code>std::find()</code>
and <code>std::find_if()</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">InputIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">constexpr</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">find</code><code class="p">(</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">InputIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">UnaryPredicate</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">constexpr</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">find_if</code><code class="p">(</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">UnaryPredicate</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>By means of the template parameters, and implicitly, the corresponding concepts,
<code>std::find()</code> and <code>std::find_if()</code> (just as all other algorithms) enable
you to use your own (iterator) types to perform a search. In addition,
<code>std::find_if()</code> allows you to customize how the comparison of
elements is handled. Thus, these functions are definitely designed for
extension and customization.</p>
<p>The last kind of <em>customization point</em> is template specialization. This
approach is, for instance, used by the <code>std::hash</code> class template. Assuming
the <code>CustomType</code> from the <code>std::swap()</code> example, we can specialize
<code>std::hash</code> explicitly:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">std</code><code class="o">::</code><code class="n">hash</code><code class="o">&lt;</code><code class="n">CustomType</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="kt">size_t</code><code class="w"> </code><code class="nf">operator</code><code class="p">()(</code><code class="w"> </code><code class="n">CustomType</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">noexcept</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="cm">/*...*/</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>The design of <code>std::hash</code> puts you in a position to adapt its behavior
for any custom type. Most noteworthy, you are not required
to modify any existing code; it’s enough to provide this separate
specialization to adapt to special requirements.</p>
<p>Almost the entire Standard Library is designed for extension and
customization. This shouldn’t come as a surprise, however,
because the Standard Library is supposed to represent one of the
highest levels in your architecture. Thus, the Standard Library
cannot depend on anything in your code, but you depend entirely on
the Standard Library.<a data-primary="" data-startref="comtimex01" data-type="indexterm" id="idm45043121162256"/></p>
</div></section>
<section data-pdf-bookmark="Avoid Premature Design for Extension" data-type="sect2"><div class="sect2" id="idm45043121648912">
<h2>Avoid Premature Design for Extension</h2>
<p>The<a data-primary="software design" data-secondary="extension" data-tertiary="premature design for" data-type="indexterm" id="idm45043121160080"/><a data-primary="extensions, designing for" data-secondary="premature design" data-type="indexterm" id="idm45043121158800"/> C++ Standard Library is a great example
of designing for extension. Hopefully it gives you a feeling for how
important extensibility really is. However, although extensibility is
important, this doesn’t mean that you should automatically, without
reflection, reach for either base classes or templates for every possible
implementation detail just to guarantee extensibility in the future.
Just as you shouldn’t prematurely separate concerns, you should also
not prematurely design for extension. Of course, if you have a good
idea about how your code will evolve, then by all means, go ahead and
design it accordingly. However, remember the YAGNI principle: if you
do not know how the code will evolve, then it may be wise to wait, instead
of anticipating an extension that will never happen. Perhaps the next
extension will give you an idea about future extensions,
which puts you in a position to refactor the code such that subsequent
extensions are easy. Otherwise you might run into the problem that favoring
one kind of extension makes other kinds of extensions much more difficult
(see, for instance, <a data-type="xref" href="ch04.xhtml#design_for_the_addition_of_types_or_operations">“Guideline 15: Design for the Addition of 
<span class="keep-together">Types or Operations</span>”</a>).
That is something you should avoid, if possible.</p>
<p>In summary, designing for extension is an important part of design for
change. Therefore, explicitly keep an eye out for pieces of functionality
that are expected to be extended and design the code so that extension
is easy.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043121147200">
<h5>Guideline 5: Design for Extension</h5>
<ul>
<li>
<p>Favor design that makes it easy to extend code.</p>
</li>
<li>
<p>Adhere to the Open-Closed Principle (OCP) to keep code open for extension but closed for modification.</p>
</li>
<li>
<p>Design for code additions by means of base classes, templates, function overloading, or template specialization.</p>
</li>
<li>
<p>Avoid premature abstraction if you are not sure about the next addition.<a data-primary="" data-startref="SDext01" data-type="indexterm" id="idm45043121142752"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45043124162128"><sup><a href="ch01.xhtml#idm45043124162128-marker">1</a></sup> But of course you would never even try to print the current C++ standard. You would either use a PDF of the <a href="https://oreil.ly/bZUDd">official C++ standard</a> or use the <a href="https://oreil.ly/r46ta">current working draft</a>. For most of your daily work, however, you might want to refer to <a href="https://oreil.ly/z0tKS">the C++ reference site</a>.</p><p data-type="footnote" id="idm45043137738976"><sup><a href="ch01.xhtml#idm45043137738976-marker">2</a></sup> Unfortunately, I can’t present any numbers, as I can hardly say that I have a complete overview of the vast realm of C++. On the contrary, I might not even have a complete overview of the sources I’m aware of! So please consider this as my personal impression and the way I perceive the C++ community. You may have a different impression.</p><p data-type="footnote" id="idm45043125488704"><sup><a href="ch01.xhtml#idm45043125488704-marker">3</a></sup> Whether or not the code modification is risky may very much depend on your test coverage. A good test coverage may actually absorb some of the damage bad software design may cause.</p><p data-type="footnote" id="idm45043123493296"><sup><a href="ch01.xhtml#idm45043123493296-marker">4</a></sup> Kent Beck, <em>Test-Driven Development: By Example</em> (Addison-Wesley, 2002).</p><p data-type="footnote" id="idm45043126004560"><sup><a href="ch01.xhtml#idm45043126004560-marker">5</a></sup> Robert C. Martin, <em>Clean Architecture</em> (Addison-Wesley, 2017).</p><p data-type="footnote" id="idm45043124440192"><sup><a href="ch01.xhtml#idm45043124440192-marker">6</a></sup> These are indeed my own words, as there is no single, common definition of software design. Consequently, you may have your own definition of what software design entails and that is perfectly fine. However, note that this book, including the discussion of design patterns, is based on my definition.</p><p data-type="footnote" id="idm45043124165840"><sup><a href="ch01.xhtml#idm45043124165840-marker">7</a></sup> Just to be clear: computer science is a science (it’s in the name). Software <em>engineering</em> appears to be a hybrid form of science, craft, and art. And one aspect of the latter is software <em>design</em>.</p><p data-type="footnote" id="idm45043123335424"><sup><a href="ch01.xhtml#idm45043123335424-marker">8</a></sup> With this metaphor, I’m not trying to imply that architects for buildings work at the construction site all day. Very likely, such an architect spends as much time in a comfy chair and in front of a computer as people like you and me. But I think you get the point.</p><p data-type="footnote" id="idm45043130422608"><sup><a href="ch01.xhtml#idm45043130422608-marker">9</a></sup> Substitution Failure Is Not An Error (SFINAE) is a basic template mechanism commonly used as a substitute for C++20 concepts to constrain templates. For an explanation of SFINAE and <code>std::enable_if</code> in particular, refer to your favorite textbook about C++ templates. If you don’t have any, a great choice is the C++ template bible: David Vandevoorde, Nicolai Josuttis, and Douglas Gregor’s <em>C++ Templates: The Complete Guide</em> (Addison-Wesley).</p><p data-type="footnote" id="idm45043124605168"><sup><a href="ch01.xhtml#idm45043124605168-marker">10</a></sup> For a lot more information on physical and logical dependency management, see John Lakos’s “dam” book, <em>Large-Scale C++ Software Development: Process and Architecture</em> (Addison-Wesley).</p><p data-type="footnote" id="idm45043123295968"><sup><a href="ch01.xhtml#idm45043123295968-marker">11</a></sup> Martin Fowler, “Who Needs an Architect?” <em>IEEE Software</em>, 20, no. 5 (2003), 11–13, <a href="https://doi.org/10.1109/MS.2003.1231144"><em class="hyperlink">https://doi.org/10.1109/MS.2003.1231144</em></a>.</p><p data-type="footnote" id="idm45043124008192"><sup><a href="ch01.xhtml#idm45043124008192-marker">12</a></sup> A very good introduction to microservices can be found in Sam Newman’s book <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/building-microservices-2nd/9781492034018/"><em>Building Microservices: Designing
Fine-Grained Systems</em></a>, 2nd ed. (O’Reilly).</p><p data-type="footnote" id="idm45043130766672"><sup><a href="ch01.xhtml#idm45043130766672-marker">13</a></sup> Mark Richards and Neal Ford, <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/fundamentals-of-software/9781492043447/"><em>Fundamentals of Software
Architecture: An Engineering Approach</em></a> (O’Reilly, 2020).</p><p data-type="footnote" id="idm45043131054400"><sup><a href="ch01.xhtml#idm45043131054400-marker">14</a></sup> The term <em>implementation pattern</em> was first used in Kent Beck’s book <em>Implementation Patterns</em> (Addison-Wesley). In this book, I’m using that term to provide a clear distinction from the term <em>design pattern</em>, since the term <em>idiom</em> may refer to a pattern on either the Software Design level or the<a data-primary="Implementation Details level" data-type="indexterm" id="idm45043124266144"/> Implementation Details level. I will use the term consistently to refer to commonly used solutions on the Implementation Details level.</p><p data-type="footnote" id="idm45043125635792"><sup><a href="ch01.xhtml#idm45043125635792-marker">15</a></sup> Second-favorite after this one, of course. If this is your only book, then you might refer to the classic <em>Effective C++: 55 Specific Ways to Improve Your Programs and Designs</em>, 3rd ed., by Scott Meyers (Addison-Wesley).</p><p data-type="footnote" id="idm45043123823504"><sup><a href="ch01.xhtml#idm45043123823504-marker">16</a></sup> The Template Method and Bridge design patterns are 2 of the 23 classic design patterns introduced in the so-called Gang of Four (GoF) book by Erich Gamma et al., <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. I won’t go into detail about the Template Method in this book, but you’ll find good explanations in various textbooks, including the GoF book itself. I will, however, explain the Bridge design pattern in <a data-type="xref" href="ch07.xhtml#build_bridges_to_remove_physical_dependencies">“Guideline 28: Build Bridges to Remove 
<span class="keep-together">Physical Dependencies</span>”</a>.</p><p data-type="footnote" id="idm45043123657936"><sup><a href="ch01.xhtml#idm45043123657936-marker">17</a></sup> Bjarne Stroustrup, <em>The C++ Programming Language</em>, 3rd ed. (Addison-Wesley, 2000).</p><p data-type="footnote" id="idm45043123631872"><sup><a href="ch01.xhtml#idm45043123631872-marker">18</a></sup> Kudos to John Lakos, who argues similarly and uses C++98 in his book, <em>Large-Scale C++ Software Development: Process and Architecture</em> (Addison-Wesley).</p><p data-type="footnote" id="idm45043124608352"><sup><a href="ch01.xhtml#idm45043124608352-marker">19</a></sup> Yes, Ben and Jason, you have read correctly, I will not <code>constexpr</code> ALL the things. See Ben Deane and Jason Turner, <a href="https://oreil.ly/Pazfb">“constexpr ALL the things”</a>, CppCon 2017.</p><p data-type="footnote" id="idm45043124044208"><sup><a href="ch01.xhtml#idm45043124044208-marker">20</a></sup> Michael Feathers, <em>Working Effectively with Legacy Code</em> (Addison-Wesley, 2013).</p><p data-type="footnote" id="idm45043123834288"><sup><a href="ch01.xhtml#idm45043123834288-marker">21</a></sup> David Thomas and Andrew Hunt, <em>The Pragmatic Programmer: Your Journey to Mastery</em>, 20th Anniversary Edition (Addison Wesley, 2019).</p><p data-type="footnote" id="idm45043123832000"><sup><a href="ch01.xhtml#idm45043123832000-marker">22</a></sup> Tom DeMarco, <em>Structured Analysis and System Specification</em> (Prentice Hall, 1979).</p><p data-type="footnote" id="idm45043124286736"><sup><a href="ch01.xhtml#idm45043124286736-marker">23</a></sup> SOLID is an acronym of acronyms, an abbreviation of the five principles described in the next few guidelines: SRP, OCP, LSP, ISP, and DIP.</p><p data-type="footnote" id="idm45043123403072"><sup><a href="ch01.xhtml#idm45043123403072-marker">24</a></sup> The first book on the SOLID principles was Robert C. Martin’s <em>Agile Software Development: Principles, Patterns, and Practices</em> (Pearson). A newer and much cheaper alternative is <em>Clean Architecture</em>, also from Robert C. Martin (Addison-Wesley).</p><p data-type="footnote" id="idm45043123603040"><sup><a href="ch01.xhtml#idm45043123603040-marker">25</a></sup> Don’t forget that the design decisions taken by that external library may impact your own design, which would obviously increase the coupling.</p><p data-type="footnote" id="idm45043124305408"><sup><a href="ch01.xhtml#idm45043124305408-marker">26</a></sup> That includes the classes that other people may have written, i.e., classes that you do not control. And no, the other people won’t be happy about the change. Thus, the change may be <em>really</em> difficult.</p><p data-type="footnote" id="idm45043128374128"><sup><a href="ch01.xhtml#idm45043128374128-marker">27</a></sup> An enumeration seems to be an obvious choice, but of course there are other options as well. In the end, we need an agreed-upon set of values that represent the different document formats in the byte representation.</p><p data-type="footnote" id="idm45043129091136"><sup><a href="ch01.xhtml#idm45043129091136-marker">28</a></sup> You might be wondering about the explicit use of the <code>explicit</code> keyword for this constructor. Then you might also be aware that <a href="https://oreil.ly/1DPsA">Core Guideline C.46</a> advises using <code>explicit</code> by default for single-argument constructors. This is really good and highly recommended advice, as it prevents unintentional, potentially undesirable conversions. While not as valuable, the same advice is also reasonable for all the other constructors, except for the copy and move constructors, which don’t perform a conversion. At least it doesn’t hurt.</p><p data-type="footnote" id="idm45043128523184"><sup><a href="ch01.xhtml#idm45043128523184-marker">29</a></sup> You might realize I’ve picked the names of the three conferences I regularly attend: <a href="https://cppcon.org">CppCon</a>, <a href="http://meetingcpp.com">Meeting C++</a>, and <a href="https://cpponsea.uk">C++ on Sea</a>. There are many more C++ conferences, though. To give a few examples: <a href="https://accu.org/conf-main/main">ACCU</a>, <a href="https://corecpp.org">Core C++</a>, <a href="https://www.pacificplusplus.com">pacific++</a>, <a href="https://cppnorth.ca">CppNorth</a>, <a href="https://www.embo.io">emBO++</a>, and <a href="https://cppp.fr">CPPP</a>. Conferences are a great and fun way to stay up to date with C++. Make sure to check out <a href="https://isocpp.org">the Standard C++ Foundation home page</a> for any upcoming conferences.</p><p data-type="footnote" id="idm45043128758896"><sup><a href="ch01.xhtml#idm45043128758896-marker">30</a></sup> Katerina Trajchevska, <a href="https://oreil.ly/cwo8Y">“Becoming a Better Developer by Using the SOLID Design Principles”</a>, Laracon EU, August 30–31, 2018.</p><p data-type="footnote" id="idm45043123066176"><sup><a href="ch01.xhtml#idm45043123066176-marker">31</a></sup> Robert C. Martin, <em>Agile Software Development: Principles, Patterns, and Practices</em>.</p><p data-type="footnote" id="idm45043122620688"><sup><a href="ch01.xhtml#idm45043122620688-marker">32</a></sup> If you don’t have a test suite in place, then you have work to do. Seriously. A very coherent reference to get started is Ben Saks’s talk on unit tests, <a href="https://oreil.ly/VBo9X">“Back to Basics: Unit Tests”</a>, from CppCon 2020. A second, very good reference to wrap your mind around the whole topic of testing and test-driven development in particular is Jeff Langr’s book, <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/modern-c-programming/9781941222423/"><em>Modern C{plus}{plus} Programming with Test-Driven Development</em></a> (O’Reilly).</p><p data-type="footnote" id="idm45043122618256"><sup><a href="ch01.xhtml#idm45043122618256-marker">33</a></sup> I know, “everyone agrees” is unfortunately far from reality. If you need proof that the seriousness of tests has not yet reached every project and every developer, take a look at <a href="https://oreil.ly/NuEua">this issue</a> from the OpenFOAM issue tracker.</p><p data-type="footnote" id="idm45043122277712"><sup><a href="ch01.xhtml#idm45043122277712-marker">34</a></sup> David Thomas and Andrew Hunt, <em>The Pragmatic Programmer: Your Journey to Mastery</em>.</p><p data-type="footnote" id="idm45043122228608"><sup><a href="ch01.xhtml#idm45043122228608-marker">35</a></sup> We may even have entered the scary realm of undefined behavior.</p><p data-type="footnote" id="idm45043121978352"><sup><a href="ch01.xhtml#idm45043121978352-marker">36</a></sup> You can find this compelling argument in item 23 of Scott Meyers’s <em>Effective C++</em>.</p><p data-type="footnote" id="idm45043121676880"><sup><a href="ch01.xhtml#idm45043121676880-marker">37</a></sup> Bertrand Meyer, <em>Object-Oriented Software Construction</em>, 2nd ed. (Pearson, 2000).</p><p data-type="footnote" id="idm45043121655248"><sup><a href="ch01.xhtml#idm45043121655248-marker">38</a></sup> The answer “It depends!” will of course satisfy even the strongest critics of the OCP.</p><p data-type="footnote" id="idm45043121526144"><sup><a href="ch01.xhtml#idm45043121526144-marker">39</a></sup> The <a href="https://oreil.ly/PGze4">C++ Core Guidelines</a> are a community effort to collect and agree on a set of guidelines for writing good C++ code. They best represent the common sense of what idiomatic C++ is. You can find these guidelines on <a href="https://oreil.ly/PGze4">GitHub</a>.</p><p data-type="footnote" id="idm45043121480288"><sup><a href="ch01.xhtml#idm45043121480288-marker">40</a></sup> The abbreviation ADL refers to Argument Dependent Lookup. See the <a href="https://oreil.ly/lRSZD">CppReference</a> or my <a href="https://oreil.ly/3f7Zo">CppCon 2020 talk</a> for an introduction.</p></div></div></section></div></body></html>