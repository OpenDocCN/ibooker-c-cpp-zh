<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 10. Implementing Logging Functionality" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_story_logging">
<h1><span class="label">Chapter 10. </span>Implementing Logging Functionality</h1>
<p>Choosing<a data-primary="design patterns" data-secondary="selecting" data-type="indexterm" id="idm45587910626832"/> the right patterns in the right situations helps a lot when designing software. But sometimes it is difficult to find the right pattern and to decide when to apply it. You can find guidance for that in the context and problem sections of the patterns from <a data-type="xref" href="part01.xhtml#part_1">Part I</a> of this book. But usually it is much easier to understand how to do something by looking at a concrete example.</p>
<p>This chapter tells the story of applying the patterns from <a data-type="xref" href="part01.xhtml#part_1">Part I</a> of this book to a running example that was abstracted from an industrial-strength implementation of a logging system. To keep the example code easy to grasp, not all aspects of the original industrial-strength code are covered. For example, the code design does not focus on performance or testability aspects. Still, the example nicely shows how to build a logging system piece by piece by applying patterns.</p>
<section data-pdf-bookmark="The Pattern Story" data-type="sect1"><div class="sect1" id="idm45587910622720">
<h1>The Pattern Story</h1>
<p>Imagine<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="context" data-type="indexterm" id="idm45587910621088"/> you have a C program out in the field that you have to maintain. If an error occurs, you get into your car, drive to the customer, and debug the program. This works fine until your customer moves to another city. The car ride now takes several hours, which is not at all satisfactory.</p>
<p>You’d prefer to solve the problem from your desk to save both time and nerves. In some instances, you can utilize<a data-primary="debugging" data-secondary="remote debugging" data-type="indexterm" id="idm45587910619168"/> remote debugging. In other instances, you need detailed data about the exact software states in which the error occurred, which is very hard to get via a remote connection—especially in instances of sporadic errors.</p>
<p>Perhaps you’ve already guessed what the solution is to avoiding your long car rides. Your solution is to implement a logging functionality and to ask your customer in case of error to send you the log files containing the debug information. In other words, you want to implement the Log Errors pattern to be able to analyze bugs after they occur, which allows you to more easily fix those bugs without having to reproduce them. While this sounds simple, there are many crucial design decisions you’ll need to make to implement logging functionality.</p>
<section data-pdf-bookmark="File Organization" data-type="sect2"><div class="sect2" id="idm45587910616976">
<h2>File Organization</h2>
<p>To<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="file organization" data-type="indexterm" id="idm45587910615472"/> get started, organize the header and implementation files that you expect to need. You already have a large codebase, so you want to clearly separate these files from the rest of your code. How should you organize the files? Should you put all your logging-related files into the same directory? Should you put all the header files of your code into a single directory?</p>
<p>To<a data-primary="Software-Module Directories pattern" data-type="indexterm" id="idm45587910613456"/><a data-primary="Header Files pattern" data-type="indexterm" id="idm45587910612784"/><a data-primary="Global Include Directory pattern" data-type="indexterm" id="idm45587910612080"/><a data-primary="files, organizing in modular programs" data-secondary="Software-Module Directories pattern" data-type="indexterm" id="idm45587910611440"/><a data-primary="APIs, flexible" data-secondary="Header Files pattern" data-type="indexterm" id="idm45587910610560"/><a data-primary="files, organizing in modular programs" data-secondary="Global Include Directory pattern" data-type="indexterm" id="idm45587910609616"/> answer these questions, you search for patterns on organizing files and find them in Chapters <a href="ch06.xhtml#chapter_api_flexibility">6</a> and <a href="ch08.xhtml#directory_structure">8</a>. You read through the problem statements of these patterns, and you trust in the knowledge provided in the described solutions. You end up with the following three patterns that nicely address your problems:</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Software-Module Directories</p></td>
<td><p>Put header files and implementation files that belong to a tightly coupled functionality into one directory. Name that directory after the functionality that is provided via the header files.</p></td>
</tr>
<tr>
<td><p>Header Files</p></td>
<td><p>Provide function declarations in your API for any functionality you want to provide to your user. Hide any internal functions, internal data, and your function definitions (the implementations) in your implementation file and don’t provide this implementation file to the user.</p></td>
</tr>
<tr>
<td><p>Global Include Directory</p></td>
<td><p>Have one global directory in your codebase that contains all software-module APIs. Add this directory to the global include paths in your toolchain.</p></td>
</tr>
</tbody>
</table>
<p>Create a Software-Module Directory for your implementation files and put the Header File of your logging software-module into the already existing Global Include Directory of your codebase. Having this header file in the Global Include Directory has the advantage that the callers of your code will definitely know which header file they are supposed to use.</p>
<p>Your file structure should appear as shown in <a data-type="xref" href="#fig_story1">Figure 10-1</a>.</p>
<figure><div class="figure" id="fig_story1">
<img alt="fluc 1001" src="assets/fluc_1001.png" width="100"/>
<h6><span class="label">Figure 10-1. </span>File structure</h6>
</div></figure>
<p>With this file structure, you can put any implementation files that only concern your logging software-module into the <em>logger</em> directory. You can put the interface, which can be used from other parts of your program, into the <em>inc</em> directory.</p>
</div></section>
<section data-pdf-bookmark="Central Logging Function" data-type="sect2"><div class="sect2" id="idm45587910594256">
<h2>Central Logging Function</h2>
<p class="fix-tracking">As<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="central logging function" data-type="indexterm" id="idm45587910592304"/><a data-primary="central logging function" data-type="indexterm" id="idm45587910590960"/> a start, implement a central function for error logging that takes custom error texts, adds the current timestamp to the texts, and prints it to the standard output. The timestamp information will make it easier for you to analyze the error texts 
<span class="keep-together">later on</span>.</p>
<p>Put<a data-primary="files, organizing in modular programs" data-secondary="Include Guard pattern" data-type="indexterm" id="idm45587910588768"/><a data-primary="files, organizing in modular programs" data-secondary="Stateless Software-Module pattern" data-type="indexterm" id="idm45587910587744"/><a data-primary="Include Guard pattern" data-type="indexterm" id="idm45587910586768"/><a data-primary="Stateless Software-Module pattern" data-type="indexterm" id="idm45587910586096"/> the function declaration into the <em>logger.h</em> file. To protect your header file against multiple inclusion, add an Include Guard. There is no need to store any information in that code or to initialize it; simply implement a Stateless Software-Module. Having a stateless logger brings many benefits: you keep your logging code simple, and things get easier when calling the code in a multithreaded environment.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Include Guard</p></td>
<td><p>Protect the content of your header files against multiple inclusion so that the developer using the header files does not have to care whether it is included multiple times. Use an interlocked <code>#ifdef</code> statement or a <code>#pragma once</code> statement to achieve this.</p></td>
</tr>
<tr>
<td><p>Stateless Software-Module</p></td>
<td><p>Keep your functions simple and don’t build up state information in your implementation. Put all related functions into one header file and provide the caller this interface to your software-module.</p></td>
</tr>
</tbody>
</table>
<p><em>logger.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifndef LOGGER_H</code>
<code class="cp">#define LOGGER_H</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">logging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">text</code><code class="p">);</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p><br/><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="n">logging</code><code class="p">(</code><code class="s">"Some text to log"</code><code class="p">);</code><code class="w"/></pre>
<p>To implement the function in your <em>logger.h</em> file, call a <code>printf</code> to write the timestamp and the text to <code>stdout</code>. But what if the caller of your function provides invalid logging input like a <code>NULL</code> pointer? Should you check for such invalid input and provide error information to the caller? Adhere<a data-primary="error handling" data-secondary="Samurai Principle pattern" data-type="indexterm" id="idm45587910549008"/><a data-primary="Samurai Principle pattern" data-type="indexterm" id="idm45587910548096"/> to the Samurai Principle, according to which you should not return error information about programming errors.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Samurai Principle</p></td>
<td><p>Return from a function victorious or not at all. If there is a situation for that you know that an error cannot be handled, then abort the program.</p></td>
</tr>
</tbody>
</table>
<p>Forward the provided text to the <code>printf</code> function, and in case of invalid input your program simply crashes, which makes it easy for the caller to find out programming errors regarding invalid input:</p>
<p><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">logging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">text</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">time_t</code><code class="w"> </code><code class="n">mytime</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">time</code><code class="p">(</code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">printf</code><code class="p">(</code><code class="s">"%s %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">ctime</code><code class="p">(</code><code class="o">&amp;</code><code class="n">mytime</code><code class="p">),</code><code class="w"> </code><code class="n">text</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>And what if you call the function in the context of a multithreaded program? Can the string provided to the function be changed by other threads, or is it necessary for the string to remain unchanged until the logging function is finished? In the preceding code example, the caller has to provide <code>text</code> as input for the <code>logging</code> function and is responsible for ensuring that the string is valid until the function returns. So<a data-primary="C functions, returning data from" data-secondary="Caller-Owned Buffer pattern" data-type="indexterm" id="idm45587910430336"/><a data-primary="Caller-Owned Buffer pattern" data-type="indexterm" id="idm45587910429488"/> we have a Caller-Owned Buffer here. That behavior has to be documented in the function’s interface.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Caller-Owned Buffer</p></td>
<td><p>Require the caller to provide a buffer and its size to the function that returns the large, complex data. In the function implementation, copy the required data into the buffer if the buffer size is large enough.</p></td>
</tr>
</tbody>
</table>
<p><em>logger.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Prints the current timestamp followed by the provided string to stdout.</code>
<code class="cm">   The string must be valid until this function returns. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">logging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">text</code><code class="p">);</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Logging Source Filter" data-type="sect2"><div class="sect2" id="idm45587910593760">
<h2>Logging Source Filter</h2>
<p>Now<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="logging source filter" data-type="indexterm" id="idm45587910405152"/> imagine that every software-module calls the logging function in order to log some information. The output can become quite messy, especially if you have a multithreaded program.</p>
<p>To make it easier to get the information you are looking for, you want to make it possible to configure the code so that it only prints the logging information for configured software-modules. To achieve this, add an additional parameter to your function which identifies the current software-module. Add a function to enable printing output for a software-module. If that function is called, all future logging output for that software-module will be printed:</p>
<p><em>logger.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Prints the current timestamp followed by the provided string to stdout.</code>
<code class="cm">   The string must be valid until this function returns. The provided module</code>
<code class="cm">   identifies the software-module that calles this function. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">logging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">module</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">text</code><code class="p">);</code><code class="w"/>

<code class="cm">/* Enables printing output for the provided module. */</code><code class="w"/>
<code class="kt">bool</code><code class="w"> </code><code class="nf">enableModule</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">module</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="n">logging</code><code class="p">(</code><code class="s">"MY-SOFTWARE-MODULE"</code><code class="p">,</code><code class="w"> </code><code class="s">"Some text to log"</code><code class="p">);</code><code class="w"/></pre>
<p>How will you keep track of which software-modules’ logging information should be printed? Should you store that state information in a global variable, or is each global variable a code smell? Or in order to avoid global variables, should you pass an additional parameter to all your functions that stores this state information? Should the required memory be allocated throughout the whole lifetime of your program? The<a data-primary="data lifetime and ownership" data-secondary="Software-Module with Global State pattern" data-type="indexterm" id="idm45587910345184"/><a data-primary="Software-Module with Global State pattern" data-type="indexterm" id="idm45587910344336"/><a data-primary="memory management" data-secondary="Eternal Memory pattern" data-type="indexterm" id="idm45587910343728"/><a data-primary="Eternal Memory pattern" data-type="indexterm" id="idm45587910342848"/> answer to these questions involves implementing a Software-Module with Global State using Eternal Memory.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Software-Module with Global State</p></td>
<td><p>Have one global instance to let your related functions share common resources. Put all functions that operate on this instance into one header file and provide the caller this interface to your software-module.</p></td>
</tr>
<tr>
<td><p>Eternal Memory</p></td>
<td><p>Put your data into memory that is available throughout the whole lifetime of your program.</p></td>
</tr>
</tbody>
</table>
<p><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#define MODULE_SIZE 20</code>
<code class="cp">#define LIST_SIZE 10</code>
<code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">module</code><code class="p">[</code><code class="n">MODULE_SIZE</code><code class="p">];</code><code class="w"/>
<code class="p">}</code><code class="n">LIST</code><code class="p">;</code><code class="w"/>
<code class="k">static</code><code class="w"> </code><code class="n">LIST</code><code class="w"> </code><code class="n">list</code><code class="p">[</code><code class="n">LIST_SIZE</code><code class="p">];</code><code class="w"/></pre>
<p>The list in the preceding code example is populated by enabling software-modules with the following function:</p>
<p><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">bool</code><code class="w"> </code><code class="nf">enableModule</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">module</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">LIST_SIZE</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">strcmp</code><code class="p">(</code><code class="n">list</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">module</code><code class="p">,</code><code class="w"> </code><code class="s">""</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">list</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">module</code><code class="p">,</code><code class="w"> </code><code class="n">module</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">strcmp</code><code class="p">(</code><code class="n">list</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">module</code><code class="p">,</code><code class="w"> </code><code class="n">module</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The<a data-primary="C functions, returning data from" data-secondary="Return Value pattern" data-type="indexterm" id="idm45587910062960"/><a data-primary="Return Value pattern" data-type="indexterm" id="idm45587910062112"/><a data-primary="error information, returning" data-secondary="Return Relevant Errors pattern" data-type="indexterm" id="idm45587910083392"/><a data-primary="Return Relevant Errors pattern" data-type="indexterm" id="idm45587910082512"/> preceding code adds the software-module name to the list if a slot in the list is empty and if that name is not already in the list. The caller sees through the Return Value whether an error occurred but does not see which of these errors occurred. You don’t Return Status Codes; you only Return Relevant Errors, because there is no relevant scenario in which the caller could react differently to the described error situations. You should also document this behavior in your function definition.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Return Value</p></td>
<td><p>Simply use the one C mechanism intended to retrieve information about the result of a function call: the Return Value. The mechanism to return data in C copies the function result and provides the caller access to this copy.</p></td>
</tr>
<tr>
<td><p>Return Relevant Errors</p></td>
<td><p>Only return error information to the caller if that information is relevant to the caller. Error information is only relevant to the caller if the caller can react to that information.</p></td>
</tr>
</tbody>
</table>
<p><em>logger.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Enables printing output for the provided module. Returns true on success</code>
<code class="cm">   and false on error (no more modules can be enabled or module was already</code>
<code class="cm">   enabled). */</code><code class="w"/>
<code class="kt">bool</code><code class="w"> </code><code class="nf">enableModule</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">module</code><code class="p">);</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Conditional Logging" data-type="sect2"><div class="sect2" id="idm45587910416992">
<h2>Conditional Logging</h2>
<p>Now, with<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="conditional logging" data-type="indexterm" id="idm45587910030560"/> the activated software-modules in your list, you can conditionally log information depending on the activated modules, as shown in the following code:</p>
<p><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">logging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">module</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">text</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">time_t</code><code class="w"> </code><code class="n">mytime</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">time</code><code class="p">(</code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">isInList</code><code class="p">(</code><code class="n">module</code><code class="p">))</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">printf</code><code class="p">(</code><code class="s">"%s %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">ctime</code><code class="p">(</code><code class="o">&amp;</code><code class="n">mytime</code><code class="p">),</code><code class="w"> </code><code class="n">text</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>But how do you implement the <code>isInList</code> function? There are several ways to iterate through a list. You could have a Cursor Iterator that provides a <code>getNext</code> method to abstract the underlying data structure. But is that necessary here? After all, you only go through an array in your own software-module. Because the iterated data is not carried across API boundaries that might have to be kept compatible, you can apply a much simpler solution here. Index Access<a data-primary="iterator interfaces" data-secondary="Index Access pattern" data-type="indexterm" id="idm45587909953568"/><a data-primary="Index Access pattern" data-type="indexterm" id="idm45587909952688"/> directly uses an index to access the elements you want to iterate:</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Index Access</p></td>
<td><p>Provide a function that takes an index to address the element in your underlying data structure and return the content of this element. The user calls this function in a loop to iterate over all elements.</p></td>
</tr>
</tbody>
</table>
<p><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">bool</code><code class="w"> </code><code class="nf">isInList</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">module</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">LIST_SIZE</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">strcmp</code><code class="p">(</code><code class="n">list</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">module</code><code class="p">,</code><code class="w"> </code><code class="n">module</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Now all your code for software-module-specific logging is written. The code simply iterates the data structure by incrementing an index. The same kind of iteration was already used in your <code>enableModule</code> function.</p>
</div></section>
<section data-pdf-bookmark="Multiple Logging Destinations" data-type="sect2"><div class="sect2" id="idm45587909782160">
<h2>Multiple Logging Destinations</h2>
<p>Next, you<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="multiple logging destinations" data-type="indexterm" id="idm45587909813168"/> want to provide different destinations for your log entries. Until now, all output is logged to the <code>stdout</code>, but you want your caller to be able to configure your code to directly log into a file. Such a configuration is usually done before the action to be logged is started. Start with a function that allows you to configure the logging destination for all future loggings:</p>
<p><em>logger.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* All future log messages will be logged to stdout */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">logToStdout</code><code class="p">();</code><code class="w"/>

<code class="cm">/* All future log messages will be logged to a file */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">logToFile</code><code class="p">();</code><code class="w"/></pre>
<p>To implement this log destination selection, you could simply have an <code>if</code> or <code>switch</code> statement to call the right function depending on the configured logging destination. However, each time you add another logging destination, you’d have to touch that piece of code. That is not a good solution according to the open-closed principle. A much better solution is to implement<a data-primary="APIs, flexible" data-secondary="Dynamic Interface pattern" data-type="indexterm" id="idm45587909777264"/><a data-primary="Dynamic Interface pattern" data-type="indexterm" id="idm45587909776384"/> a Dynamic Interface.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Dynamic Interface</p></td>
<td><p>Define a common interface for the deviating functionalities in your API and require the caller to provide a callback function for that functionality which you then call in your function implementation.</p></td>
</tr>
</tbody>
</table>
<p class="pagebreak-before"><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">typedef</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">logDestination</code><code class="p">)(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="p">);</code><code class="w"/>
<code class="k">static</code><code class="w"> </code><code class="n">logDestination</code><code class="w"> </code><code class="n">fp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">stdoutLogging</code><code class="p">;</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">stdoutLogging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buffer</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">printf</code><code class="p">(</code><code class="s">"%s"</code><code class="p">,</code><code class="w"> </code><code class="n">buffer</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">fileLogging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buffer</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* not yet implemented */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">logToStdout</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">fp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">stdoutLogging</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">logToFile</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">fp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fileLogging</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cp">#define BUFFER_SIZE 100</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">logging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">module</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">text</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">buffer</code><code class="p">[</code><code class="n">BUFFER_SIZE</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">time_t</code><code class="w"> </code><code class="n">mytime</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">time</code><code class="p">(</code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">isInList</code><code class="p">(</code><code class="n">module</code><code class="p">))</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">sprintf</code><code class="p">(</code><code class="n">buffer</code><code class="p">,</code><code class="w"> </code><code class="s">"%s %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">ctime</code><code class="p">(</code><code class="o">&amp;</code><code class="n">mytime</code><code class="p">),</code><code class="w"> </code><code class="n">text</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">fp</code><code class="p">(</code><code class="n">buffer</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>A lot changed in the existing code, but now additional log destinations can be added without any changes to the <code>logging</code> function. In the preceding code, the <code>stdoutLogging</code> function is already implemented, but the <code>fileLogging</code> function is still missing.</p>
</div></section>
<section data-pdf-bookmark="File Logging" data-type="sect2"><div class="sect2" id="idm45587909611968">
<h2>File Logging</h2>
<p>To<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="file logging" data-type="indexterm" id="idm45587909542976"/> log to a file, you could simply open and close the file each time you log a message. But that is not very efficient, and if you want to log a lot of information, that approach takes a lot of time. So what alternative do you have? You could simply open the file once and then leave it open. But how do you know when to open the file? And when would you close it?</p>
<p class="pagebreak-before">After reviewing the patterns in this book, you cannot find one that solves your problem. However, a quick Google search will lead you to the pattern that solves your<a data-primary="Lazy Acquisition pattern" data-type="indexterm" id="idm45587909540912"/> problem: Lazy Acquisition. In the first call to your <code>fileLogging</code> function, open the file once and then leave it open. You can store the file descriptor in<a data-primary="memory management" data-secondary="Eternal Memory pattern" data-type="indexterm" id="idm45587909539616"/><a data-primary="Eternal Memory pattern" data-type="indexterm" id="idm45587909538640"/> Eternal Memory.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Lazy Acquisition</p></td>
<td><p>Implicitly initialize the object or data the first time it is used (see <em>Pattern-Oriented Software Architecture: Volume 3: Patterns for Resource Management</em> by Michael Kirchner and Prashant Jain [Wiley, 2004])</p></td>
</tr>
<tr>
<td><p>Eternal Memory</p></td>
<td><p>Put your data into memory that is available throughout the whole lifetime of your program.</p></td>
</tr>
</tbody>
</table>
<p><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">fileLogging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buffer</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="k">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_implementing_logging_functionality_CO1-1" id="co_implementing_logging_functionality_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w">
</code><code class="w">  </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">open</code><code class="p">(</code><code class="s">"</code><code class="s">log.txt</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">O_RDWR</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="n">O_CREAT</code><code class="p">,</code><code class="w"> </code><code class="mo">0666</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="p">}</code><code class="w">
</code><code class="w">  </code><code class="n">write</code><code class="p">(</code><code class="n">fd</code><code class="p">,</code><code class="w"> </code><code class="n">buffer</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">buffer</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_implementing_logging_functionality_CO1-1" id="callout_implementing_logging_functionality_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Such <code>static</code> variables are only initialized once and not each time the function is called.</p></dd>
</dl>
<p>To keep the code example simple, it does not target thread safety. In order to be thread-safe, the code would have to protect the Lazy Acquisition with a Mutex to make sure that the acquisition only happens once.</p>
<p>What about closing the file? For some applications, like the one in this chapter, not closing the file is a valid option. Imagine that you want to log as long as your application is running, and when you shut the application down, you rely on the operating system to clean up the file that you left open. If you are afraid that the information is not stored in case of a system crash, you could even flush the file content from time to time.</p>
</div></section>
<section data-pdf-bookmark="Cross-Platform Files" data-type="sect2"><div class="sect2" id="idm45587909414512">
<h2>Cross-Platform Files</h2>
<p>The<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="cross-platform files" data-type="indexterm" id="idm45587909412592"/><a data-primary="cross-platform files" data-type="indexterm" id="idm45587909411312"/> code so far implements logging to a file on Linux systems, but you also want to use your code on Windows platforms, for which the current code won’t yet work.</p>
<p>To support multiple platforms, you first consider to<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Avoid Variants pattern" data-type="indexterm" id="idm45587909410128"/><a data-primary="Avoid Variants pattern" data-type="indexterm" id="idm45587909408912"/> Avoid Variants so that you only have common code for all platforms. That would be possible for writing files by simply using the <code>fopen</code>, <code>fwrite</code>, and <code>fclose</code> functions, which are available on Linux as well as on Windows systems.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Avoid Variants</p></td>
<td><p>Use standardized functions that are available on all platforms. If there are no standardized functions, consider not implementing the functionality.</p></td>
</tr>
</tbody>
</table>
<p>However, you want to make your file logging code as efficient as possible and using the platform-specific functions for accessing files is more efficient. But how do you implement platform-specific code? Duplicating your codebase to have one full code version for Windows and one full code version for Linux is not an option because future changes and maintenance of duplicated code can become a nightmare.</p>
<p>You decide to use <code>#ifdef</code> statements in your code to differentiate between the platforms. But isn’t that a code duplication as well? After all, when you have huge <code>#ifdef</code> blocks in your code, all the program logic in these statements is duplicated. How can you avoid code duplication while still supporting multiple platforms?</p>
<p>Again the patterns show you the way. First, define platform-independent interfaces for the functionality that requires the platform-dependent functions. In other words, define an<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Abstraction Layer pattern" data-type="indexterm" id="idm45587909357072"/><a data-primary="Abstraction Layer pattern" data-type="indexterm" id="idm45587909355888"/> Abstraction Layer.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Abstraction Layer</p></td>
<td><p>Provide an API for each functionality that requires platform-specific code. Define only platform-independent functions in the header file and put all platform-specific <code>#ifdef</code> code into the implementation file. The caller of your functions includes only your header file and does not have to include any platform-specific files.</p></td>
</tr>
</tbody>
</table>
<p><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">fileLogging</code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buffer</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">fileDescriptor</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">initiallyOpenLogFile</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="n">writeLogFile</code><code class="p">(</code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="n">buffer</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cm">/* Opens the logfile at the first call.</code>
<code class="cm">   Works on Linux and on Windows systems */</code><code class="w"/>
<code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="nf">initiallyOpenLogFile</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cm">/* Writes the provided buffer to the logfile.</code>
<code class="cm">   Works on Linux and on Windows systems */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">writeLogFile</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buffer</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Behind this Abstraction Layer you have<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Isolated Primitives pattern" data-type="indexterm" id="idm45587909346816"/><a data-primary="Isolated Primitives pattern" data-type="indexterm" id="idm45587909296048"/> Isolated Primitives of your code variants. That means you don’t use <code>#ifdef</code> statements across several functions, but you stick to one <code>#ifdef</code> for one function. Should you have an <code>#ifdef</code> statement across the whole function implementation or just across the platform-specific part?</p>
<p>The solution is to have both. You should have<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Atomic Primitives pattern" data-type="indexterm" id="idm45587909293600"/><a data-primary="Atomic Primitives pattern" data-type="indexterm" id="idm45587909292320"/> Atomic Primitives. The functions should be on a granularity so that they only contain platform-specific code. If they don’t, then you can split these functions up further. That is the best way to keep platform-dependent code manageable.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Isolated Primitives</p></td>
<td><p>Isolate your code variants. In your implementation file, put the code handling the variants into separate functions and call these functions from your main program logic, which then contains only platform-independent code.</p></td>
</tr>
<tr>
<td><p>Atomic Primitives</p></td>
<td><p>Make your primitives atomic. Only handle exactly one kind of variant per function. If you handle multiple kinds of variants, for example, operating system variants and hardware variants, then have separate functions for that.</p></td>
</tr>
</tbody>
</table>
<p>The following code shows the implementations of your Atomic Primitives:</p>
<p><em>logger.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="nf">initiallyOpenLogFile</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="cp">#ifdef __unix__</code>
<code class="w">  </code><code class="k">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">fd</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">open</code><code class="p">(</code><code class="s">"log.txt"</code><code class="p">,</code><code class="w"> </code><code class="n">O_RDWR</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="n">O_CREAT</code><code class="p">,</code><code class="w"> </code><code class="mo">0666</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">fd</code><code class="p">;</code><code class="w"/>
<code class="cp">#elif defined _WIN32</code>
<code class="w">  </code><code class="k">static</code><code class="w"> </code><code class="n">HANDLE</code><code class="w"> </code><code class="n">hFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">NULL</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">hFile</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nb">NULL</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">hFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CreateFile</code><code class="p">(</code><code class="s">"log.txt"</code><code class="p">,</code><code class="w"> </code><code class="n">GENERIC_WRITE</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">,</code><code class="w"/>
<code class="w">                       </code><code class="n">CREATE_NEW</code><code class="p">,</code><code class="w"> </code><code class="n">FILE_ATTRIBUTE_NORMAL</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">hFile</code><code class="p">;</code><code class="w"/>
<code class="cp">#endif</code>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">writeLogFile</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buffer</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="cp">#ifdef __unix__</code>
<code class="w">  </code><code class="n">write</code><code class="p">((</code><code class="kt">int</code><code class="p">)</code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="n">buffer</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">buffer</code><code class="p">));</code><code class="w"/>
<code class="cp">#elif defined _WIN32</code>
<code class="w">  </code><code class="n">WriteFile</code><code class="p">((</code><code class="n">HANDLE</code><code class="p">)</code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="n">buffer</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">buffer</code><code class="p">),</code><code class="w"> </code><code class="nb">NULL</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="cp">#endif</code>
<code class="p">}</code><code class="w"/></pre>
<p>The preceding code doesn’t look great. But then again, any platform-dependent code rarely looks nice. Is there anything else you can do to make that code easier to read and maintain? A possible approach to improve things is to<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Split Variant Implementations" data-type="indexterm" id="idm45587909220640"/><a data-primary="Split Variant Implementations pattern" data-type="indexterm" id="idm45587909219552"/> Split Variant Implementations into separate files.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Split Variant Implementations</p></td>
<td><p>Put each variant implementation into a separate implementation file and select per file what you want to compile for which platform.</p></td>
</tr>
</tbody>
</table>
<p><em>fileLinux.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef __unix__</code>
<code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="nf">initiallyOpenLogFile</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">fd</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">open</code><code class="p">(</code><code class="s">"log.txt"</code><code class="p">,</code><code class="w"> </code><code class="n">O_RDWR</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="n">O_CREAT</code><code class="p">,</code><code class="w"> </code><code class="mo">0666</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">fd</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">writeLogFile</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buffer</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">write</code><code class="p">((</code><code class="kt">int</code><code class="p">)</code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="n">buffer</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">buffer</code><code class="p">));</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p><br/><em>fileWindows.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef _WIN32</code>
<code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="nf">initiallyOpenLogFile</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">static</code><code class="w"> </code><code class="n">HANDLE</code><code class="w"> </code><code class="n">hFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">NULL</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">hFile</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nb">NULL</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">hFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CreateFile</code><code class="p">(</code><code class="s">"log.txt"</code><code class="p">,</code><code class="w"> </code><code class="n">GENERIC_WRITE</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">,</code><code class="w"/>
<code class="w">                       </code><code class="n">CREATE_NEW</code><code class="p">,</code><code class="w"> </code><code class="n">FILE_ATTRIBUTE_NORMAL</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">hFile</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">writeLogFile</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buffer</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">WriteFile</code><code class="p">((</code><code class="n">HANDLE</code><code class="p">)</code><code class="n">fileDescriptor</code><code class="p">,</code><code class="w"> </code><code class="n">buffer</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">buffer</code><code class="p">),</code><code class="w"> </code><code class="nb">NULL</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p>Both of the shown code files are a lot easier to read compared to the code where Linux and Windows code is mixed within a single function. Also, instead of 
<span class="keep-together">conditionally</span> compiling the code on a platform via <code>#ifdef</code> statements, it is now possible to eliminate all <code>#ifdef</code> statements and to use Makefiles to select which files to compile.</p>
</div></section>
<section data-pdf-bookmark="Using the Logger" data-type="sect2"><div class="sect2" id="idm45587909413568">
<h2>Using the Logger</h2>
<p>With<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="using the logger" data-type="indexterm" id="idm45587908693728"/> these final changes to your logging functionality, your code can now log messages for configured software-modules to <code>stdout</code> or to cross-platform files. The following code shows how to use the logging functionality:</p>
<pre data-code-language="c" data-type="programlisting"><code class="n">enableModule</code><code class="p">(</code><code class="s">"MYMODULE"</code><code class="p">);</code><code class="w"/>
<code class="n">logging</code><code class="p">(</code><code class="s">"MYMODULE"</code><code class="p">,</code><code class="w"> </code><code class="s">"Log to stdout"</code><code class="p">);</code><code class="w"/>
<code class="n">logToFile</code><code class="p">();</code><code class="w"/>
<code class="n">logging</code><code class="p">(</code><code class="s">"MYMODULE"</code><code class="p">,</code><code class="w"> </code><code class="s">"Log to file"</code><code class="p">);</code><code class="w"/>
<code class="n">logging</code><code class="p">(</code><code class="s">"MYMODULE"</code><code class="p">,</code><code class="w"> </code><code class="s">"Log to file some more"</code><code class="p">);</code><code class="w"/></pre>
<p>After you finish making all these coding decisions and then implementing them, you are very relieved. You take your hands off the keyboard and look at the code in admiration. You are astonished at how some of your initial questions that seemed difficult to you were easily resolved by the patterns. The benefit to utilizing the patterns is that they remove the burden of making hundreds of decisions by yourself.</p>
<p>The long car rides to fix bugs on site are in the past. Now you simply get the debug information that you need via the log files. That makes your customer happy, because they get quicker bug fixes. More importantly, it makes your own life better. You can provide more professional software, and you now have the time to get home from work early.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45587910622128">
<h1>Summary</h1>
<p>You<a data-primary="design patterns" data-secondary="benefits of" data-type="indexterm" id="idm45587908610688"/> constructed the code for this logging functionality step by step by applying the patterns presented in <a data-type="xref" href="part01.xhtml#part_1">Part I</a> in order to solve one problem after another. At the start you had many questions on how to organize the files or how to cope with error handling. The patterns showed you the way. They gave you guidance and made it easier to construct this piece of code. They also provide understanding as to why the code looks and behaves the way it does. <a data-type="xref" href="#fig_story1_patterns">Figure 10-2</a> shows an<a data-primary="Log Errors pattern" data-secondary="implementation example" data-tertiary="overview of patterns used" data-type="indexterm" id="idm45587908607824"/> overview of the decisions that the patterns helped you make.</p>
<p>There are, of course, still a lot of potential feature improvements for your code. The code, for example, doesn’t handle maximum file sizes or rotation of logfiles, and doesn’t support configuration of a log level to skip very detailed logging. To keep things simple and easier to grasp, these features are not covered but could be added to the code examples.</p>
<p>The next chapter will tell another story on how to apply the patterns to build another larger industrial-strength piece of code.</p>
<figure><div class="figure" id="fig_story1_patterns">
<img alt="fluc 1002" height="2107" src="assets/fluc_1002.png" width="1436"/>
<h6><span class="label">Figure 10-2. </span>The patterns applied throughout this story</h6>
</div></figure>
</div></section>
</div></section></div></body></html>