<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. The Adapter, Observer, and &#10;CRTP Design Patterns" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_adapter_observer_and_crtp_design_patterns">
<h1><span class="label">Chapter 6. </span>The Adapter, Observer, and 
<span class="keep-together">CRTP Design Patterns</span></h1>
<p>In<a data-primary="abstract notification mechanisms" data-see="Observer design pattern" data-type="indexterm" id="idm45043101356224"/><a data-primary="Adapter design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043101355200"/><a data-primary="Observer design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043101354256"/><a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043101353312"/> this chapter, we turn our attention to three must-know design patterns: the two
GoF design patterns, Adapter and <em>Observer</em>, and the <em>Curiously Recurring Template Pattern (CRTP)</em> design pattern.</p>
<p>In <a data-type="xref" href="#use_adapters_to_standardize_interfaces">“Guideline 24: Use Adapters to Standardize Interfaces”</a>, we talk about making
incompatible things fit together by adapting interfaces. To achieve this, I will show
you the Adapter design pattern and its application in both inheritance hierarchies
and generic programming. You will also get an overview of different kinds of
Adapters, including object, class, and function Adapters.</p>
<p>In <a data-type="xref" href="#apply_observers_as_an_abstract_notification_mechanism">“Guideline 25: Apply Observers as an Abstract Notification Mechanism”</a>, we will deal with how to observe state change and how to get notified about it. In this context, I
will introduce you to the Observer design pattern, one of the most famous and most
commonly used design patterns. We will talk about the classic, GoF-style Observer,
and also how to implement the Observer in modern C++.</p>
<p>In <a data-type="xref" href="#use_crtp_to_introduce_static_type_categories">“Guideline 26: Use CRTP to Introduce Static Type Categories”</a>, we will turn our attention to
the CRTP. I will show you how to use CRTP to define a compile-time relationship
between a family of related types and how to properly implement a CRTP base class.</p>
<p>In <a data-type="xref" href="#use_crtp_for_static_mixin_classes">“Guideline 27: Use CRTP for Static Mixin Classes”</a>, I will continue the CRTP story by
showing you how CRTP can be used to create compile-time mixin classes. We will
also see the difference between semantic inheritance, where it is used to create an abstraction, and technical inheritance, where it is used
as an implementation detail for technical elegance and convenience only.</p>
<section data-pdf-bookmark="Guideline 24: Use Adapters to Standardize Interfaces" data-type="sect1"><div class="sect1" id="use_adapters_to_standardize_interfaces">
<h1>Guideline 24: Use Adapters to Standardize Interfaces</h1>
<p>Let’s<a data-primary="Adapter design pattern" data-secondary="standardizing interfaces" data-type="indexterm" id="ADPstdinter06"/><a data-primary="interfaces, standardizing" data-secondary="example problem" data-type="indexterm" id="idm45043101342400"/><a data-primary="Adapter design pattern" data-secondary="standardizing interfaces" data-tertiary="example problem" data-type="indexterm" id="idm45043101341440"/> assume that you have implemented the <code>Document</code> example from
<a data-type="xref" href="ch01.xhtml#separate_interfaces_to_avoid_artificial_coupling">“Guideline 3: Separate Interfaces to Avoid 
<span class="keep-together">Artificial Coupling</span>”</a>, and that, because you properly adhere
to the Interface Segregation Principle (ISP), you’re reasonably happy with the way it works:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">JSONExportable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">JSONExportable</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Serializable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Serializable</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Document</code><code class="w"/>
<code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">JSONExportable</code><code class="w"/>
<code class="w">   </code><code class="p">,</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Serializable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p class="less_space pagebreak-after">However, one day you’re required to introduce the Pages document
format.<sup><a data-type="noteref" href="ch06.xhtml#idm45043101334880" id="idm45043101334880-marker">1</a></sup> Of course,
it is similar to the Word document that you already have in place, but unfortunately, you’re
not familiar with the details of the Pages format. To make things worse, you don’t
have a lot of time to get familiar with the format, because you have way too many other
things to do. Luckily, you know about a quite reasonable, open source implementation
for that format: the <code>OpenPages</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">OpenPages</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">convertToBytes</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">exportToJSONFormat</code><code class="p">(</code><code class="w"> </code><code class="n">OpenPages</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">pages</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>On the bright side, this class provides about everything you need for your purposes: a <code>convertToBytes()</code> member function to serialize the content of the document,
and the free <code>exportToJSONFormat()</code> function to convert the Pages document into
the JSON format. Unfortunately, it does not fit your interface expectations: instead of the
<code>convertToBytes()</code> member function, you expect a <code>serialize()</code> member function. And instead
of the free <code>exportToJSONFormat()</code> function, you expect the 
<span class="keep-together"><code>exportToJSON()</code></span> member function.
Ultimately, of course, the third-party class does not inherit from your <code>Document</code> base
class, which means that you can’t easily incorporate the class into your existing hierarchy.
However, there is a solution to this problem: a seamless integration using the Adapter design pattern.</p>
<section data-pdf-bookmark="The Adapter Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043101098704">
<h2>The Adapter Design Pattern Explained</h2>
<p>The<a data-primary="Adapter design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043101096736"/><a data-primary="interfaces, standardizing" data-secondary="Adapter design pattern" data-type="indexterm" id="ISadp06"/> Adapter design pattern is another one of the classic GoF design patterns. It’s
focused on standardizing interfaces and helping nonintrusively add functionality
into an existing inheritance hierarchy.</p>
<div data-type="tip"><h1>The Adapter Design Pattern</h1>
<p>Intent: “Convert the interface of a class into another interface clients expect.
Adapter lets classes work together that couldn’t otherwise because of incompatible
interfaces.”<sup><a data-type="noteref" href="ch06.xhtml#idm45043101092960" id="idm45043101092960-marker">2</a></sup></p>
</div>
<p><a data-type="xref" href="#fig_adapter_document">Figure 6-1</a> shows the UML diagram for your Adapter scenario: you already
have the <code>Document</code> base class in place (we ignore the <code>JSONExportable</code> and <code>Serializable</code>
interfaces for a second) and have already implemented a couple of different kinds of
documents (for instance, with the <code>Word</code> class). The new addition to this hierarchy
is the <code>Pages</code> class.</p>
<figure><div class="figure" id="fig_adapter_document">
<img alt="cpsd 0601" height="583" src="assets/cpsd_0601.png" width="1210"/>
<h6><span class="label">Figure 6-1. </span>The UML representation of the Adapter design pattern</h6>
</div></figure>
<p>The <code>Pages</code> class<a data-primary="Adapter design pattern" data-secondary="standardizing interfaces" data-tertiary="UML diagram" data-type="indexterm" id="idm45043101081392"/> acts as a wrapper to the third-party <code>OpenPages</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">Pages</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Document</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">exportToJSONFormat</code><code class="p">(</code><code class="n">pages</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g24_1" id="code_g24_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">pages</code><code class="p">.</code><code class="n">convertToBytes</code><code class="p">(</code><code class="cm">/*...*/</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g24_2" id="code_g24_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">OpenPages</code><code class="w"> </code><code class="n">pages</code><code class="p">;</code><code class="w">  </code><code class="c1">// Example of an object adapter
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p><code>Pages</code> implements the <code>Document</code> interface by forwarding the calls to the corresponding
<code>OpenPages</code> functions: a call to <code>exportToJSON()</code> is forwarded to the free

<span class="keep-together"><code>exportToJSONFormat()</code></span> function
(<a class="co" href="#code_g24_1" id="para_g24_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>),
and the call to <code>serialize()</code> is forwarded to the <code>convertToBytes()</code> member function
(<a class="co" href="#code_g24_2" id="para_g24_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).</p>
<p>With the <code>Pages</code> class, you can easily integrate the third-party implementation
into your existing hierarchy. <em>Very</em> easily indeed: you can integrate it without having
to modify it in any way. This nonintrusive nature of the Adapter design pattern is
what you should consider one of the greatest strengths of the Adapter design pattern:
anyone can add an Adapter to adapt an interface to another, existing interface.</p>
<p>In this context, the <code>Pages</code> class serves as an abstraction from the actual
implementation details in the <code>OpenPages</code> class. Therefore, the Adapter design pattern
separates the concerns of the interface from the implementation details. This nicely fulfills
the Single-Responsibility Principle (SRP) and blends well with the intention of the
Open-Closed Principle (OCP) (see <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a> and <a data-type="xref" href="ch01.xhtml#design_for_extension">“Guideline 5: Design for Extension”</a>).</p>
<p>In a way, the <code>Pages</code> Adapter works as an indirection and maps from one
set of functions to another one. Note that it is not strictly necessary to map from one
function to exactly one other function. On the contrary, you have complete flexibility
on how to map the expected set of functions onto the available set of functions. Thus,
Adapter does not necessarily represent a 1-to-1 relationship, but can also support a
1-to-<em>N</em> relationship.<sup><a data-type="noteref" href="ch06.xhtml#idm45043100929584" id="idm45043100929584-marker">3</a></sup><a data-primary="" data-startref="ISadp06" data-type="indexterm" id="idm45043100928464"/></p>
</div></section>
<section data-pdf-bookmark="Object Adapters Versus Class Adapters" data-type="sect2"><div class="sect2" id="idm45043101098080">
<h2>Object Adapters Versus Class Adapters</h2>
<p>The<a data-primary="interfaces, standardizing" data-secondary="object versus class adapters" data-type="indexterm" id="idm45043100925920"/><a data-primary="Adapter design pattern" data-secondary="standardizing interfaces" data-tertiary="object versus class adapters" data-type="indexterm" id="idm45043100924976"/> <code>Pages</code> class is an example of a so-called<a data-primary="object adapters" data-type="indexterm" id="idm45043100923280"/> <em>object adapter</em>. This term refers
to the fact that you store an instance of the wrapped type. Alternatively, given
that the wrapped type is part of an inheritance hierarchy, you could store a pointer
to the base class of this hierarchy. This would allow you to use the object adapter
for all types that are part of the hierarchy, giving the object adapter a considerable
boost in 
<span class="keep-together">flexibility.</span></p>
<p>In contrast, there is also the option to implement a so-called<a data-primary="class adapters" data-type="indexterm" id="idm45043100921216"/> <em>class adapter</em>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">Pages</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Document</code><code class="w">
</code><code class="w">            </code><code class="p">,</code><code class="w"> </code><code class="k">private</code><code class="w"> </code><code class="n">OpenPages</code><code class="w">  </code><code class="c1">// Example of a class adapter  </code><a class="co" href="#para_g24_3" id="code_g24_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="c1">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">exportToJSONFormat</code><code class="p">(</code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">this</code><code class="o">-</code><code class="o">&gt;</code><code class="n">convertToBytes</code><code class="p">(</code><code class="cm">/*...*/</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p class="less_space pagebreak-before">Instead of storing an instance of the adapted type, you would inherit from it (if
possible, nonpublicly) and implement the expected interface accordingly
(<a class="co" href="#code_g24_3" id="para_g24_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>).
However, as discussed in <a data-type="xref" href="ch05.xhtml#favor_composition_over_inheritance">“Guideline 20: Favor Composition over Inheritance”</a>, it is preferable to
build on composition. In general, object adapters prove to be much more flexible
than class adapters and thus should be your favorite. There are only a few reasons
why you would prefer a class adapter:</p>
<ul>
<li>
<p>If you have to override a virtual function.</p>
</li>
<li>
<p>If you need access to a <code>protected</code> member function.</p>
</li>
<li>
<p>If you require the adapted type to be constructed <em>before</em> another base class.</p>
</li>
<li>
<p>If you need to share a common virtual base class or override the construction of a
virtual base class.</p>
</li>
<li>
<p>If<a data-primary="Empty Base Optimization (EBO)" data-type="indexterm" id="idm45043100829984"/> you can draw <em>significant</em> advantage from the
<a href="https://oreil.ly/7wLyW"><em>Empty Base Optimization (EBO)</em></a>.<sup><a data-type="noteref" href="ch06.xhtml#idm45043100781216" id="idm45043100781216-marker">4</a></sup></p>
</li>
</ul>
<p>Otherwise, and this applies to most cases, you should prefer an object
adapter.</p>
<p>“I like this design pattern—it’s powerful. However, I just remembered that you recommended
using the name of the design pattern in the code to communicate intent. Shouldn’t the
class be called <code>PagesAdapter</code>?” You make an excellent point. And I’m happy
that you remember <a data-type="xref" href="ch03.xhtml#use_a_design_patterns_name_to_communicate_intent">“Guideline 14: Use a Design Pattern’s Name to Communicate Intent”</a>,
in which I indeed argued that the name of the pattern helps to understand the code.
I admit that in this case, I’m open to both naming conventions. While I do see the
advantages of the name <code>PagesAdapter</code>, as this immediately communicates that you built
on the Adapter design pattern, I don’t consider it a necessity to communicate the
fact that this class represents an adapter. To me, the Adapter feels like an
implementation detail in this situation: I do not need to know that the <code>Pages</code> class
doesn’t implement all the details itself, but uses the <code>OpenPages</code> class for that.
That’s why I said to “consider using the name.” You should decide on a case-by-case basis.</p>
</div></section>
<section data-pdf-bookmark="Examples from the Standard Library" data-type="sect2"><div class="sect2" id="idm45043100775392">
<h2>Examples from the Standard Library</h2>
<p>One<a data-primary="Adapter design pattern" data-secondary="standardizing interfaces" data-tertiary="examples from Standard Library" data-type="indexterm" id="idm45043100773920"/><a data-primary="interfaces, standardizing" data-secondary="examples from Standard Library" data-type="indexterm" id="ISstdlib06"/> useful application of the Adapter design pattern is to standardize the interface of
different kinds of containers. Let’s assume the following <code>Stack</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Stack.h&gt; ----------------
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Stack</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Stack</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="n">T</code><code class="o">&amp;</code><code class="w"> </code><code class="nf">top</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g24_4" id="code_g24_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="nf">empty</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g24_5" id="code_g24_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="nf">size</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g24_6" id="code_g24_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">push</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g24_7" id="code_g24_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">pop</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g24_8" id="code_g24_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>This <code>Stack</code> class provides the necessary interface to access the top element of the stack
(<a class="co" href="#code_g24_4" id="para_g24_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>),
check if the stack is empty
(<a class="co" href="#code_g24_5" id="para_g24_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>),
query the size of the stack
(<a class="co" href="#code_g24_6" id="para_g24_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>),
push an element onto the stack
(<a class="co" href="#code_g24_7" id="para_g24_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>),
and remove the top element of the stack
(<a class="co" href="#code_g24_8" id="para_g24_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).
This base class can now be used to implement different Adapters for various data
structures, such as <code>std::vector</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;VectorStack.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Stack.h&gt;</code><code class="cp"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">VectorStack</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Stack</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">T</code><code class="o">&amp;</code><code class="w"> </code><code class="n">top</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">vec_</code><code class="p">.</code><code class="n">back</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="n">empty</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">vec_</code><code class="p">.</code><code class="n">empty</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="kt">size_t</code><code class="w"> </code><code class="n">size</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">vec_</code><code class="p">.</code><code class="n">size</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">push</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">vec_</code><code class="p">.</code><code class="n">push_back</code><code class="p">(</code><code class="n">value</code><code class="p">);</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">pop</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">vec_</code><code class="p">.</code><code class="n">pop_back</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">vec_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>You worry, “Do you seriously suggest implementing a stack by an abstract base class?
Aren’t you worried about the performance implications? For every use of a member
function, you have to pay with a virtual function call!” No, of course I don’t suggest that. Obviously, you are correct, and I completely agree with you: from a
C++ perspective, this kind of container feels strange and very inefficient.
Because of efficiency, we usually realize the same idea via class templates. This is
the approach taken by the C++ Standard Library in the form of the three STL
classes called <a href="https://oreil.ly/RMYzu">Container adaptors</a>:
<a href="https://oreil.ly/y4cr6"><code>std::stack</code></a>,
<a href="https://oreil.ly/LvVNn"><code>std::queue</code></a>, and
<a href="https://oreil.ly/nTBM8"><code>std::priority_queue</code></a>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"/>
<code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Container</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">deque</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">stack</code><code class="p">;</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"/>
<code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Container</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">deque</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">queue</code><code class="p">;</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"/>
<code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Container</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Compare</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">less</code><code class="o">&lt;</code><code class="k">typename</code><code class="w"> </code><code class="nc">Container</code><code class="o">::</code><code class="n">value_type</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">priority_queue</code><code class="p">;</code><code class="w"/></pre>
<p>These three class templates adapt
the interface of a given <code>Container</code> type to a special purpose. For instance, the
purpose of the <code>std::stack</code> class template is to adapt the interface of a container
to the stack operations <code>top()</code>, <code>empty()</code>, <code>size()</code>, <code>push()</code>, <code>emplace()</code>, <code>pop()</code>,
and <code>swap()</code>.<sup><a data-type="noteref" href="ch06.xhtml#idm45043100261104" id="idm45043100261104-marker">5</a></sup> By default, you’re able
to use the three available sequence containers: <code>std::vector</code>, <code>std::list</code>, and
<code>std::deque</code>. For any other container type, you are able to specialize the <code>std::stack</code>
class template.</p>
<p>“This feels <em>so</em> much more familiar,” you say, visibly relieved. Again, I absolutely
agree. I also consider the Standard Library approach the more suitable solution for the
purpose of containers. But it’s still interesting to compare the two
approaches. While there are many technical differences between the <code>Stack</code> base class
and the <code>std::stack</code> class template, the purpose and semantics of these two approaches are
remarkably similar: both provide the ability to adapt any data structure to a given
stack interface. And both serve as a variation point, allowing you to nonintrusively
add new Adapters without having to modify existing code.<a data-primary="" data-startref="ISstdlib06" data-type="indexterm" id="idm45043100256192"/></p>
</div></section>
<section data-pdf-bookmark="Comparison Between Adapter and Strategy" data-type="sect2"><div class="sect2" id="idm45043100255088">
<h2>Comparison Between Adapter and Strategy</h2>
<p>“The three<a data-primary="interfaces, standardizing" data-secondary="Adapter versus Strategy design patterns" data-type="indexterm" id="idm45043100225120"/><a data-primary="Adapter design pattern" data-secondary="standardizing interfaces" data-tertiary="versus Strategy design pattern" data-tertiary-sortas="Strategy design pattern" data-type="indexterm" id="idm45043100224272"/><a data-primary="Strategy design pattern" data-secondary="versus Adapter design pattern" data-secondary-sortas=" Adapter design pattern" data-type="indexterm" id="idm45043100222944"/> STL classes seem to fulfill the intent of Adapters, but isn’t
this the same way of configuring behavior as in the Strategy design pattern? Isn’t
this similar to <code>std::unique_ptr</code> and its deleter?” you ask. And yes, you’re
correct. From a structural point of view, the Strategy and Adapter design patterns
are very similar. However, as explained in <a data-type="xref" href="ch03.xhtml#understand_the_purpose_of_design_patterns">“Guideline 11: Understand the Purpose of Design Patterns”</a>,
the structure of design patterns may be similar or even the same, but the intent is different. In this context, the <code>Container</code> parameter specifies not just a
single aspect of the behavior, but most of the behavior or even all of it. The class
templates merely act as a wrapper around the functionality of the given type—they
mainly adapt the interface. So the primary focus of an Adapter is to standardize
interfaces and integrate incompatible functionality into an existing set of
conventions; while on the other hand, the primary focus of the Strategy design pattern
is to enable the configuration of behavior from the outside, building on and providing
an expected interface. Also, for an Adapter there is no need to reconfigure the
behavior at any time.</p>
</div></section>
<section data-pdf-bookmark="Function Adapters" data-type="sect2"><div class="sect2" id="idm45043100219776">
<h2>Function Adapters</h2>
<p>Additional<a data-primary="Adapter design pattern" data-secondary="standardizing interfaces" data-tertiary="function adapters" data-type="indexterm" id="idm45043100218048"/><a data-primary="interfaces, standardizing" data-secondary="function adapters" data-type="indexterm" id="idm45043100216832"/><a data-primary="function adapters" data-type="indexterm" id="idm45043100215888"/> examples for the Adapter design pattern are the Standard Library’s free
functions <a href="https://oreil.ly/ZP74K"><code>begin()</code></a> and
<a href="https://oreil.ly/qFeMX"><code>end()</code></a>. “Are you serious?” you ask,
surprised. “You claim that free functions serve as an example of the Adapter design pattern?
Isn’t this a job for classes?” Well, not necessarily. The purpose of the free <code>begin()</code>
and <code>end()</code> functions is to adapt the iterator interface of any type to the expected
STL iterator interface. Thus, it maps from an available set of functions to an expected
set of functions and serves the same purpose as any other Adapter. The major
difference is that in contrast to object adapters or class adapters, which are
based on either inheritance (runtime polymorphism) or templates (compile-time polymorphism),
<code>begin()</code> and <code>end()</code> draw their power from function overloading, which is the second
major compile-time polymorphism mechanism in C++. Still, some form of
abstraction is at play.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Remember that all kinds of abstractions represent a set of requirements and thus have to
adhere to the Liskov Substitution Principle (LSP). This is also true for overload sets;
see <a data-type="xref" href="ch02.xhtml#understand_the_semantic_requirements_of_overload_sets">“Guideline 8: Understand the Semantic Requirements of Overload Sets”</a>.</p>
</div>
<p>Consider the following function template:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Range</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">traverseRange</code><code class="p">(</code><code class="w"> </code><code class="n">Range</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">range</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">range</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In the <code>traverseRange()</code> function, we iterate through all the elements contained in
the given range with a range-based <code>for</code> loop. The traversal happens via iterators
that the compiler acquires with the free <code>begin()</code> and <code>end()</code> functions. Hence,
the preceding <code>for</code> loop is equivalent to the following form of <code>for</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Range</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">traverseRange</code><code class="p">(</code><code class="w"> </code><code class="n">Range</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">range</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">begin</code><code class="p">;</code><code class="w"/>
<code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">end</code><code class="p">;</code><code class="w"/>

<code class="w">      </code><code class="k">auto</code><code class="w"> </code><code class="n">first</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">range</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="k">auto</code><code class="w"> </code><code class="n">last</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">range</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="p">;</code><code class="w"> </code><code class="n">first</code><code class="o">!=</code><code class="n">last</code><code class="p">;</code><code class="w"> </code><code class="o">++</code><code class="n">first</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">         </code><code class="k">auto</code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">first</code><code class="p">;</code><code class="w"/>
<code class="w">         </code><code class="c1">// ...</code>
<code class="w">      </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Obviously, the range-based <code>for</code> loop is much more convenient to use. However, underneath
the surface, the compiler generates code based on the free <code>begin()</code> and <code>end()</code> functions.
Note the two <code>using</code> declarations in their beginning: the<a data-primary="Argument-Dependent Lookup (ADL)" data-type="indexterm" id="idm45043100002896"/><a data-primary="ADL (Argument-Dependent Lookup)" data-type="indexterm" id="idm45043100002336"/> purpose is to enable
<a href="https://oreil.ly/VKcsl"><em>Argument-Dependent Lookup (ADL)</em></a> for the
given type of range. ADL is the mechanism that makes sure the “correct” <code>begin()</code> and
<code>end()</code> functions are called, even if they are overloads that reside in a user-specific
namespace. This means that you have the opportunity to overload <code>begin()</code> and <code>end()</code>
for any type and map the expected interface to a different, special-purpose set of
functions.</p>
<p>This kind of <em>function adapter</em> was called a<a data-primary="shims" data-type="indexterm" id="idm45043099972896"/> <em>shim</em> by Matthew Wilson in
2004.<sup><a data-type="noteref" href="ch06.xhtml#idm45043099971744" id="idm45043099971744-marker">6</a></sup> One valuable property of
this technique is that it’s completely nonintrusive: it is possible to add a free
function to any type, even to types that you could never adapt, such as types provided
by third-party libraries. Hence, any generic code written in terms of shims gives you
the enormous power to adapt virtually any type to the expected interface. Thus, you can
imagine that shims or function adapters are the backbone of generic programming.</p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the Adapter Design Pattern" data-type="sect2"><div class="sect2" id="idm45043099970480">
<h2>Analyzing the Shortcomings of the Adapter Design Pattern</h2>
<p>Despite<a data-primary="Adapter design pattern" data-secondary="standardizing interfaces" data-tertiary="shortcomings of" data-type="indexterm" id="idm45043099968912"/><a data-primary="interfaces, standardizing" data-secondary="Adapter shortcomings" data-type="indexterm" id="ISshort06"/> the value of the Adapter design pattern, there is one issue with this design
pattern that I should explicitly point out. Consider the following example,
which I adopted from Eric Freeman and Elisabeth Robson:<sup><a data-type="noteref" href="ch06.xhtml#idm45043099966256" id="idm45043099966256-marker">7</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Duck.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Duck</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Duck</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">quack</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">fly</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;MallardDuck.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Duck.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">MallardDuck</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Duck</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">quack</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">fly</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>We start with the abstract <code>Duck</code> class, which introduces the two pure virtual functions
<code>quack()</code> and <code>fly()</code>. Indeed, this appears to be a pretty expected and natural interface
for a <code>Duck</code> class and of course raises some expectations: ducks make a very characteristic
sound and can fly pretty well. This interface is implemented by many possible kinds of
<code>Duck</code>, such as the <code>MallardDuck</code> class. Now, for some reason we also have to deal
with turkeys:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Turkey.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Turkey</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Turkey</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">gobble</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><code class="c1">// Turkeys don't quack, they gobble!</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">fly</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">     </code><code class="c1">// Turkeys can fly (a short distance)</code>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;WildTurkey.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">WildTurkey</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Turkey</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">gobble</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">fly</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>Turkeys are represented by the abstract <code>Turkey</code> class, which of course is implemented
by many different kinds of specific <code>Turkey</code>s, like the <code>WildTurkey</code>. To make
things worse, for some reason ducks and turkeys are expected be used together.<sup><a data-type="noteref" href="ch06.xhtml#idm45043099762144" id="idm45043099762144-marker">8</a></sup> One possible way to make this work is
to pretend that a turkey is a duck. After all, a turkey is pretty similar to a duck. Well,
OK, it doesn’t quack, but it can gobble (the typical turkey sound), and it can also fly
(not for a long distance, but yes, it can fly). So you could adapt turkeys
to ducks with the <code>TurkeyAdapter</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;TurkeyAdapter.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">TurkeyAdapter</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Duck</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">TurkeyAdapter</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Turkey</code><code class="o">&gt;</code><code class="w"> </code><code class="n">turkey</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">turkey_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">turkey</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">quack</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">turkey_</code><code class="o">-&gt;</code><code class="n">gobble</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">fly</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">turkey_</code><code class="o">-&gt;</code><code class="n">fly</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Turkey</code><code class="o">&gt;</code><code class="w"> </code><code class="n">turkey_</code><code class="p">;</code><code class="w">  </code><code class="c1">// This is an example for an object adapter</code>
<code class="p">};</code><code class="w"/></pre>
<p>While this is an amusing interpretation of <a href="https://oreil.ly/3rGpx">duck typing</a>,
this example nicely demonstrates that it’s way too easy to integrate
something alien into an existing hierarchy. A <code>Turkey</code> is simply not a <code>Duck</code>, even if we
want it to be. I would argue that likely both the <code>quack()</code> and the <code>fly()</code> function
violate the LSP. Neither functions really does what I would expect it to (at least
I’m pretty sure that I want a quacking, not gobbling, critter and that I want something
that can really fly like a duck). Of course, it depends on the specific context, but
undeniably, the Adapter design pattern makes it very easy to combine things that do
not belong together. Thus, it’s very important that you consider the expected behavior
and check for LSP violations when applying this design pattern:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;MallardDuck.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;WildTurkey.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;TurkeyAdapter.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;vector&gt;</code><code class="cp"/>

<code class="k">using</code><code class="w"> </code><code class="n">DuckChoir</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Duck</code><code class="o">&gt;&gt;</code><code class="p">;</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">give_concert</code><code class="p">(</code><code class="w"> </code><code class="n">DuckChoir</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">duck_choir</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">duck</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">duck_choir</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">duck</code><code class="o">-&gt;</code><code class="n">quack</code><code class="p">();</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">DuckChoir</code><code class="w"> </code><code class="n">duck_choir</code><code class="p">{};</code><code class="w"/>

<code class="w">   </code><code class="c1">// Let's hire the world's best ducks for the choir</code>
<code class="w">   </code><code class="n">duck_choir</code><code class="p">.</code><code class="n">push_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">MallardDuck</code><code class="o">&gt;</code><code class="p">()</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">duck_choir</code><code class="p">.</code><code class="n">push_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">MallardDuck</code><code class="o">&gt;</code><code class="p">()</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">duck_choir</code><code class="p">.</code><code class="n">push_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">MallardDuck</code><code class="o">&gt;</code><code class="p">()</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Unfortunately we also hire a turkey in disguise</code>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">turkey</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">WildTurkey</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">turkey_in_disguise</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">TurkeyAdapter</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">turkey</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">duck_choir</code><code class="p">.</code><code class="n">push_back</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">turkey_in_disguise</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// The concert is going to be a musical disaster...</code>
<code class="w">   </code><code class="n">give_concert</code><code class="p">(</code><code class="w"> </code><code class="n">duck_choir</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In summary, the Adapter design pattern can be considered one of the most valuable
design patterns for combining different pieces of functionality and making them work together.
I promise that it will prove to be a valuable tool in your daily work. Still, do not
abuse the power of Adapter in some heroic effort to combine apples and oranges (or
even oranges and grapefruits: they are similar but not the same). Always be aware of
LSP expectations.<a data-primary="" data-startref="ISshort06" data-type="indexterm" id="idm45043099376528"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043099375552">
<h5>Guideline 24: Use Adapters to Standardize Interfaces</h5>
<ul>
<li>
<p>Apply the Adapter design pattern with the intent to adapt interfaces so that otherwise incompatible pieces can work together.</p>
</li>
<li>
<p>Be aware that Adapter is useful for both dynamic and static polymorphism.</p>
</li>
<li>
<p>Distinguish among object adapters, class adapters, and function adapters.</p>
</li>
<li>
<p>Understand the differences between the Adapter and Strategy design patterns.</p>
</li>
<li>
<p>Pay attention to LSP violations when using the Adapter design pattern.<a data-primary="" data-startref="ADPstdinter06" data-type="indexterm" id="idm45043099275744"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 25: Apply Observers as an Abstract Notification Mechanism" data-type="sect1"><div class="sect1" id="apply_observers_as_an_abstract_notification_mechanism">
<h1>Guideline 25: Apply Observers as an Abstract Notification Mechanism</h1>
<p>Chances<a data-primary="Observer design pattern" data-secondary="abstract notification mechanism" data-type="indexterm" id="ODPabstract06"/><a data-primary="notification mechanisms" data-see="Observer design pattern" data-type="indexterm" id="idm45043099271808"/> are good that you’ve heard about observers before. “Oh, yes, of course I 
<span class="keep-together">have—isn’t</span> this what the so-called social media platforms are doing with us?” you ask.
Well, not exactly what I was going for, but yes, I believe we could call these platforms
observers. And yes, there is also a pattern to what they do, even though it is not a design
pattern. But I’m actually thinking about one of the most popular GoF design patterns, the
Observer design pattern. Even if you are not familiar with the idea yet, you
very likely have some experience with helpful observers from real life. For instance,
you may have noticed that in some messenger apps the sender of a text message
is immediately informed once you’ve read a new text message. That means that the message
is displayed as “read” instead of just “delivered.” This little service is essentially
the work of a real-life Observer: as soon as the status of the new message changes,
the sender is notified, providing the opportunity to respond to the state change.</p>
<section data-pdf-bookmark="The Observer Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043099269952">
<h2>The Observer Design Pattern Explained</h2>
<p>In many software situations it’s desirable to get feedback as soon as some state change
occurs: a new job is added to a task queue, a setting is changed in some configuration
object, a result is ready to be picked up, etc. But at the same time, it would be highly
undesirable to introduce explicit dependencies between the subject (the observed entity
that changes) and its observers (the callbacks that are notified based on a state change).
On the contrary, the subject should be oblivious to the potentially many different kinds of
observers. And that’s for the simple reason that any direct dependency would make the software
harder to change and harder to extend. This decoupling between the subject and its potentially
many observers is the intent of the Observer design pattern.</p>
<div data-type="tip"><h1>The Observer Design Pattern</h1>
<p>Intent: “Define<a data-primary="Observer design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043099267152"/> a one-to-many dependency between objects so that when one object
changes state, all its dependents are notified and updated automatically.”<sup><a data-type="noteref" href="ch06.xhtml#idm45043099265856" id="idm45043099265856-marker">9</a></sup></p>
</div>
<p>As with all design patterns, the Observer design pattern identifies one aspect as a<a data-primary="variation points" data-secondary="in Observer design pattern" data-secondary-sortas="Observer design pattern" data-type="indexterm" id="idm45043099264048"/> <em>variation
point</em> (an aspect that changes or is expected to change) and extracts it in the form of an
abstraction. It thus helps to decouple software entities. In the case of the Observer, the need to
introduce new observers—the need to extend a one-to-many dependency—is recognized to be the
variation point. As <a data-type="xref" href="#fig_observer_original">Figure 6-2</a> illustrates, this variation point is
realized in the form<a data-primary="Observer design pattern" data-secondary="abstract notification mechanism" data-tertiary="UML diagram" data-type="indexterm" id="idm45043099261456"/> of the <code>Observer</code> base class.</p>
<figure><div class="figure" id="fig_observer_original">
<img alt="" height="624" src="assets/cpsd_0602.png" width="1297"/>
<h6><span class="label">Figure 6-2. </span>The UML representation of the Observer design pattern</h6>
</div></figure>
<p>The <code>Observer</code> class represents the abstraction for all possible implementations of
observers. These observers are attached to a specific subject, represented by the

<span class="keep-together"><code>ConcreteSubject</code></span> class. To reduce the coupling between observers and their
subjects, or to simply reduce code duplication by providing all common services to <code>attach()</code>
and <code>detach()</code> to different observers, the <code>Subject</code> abstraction can be used. This 
<span class="keep-together"><code>Subject</code></span>
might also <code>notify()</code> all attached observers about a state change and trigger their corresponding
<code>update()</code> functionality.</p>
<p>“Isn’t the introduction of the <code>Observer</code> base class another example of the
SRP?” you ask. And yes, you’re 100% correct:
extracting the <code>Observer</code> class, extracting a variation point, is the SRP in action
(see <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>). Again, the SRP acts as an enabler for the OCP (see <a data-type="xref" href="ch01.xhtml#design_for_extension">“Guideline 5: Design for Extension”</a>): by introducing the <code>Observer</code> abstraction,
anyone is able to add new kinds of observers (e.g., <code>ConcreteObserver</code>) without the need to
modify existing code. If you pay attention to the ownership of the <code>Observer</code> base class and
make sure that the <code>Observer</code> class lives in the high level of your architecture, then you
also fulfill the Dependency Inversion Principle (DIP).</p>
</div></section>
<section data-pdf-bookmark="A Classic Observer Implementation" data-type="sect2"><div class="sect2" id="idm45043099212160">
<h2>A Classic Observer Implementation</h2>
<p>“Great, I get it! It’s<a data-primary="Observer design pattern" data-secondary="abstract notification mechanism" data-tertiary="classic implementation" data-type="indexterm" id="idm45043099210864"/> nice to see these design principles in action again, but I would
like to see a concrete Observer example.” I understand. So let’s take a look at a
concrete implementation. However, I should clearly state the limitations of the following
example before we start to look at the code. You might already be familiar with <code>Observer</code>, and
therefore you might be looking for help and deeper advice on many of the tricky implementation
details of Observer: how to deal with the order of attaching and detaching observers, attaching an observer multiple times, and especially using observers
in a concurrent environment. I should honestly state up front that it is not my intention
to provide answers to these questions. That discussion would be like opening a can of worms, quickly sucking us into the realm of implementation details. No, although you may be
disappointed, my intention is to mostly stay on the level of software design.<sup><a data-type="noteref" href="ch06.xhtml#idm45043099207840" id="idm45043099207840-marker">10</a></sup></p>
<p class="less_space pagebreak-before">Like for the previous design patterns, we start with a classic implementation of the
Observer design pattern. The central element is the <code>Observer</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Observer.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Observer</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Observer</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">update</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_1" id="code_g25_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The most important implementation detail of this class is the pure virtual <code>update()</code> function
(<a class="co" href="#code_g25_1" id="para_g25_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>),
which is called whenever the observer is notified of some state change.<sup><a data-type="noteref" href="ch06.xhtml#idm45043099160560" id="idm45043099160560-marker">11</a></sup> There are three
alternatives for how to define the <code>update()</code> function, which provide a reasonable
implementation and design flexibility. The first alternative is to push the updated state
via one or even several <code>update()</code> functions:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Observer</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">update1</code><code class="p">(</code><code class="w"> </code><code class="cm">/*arguments representing the updated state*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">update2</code><code class="p">(</code><code class="w"> </code><code class="cm">/*arguments representing the updated state*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>This form of observer is commonly called a<a data-primary="push observers" data-type="indexterm" id="idm45043099106992"/> <em>push observer</em>. In this form, the observer is
given all necessary information by the subject and therefore is not required to pull any
information from the subject on its own. This can reduce the coupling to the subject
significantly and create the opportunity to reuse the <code>Observer</code> class for several subjects.
Additionally, there is the option to use a separate overload for each kind of state change.
In the preceding code snippet, there are two <code>update()</code> functions, one for each of two possible
state changes. And since it’s always clear which state changed, the observer is not required
to “search” for any state change, which proves to be efficient.</p>
<p>“Excuse me,” you say, “but isn’t this a violation of the ISP? Shouldn’t we separate concerns by separating the <code>update()</code> functions into several
base classes?” This is a great question! Obviously, you’re watching out for artificial coupling.
Very good! And you are correct: we could separate an <code>Observer</code> with several <code>update()</code>
functions into smaller <code>Observer</code> classes:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Observer1</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">update1</code><code class="p">(</code><code class="w"> </code><code class="cm">/*arguments representing the updated state*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Observer2</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">update2</code><code class="p">(</code><code class="w"> </code><code class="cm">/*arguments representing the updated state*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>In theory, this approach could help reduce the coupling to a particular subject and
more easily reuse observers for different subjects. It might also help because different
observers might be interested in different state changes, and therefore it might be a violation
of the ISP to artificially couple all possible state changes. And of course this might result
in an efficiency gain if a lot of unnecessary state change notifications can be avoided.</p>
<p>Unfortunately, a particular subject is not likely to distinguish among different kinds of
observers. First, because this would require it to store different kinds of pointers (which is
inconvenient to handle for the subject), and second, because it is possible that different state
changes are linked in a certain way. In that case, the subject will expect that observers
are interested in <em>all</em> possible state changes. From that perspective it can be reasonable to
combine several <code>update()</code> functions into one base class. Either way, it’s very likely that a
concrete observer will have to deal with all kinds of state changes. I know, it can be a nuisance
to have to deal with several <code>update()</code> functions, even if only a small fraction of them
are interesting. But still, make sure that you’re not accidentally violating the Liskov
Substitution Principle by not adhering to some expected behavior (if there is any).</p>
<p>There are several more potential downsides of a push observer. First, the observers are
<em>always</em> given <em>all</em> the information, whether they need it or not. Thus, this push style works
well only if the observers need the information most of the time. Otherwise, a lot of effort is
lost on unnecessary notifications. Second, pushing creates a dependency on the number and kind
of arguments that are passed to the observer. Any change to these arguments requires a lot of
subsequent changes in the deriving observer classes.</p>
<p>Some of these downsides are resolved by the second <code>Observer</code> alternative. It’s possible to
only pass a reference to the subject to the observer:<sup><a data-type="noteref" href="ch06.xhtml#idm45043098985312" id="idm45043098985312-marker">12</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Observer</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">update</code><code class="p">(</code><code class="w"> </code><code class="n">Subject</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">subject</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>Due to the lack of specific information passed to the observer, the classes
deriving from the <code>Observer</code> base class are required to pull the new information from the
subject on their own. For this reason, this form of observer is commonly called a<a data-primary="pull observers" data-type="indexterm" id="idm45043098876944"/> <em>pull
observer</em>. The advantage is the reduced dependency on the number and kinds of arguments.
Deriving observers are free to query for any information, not just the changed state. On
the other hand, this design creates a strong, direct dependency between the classes deriving
from <code>Observer</code> and the subject. Hence, any change to the subject easily reflects on the
observers. Additionally, observers might have to “search” for the state change if
multiple details have changed. This might prove to be unnecessarily inefficient.</p>
<p>If you consider only a single piece of information as the changing state, the
performance disadvantage might not pose a limitation for you. Still, please remember
that software changes: a subject may grow, and with it the desire to notify about different
kinds of changes. Adapting the observers in the process would result in a lot of additional
work. From that point of view, the <em>push observer</em> appears to be a better choice.</p>
<p>Luckily, there is a third alternative, which removes a lot of the previous disadvantages and
thus becomes our approach of choice: in addition to passing a reference to the subject, we
pass a tag to provide information about which property of a subject has changed:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Observer.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Observer</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Observer</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">update</code><code class="p">(</code><code class="w"> </code><code class="n">Subject</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">subject</code><code class="w"/>
<code class="w">                      </code><code class="p">,</code><code class="w"> </code><code class="cm">/*Subject-specific type*/</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p class="less_space pagebreak-before">The tag may help an observer to decide on its own whether some state change is interesting
or not. It’s commonly represented by some subject-specific enumeration type, which lists
all possible state changes. This, unfortunately, increases the coupling of the <code>Observer</code>
class to a specific subject.</p>
<p>“Wouldn’t it be possible to remove the dependency on a specific <code>Subject</code> by implementing
the <code>Observer</code> base class as a class template? Take a look at the following code snippet:”</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Observer.h&gt; ----------------
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Subject</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">StateTag</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g25_2" id="code_g25_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Observer</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Observer</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">update</code><code class="p">(</code><code class="w"> </code><code class="n">Subject</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">subject</code><code class="p">,</code><code class="w"> </code><code class="n">StateTag</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>This is a great suggestion. By defining the <code>Observer</code> class in the form of a class template
(<a class="co" href="#code_g25_2" id="para_g25_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>),
we can easily lift the <code>Observer</code> to a higher architectural level. In this form, the
class does not depend on any specific subject and thus may be reused by many different
subjects that want to define a one-to-many relationship. However, you should not expect
too much of this improvement: the effect is limited to the <code>Observer</code> class. Concrete
subjects will expect concrete instantiations of this observer class, and in consequence,
concrete implementations of <code>Observer</code> will still strongly depend on the subject.</p>
<p>To better understand why that is, let’s take a look at a possible subject
implementation. After your initial comment about social media, I suggest that we implement
an Observer for persons. Well, OK, this example may be morally questionable, but it will
serve its purpose, so let’s go with that. At least we know who is to blame for this.</p>
<p>The following <code>Person</code> class represents an observed person:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Person.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Observer.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;set&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Person</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">enum</code><code class="w"> </code><code class="nc">StateChange</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">forenameChanged</code><code class="p">,</code><code class="w">
</code><code class="w">      </code><code class="n">surnameChanged</code><code class="p">,</code><code class="w">
</code><code class="w">      </code><code class="n">addressChanged</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">PersonObserver</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Observer</code><code class="o">&lt;</code><code class="n">Person</code><code class="p">,</code><code class="n">StateChange</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_5" id="code_g25_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Person</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">forename</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">surname</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">forename_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">forename</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">surname_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">surname</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="n">attach</code><code class="p">(</code><code class="w"> </code><code class="n">PersonObserver</code><code class="o">*</code><code class="w"> </code><code class="n">observer</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_6" id="code_g25_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="nf">detach</code><code class="p">(</code><code class="w"> </code><code class="n">PersonObserver</code><code class="o">*</code><code class="w"> </code><code class="n">observer</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_7" id="code_g25_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">notify</code><code class="p">(</code><code class="w"> </code><code class="n">StateChange</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_8" id="code_g25_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">forename</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">newForename</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_9" id="code_g25_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">surname</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">newSurname</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">address</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">newAddress</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">forename</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">forename_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">surname</code><code class="w"> </code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">surname_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">address</code><code class="w"> </code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">address_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">forename_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_3" id="code_g25_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">surname_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">address_</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">set</code><code class="o">&lt;</code><code class="n">PersonObserver</code><code class="o">*</code><code class="o">&gt;</code><code class="w"> </code><code class="n">observers_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_4" id="code_g25_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>In this example, a <code>Person</code> is merely an aggregation of the three data members:

<span class="keep-together"><code>forename_</code>,</span> <code>surname_</code>, and <code>address_</code>
(<a class="co" href="#code_g25_3" id="para_g25_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>)
(I know, this is a rather simple representation of a person.) In addition, a person
holds the <code>std::set</code> of registered observers
(<a class="co" href="#code_g25_4" id="para_g25_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>).
Please note that the observers are registered by pointers to instances of

<span class="keep-together"><code>PersonObserver</code></span>
(<a class="co" href="#code_g25_5" id="para_g25_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
This is interesting for two reasons: first, this demonstrates the purpose of the templated
<code>Observer</code> class: the <code>Person</code> class instantiates its own kind of observer from the class
template. And second, pointers prove to be very useful in this context, since the address
of an object is unique. Thus, it is common to use the address as a unique identifier for
an observer.</p>
<p>“Shouldn’t this be <code>std::unique_ptr</code> or <code>std::shared_ptr</code>?” you ask. No, not in
this situation. The pointers merely serve as handles to the registered observers; they should
not own the observers. Therefore, any owning smart pointer would be the wrong tool in this
situation. The only reasonable choice would be <code>std::weak_ptr</code>, which would allow you to check
for dangling pointers. However, <code>std::weak_ptr</code> is not a good candidate for a key for
<code>std::set</code> (not even with a custom comparator). Although there are ways to still use
<code>std::weak_ptr</code>, I will stick to raw pointers. But don’t worry, this doesn’t mean we
are abandoning the benefits of modern C++. No, using a raw pointer is perfectly valid
in this situation. This is also expressed in 
<span class="keep-together">C++</span>
<a href="https://oreil.ly/xS6w6">Core Guideline F.7</a>:</p>
<blockquote>
<p>For the general use, take <code>T*</code> or <code>T&amp;</code> arguments rather than smart pointers.</p></blockquote>
<p>Whenever you’re interested in getting a notification for a state change of a person, you
can register an observer via the <code>attach()</code> member function
(<a class="co" href="#code_g25_6" id="para_g25_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).
And whenever you’re no longer interested in getting notifications, you can deregister an
observer via the <code>detach()</code> member function
(<a class="co" href="#code_g25_7" id="para_g25_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).
These two functions are an essential ingredient of the Observer design pattern and a clear indication of the application of the design pattern:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">bool</code><code class="w"> </code><code class="nf">Person::attach</code><code class="p">(</code><code class="w"> </code><code class="n">PersonObserver</code><code class="o">*</code><code class="w"> </code><code class="n">observer</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="p">[</code><code class="n">pos</code><code class="p">,</code><code class="n">success</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">observers_</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="w"> </code><code class="n">observer</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">success</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">bool</code><code class="w"> </code><code class="nf">Person::detach</code><code class="p">(</code><code class="w"> </code><code class="n">PersonObserver</code><code class="o">*</code><code class="w"> </code><code class="n">observer</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="n">observers_</code><code class="p">.</code><code class="n">erase</code><code class="p">(</code><code class="w"> </code><code class="n">observer</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">0U</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You have complete freedom to implement the <code>attach()</code> and <code>detach()</code> functions as you
see fit. In this example, we allow an observer to be registered only a single time with a <code>std::set</code>. If you try to register an observer a second time, the function
returns <code>false</code>. The same thing happens if you try to deregister an observer that
is not registered. Note that the decision to not allow multiple registrations is my
choice for this example. In other scenarios, it might be desirable or even necessary to
accept duplicate registrations. Either way, the behavior and interface of the subject
should of course be consistent in all cases.</p>
<p>Another core function of the Observer design pattern is the <code>notify()</code>
member function
(<a class="co" href="#code_g25_8" id="para_g25_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).
Whenever some state change occurs, this function is called to notify all registered
observers about the change:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">Person::notify</code><code class="p">(</code><code class="w"> </code><code class="n">StateChange</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="n">iter</code><code class="o">=</code><code class="n">begin</code><code class="p">(</code><code class="n">observers_</code><code class="p">);</code><code class="w"> </code><code class="n">iter</code><code class="o">!=</code><code class="n">end</code><code class="p">(</code><code class="n">observers_</code><code class="p">);</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">iter</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">      </code><code class="p">(</code><code class="o">*</code><code class="n">pos</code><code class="p">)</code><code class="o">-&gt;</code><code class="n">update</code><code class="p">(</code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="n">property</code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>“Why is the implementation of the <code>notify()</code> function so complicated? Wouldn’t a range-based
<code>for</code> loop be completely sufficient?” You are correct; I should explain what’s happening here.
The given formulation makes sure <code>detach()</code> operations can be detected during the iteration.
This may happen, for instance, if an observer decides to detach itself during the call to the
<code>update()</code> function. But I do not claim that this formulation is perfect: unfortunately it is
not able to cope with <code>attach()</code> operations. And don’t even start to ask about concurrency!
So this is just one example why the implementation details of observer can be so tricky.</p>
<p>The <code>notify()</code> function is called in all three setter functions
(<a class="co" href="#code_g25_9" id="para_g25_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).
Note that in all three functions, we always pass a different tag to indicate which property
has changed. This tag may be used by classes deriving from the <code>Observer</code> base class to
determine the nature of the change:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">Person::forename</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">newForename</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">forename_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">newForename</code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">notify</code><code class="p">(</code><code class="w"> </code><code class="n">forenameChanged</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">Person::surname</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">newSurname</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">surname_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">newSurname</code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">notify</code><code class="p">(</code><code class="w"> </code><code class="n">surnameChanged</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">Person::address</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">newAddress</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">address_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">newAddress</code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">notify</code><code class="p">(</code><code class="w"> </code><code class="n">addressChanged</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>With these mechanics in place, you are now able to write new kinds of fully OCP-conforming observers. For instance, you could decide to implement a <code>NameObserver</code>
and an <code>AddressObserver</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;NameObserver.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Observer.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Person.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">NameObserver</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Observer</code><code class="o">&lt;</code><code class="n">Person</code><code class="p">,</code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">update</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">person</code><code class="p">,</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;NameObserver.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;NameObserver.h&gt;</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">NameObserver::update</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">person</code><code class="p">,</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">forenameChanged</code><code class="w"> </code><code class="o">||</code><code class="w"/>
<code class="w">       </code><code class="n">property</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">surnameChanged</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ... Respond to changed name</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>


<code class="c1">//---- &lt;AddressObserver.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Observer.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Person.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">AddressObserver</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Observer</code><code class="o">&lt;</code><code class="n">Person</code><code class="p">,</code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">update</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">person</code><code class="p">,</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="c1">//---- &lt;AddressObserver.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;AddressObserver.h&gt;</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">AddressObserver::update</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">person</code><code class="p">,</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">addressChanged</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ... Respond to changed address</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Equipped with these two observers, you are now notified whenever either the
name or address of a person changes:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;AddressObserver.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;NameObserver.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Person.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">NameObserver</code><code class="w"> </code><code class="n">nameObserver</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">AddressObserver</code><code class="w"> </code><code class="n">addressObserver</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="n">Person</code><code class="w"> </code><code class="n">homer</code><code class="p">(</code><code class="w"> </code><code class="s">"Homer"</code><code class="w">     </code><code class="p">,</code><code class="w"> </code><code class="s">"Simpson"</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">Person</code><code class="w"> </code><code class="n">marge</code><code class="p">(</code><code class="w"> </code><code class="s">"Marge"</code><code class="w">     </code><code class="p">,</code><code class="w"> </code><code class="s">"Simpson"</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">Person</code><code class="w"> </code><code class="n">monty</code><code class="p">(</code><code class="w"> </code><code class="s">"Montgomery"</code><code class="p">,</code><code class="w"> </code><code class="s">"Burns"</code><code class="w">   </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Attaching observers</code>
<code class="w">   </code><code class="n">homer</code><code class="p">.</code><code class="n">attach</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">nameObserver</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">marge</code><code class="p">.</code><code class="n">attach</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">addressObserver</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">monty</code><code class="p">.</code><code class="n">attach</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">addressObserver</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Updating information on Homer Simpson</code>
<code class="w">   </code><code class="n">homer</code><code class="p">.</code><code class="n">forename</code><code class="p">(</code><code class="w"> </code><code class="s">"Homer Jay"</code><code class="w"> </code><code class="p">);</code><code class="w">  </code><code class="c1">// Adding his middle name</code>

<code class="w">   </code><code class="c1">// Updating information on Marge Simpson</code>
<code class="w">   </code><code class="n">marge</code><code class="p">.</code><code class="n">address</code><code class="p">(</code><code class="w"> </code><code class="s">"712 Red Bark Lane, Henderson, Clark County, Nevada 89011"</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Updating information on Montgomery Burns</code>
<code class="w">   </code><code class="n">monty</code><code class="p">.</code><code class="n">address</code><code class="p">(</code><code class="w"> </code><code class="s">"Springfield Nuclear Power Plant"</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Detaching observers</code>
<code class="w">   </code><code class="n">homer</code><code class="p">.</code><code class="n">detach</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">nameObserver</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>After these many implementation details, let’s take a step back and look at the
bigger picture again. <a data-type="xref" href="#fig_observer_dependency_graph">Figure 6-3</a> shows the dependency graph for
this Observer example.</p>
<figure><div class="figure" id="fig_observer_dependency_graph">
<img alt="" height="1267" src="assets/cpsd_0603.png" width="1439"/>
<h6><span class="label">Figure 6-3. </span>Dependency graph for the Observer design pattern</h6>
</div></figure>
<p class="less_space pagebreak-before">Due to the decision to implement the <code>Observer</code> class in the form
of a class template, the <code>Observer</code> class resides on the highest level of our architecture.
This enables you to reuse the <code>Observer</code> class for multiple purposes, for instance, for the
<code>Person</code> class. The <code>Person</code> class declares its own <code>Observer&lt;Person,Person::StateChange&gt;</code> type
and by that injects the code into its own architectural level. Concrete person observers,
e.g., <code>NameObserver</code> and <code>AddressObserver</code>, can subsequently build on this declaration.</p>
</div></section>
<section data-pdf-bookmark="An Observer Implementation Based on Value Semantics" data-type="sect2"><div class="sect2" id="idm45043099210608">
<h2>An Observer Implementation Based on Value Semantics</h2>
<p>“I<a data-primary="Observer design pattern" data-secondary="abstract notification mechanism" data-tertiary="dependency graph" data-type="indexterm" id="idm45043097351520"/><a data-primary="Observer design pattern" data-secondary="abstract notification mechanism" data-tertiary="value-based implementation" data-type="indexterm" id="idm45043097350432"/><a data-primary="value semantics, versus reference semantics" data-secondary="value-based Observer design pattern" data-type="indexterm" id="VSVRobserv05"/><a data-primary="reference semantics, versus value semantics" data-secondary="value-based Observer design pattern" data-type="indexterm" id="RSVSobs05"/> understand why you’ve started with a classic implementation, but since you have
made the point about favoring value semantics, how would the observer look in a
value semantics world?” That is an excellent question, since this a very reasonable
next step. As explained in <a data-type="xref" href="ch05.xhtml#prefer_value_semantics_to_reference_semantics">“Guideline 22: Prefer Value Semantics over 
<span class="keep-together">Reference Semantics</span>”</a>, there
are a lot of good reasons to avoid the realm of reference semantics. However, we
won’t entirely stray from the classic implementation: to register and
deregister observers, we will always be in need of some unique identifier for
observers, and the unique address of an observer is just the easiest and most
convenient way to tackle that problem. Therefore, we’ll stick to using a pointer
to refer to a registered observer. However, <code>std::function</code> is an elegant way to avoid the
inheritance hierarchy—<code>std::function</code>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Observer.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;functional&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Subject</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">StateTag</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Observer</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">OnUpdate</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">function</code><code class="o">&lt;</code><code class="kt">void</code><code class="p">(</code><code class="n">Subject</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="p">,</code><code class="n">StateTag</code><code class="p">)</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_10" id="code_g25_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// No virtual destructor necessary
</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Observer</code><code class="p">(</code><code class="w"> </code><code class="n">OnUpdate</code><code class="w"> </code><code class="n">onUpdate</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g25_11" id="code_g25_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">onUpdate_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">onUpdate</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="c1">// Possibly respond on an invalid/empty std::function instance
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Non-virtual update function
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">update</code><code class="p">(</code><code class="w"> </code><code class="n">Subject</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">subject</code><code class="p">,</code><code class="w"> </code><code class="n">StateTag</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">onUpdate_</code><code class="p">(</code><code class="w"> </code><code class="n">subject</code><code class="p">,</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_13" id="code_g25_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">OnUpdate</code><code class="w"> </code><code class="n">onUpdate_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g25_12" id="code_g25_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Instead of implementing the <code>Observer</code> class as a base class, and thus requiring deriving
classes to inherit and implement the <code>update()</code> function in a very specific way, we
separate concerns and instead build on composition (see <a data-type="xref" href="ch05.xhtml#favor_composition_over_inheritance">“Guideline 20: Favor Composition over Inheritance”</a>).
The <code>Observer</code> class first provides a type alias called <code>OnUpdate</code> for the <code>std::function</code>
type for the expected signature of our <code>update()</code> function
(<a class="co" href="#code_g25_10" id="para_g25_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).
Via the constructor, you are passed an instance of 
<span class="keep-together"><code>std::function</code></span>
(<a class="co" href="#code_g25_11" id="para_g25_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>),
and you move it into your data member <code>onUpdate_</code>
(<a class="co" href="#code_g25_12" id="para_g25_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>).
The job of the <code>update()</code> function is now to forward the call, including the arguments, to

<span class="keep-together"><code>onUpdate_</code></span>
(<a class="co" href="#code_g25_13" id="para_g25_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).</p>
<p>The flexibility gained with <code>std::function</code> is easily demonstrated with an updated
<code>main()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Observer.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Person.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">propertyChanged</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">person</code><code class="p">,</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">forenameChanged</code><code class="w"> </code><code class="o">||</code><code class="w"/>
<code class="w">       </code><code class="n">property</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">surnameChanged</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ... Respond to changed name</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">PersonObserver</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Observer</code><code class="o">&lt;</code><code class="n">Person</code><code class="p">,</code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="n">PersonObserver</code><code class="w"> </code><code class="n">nameObserver</code><code class="p">(</code><code class="w"> </code><code class="n">propertyChanged</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">PersonObserver</code><code class="w"> </code><code class="n">addressObserver</code><code class="p">(</code><code class="w"/>
<code class="w">      </code><code class="p">[</code><code class="cm">/*captured state*/</code><code class="p">](</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">person</code><code class="p">,</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">StateChange</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="p">){</code><code class="w"/>
<code class="w">         </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">property</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">Person</code><code class="o">::</code><code class="n">addressChanged</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">         </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// ... Respond to changed address</code>
<code class="w">         </code><code class="p">}</code><code class="w"/>
<code class="w">      </code><code class="p">}</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">Person</code><code class="w"> </code><code class="n">homer</code><code class="p">(</code><code class="w"> </code><code class="s">"Homer"</code><code class="w">     </code><code class="p">,</code><code class="w"> </code><code class="s">"Simpson"</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">Person</code><code class="w"> </code><code class="n">marge</code><code class="p">(</code><code class="w"> </code><code class="s">"Marge"</code><code class="w">     </code><code class="p">,</code><code class="w"> </code><code class="s">"Simpson"</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">Person</code><code class="w"> </code><code class="n">monty</code><code class="p">(</code><code class="w"> </code><code class="s">"Montgomery"</code><code class="p">,</code><code class="w"> </code><code class="s">"Burns"</code><code class="w">   </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Attaching observers</code>
<code class="w">   </code><code class="n">homer</code><code class="p">.</code><code class="n">attach</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">nameObserver</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">marge</code><code class="p">.</code><code class="n">attach</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">addressObserver</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">monty</code><code class="p">.</code><code class="n">attach</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">addressObserver</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Thanks to choosing a less intrusive approach and to decoupling with 
<span class="keep-together"><code>std::function</code></span>,
the choice of how to implement the <code>update()</code> function is completely up to the observer’s
implementer (stateless, stateful, etc.). For the <code>nameObserver</code>, we build on the free
function <code>propertyChanged()</code>, which itself is strongly decoupled because it’s not bound
to a class and might be reused on several occasions. The 
<span class="keep-together"><code>addressObserver</code></span>, on the other
hand, chooses a lambda instead, which could possibly capture some state. Either way, the
only convention that these two have to follow is to fulfill the required signature of the
required <code>std::function</code> type.</p>
<p>“Why do we still need the <code>Observer</code> class? Couldn’t we just directly use 
<span class="keep-together"><code>std::function</code></span>?”
Yes, it most certainly looks that way. From a functionality point of view, the <code>Observer</code>
class doesn’t add anything by itself. However, as <code>std::function</code> is a true child of
value semantics, we tend to copy or move <code>std::function</code> objects. But this is not desirable
in this situation: especially if you use a stateful observer, you don’t want a copy of your
observer to be called. And although technically possible, it is not particularly common to
pass around pointers to <code>std::function</code>. Therefore, the <code>Observer</code> class may still be of
value in the form of an Adapter for <code>std::function</code>
(see <a data-type="xref" href="#use_adapters_to_standardize_interfaces">“Guideline 24: Use Adapters to Standardize Interfaces”</a>).<a data-primary="" data-startref="VSVRobserv05" data-type="indexterm" id="idm45043096856992"/><a data-primary="" data-startref="RSVSobs05" data-type="indexterm" id="idm45043096856016"/></p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the Observer Design Pattern" data-type="sect2"><div class="sect2" id="idm45043096861680">
<h2>Analyzing the Shortcomings of the Observer Design Pattern</h2>
<p>“This<a data-primary="Observer design pattern" data-secondary="abstract notification mechanism" data-tertiary="shortcomings of" data-type="indexterm" id="idm45043096853856"/> is not quite the value semantics solution I was expecting, but I still like it!”
Well, I’m glad you feel this way. Indeed, the value semantics advantages, in combination
with the benefits of the Observer design pattern (i.e., decoupling an event from the action
taken for that event and the ability to easily add new kinds of observers), work really, really
well. Unfortunately, there is no perfect design, and every design also comes with disadvantages.</p>
<p>First, I should explicitly spell out that the demonstrated <code>std::function</code> approach
works well only for a<a data-primary="pull observers" data-type="indexterm" id="idm45043096851296"/> <em>pull observer</em> with a single <code>update()</code> function. Since

<span class="keep-together"><code>std::function</code></span> can cope with only a single callable, any approach that would
require multiple <code>update()</code> functions cannot be handled by a single
<code>std::function</code>. Therefore, <code>std::function</code> is usually not the way to go for a<a data-primary="push observers" data-type="indexterm" id="idm45043096847472"/>
<em>push observer</em> with multiple <code>update()</code> functions, or the potential for a growing
number of <code>update()</code> functions (remember, code tends to change!). However, it is
possible to generalize the approach of <code>std::function</code>. If the need arises,
the design pattern of choice is Type Erasure (see <a data-type="xref" href="ch08.xhtml#type_erasure">Chapter 8</a>).</p>
<p class="less_space pagebreak-before">A second (minor) disadvantage, as you have seen, is that there is no pure value-based implementation. While we might be able to implement the <code>update()</code> functionality
in terms of <code>std::function</code> to gain flexibility, we still use a raw pointer to attach
and detach Observers. And that is easy to explain: the advantages of using a pointer
as a unique identifier are just too good to dismiss. Additionally, for a stateful
Observer, we don’t want to deal with the copy of an entity. Still, this of course
requires us to check for <code>nullptr</code> (which takes additional effort), and we always have
to pay for the indirection that the pointer represents.<sup><a data-type="noteref" href="ch06.xhtml#idm45043096802160" id="idm45043096802160-marker">13</a></sup> I personally would
rate this as only a minor point because of the many advantages of this approach.</p>
<p>A far bigger disadvantage is the potential implementation issues with <em>Observers</em>:
the order of registration and deregistration may matter a lot, in particular if
an observer is allowed to register multiple times. Also, in a multithreaded
environment, the thread-safe registration and deregistration of observers and
handling of events are highly nontrivial topics. For instance, an untrusted
observer can freeze a server during a callback if it behaves inappropriately,
and implementing timeouts for arbitrary computations is <em>very</em> nontrivial.
However, this topic is far outside the scope of this book.</p>
<p>What is in the scope of this book, however, is the alleged danger that the overuse of
observers can quickly and easily lead to a complex network of interconnections. Indeed,
if you are not careful, you can accidentally introduce an infinite loop of callbacks!
For that reason, developers are sometimes concerned about using Observers and are afraid
that a single notification may result in a huge, global response due to these interconnections.
While this danger exists, of course, a proper design should not be severely affected by this:
if you have a proper architecture and if you have properly implemented your observers, then
any sequence of notifications should always run along a<a data-primary="directed, acyclic graph (DAG)" data-type="indexterm" id="idm45043096798880"/><a data-primary="DAG (directed, acyclic graph)" data-type="indexterm" id="idm45043096798272"/> directed, acyclic graph (DAG)
toward the lower levels of your architecture. And that, of course, is the beauty
of good software design.</p>
<p>In summary, with the intent of providing a solution for notification of state change, the
Observer design pattern proves to be one of the most famous and most commonly used
design patterns. Aside from the potentially tricky implementation details, it is
definitely one of the design patterns that should be in every developer’s toolbox.</p>
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043096796768">
<h5>Guideline 25: Apply Observers as an Abstract Notification Mechanism</h5>
<ul>
<li>
<p>Apply the Observer design pattern with the intent to create a one-to-many relationship between a subject and its observers.</p>
</li>
<li>
<p>Understand the trade-offs between push observers and pull observers.</p>
</li>
<li>
<p>Utilize the advantages of a value semantics–based Observer implementation.<a data-primary="" data-startref="ODPabstract06" data-type="indexterm" id="idm45043096792560"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 26: Use CRTP to Introduce Static Type Categories" data-type="sect1"><div class="sect1" id="use_crtp_to_introduce_static_type_categories">
<h1>Guideline 26: Use CRTP to Introduce Static Type Categories</h1>
<p>C++ really has a lot to offer. It<a data-primary="Curiously Recurring Template Pattern" data-see="CRTP" data-type="indexterm" id="idm45043096788960"/><a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static type categories" data-type="indexterm" id="CRTPstatic06"/><a data-primary="static type categories" data-see="CRTP design pattern" data-type="indexterm" id="idm45043096786752"/><a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="naming of" data-type="indexterm" id="idm45043096785808"/> comes with lots of features,
many syntactic curiosities, and a large number of amazing, utterly
unpronounceable and (for the uninitiated) plainly cryptic acronyms: RAII, ADL, CTAD,
SFINAE, NTTP, IFNDR, and SIOF. Oh, what fun! One of these cryptic acronyms is CRTP,
short for the <em>Curiously Recurring Template Pattern</em>.<sup><a data-type="noteref" href="ch06.xhtml#idm45043096784000" id="idm45043096784000-marker">14</a></sup> If you’re’ scratching your head because the name doesn’t make any sense to you, don’t worry: as is so often in C++, the name was chosen randomly, but has stuck and has never been reconsidered or changed. The
pattern was named by James Coplien in the February 1995 issue of the <em>C++ Report</em>
after realizing that, curiously, this pattern was recurring in many different C++
codebases.<sup><a data-type="noteref" href="ch06.xhtml#idm45043096781776" id="idm45043096781776-marker">15</a></sup> And curiously, this pattern,
although building on inheritance and (potentially) serving as an abstraction, does not exhibit
the usual performance drawbacks of many other classic design patterns. For that reason,
CRTP is definitely worth a look, as it may become a valuable, or should I say <em>curious</em>,
addition to your design pattern toolbox.</p>
<section data-pdf-bookmark="A Motivation for CRTP" data-type="sect2"><div class="sect2" id="idm45043096777824">
<h2>A Motivation for CRTP</h2>
<p>Performance<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static type categories" data-tertiary="high-performance computing and" data-type="indexterm" id="idm45043096776192"/><a data-primary="high performance computing (HPC)" data-type="indexterm" id="idm45043096774848"/> is very important in C++. So important in fact, that in several
contexts the performance overhead of using virtual functions is considered outright

<span class="keep-together">unacceptable</span>. Therefore, in performance-sensitive contexts, such as certain parts of computer
games or high-frequency trading, no virtual functions are used. The same is true for
high-performance computing (HPC). In HPC, any kind of conditional or indirection, and this
includes virtual functions, is banned from the most performance-critical parts, such as the
innermost loops of compute kernels. Using them would incur too much of a performance overhead.</p>
<p>To give an example of how and why this matters, let’s consider the following 
<span class="keep-together"><code>DynamicVector</code></span>
class template from a linear algebra (LA) library:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;DynamicVector.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;numeric&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;iosfwd&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;iterator&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;vector&gt;</code><code class="cp">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">DynamicVector</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">value_type</code><code class="w">     </code><code class="o">=</code><code class="w"> </code><code class="n">T</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_2" id="code_g26_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">iterator</code><code class="w">       </code><code class="o">=</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="o">:</code><code class="o">:</code><code class="n">iterator</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">const_iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="o">:</code><code class="o">:</code><code class="n">const_iterator</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Constructors and special member functions
</code><code class="w">
</code><code class="w">   </code><code class="kt">size_t</code><code class="w"> </code><code class="nf">size</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_3" id="code_g26_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">T</code><code class="o">&amp;</code><code class="w">       </code><code class="k">operator</code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_4" id="code_g26_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">iterator</code><code class="w">       </code><code class="nf">begin</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_5" id="code_g26_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">const_iterator</code><code class="w"> </code><code class="nf">begin</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">iterator</code><code class="w">       </code><code class="nf">end</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">const_iterator</code><code class="w"> </code><code class="nf">end</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Many numeric functions
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">values_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_1" id="code_g26_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">&lt;</code><code class="o">&lt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">os</code><code class="p">,</code><code class="w"> </code><code class="n">DynamicVector</code><code class="w"> </code><code class="k">const</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g26_6" id="code_g26_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">os</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s">(</code><code class="s">"</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">os</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s"> </code><code class="s">"</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="n">element</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">os</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s"> )</code><code class="s">"</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">os</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">auto</code><code class="w"> </code><code class="n">l2norm</code><code class="p">(</code><code class="w"> </code><code class="n">DynamicVector</code><code class="w"> </code><code class="k">const</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g26_7" id="code_g26_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">begin</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">end</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">sqrt</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">inner_product</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">vector</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">vector</code><code class="p">)</code><code class="w">
</code><code class="w">                                       </code><code class="p">,</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">vector</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="p">{</code><code class="p">}</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="c1">// ... Many more
</code></pre>
<p>Despite the name, <code>DynamicVector</code> does not represent a container but a numerical vector
for the purpose of LA computations. The <code>Dynamic</code> part of the name implies that it
allocates its elements of type <code>T</code> dynamically, in this example, in the form of <code>std::vector</code>
(<a class="co" href="#code_g26_1" id="para_g26_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
For that reason, it is suited for large LA problems (definitely in the range of several million
elements). Although this class may be loaded with many numerical operations, from an
interface point of view you might indeed be tempted to call it a container: it provides
the usual nested types (<code>value_type</code>, <code>iterator</code>, and <code>const_iterator</code>)
(<a class="co" href="#code_g26_2" id="para_g26_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>),
a <code>size()</code> function to query the current number of elements
(<a class="co" href="#code_g26_3" id="para_g26_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>),
subscript operators to access individual elements by index (one for non-<code>const</code> and one
for <code>const</code> vectors)
(<a class="co" href="#code_g26_4" id="para_g26_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>),
and <code>begin()</code> and <code>end()</code> functions to iterate over the elements
(<a class="co" href="#code_g26_5" id="para_g26_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
Apart from the member functions, it also provides an output operator
(<a class="co" href="#code_g26_6" id="para_g26_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>)
and, to show at least one LA operation, a function to compute the vector’s
<a href="https://oreil.ly/x2a47">Euclidean norm</a> (often
also called the <em>L2 norm</em>, because it approximates the L2 norm for discrete vectors)
(<a class="co" href="#code_g26_7" id="para_g26_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).</p>
<p>The <code>DynamicVector</code> is not the only vector class, though. In our LA library, you will
also find the following <code>StaticVector</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;StaticVector.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;array&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;numeric&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;iosfwd&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;iterator&gt;</code><code class="cp">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Size</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">StaticVector</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">value_type</code><code class="w">     </code><code class="o">=</code><code class="w"> </code><code class="n">T</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_8" id="code_g26_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">iterator</code><code class="w">       </code><code class="o">=</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">std</code><code class="o">:</code><code class="o">:</code><code class="n">array</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Size</code><code class="o">&gt;</code><code class="o">:</code><code class="o">:</code><code class="n">iterator</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">const_iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">std</code><code class="o">:</code><code class="o">:</code><code class="n">array</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Size</code><code class="o">&gt;</code><code class="o">:</code><code class="o">:</code><code class="n">const_iterator</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Constructors and special member functions
</code><code class="w">
</code><code class="w">   </code><code class="kt">size_t</code><code class="w"> </code><code class="nf">size</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_9" id="code_g26_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">T</code><code class="o">&amp;</code><code class="w">       </code><code class="k">operator</code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_10" id="code_g26_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">iterator</code><code class="w">       </code><code class="nf">begin</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_11" id="code_g26_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">const_iterator</code><code class="w"> </code><code class="nf">begin</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">iterator</code><code class="w">       </code><code class="nf">end</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">const_iterator</code><code class="w"> </code><code class="nf">end</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Many numeric functions
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">array</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Size</code><code class="o">&gt;</code><code class="w"> </code><code class="n">values_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_14" id="code_g26_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Size</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">&lt;</code><code class="o">&lt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">os</code><code class="p">,</code><code class="w">    </code><a class="co" href="#para_g26_12" id="code_g26_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">                          </code><code class="n">StaticVector</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Size</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">os</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s">(</code><code class="s">"</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">os</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s"> </code><code class="s">"</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="n">element</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">os</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s"> )</code><code class="s">"</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">os</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Size</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">auto</code><code class="w"> </code><code class="n">l2norm</code><code class="p">(</code><code class="w"> </code><code class="n">StaticVector</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Size</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g26_13" id="code_g26_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">begin</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">end</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">sqrt</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">inner_product</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">vector</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">vector</code><code class="p">)</code><code class="w">
</code><code class="w">                                       </code><code class="p">,</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">vector</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="p">{</code><code class="p">}</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>“Isn’t this almost the same as the <code>DynamicVector</code> class?” you wonder. Yes, these
two classes are very similar indeed. The <code>StaticVector</code> class provides the same interface
as the <code>DynamicVector</code>, such as the nested types <code>value_type</code>, <code>iterator</code>, and 
<span class="keep-together"><code>const_iterator</code></span>
(<a class="co" href="#code_g26_8" id="para_g26_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>);
the <code>size()</code> member function
(<a class="co" href="#code_g26_9" id="para_g26_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>);
the subscript operators
(<a class="co" href="#code_g26_10" id="para_g26_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>);
and the <code>begin()</code> and <code>end()</code> functions
(<a class="co" href="#code_g26_11" id="para_g26_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>).
It also comes with an output operator
(<a class="co" href="#code_g26_12" id="para_g26_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>)
and a free <code>l2norm()</code> function
(<a class="co" href="#code_g26_13" id="para_g26_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).
However, there is an important, performance-related difference between the two vector classes:
as the <code>Static</code> in the name suggests, the 
<span class="keep-together"><code>StaticVector</code></span> does not allocate its elements
dynamically. Instead, it uses an in-class buffer to store its elements, for instance, with a <code>std::array</code>
(<a class="co" href="#code_g26_14" id="para_g26_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>).
Thus, in 
<span class="keep-together">contrast</span> to 
<span class="keep-together"><code>DynamicVector</code></span>, the entire functionality of <code>StaticVector</code> is optimized
for a small, fixed number of elements, such as 2D or 3D vectors.</p>
<p>“OK, I understand that this is important for performance, but there’s still a lot of
code duplication, right?” Again, you are correct. If you take a close look at the associated
output operator of the two vector classes, you will find that the implementation of these two
functions is identical. This is deeply undesirable: if anything changes, for instance,
the way vectors are formatted (and remember: change is <em>the one</em> constant in software
development and needs to be expected; see <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>), then you would have to make
the change in many places, not just one. This is a violation of the Don’t Repeat Yourself
(DRY) principle: it’s easy to forget or miss updating one of the many places, thus
introducing an inconsistency or even a bug.</p>
<p>“But isn’t this duplication easily resolved with a slightly more general function
template? For example, I can imagine the following output operator for all kinds of dense
vectors:”</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">&lt;&lt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">os</code><code class="p">,</code><code class="w"> </code><code class="n">DenseVector</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... as before</code>
<code class="p">}</code><code class="w"/></pre>
<p>Although this seems like an adequate solution, I wouldn’t accept this code in a pull
request. This function template is indeed more general, but I would definitely not call
it “slightly” more general; what you are suggesting is the most general output operator one
could possibly write. Yes, the name of the function template may suggest that it’s written
for only dense vectors (including <code>DynamicVector</code> and <code>StaticVector</code>), but this function
template will in fact accept any type: <code>DynamicVector</code>, <code>StaticVector</code>, <code>std::vector</code>,
<code>std::string</code>, and fundamental types such as <code>int</code> and <code>double</code>. It simply fails
to specify any requirement or any kind of constraint. For that reason it violates
<a href="https://oreil.ly/bVjjh">Core Guideline T.10</a>:<sup><a data-type="noteref" href="ch06.xhtml#idm45043095642896" id="idm45043095642896-marker">16</a></sup></p>
<blockquote>
<p>Specify concepts for all template arguments.</p></blockquote>
<p>While this output operator will work for all dense vectors and sequence containers,
you would get a compilation error for all types that do not provide the expected interface.
Or even worse, you might subtly violate the implicit requirements and expectations, and with
that the LSP (see
<a data-type="xref" href="ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>). Of course, you wouldn’t do this
consciously, but likely accidentally: this output operator is a perfect match for
any type and might be used even though you don’t expect it. Therefore, this function
template would be a very unfortunate addition to the output operator overload set.
What we need is a totally new set of types, a new type category.</p>
<p>“Isn’t this what base classes are for? Couldn’t we just formulate a <code>DenseVector</code>
base class that defines the expected interface for all dense vectors? Consider the
following sketch of a <code>DenseVector</code> base class:”</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><code class="c1">// Type of the elements</code>
<code class="k">class</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">DenseVector</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="nf">size</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="n">T</code><code class="o">&amp;</code><code class="w">       </code><code class="k">operator</code><code class="p">[](</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="p">[](</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">&lt;&lt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">os</code><code class="p">,</code><code class="w"> </code><code class="n">DenseVector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... as before</code>
<code class="p">}</code><code class="w"/></pre>
<p>“This should work, right? I’m just not sure how to declare the <code>begin()</code> and <code>end()</code>
functions, as I don’t know how to abstract from different iterator types, such as
<code>std::vector&lt;T&gt;::iterator</code> and <code>std::array&lt;T&gt;::iterator</code>.” I also have a feeling that
this could be a problem, and I admit that I also do not have a quick solution for that.
But there is something far more concerning: with this base class, we would turn all our
member functions into virtual member functions. That would include the <code>begin()</code> and
<code>end()</code> functions but, most importantly, the two subscript operators. The consequences
would be significant: with every access to an element of the vector, we would now have
to call a virtual function. Every single access! Therefore, with this base class,
we could wave goodbye to high performance.</p>
<p>Still, the general idea of building an abstraction with a base class is good.
We just have to do it differently. This is where we should take a closer look at the CRTP.</p>
</div></section>
<section data-pdf-bookmark="The CRTP Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043096777232">
<h2>The CRTP Design Pattern Explained</h2>
<p>The<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static type categories" data-tertiary="CRTP explained" data-type="indexterm" id="idm45043095532864"/> CRTP design pattern builds on the common idea of creating an abstraction using a base class. But instead of establishing a runtime relationship between base and
derived classes via virtual functions, it creates a compile-time relationship.</p>
<div data-type="tip"><h1>The CRTP Design Pattern</h1>
<p>Intent: “Define<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043095530224"/> a compile-time abstraction for a family of related types.”</p>
</div>
<p>The compile-time relationship between the <code>DenseVector</code> base class and the 
<span class="keep-together"><code>DynamicVector</code></span>
derived class is created by upgrading the base class to a class 
<span class="keep-together">template:</span></p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;DenseVector.h&gt; ----------------
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g26_15" id="code_g26_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="kt">size_t</code><code class="w"> </code><code class="nf">size</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Derived</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="o">&gt;</code><code class="p">(</code><code class="o">*</code><code class="k">this</code><code class="p">)</code><code class="p">.</code><code class="n">size</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g26_17" id="code_g26_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;DynamicVector.h&gt; ----------------
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">DynamicVector</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">DenseVector</code><code class="o">&lt;</code><code class="n">DynamicVector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g26_16" id="code_g26_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="kt">size_t</code><code class="w"> </code><code class="n">size</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_18" id="code_g26_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The curious detail about CRTP is that the new template parameter of the 
<span class="keep-together"><code>DenseVector</code></span> base
class represents the type of the associated derived class
(<a class="co" href="#code_g26_15" id="para_g26_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>).
Derived classes, for instance, the 
<span class="keep-together"><code>DynamicVector</code></span>, are expected to provide their own type to
instantiate the base class
(<a class="co" href="#code_g26_16" id="para_g26_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>).</p>
<p>“Wow, wait a second—is that even possible?” you ask. It is. To instantiate a
template, you do not need the complete definition of a type. It is sufficient to use an incomplete
type. Such an incomplete type is available after the compiler has seen the <code>class DynamicVector</code>
declaration. In essence, this piece of syntax works as a forward declaration. Therefore, the
<code>DynamicVector</code> class can indeed use itself as a template argument to the <code>DenseVector</code> base
class.</p>
<p>Of course, you can name the template parameter of the base class however you’d like (e.g., simply <code>T</code>),
but as discussed in <a data-type="xref" href="ch03.xhtml#use_a_design_patterns_name_to_communicate_intent">“Guideline 14: Use a Design Pattern’s Name to Communicate Intent”</a>, it helps to communicate
intent by using the name of the design pattern or names commonly used for a pattern. For that
reason, you could name the parameter <code>CRTP</code>, which nicely communicates the pattern but

<span class="keep-together">unfortunately</span> only to the initiated. Everyone else will be puzzled by the acronym. Therefore,
the template parameter is often called <code>Derived</code>, which perfectly expresses its purpose and
communicates its intent: it represents the type of the derived class.</p>
<p>Via this template parameter, the base class is now aware of the actual type of the derived
type. While it still represents an abstraction and the common interface for all dense
vectors, it is now able to access and call the concrete implementation in the derived type.
This happens, for instance, in the <code>size()</code> member function
(<a class="co" href="#code_g26_17" id="para_g26_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>):
the <code>DenseVector</code> uses a <code>static_cast</code> to convert itself into a reference to the derived class
and calls the <code>size()</code> function on that. What at first glance may look like a recursive function
call (calling the <code>size()</code> function within the <code>size()</code> function) is in fact a call of the
<code>size()</code> member function in the derived class
(<a class="co" href="#code_g26_18" id="para_g26_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>).</p>
<p>“So this is the compile-time relationship you were taking about. The base class
represents an abstraction from concrete derived types and implementation details but still
knows exactly where the implementation details are. So we really do not need any virtual
function.” Correct. With CRTP, we are now able to
implement a common interface and forward every call to the derived class by simply performing
a <code>static_cast</code>. And there is no performance penalty for doing this. In fact, the base class
function is very likely to be inlined, and if the <code>DenseVector</code> is the only or first base
class, the <code>static_cast</code> will not even result in a single assembly instruction. It merely
tells the compiler to treat the object as an object of the derived type.</p>
<p>To provide a clean CRTP base class, we should update a couple of details, though:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;DenseVector.h&gt; ----------------
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">protected</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="o">~</code><code class="n">DenseVector</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_19" id="code_g26_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">Derived</code><code class="o">&amp;</code><code class="w">       </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Derived</code><code class="o">&amp;</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g26_20" id="code_g26_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">Derived</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Derived</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">size_t</code><code class="w"> </code><code class="n">size</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">size</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Since we want to avoid any virtual functions, we’re also not interested in a virtual
destructor. Therefore, we implement the destructor as a nonvirtual function in the
<code>protected</code> section of the class
(<a class="co" href="#code_g26_19" id="para_g26_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a>).
This perfectly adheres to
<a href="https://oreil.ly/RxGfR">Core Guideline C.35</a>:</p>
<blockquote>
<p>A base class destructor should be either public and virtual, or protected and non-virtual.</p></blockquote>
<p>Keep in mind, though, that this definition of the destructor keeps the compiler from
generating the two move operations. Since a CRTP base class is usually empty

<span class="keep-together">with nothing</span> to move, this is not a problem; but still, always be mindful
about the
<a href="https://oreil.ly/fzS3f">Rule of 5</a>.</p>
<p>We should also avoid using a <code>static_cast</code> in every single member function of the base
class. Although it would be correct, any cast should be considered suspicious, and
casts should be minimized.<sup><a data-type="noteref" href="ch06.xhtml#idm45043095164048" id="idm45043095164048-marker">17</a></sup>
For that reason, we add the two <code>derived()</code> member functions, which perform the cast and can be
used in the other member functions
(<a class="co" href="#code_g26_20" id="para_g26_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a>).
This resulting code not only looks cleaner and adheres to the <em>DRY</em> principle, but it also
looks far less suspicious.</p>
<p>Equipped with the <code>derived()</code> functions, we can now go ahead and define the subscript
operators and the <code>begin()</code> and <code>end()</code> functions:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="o">???</code><code class="w"> </code><code class="k">operator</code><code class="p">[](</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">()[</code><code class="n">index</code><code class="p">];</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="o">???</code><code class="w"> </code><code class="k">operator</code><code class="p">[](</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">()[</code><code class="n">index</code><code class="p">];</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="o">???</code><code class="w"> </code><code class="n">begin</code><code class="p">()</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">begin</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="o">???</code><code class="w"> </code><code class="n">begin</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">begin</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="o">???</code><code class="w"> </code><code class="n">end</code><code class="p">()</code><code class="w">         </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">end</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="o">???</code><code class="w"> </code><code class="n">end</code><code class="p">()</code><code class="w">   </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">end</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>However, these functions are not as straightforward as the <code>size()</code> member function.
In particular, the return types prove to be a little harder to specify, as these types
depend on the implementation of the <code>Derived</code> class. “Well, that shouldn’t be too hard,”
you say. “This is why the derived types provide a couple of nested types,
such as <code>value_type</code>, <code>iterator</code>, and <code>const_iterator</code>, right?” Indeed, it appears to be
intuitive to just ask nicely:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">value_type</code><code class="w">     </code><code class="o">=</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="o">:</code><code class="o">:</code><code class="n">value_type</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_21" id="code_g26_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">iterator</code><code class="w">       </code><code class="o">=</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="o">:</code><code class="o">:</code><code class="n">iterator</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">const_iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="o">:</code><code class="o">:</code><code class="n">const_iterator</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">value_type</code><code class="o">&amp;</code><code class="w">       </code><code class="k">operator</code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="p">[</code><code class="n">index</code><code class="p">]</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">value_type</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="p">[</code><code class="n">index</code><code class="p">]</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">iterator</code><code class="w">       </code><code class="n">begin</code><code class="p">(</code><code class="p">)</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">begin</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">const_iterator</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">begin</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">iterator</code><code class="w">       </code><code class="n">end</code><code class="p">(</code><code class="p">)</code><code class="w">         </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">end</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">const_iterator</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="p">)</code><code class="w">   </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">end</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>We query for the <code>value_type</code>, <code>iterator</code>, and <code>const_iterator</code> types in the derived
class (don’t forget the <code>typename</code> keyword) and use these to specify our return types
(<a class="co" href="#code_g26_21" id="para_g26_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a>).
Easy, right? You can almost bet that it’s not that easy. If you try this,
the Clang compiler will complain with a seriously weird and baffling error message:</p>
<pre data-type="programlisting">CRTP.cpp:29:41: error: no type named 'value_type' in 'DynamicVector&lt;int&gt;'
using value_type = typename Derived::value_type;
                      ~~~~~~~~~~~~~~~~~~^~~~~~~~~~</pre>
<p>“No <code>value_type</code> in <code>DynamicVector&lt;int&gt;</code>—strange.” The first idea that crosses your mind
is that you messed up. It must be a typo. Of course! So you go back to your code and check
the spelling. However, it turns out that everything seems to be OK. There is no typo. You
check the <code>DynamicVector</code> class again: there it is, the nested <code>value_type</code> member. And
everything is <code>public</code>, too. The error message just doesn’t make any sense. You reexamine
everything, and again, and half an hour later you conclude, “The compiler has a bug!”</p>
<p>No, it isn’t a bug in the compiler. Not in Clang or any other compiler. GCC provides a
different, still slightly puzzling, but a perhaps little more illuminating error 
<span class="keep-together">message</span>:<sup><a data-type="noteref" href="ch06.xhtml#idm45043094873184" id="idm45043094873184-marker">18</a></sup></p>
<pre data-type="programlisting">CRTP.cpp:29:10: error: invalid use of incomplete type 'class DynamicVector&lt;int&gt;'
   29 |    using value_type = typename Derived::value_type;
      |          ^~~~~~~~~~</pre>
<p class="less_space pagebreak-before">The Clang compiler is correct: there is no <code>value_type</code> in the <code>DynamicVector</code> class.
Not yet! When you query for the nested types, the definition of the
<code>DynamicVector</code> class hasn’t been seen, and <code>DynamicVector</code> is still an incomplete type.
That’s because the compiler will instantiate the <code>DenseVector</code> base class before the
definition of the <code>DynamicVector</code> class. After all, syntactically, the base class is
specified before the body of the class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">DynamicVector</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">DenseVector</code><code class="o">&lt;</code><code class="n">DynamicVector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="w"/>
<code class="c1">// ...</code></pre>
<p>In consequence, there is no way that you can use the nested types of the derived class
for the return types of the CRTP class. In fact, you can’t use anything as long as
the derived class is an incomplete type. “But why can I call the member functions of
the derived class? Shouldn’t this result in the same problem?” Luckily, this works
(otherwise the CRTP pattern would not work at all). But it only works because of a
special property of class templates: member functions are only instantiated on demand,
meaning when they are actually called. Since an actual call usually happens only after
the definition of the derived class is available, there is no problem with a missing
definition. At that point, the derived class is not an incomplete type anymore.</p>
<p>“OK, I get it. But how do we specify the return types of the subscript operators and
<code>begin()</code> and <code>end()</code> functions?” The most convenient way to handle this is to use
return type deduction. This is a perfect opportunity to use the <code>decltype(auto)</code>
return type:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="k">decltype</code><code class="p">(</code><code class="k">auto</code><code class="p">)</code><code class="w"> </code><code class="k">operator</code><code class="p">[](</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">()[</code><code class="n">index</code><code class="p">];</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">decltype</code><code class="p">(</code><code class="k">auto</code><code class="p">)</code><code class="w"> </code><code class="k">operator</code><code class="p">[](</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">()[</code><code class="n">index</code><code class="p">];</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">decltype</code><code class="p">(</code><code class="k">auto</code><code class="p">)</code><code class="w"> </code><code class="n">begin</code><code class="p">()</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">begin</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">decltype</code><code class="p">(</code><code class="k">auto</code><code class="p">)</code><code class="w"> </code><code class="n">begin</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">begin</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">decltype</code><code class="p">(</code><code class="k">auto</code><code class="p">)</code><code class="w"> </code><code class="n">end</code><code class="p">()</code><code class="w">         </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">end</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">decltype</code><code class="p">(</code><code class="k">auto</code><code class="p">)</code><code class="w"> </code><code class="n">end</code><code class="p">()</code><code class="w">   </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">end</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>“Wouldn’t it be enough to just use <code>auto</code>? For instance, we could define the return
types like this:”</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Note: this doesn't always work, whereas decltype(auto) always works</code>

<code class="w">   </code><code class="k">auto</code><code class="o">&amp;</code><code class="w">       </code><code class="k">operator</code><code class="p">[](</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">()[</code><code class="n">index</code><code class="p">];</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="p">[](</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">()[</code><code class="n">index</code><code class="p">];</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">begin</code><code class="p">()</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">begin</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">begin</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">begin</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">end</code><code class="p">()</code><code class="w">         </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">end</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">end</code><code class="p">()</code><code class="w">   </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">derived</code><code class="p">().</code><code class="n">end</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>It would be enough for this example, yes. However, as I keep emphasizing, code changes.
Eventually, there may be another, deriving vector class that does not store its values
and returns references to its values but produces values and returns
by value. And yes, this is easily conceivable: consider, for instance, a 
<span class="keep-together"><code>ZeroVector</code></span> class,
which represents the <a href="https://oreil.ly/DS9FB">zero element</a> for vectors.
Such a vector would not store all of its elements, as this would be wasteful, but would
likely be implemented as an empty class, which returns a zero by value every time an element
is accessed. In that case, an <code>auto&amp;</code> return type would be incorrect. Yes, the compiler
would (hopefully) warn you about that. But you could avoid the entire problem by just
returning <em>exactly</em> what the deriving class returns. And that kind of return type is
represented by the <code>decltype(auto)</code> return.</p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the CRTP Design Pattern" data-type="sect2"><div class="sect2" id="idm45043095533936">
<h2>Analyzing the Shortcomings of the CRTP Design Pattern</h2>
<p>“Wow, this<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static type categories" data-tertiary="CRTP shortcomings" data-type="indexterm" id="idm45043094186736"/> CRTP design pattern sounds amazing. So seriously, apart from these
slightly-more-complex-than-usual implementation details, isn’t this the solution to all
performance issues with virtual functions? And isn’t this the key, the holy grail for all
inheritance-related problems?” I can understand the enthusiasm! At first sight, CRTP
most definitely looks like the ultimate solution for all kinds of inheritance hierarchies.
Unfortunately, that is an illusion. Remember: every design pattern comes with
benefits but unfortunately also with drawbacks. And there are several pretty limiting
drawbacks to the CRTP design pattern.</p>
<p>The first, and one of the most restricting, drawbacks is the lack of a 
<span class="keep-together">common base class.</span>
I will repeat this to emphasize the gravity of the repercussions: there is <em>no</em> common
base class! Effectively, every single derived class has a different base class. For example,
the <code>DynamicVector&lt;T&gt;</code> class has the <code>DenseVector&lt;Dynamic​Vector&lt;T&gt;&gt;</code> base class. The <code>StaticVector&lt;T,Size&gt;</code> class has the <code>Dense​Vector​&lt;StaticVector&lt;T,Size&gt;&gt;</code> base class<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static type categories" data-tertiary="dependency graph" data-type="indexterm" id="idm45043094181792"/> (see
<a data-type="xref" href="#fig_crtp_dependency_graph">Figure 6-4</a>). Thus, whenever a common base class is required, a common
abstraction that can be used, for instance, to store different types in a collection, the
CRTP design pattern is <em>not</em> the right choice.</p>
<figure><div class="figure" id="fig_crtp_dependency_graph">
<img alt="" height="763" src="assets/cpsd_0604.png" width="1439"/>
<h6><span class="label">Figure 6-4. </span>Dependency graph for the CRTP design pattern</h6>
</div></figure>
<p>“Oh, wow, I see that this could be a real limitation. But couldn’t we just make the
CRTP base class derive from a common base class?” you argue. No, not really, because this
would require us to introduce virtual functions again. “OK, I see. What about simulating a
common base class using <code>std::variant</code>?” Yes, that’s an option. However, please
remember that <code>std::variant</code> is a representation of the <em>Visitor</em> design pattern (see
<a data-type="xref" href="ch04.xhtml#use_visitors_to_extend_operations">“Guideline 16: Use Visitor to Extend Operations”</a>). And since <code>std::variant</code> needs
to know about all its potential alternatives, this will limit your freedom to add new types.
So you see, even though you might not like it, CRTP really is <em>not</em> a replacement for
every inheritance hierarchy.</p>
<p>The second, also potentially very limiting drawback is that everything that
comes in touch with a CRTP base class becomes a template itself. That is particularly
true for all functions that work with such a base class. Consider, for instance, the upgraded
output operator and the <code>l2norm()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">&lt;&lt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">os</code><code class="p">,</code><code class="w"> </code><code class="n">DenseVector</code><code class="o">&lt;</code><code class="n">Derived</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">auto</code><code class="w"> </code><code class="n">l2norm</code><code class="p">(</code><code class="w"> </code><code class="n">DenseVector</code><code class="o">&lt;</code><code class="n">Derived</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>These two functions should work with all classes deriving from the <code>DenseVector</code> CRTP
class. And of course they should not depend on the concrete types of the derived classes.
Therefore, these two functions must be function templates: the <code>Derived</code> type must be
deduced. While in the context of a linear algebra library this is usually not an issue
because almost all functionality is implemented in terms of templates anyway, this may
be a big downside in other contexts. It might be highly 
<span class="keep-together">undesirable</span> to turn lots of
code into templates and move the definitions into header files, effectively sacrificing
the encapsulation of source files. Yes, this may be a severe drawback indeed!</p>
<p>Third, CRTP is an intrusive design pattern. Deriving classes have to explicitly opt in by inheriting from the CRTP base class. While this may be a nonissue in our
own code, you cannot easily add a base class to foreign code. In such a situation,
you would have to resort to the Adapter design pattern (see
<a data-type="xref" href="#use_adapters_to_standardize_interfaces">“Guideline 24: Use Adapters to Standardize Interfaces”</a>). Thus, CRTP does not provide
the flexibility of nonintrusive design patterns (e.g., the Visitor design pattern
implemented with <code>std::variant</code>, the Adapter design pattern, and so on).</p>
<p>Last but not least, CRTP does not provide runtime polymorphism, only compile-time
polymorphism. Therefore, the pattern makes sense only if some kind of static type abstraction
is required. If not, it is again not a replacement for all inheritance 
<span class="keep-together">hierarchies</span>.</p>
</div></section>
<section data-pdf-bookmark="The Future of CRTP: A Comparison Between CRTP and &#10;C++20 Concepts" data-type="sect2"><div class="sect2" id="idm45043094188048">
<h2>The Future of CRTP: A Comparison Between CRTP and 
<span class="keep-together">C++20 Concepts</span></h2>
<p>“I<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static type categories" data-tertiary="CRTP versus C++ concepts" data-type="indexterm" id="idm45043094125856"/> understand, you’re right. CRTP is pure compile-time polymorphism. However, this
makes me wonder: wouldn’t it be possible to build on C++20 concepts instead
of CRTP? Consider the following code. We could use a concept to define the requirements
for a set of types, and restrict functions and operators to only those types that provide
the expected interface:”<sup><a data-type="noteref" href="ch06.xhtml#idm45043094124512" id="idm45043094124512-marker">19</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">concept</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">   </code><code class="k">requires</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="n">t</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">t</code><code class="p">.</code><code class="n">size</code><code class="p">();</code><code class="w"/>
<code class="w">      </code><code class="n">t</code><code class="p">[</code><code class="n">index</code><code class="p">];</code><code class="w"/>
<code class="w">      </code><code class="p">{</code><code class="w"> </code><code class="n">t</code><code class="p">.</code><code class="n">begin</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">same_as</code><code class="o">&lt;</code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="o">::</code><code class="n">iterator</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">      </code><code class="p">{</code><code class="w"> </code><code class="n">t</code><code class="p">.</code><code class="n">end</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">same_as</code><code class="o">&lt;</code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="o">::</code><code class="n">iterator</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"/>
<code class="w">   </code><code class="k">requires</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">t</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">t</code><code class="p">[</code><code class="n">index</code><code class="p">];</code><code class="w"/>
<code class="w">      </code><code class="p">{</code><code class="w"> </code><code class="n">t</code><code class="p">.</code><code class="n">begin</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">same_as</code><code class="o">&lt;</code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="o">::</code><code class="n">const_iterator</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">      </code><code class="p">{</code><code class="w"> </code><code class="n">t</code><code class="p">.</code><code class="n">end</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">same_as</code><code class="o">&lt;</code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="o">::</code><code class="n">const_iterator</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">};</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="n">DenseVector</code><code class="w"> </code><code class="n">VectorT</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">&lt;&lt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">os</code><code class="p">,</code><code class="w"> </code><code class="n">VectorT</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... as before</code>
<code class="p">}</code><code class="w"/></pre>
<p>You are absolutely correct. I agree, this is a very reasonable alternative. Indeed,

<span class="keep-together">C++20</span> concepts are pretty similar to CRTP but represent an easier,
nonintrusive alternative. Especially by being nonintrusive, if you have
access to C++20 concepts and it is possible to define the static set of
types by a concept, you should prefer the concept over the CRTP.</p>
<p>Still, I’m not entirely happy with this solution. While this formulation of the output
operator effectively constrains the function template to only those types that provide
the expected interface, it does not completely restrict the function template to our set
of dense vector types. It’s still possible to pass <code>std::vector</code> and <code>std::string</code>
(<code>std::string</code> already has an output operator in the <code>std</code> namespace). Therefore, this concept
is not specific enough. But if you run into this situation, don’t worry: there is a solution
using a tag class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">struct</code><code class="w"> </code><code class="nc">DenseVectorTag</code><code class="w"> </code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_22" id="code_g26_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">concept</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Definition of all requirements on a dense vector (as before)
</code><code class="w">   </code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">is_base_of_v</code><code class="o">&lt;</code><code class="n">DenseVectorTag</code><code class="p">,</code><code class="n">T</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">DynamicVector</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">private</code><code class="w"> </code><code class="n">DenseVectorTag</code><code class="w">  </code><a class="co" href="#para_g26_23" id="code_g26_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>By inheriting (preferably nonpublicly) from the <code>DenseVectorTag</code> class
(<a class="co" href="#code_g26_22" id="para_g26_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a>),
classes like <code>DynamicVector</code> can identify as being part of a certain set of
types
(<a class="co" href="#code_g26_23" id="para_g26_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a>).
Function and operator templates can therefore be effectively limited to accept only those
types that explicitly opt in to the set of types. Unfortunately, there’s a catch: this
approach is no longer nonintrusive. To overcome this limitation, we introduce
a compile-time indirection by a customizable type trait class. In other words,
we apply the SRP and separate concerns:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">struct</code><code class="w"> </code><code class="nc">DenseVectorTag</code><code class="w"> </code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">IsDenseVector</code><code class="w">  </code><a class="co" href="#para_g26_24" id="code_g26_24"><img alt="24" height="12" src="assets/24.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">is_base_of</code><code class="o">&lt;</code><code class="n">DenseVectorTag</code><code class="p">,</code><code class="n">T</code><code class="o">&gt;</code><code class="w">
</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">constexpr</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="n">IsDenseVector_v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">IsDenseVector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="o">:</code><code class="o">:</code><code class="n">value</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_25" id="code_g26_25"><img alt="25" height="12" src="assets/25.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">concept</code><code class="w"> </code><code class="nc">DenseVector</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Definition of all requirements on a dense vector (as before)
</code><code class="w">   </code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">IsDenseVector_v</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g26_26" id="code_g26_26"><img alt="26" height="12" src="assets/26.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">DynamicVector</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">private</code><code class="w"> </code><code class="n">DenseVectorTag</code><code class="w">  </code><a class="co" href="#para_g26_27" id="code_g26_27"><img alt="27" height="12" src="assets/27.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Size</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">StaticVector</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Size</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">IsDenseVector</code><code class="o">&lt;</code><code class="w"> </code><code class="n">StaticVector</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Size</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g26_28" id="code_g26_28"><img alt="28" height="12" src="assets/28.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">true_type</code><code class="w">
</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The <code>IsDenseVector</code> class template, along with its corresponding variable template, indicates whether a given type is part of the set of dense vector types
(<a class="co" href="#code_g26_24" id="para_g26_24"><img alt="24" height="12" src="assets/24.png" width="12"/></a> and
<a class="co" href="#code_g26_25" id="para_g26_25"><img alt="25" height="12" src="assets/25.png" width="12"/></a>).
Instead of directly querying a given type, the <code>DenseVector</code> concept would ask indirectly via
the <code>IsDenseVector</code> type trait
(<a class="co" href="#code_g26_26" id="para_g26_26"><img alt="26" height="12" src="assets/26.png" width="12"/></a>).
This opens up the opportunity for classes to either intrusively derive from the <code>DenseVectorTag</code>
(<a class="co" href="#code_g26_27" id="para_g26_27"><img alt="27" height="12" src="assets/27.png" width="12"/></a>)
or to nonintrusively specialize the <code>IsDenseVector</code> type trait
(<a class="co" href="#code_g26_28" id="para_g26_28"><img alt="28" height="12" src="assets/28.png" width="12"/></a>).
In this form, the concepts approach truly supersedes the classic CRTP approach.</p>
<p>In summary, CRTP is an amazing design pattern for defining a compile-time relationship
between a family of related types. Most interestingly, it resolves all performance issues
that you may have with inheritance hierarchies. However, CRTP comes with a couple of
potentially limiting drawbacks, such as the lack of a common base class, the quick spreading
of template code, and the restriction to compile-time polymorphism. With
C++20, consider replacing CRTP with concepts, which provide an easier and
nonintrusive alternative. However, if you do not have access to C++20
concepts and if CRTP fits, it will prove immensely valuable to you.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043093508288">
<h5>Guideline 26: Use CRTP to Introduce Static Type Categories</h5>
<ul>
<li>
<p>Apply the CRTP design pattern to define a compile-time abstraction for a family of related types.</p>
</li>
<li>
<p>Be aware of the limited access from the CRTP base class to the derived class.</p>
</li>
<li>
<p>Keep in mind the restrictions of the CRTP design pattern, in particular, the lack of a common base class.</p>
</li>
<li>
<p>Prefer C++20 concepts to the CRTP design pattern when possible.<a data-primary="" data-startref="CRTPstatic06" data-type="indexterm" id="idm45043093423584"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 27: Use CRTP for Static Mixin Classes" data-type="sect1"><div class="sect1" id="use_crtp_for_static_mixin_classes">
<h1>Guideline 27: Use CRTP for Static Mixin Classes</h1>
<p>In <a data-type="xref" href="#use_crtp_to_introduce_static_type_categories">“Guideline 26: Use CRTP to Introduce Static Type Categories”</a>, I<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static mixin classes" data-type="indexterm" id="CRTPmixin06"/><a data-primary="static mixin classes" data-see="CRTP design pattern" data-type="indexterm" id="idm45043093418752"/> introduced you to the CRTP design pattern. I may also have given you the impression
that CRTP is old hat, made obsolete by the advent of C++20 concepts. Well,
interestingly it is not. At least not entirely. That’s because I haven’t told you the
complete story yet. CRTP may still be of value: just not as a design pattern but as an
<em>implementation pattern</em>. So let’s take a detour into the realm of implementation patterns
and let me explain.</p>
<section data-pdf-bookmark="A Strong Type Motivation" data-type="sect2"><div class="sect2" id="idm45043093417056">
<h2>A Strong Type Motivation</h2>
<p>Consider<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static mixin classes" data-tertiary="problem example" data-type="indexterm" id="idm45043093415424"/> the following <code>StrongType</code> class template, which represents a wrapper around any
other type for the purpose of creating a unique, named type:<sup><a data-type="noteref" href="ch06.xhtml#idm45043093413808" id="idm45043093413808-marker">20</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;StrongType.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Tag</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">StrongType</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">value_type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">T</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">StrongType</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">value_</code><code class="p">(</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="n">T</code><code class="o">&amp;</code><code class="w">       </code><code class="n">get</code><code class="p">()</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">value_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">get</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">value_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">T</code><code class="w"> </code><code class="n">value_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>This class can, for instance, be used to define the types <code>Meter</code>, <code>Kilometer</code>, and

<span class="keep-together"><code>Surname</code></span>:<sup><a data-type="noteref" href="ch06.xhtml#idm45043093286096" id="idm45043093286096-marker">21</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Distances.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;StrongType.h&gt;</code><code class="cp"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">using</code><code class="w"> </code><code class="n">Meter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="k">struct</code><code class="w"> </code><code class="nc">MeterTag</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">using</code><code class="w"> </code><code class="n">Kilometer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="k">struct</code><code class="w"> </code><code class="nc">KilometerTag</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="c1">// ...</code>


<code class="c1">//---- &lt;Person.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;StrongType.h&gt;</code><code class="cp"/>

<code class="k">using</code><code class="w"> </code><code class="n">Surname</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="p">,</code><code class="k">struct</code><code class="w"> </code><code class="nc">SurnameTag</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="c1">// ...</code></pre>
<p>The use of alias templates for <code>Meter</code> and <code>Kilometer</code> enables you to choose, for instance,
<code>long</code> or <code>double</code> to represent a distance. However, although these types are built on
fundamental types or Standard Library types, such as <code>std::string</code> in the case of <code>Surname</code>,
they represent distinct types (strong types) with semantic meaning that cannot be
(accidentally) combined in arithmetic operations, for example, 
<span class="keep-together">addition</span>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Main.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Distances.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">m1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Meter</code><code class="o">&lt;</code><code class="kt">long</code><code class="o">&gt;</code><code class="p">{</code><code class="w"> </code><code class="mf">120L</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">m2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Meter</code><code class="o">&lt;</code><code class="kt">long</code><code class="o">&gt;</code><code class="p">{</code><code class="w">  </code><code class="mf">50L</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">km</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Kilometer</code><code class="o">&lt;</code><code class="kt">long</code><code class="o">&gt;</code><code class="p">{</code><code class="w"> </code><code class="mf">30L</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">surname1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Surname</code><code class="p">{</code><code class="w"> </code><code class="s">"</code><code class="s">Stroustrup</code><code class="s">"</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">surname2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Surname</code><code class="p">{</code><code class="w"> </code><code class="s">"</code><code class="s">Iglberger</code><code class="s">"</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="n">m1</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">km</code><code class="p">;</code><code class="w">              </code><code class="c1">// Correctly does not compile!  </code><a class="co" href="#para_g27_1" id="code_g27_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="c1">
</code><code class="w">   </code><code class="n">surname1</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">surname2</code><code class="p">;</code><code class="w">  </code><code class="c1">// Also correctly does not compile!  </code><a class="co" href="#para_g27_2" id="code_g27_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="c1">
</code><code class="w">   </code><code class="n">m1</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">m2</code><code class="p">;</code><code class="w">              </code><code class="c1">// Inconveniently this does not compile either.  </code><a class="co" href="#para_g27_3" id="code_g27_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>Although both <code>Meter</code> and <code>Kilometer</code> are represented via <code>long</code>, it isn’t
possible to directly add <code>Meter</code> and <code>Kilometer</code> together
(<a class="co" href="#code_g27_1" id="para_g27_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
This is great: it doesn’t leave any opening for accidental bugs to crawl in. It’s also not possible to add two <code>Surname</code>s, although <code>std::string</code>
provides an addition operator for string concatenation
(<a class="co" href="#code_g27_2" id="para_g27_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
But this is also great: the strong type effectively restricts undesired operations
of the underlying type. Unfortunately, this “feature” also prevents the addition of two
<code>Meter</code> instances
(<a class="co" href="#code_g27_3" id="para_g27_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>).
This operation would be desirable, though: it is intuitive, natural, and since the result
of the operation would again be of type <code>Meter</code>, physically accurate. To make this work, we could implement an addition operator for the <code>Meter</code> type. However,
obviously, this would not remain the only addition operator. We would also need one for
all the other strong types, such as <code>Kilometer</code>, <code>Mile</code>, <code>Foot</code>, etc. Since all of these
implementations would look the same, this would be a violation of the DRY principle. Therefore, it appears to be reasonable to extend the <code>StrongType</code> class
template with an addition operator:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Tag</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Tag</code><code class="o">&gt;</code><code class="w"/>
<code class="w">   </code><code class="k">operator</code><code class="o">+</code><code class="p">(</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Tag</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Tag</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Tag</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">a</code><code class="p">.</code><code class="n">get</code><code class="p">()</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">b</code><code class="p">.</code><code class="n">get</code><code class="p">()</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Whereas due to the formulation of this addition operator it is not possible to
add two different instantiations of <code>StrongType</code> together (e.g., <code>Meter</code> and <code>Kilometer</code>),
it would enable the addition of two instances of the same instantiation of <code>StrongType</code>.
“Oh, but I see a problem: while it would now be possible to add two <code>Meter</code>s or two

<span class="keep-together"><code>Kilometer</code>s</span>, it would also be possible to add two <code>Surname</code>s. We don’t want that!”
You are correct: this would be undesirable. What we need instead is a deliberate addition
of operations to specific instantiations of <code>StrongType</code>. This is where CRTP comes into
play.</p>
</div></section>
<section data-pdf-bookmark="Using CRTP as an Implementation Pattern" data-type="sect2"><div class="sect2" id="idm45043093416432">
<h2>Using CRTP as an Implementation Pattern</h2>
<p>Instead<a data-primary="CRTP (Curiously Recurring Template Pattern) design pattern" data-secondary="static mixin classes" data-tertiary="CRTP as implementation pattern" data-type="indexterm" id="idm45043092803856"/><a data-primary="implementation patterns" data-secondary="CRTP pattern as" data-type="indexterm" id="IPcrtp06"/> of directly equipping the <code>StrongType</code> class template with operations, we provide the operations via <em>mixin</em> classes: base classes that “inject” the
desired operations. These mixin classes are implemented in terms of the CRTP.
Consider, for instance, the <code>Addable</code> class template, which represents the addition
operation:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Addable.h&gt; ----------------
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">Addable</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="n">Derived</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">+</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Derived</code><code class="o">&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Derived</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">  </code><a class="co" href="#para_g27_4" id="code_g27_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="n">lhs</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="o">=</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">lhs</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="n">Derived</code><code class="w"> </code><code class="k">operator</code><code class="o">+</code><code class="p">(</code><code class="w"> </code><code class="n">Derived</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Derived</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">  </code><a class="co" href="#para_g27_5" id="code_g27_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">Derived</code><code class="p">{</code><code class="w"> </code><code class="n">lhs</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The name of the template parameters gives it away: <code>Addable</code> is a CRTP base class.
<code>Addable</code> provides only two functions, implemented
as <a href="https://oreil.ly/QmrTG">hidden friends</a>:
an addition assignment operator
(<a class="co" href="#code_g27_4" id="para_g27_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>)
and an addition operator
(<a class="co" href="#code_g27_5" id="para_g27_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
Both operators are defined for the specified <code>Derived</code> type and are injected into
the surrounding namespace.<sup><a data-type="noteref" href="ch06.xhtml#idm45043092685280" id="idm45043092685280-marker">22</a></sup> Thus, any class deriving
from this CRTP base class will “inherit” two free addition operators:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;StrongType.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Tag</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">StrongType</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">private</code><code class="w"> </code><code class="n">Addable</code><code class="o">&lt;</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Tag</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"> </code><code class="cm">/* ... */</code><code class="w"> </code><code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Distances.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;StrongType.h&gt;</code><code class="cp"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">using</code><code class="w"> </code><code class="n">Meter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="k">struct</code><code class="w"> </code><code class="nc">MeterTag</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="c1">// ...</code>


<code class="c1">//---- &lt;Main.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Distances.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">m1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Meter</code><code class="o">&lt;</code><code class="kt">long</code><code class="o">&gt;</code><code class="p">{</code><code class="w"> </code><code class="mi">100</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">m2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Meter</code><code class="o">&lt;</code><code class="kt">long</code><code class="o">&gt;</code><code class="p">{</code><code class="w">  </code><code class="mi">50</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">m3</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">m1</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">m2</code><code class="p">;</code><code class="w">  </code><code class="c1">// Compiles and results in 150 meters</code>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>“I understand the purpose of the mixin class, but in this form, <em>all</em> instantiations of
<code>StrongType</code> would inherit an addition operator, even the ones where an addition is
not required, right?” Yes, indeed. Therefore, we aren’t finished yet. What we want
to do is to selectively add the mixin class to those <code>StrongType</code> instantiations that
need the operation. Our solution of choice is to provide the mixins in the form of optional
template arguments. For that purpose, we extend the <code>StrongType</code> class template by a pack of
variadic template template parameters:<sup><a data-type="noteref" href="ch06.xhtml#idm45043092620528" id="idm45043092620528-marker">23</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;StrongType.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Tag</code><code class="p">,</code><code class="w"> </code><code class="k">template</code><code class="o">&lt;</code><code class="k">typename</code><code class="o">&gt;</code><code class="w"> </code><code class="k">class</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w"> </code><code class="n">Skills</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">StrongType</code><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="k">private</code><code class="w"> </code><code class="n">Skills</code><code class="o">&lt;</code><code class="w"> </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Tag</code><code class="p">,</code><code class="n">Skills</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&gt;</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">  </code><a class="co" href="#para_g27_9" id="code_g27_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w"> </code><code class="cm">/* ... */</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>This extension enables us to individually specify, for each single strong type, which
skills are desired. Consider, for instance, the two additional skills <code>Printable</code> and

<span class="keep-together"><code>Swappable</code></span>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Printable.h&gt; ----------------</code>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">Printable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">&lt;&lt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">ostream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">os</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">Derived</code><code class="o">&amp;</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">os</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="n">d</code><code class="p">.</code><code class="n">get</code><code class="p">();</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">os</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Swappable.h&gt; ----------------</code>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">Swappable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">swap</code><code class="p">(</code><code class="w"> </code><code class="n">Derived</code><code class="o">&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Derived</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">swap</code><code class="p">;</code><code class="w">  </code><code class="c1">// Enable ADL</code>
<code class="w">      </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">lhs</code><code class="p">.</code><code class="n">get</code><code class="p">(),</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">get</code><code class="p">()</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>Together with the <code>Addable</code> skill, we can now assemble strong types equipped with the
required and desired skills:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Distances.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;StrongType.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">using</code><code class="w"> </code><code class="n">Meter</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">   </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="k">struct</code><code class="w"> </code><code class="nc">MeterTag</code><code class="p">,</code><code class="n">Addable</code><code class="p">,</code><code class="n">Printable</code><code class="p">,</code><code class="n">Swappable</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g27_6" id="code_g27_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">using</code><code class="w"> </code><code class="n">Kilometer</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">   </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="k">struct</code><code class="w"> </code><code class="nc">KilometerTag</code><code class="p">,</code><code class="n">Addable</code><code class="p">,</code><code class="n">Printable</code><code class="p">,</code><code class="n">Swappable</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g27_7" id="code_g27_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Person.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;StrongType.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">using</code><code class="w"> </code><code class="n">Surname</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">   </code><code class="n">StrongType</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="p">,</code><code class="k">struct</code><code class="w"> </code><code class="nc">SurnameTag</code><code class="p">,</code><code class="n">Printable</code><code class="p">,</code><code class="n">Swappable</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g27_8" id="code_g27_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="c1">// ...
</code></pre>
<p>Both <code>Meter</code> and <code>Kilometer</code> can be added, printed, and swapped (see
<a class="co" href="#code_g27_6" id="para_g27_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>
and
<a class="co" href="#code_g27_7" id="para_g27_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>),
while <code>Surname</code> is printable and swappable, but not addable (i.e., does not receive the

<span class="keep-together"><code>Addable</code></span> mixin and therefore does not derive from it)
(<a class="co" href="#code_g27_8" id="para_g27_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).</p>
<p>“That’s great. I understand the purpose of the CRTP mixin class in this context. But how
is this CRTP example different from previous examples?” Very good question. You’re right,
the implementation details are very similar. But there are a couple of distinctive
differences. Note that the CRTP base class doesn’t provide a <code>virtual</code> or <code>protected</code>
destructor. Hence, in contrast to previous examples, it is not designed as a polymorphic
base class. Also note that in this example it is sufficient, and even preferable, to
use the CRTP base class as a <code>private</code> base class, not a <code>public</code> one
(<a class="co" href="#code_g27_9" id="para_g27_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).</p>
<p>Thus, in this context, the CRTP base class does not represent an abstraction but only
an implementation detail. Therefore, the CRTP does not fulfill the properties of a
design pattern, and it does not act as a design pattern. It’s still a pattern, no
question there, but it merely acts as an implementation pattern in this case.</p>
<p class="less_space pagebreak-before">The major difference in the implementation of the CRTP examples is the way we use
inheritance. For the CRTP design pattern, we use inheritance as an
abstraction according to the LSP: the base class represents the requirements, and thus
the available and expected behavior of the derived class. User code directly accesses the
operations via pointers or references to the base class, which in turn requires us
to provide a <code>virtual</code> or <code>protected</code> destructor. When implemented this way, CRTP
becomes a true element of software design—a design pattern.</p>
<p>In contrast, for the CRTP implementation pattern, we use inheritance for technical elegance and convenience. The base class becomes an implementation
detail and does not have to be known or used by calling code. Therefore, it doesn’t
need a 
<span class="keep-together"><code>virtual</code></span> or <code>protected</code> destructor. When implemented this way, CRTP stays
on the level of the implementation details and therefore is an implementation pattern. In
this form, however, CRTP does not compete with C++20 concepts. On the
contrary: in this form CRTP is unchallenged, as it represents a unique technique
to provide static mixin functionality. For that reason, CRTP is still in use today
and represents a valuable addition to every C++ developer’s toolbox.</p>
<p>In summary, CRTP is not obsolete, but its value has changed. In C++20, CRTP
is replaced by concepts and therefore is stepping down as a design pattern. However, it
continues to be valuable as an implementation pattern for mixin classes.<a data-primary="" data-startref="IPcrtp06" data-type="indexterm" id="idm45043091957952"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043091956848">
<h5>Guideline 27: Use CRTP for Static Mixin Classes</h5>
<ul>
<li>
<p>Be aware between the difference between using CRTP as a design pattern and using it as an implementation pattern.</p>
</li>
<li>
<p>Understand that CRTP base classes that represent an abstraction act as a design pattern.</p>
</li>
<li>
<p>Understand that CRTP base classes that do not represent an abstraction act as an implementation pattern.<a data-primary="" data-startref="CRTPmixin06" data-type="indexterm" id="idm45043091952752"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45043101334880"><sup><a href="ch06.xhtml#idm45043101334880-marker">1</a></sup> The Pages format is Apple’s equivalent to Microsoft’s Word format.</p><p data-type="footnote" id="idm45043101092960"><sup><a href="ch06.xhtml#idm45043101092960-marker">2</a></sup> Erich Gamma et al., <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p><p data-type="footnote" id="idm45043100929584"><sup><a href="ch06.xhtml#idm45043100929584-marker">3</a></sup> If you’re an expert on design patterns, you might realize that a 1-to-<em>N</em> Adapter has a certain similarity to the Facade design pattern. See the GoF book for more details.</p><p data-type="footnote" id="idm45043100781216"><sup><a href="ch06.xhtml#idm45043100781216-marker">4</a></sup> In C++20, you achieve a similar effect by applying the <a href="https://oreil.ly/H41V8"><code>[[no_unique_address]]</code></a> attribute to a data member. If the data member is empty, it might not occupy any storage on its own.</p><p data-type="footnote" id="idm45043100261104"><sup><a href="ch06.xhtml#idm45043100261104-marker">5</a></sup> In this context, it’s particularly interesting to note that <code>std::stack</code> doesn’t allow you to traverse the elements via iterators. As usual for a stack, you’re allowed to access only the topmost element.</p><p data-type="footnote" id="idm45043099971744"><sup><a href="ch06.xhtml#idm45043099971744-marker">6</a></sup> Matthew Wilson, <em>Imperfect C++: Practical Solutions for Real-Life Programming</em> (Addison-Wesley, 2004).</p><p data-type="footnote" id="idm45043099966256"><sup><a href="ch06.xhtml#idm45043099966256-marker">7</a></sup> Eric Freeman and Elisabeth Robson, <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/head-first-design/9781492077992/"><em>Head First Design Patterns: Building Extensible and Maintainable Object-Oriented
Software</em></a> (O’Reilly, 2021).</p><p data-type="footnote" id="idm45043099762144"><sup><a href="ch06.xhtml#idm45043099762144-marker">8</a></sup> Of course, you know better than to try this at home, but let’s assume this is one of those strange, Monday-morning management decisions.</p><p data-type="footnote" id="idm45043099265856"><sup><a href="ch06.xhtml#idm45043099265856-marker">9</a></sup> Erich Gamma et al., <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p><p data-type="footnote" id="idm45043099207840"><sup><a href="ch06.xhtml#idm45043099207840-marker">10</a></sup> Despite the fact that I don’t venture into the thicket of Observer implementation details, I can still give you a few references on how to implement Observers. A good overview on many of the implementation aspects is Victor Ciura’s CppCon 2021 talk <a href="https://oreil.ly/9TcK6">“Spooky Action at a Distance”</a>. A very detailed discussion on how to deal with the concurrency issues of the <code>Observer</code> pattern can be found in Tony Van Eerd’s C++Now 2016 talk <a href="https://oreil.ly/KKU47">“Thread-Safe Observer Pattern—You’re Doing It Wrong”</a>.</p><p data-type="footnote" id="idm45043099160560"><sup><a href="ch06.xhtml#idm45043099160560-marker">11</a></sup> If you’re aware of the <a href="https://oreil.ly/mqwgp">Non-Virtual Interface (NVI)</a> idiom or the Template Method design pattern, then please feel free to move this virtual function into the <code>private</code> section of the class and provide a public, nonvirtual wrapper function for it. You can find more information about NVI in Herb Sutter’s <a href="http://www.gotw.ca">Guru of the Week blog</a> or in the article <a href="https://oreil.ly/GSdnB">“Virtuality”</a> from the <em>C++ Users Journal</em>, 19(9), September 2001.</p><p data-type="footnote" id="idm45043098985312"><sup><a href="ch06.xhtml#idm45043098985312-marker">12</a></sup> Alternatively, the observer could also remember the subject on its own.</p><p data-type="footnote" id="idm45043096802160"><sup><a href="ch06.xhtml#idm45043096802160-marker">13</a></sup> You can also choose to build on <code>gsl::not_null&lt;T&gt;</code> from the <a href="https://oreil.ly/cx0Jd">Guideline Support Library (GSL)</a>.</p><p data-type="footnote" id="idm45043096784000"><sup><a href="ch06.xhtml#idm45043096784000-marker">14</a></sup> If you’re wondering what those others stand for: RAII: Resource Acquisition Is Initialization (which is argued to be the most valuable idea of C++, but at the same time is officially the worst acronym; it literally does not make any sense); ADL: Argument Dependent Lookup; CTAD: Class Template Argument Deduction; SFINAE: Substitution Failure Is Not An Error; NTTP: Non-Type Template Parameter; IFNDR: Ill-Formed, No Diagnostic Required; SIOF: Static Initialization Order Fiasco. For an overview of (almost) all C++ acronyms, see <a href="https://oreil.ly/36Gnd">Arthur O’Dwyer’s blog</a>.</p><p data-type="footnote" id="idm45043096781776"><sup><a href="ch06.xhtml#idm45043096781776-marker">15</a></sup> Ah, the <a href="https://oreil.ly/HJIKc"><em>C++ Report</em></a>—such glorious times! However, you may be one of the poor souls who never had an opportunity to read an original <em>C++ Report</em>. If so, you should know that it was a bimonthly computer magazine published by the SIGS Publications Group between 1989 and 2002. The original <em>C++ Report</em> is hard to come by these days, but many of its articles have been collected in the book edited by Stanley Lippmann <em>C++ Gems: Programming Pearls from the C++ Report</em> (Cambridge University Press). This book includes James Coplien’s article “Curiously Recurring Template Patterns.”</p><p data-type="footnote" id="idm45043095642896"><sup><a href="ch06.xhtml#idm45043095642896-marker">16</a></sup> If you can’t use C++20 concepts yet, <code>std::enable_if</code> provides an alternative formulation. Refer to <a href="https://oreil.ly/K2ljM">Core Guideline T.48</a>: “If your compiler does not support concepts, fake them with <code>enable_if</code>.” See also your preferred C++ templates reference.</p><p data-type="footnote" id="idm45043095164048"><sup><a href="ch06.xhtml#idm45043095164048-marker">17</a></sup> Consider any kind of cast (<code>static_cast</code>, <code>reinterpret_cast</code>, <code>const_cast</code>, <code>dynamic_cast</code>, and especially the old C-style casts) as adult features: you take full responsibility of your actions and the compiler will obey. Therefore, it is seriously advisable to reduce calls to cast operators (see also <a href="https://oreil.ly/ZEE0P">Core Guideline ES.48</a>: “Avoid casts”).</p><p data-type="footnote" id="idm45043094873184"><sup><a href="ch06.xhtml#idm45043094873184-marker">18</a></sup> This is a great example to demonstrate that it pays off to be able to compile your codebase with several major compilers (Clang, GCC, MSVC, etc.). Different error messages might help you find the source of the problem. Using only one compiler should be considered a risk!</p><p data-type="footnote" id="idm45043094124512"><sup><a href="ch06.xhtml#idm45043094124512-marker">19</a></sup> If you aren’t familiar with the idea or syntax of C++20 concepts yet, you can get a quick and painless introduction in Sándor Dargó’s <em>C++ Concepts</em>, published at <a href="https://leanpub.com/cppconcepts">Leanpub</a>.</p><p data-type="footnote" id="idm45043093413808"><sup><a href="ch06.xhtml#idm45043093413808-marker">20</a></sup> This implementation of a <code>StrongType</code> is inspired by Jonathan Boccara’s <a href="https://oreil.ly/Tqafn">Fluent C++ blog</a> and the associated <a href="https://oreil.ly/F5JO6">NamedType library</a>. There are several more strong type libraries available, though: alternatively you can use Jonathan Müller’s <a href="https://oreil.ly/Bju8Z"><em>type_safe</em> library</a>, Björn Fahller’s <a href="https://oreil.ly/bxJrf"><em>strong_type</em> library</a>, or Anthony William’s <a href="https://oreil.ly/q58u6"><em>strong_typedef</em> library</a>.</p><p data-type="footnote" id="idm45043093286096"><sup><a href="ch06.xhtml#idm45043093286096-marker">21</a></sup> The only technical oddity is the declaration of a tag class right in the template parameter list. Yes, this works, and definitely helps create a unique type for the purpose of instantiating distinct strong types.</p><p data-type="footnote" id="idm45043092685280"><sup><a href="ch06.xhtml#idm45043092685280-marker">22</a></sup> Many years ago, more specifically at the end of the ’90s, this kind of namespace injection was called the <em>Barton-Nackman trick</em>, named after John J. Barton and Lee R. Nackman. In the March 1995 issue of the <em>C++ Report</em>, they used namespace injection as a workaround for the limitation that function templates could not be overloaded at the time. Surprisingly, today this technique has experienced a renaissance as the <em>hidden friend idiom</em>.</p><p data-type="footnote" id="idm45043092620528"><sup><a href="ch06.xhtml#idm45043092620528-marker">23</a></sup> In <a href="https://oreil.ly/jefQD">Jonathan Bocarra’s blog</a>, these optional, variadic arguments are aptly called <em>skills</em>. I very much like this, so I adopt this naming convention.</p></div></div></section></div></body></html>