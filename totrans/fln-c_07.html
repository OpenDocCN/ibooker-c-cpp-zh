<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. Flexible APIs" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_api_flexibility">
<h1><span class="label">Chapter 6. </span>Flexible APIs</h1>
<p class="fix-tracking">Designing interfaces<a data-primary="APIs, flexible" data-secondary="challenges of designing" data-type="indexterm" id="idm45587920556656"/> with the right level of flexibility and the right level of abstraction is one of the most important things when writing software, because interfaces represent a contract that often cannot be changed once the system is in operation. Because of this it is important to put stable declarations into the interface and to abstract implementation details, which should have the flexibility to change at a later point in time.</p>
<p>For object-oriented programming languages, you’ll find much guidance on how to design interfaces (for example, in the form of design patterns), but there is not much guidance of this kind for procedural programming languages like C. There are the SOLID design principles (see nearby sidebar) that tell you in general how to design good software. However, for the C programming language, detailed design guidance on how to design interfaces is hard to find, and that’s where the patterns from this chapter come in.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45587920554576">
<h5>SOLID</h5>
<p>The<a data-primary="SOLID principles" data-type="indexterm" id="idm45587920553248"/> SOLID principles tell us how to implement good, flexible, and maintainable 
<span class="keep-together">software</span>.</p>
<dl>
<dt><strong>S</strong>ingle-responsibility<a data-primary="single-responsibility principle" data-type="indexterm" id="idm45587920550288"/> principle</dt>
<dd>
<p>The code has one responsibility and one reason to be changed in the future.</p>
</dd>
<dt><strong>O</strong>pen-closed<a data-primary="open-closed principle" data-type="indexterm" id="idm45587920547888"/> principle</dt>
<dd>
<p>Code should be open for behavior changes without requiring changes to the existing code.</p>
</dd>
<dt><strong>L</strong>iskow<a data-primary="Liskow substitution principle" data-type="indexterm" id="idm45587920545344"/> substitution principle</dt>
<dd>
<p>Codes that implement the same interface should be interchangable for the caller.</p>
</dd>
<dt><strong>I</strong>nterface segregation<a data-primary="interface segregation principle" data-type="indexterm" id="idm45587920542848"/> principle</dt>
<dd>
<p>Interfaces should be slim and tailored for the caller’s needs.</p>
</dd>
<dt><strong>D</strong>ependency inversion<a data-primary="dependency inversion principle" data-type="indexterm" id="idm45587920540448"/> principle</dt>
<dd>
<p>High-level modules should be independent from low-level modules.</p>
</dd>
</dl>
<p>The article <a href="https://oreil.ly/xrCtb">“SOLID Design for Embedded C”</a> by James Grenning gives you more details on how to implement the SOLID principles in C.</p>
</div></aside>
<p><a data-type="xref" href="#overview_flexible_api">Figure 6-1</a> shows the four patterns covered in this chapter, as well as related patterns, and <a data-type="xref" href="#tab_flexible_api">Table 6-1</a> contains a short description of the four patterns. Keep in mind that not all of the patterns should always be applied in all possible contexts. Generally it is advisable to design a system to not be more complex than it has to be. This means that some of the presented patterns should only be applied if the gained flexibility is already required by your API or will likely be required in the future. If it is not likely to be required, then the pattern should perhaps not be applied to keep the API as simple as possible.</p>
<figure><div class="figure" id="overview_flexible_api">
<img alt="Overview of the patterns on flexible APIs" height="415" src="assets/fluc_0601.png" width="1232"/>
<h6><span class="label">Figure 6-1. </span>Overview of patterns for flexible APIs</h6>
</div></figure>
<table id="tab_flexible_api">
<caption><span class="label">Table 6-1. </span>Patterns for flexible APIs</caption>
<thead>
<tr>
<th/>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td/>
<td><p>Header Files</p></td>
<td><p>You<a data-primary="APIs, flexible" data-secondary="overview of patterns for" data-type="indexterm" id="idm45587920528112"/> want a functionality that you implement to be accessible to code from other implementation files, but you want to hide your implementation details from the caller. Therefore, provide function declarations in your API for any functionality you want to provide to your user. Hide any internal functions, internal data, and your function definitions (the implementations) in your implementation file and don’t provide this implementation file to the user.</p></td>
</tr>
<tr>
<td/>
<td><p>Handle</p></td>
<td><p>You have to share state information or operate on shared resources in your function implementations, but you don’t want your caller to see or even access all that state information and shared resources. Therefore, have a function to create the context on which the caller operates and return an abstract pointer to internal data for that context. Require the caller to pass that pointer to all your functions, which can then use the internal data to store state information and resources.</p></td>
</tr>
<tr>
<td/>
<td><p>Dynamic Interface</p></td>
<td><p>It should be possible to call implementations with slightly deviating behaviors, but it should not be necessary to duplicate any code, not even the control logic implementation and interface declaration. Therefore, define a common interface for the deviating functionalities in your API and require the caller to provide a callback function for that functionality, which you then call in your function implementation.</p></td>
</tr>
<tr>
<td/>
<td><p>Function Control</p></td>
<td><p>You want to call implementations with slightly deviating behaviors, but you don’t want to duplicate any code, not even the control logic implementation or the interface declaration. Therefore, add a parameter to your function that passes meta-information about the function call and that specifies the actual functionality to be performed.</p></td>
</tr>
</tbody>
</table>
<p>As a running example, in this chapter you want to implement a device driver for your Ethernet network interface card. The firmware of this card provides several registers with which you can send or receive data and with which you can configure the card. You want to build some abstraction of these hardware details, and you want to make sure that a user of your API is not affected if you change some parts of your implementation. To achieve this, you build an API consisting of Header Files.</p>
<section data-pdf-bookmark="Header Files" data-type="sect1"><div class="sect1" id="pattern_header_files">
<h1>Header Files</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587920518592">
<h2>Context</h2>
<p>You<a data-primary="APIs, flexible" data-secondary="Header Files pattern" data-type="indexterm" id="Aheafipat"/><a data-primary="Header Files pattern" data-type="indexterm" id="heafilpat"/> write a larger piece of software in C. You split that software up into several functions, and you implement these functions in several files because you want to make your<a data-primary="modular programs, ease of maintaining" data-type="indexterm" id="idm45587920514512"/> program modular and easy to maintain.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587920513440">
<h2>Problem</h2>
<p><strong>You<a data-primary="implementation details, hiding" data-type="indexterm" id="idm45587920511536"/> want a functionality that you implement to be accessible to code from other implementation files, but you want to hide your implementation details from the caller.</strong></p>
<p>Unlike many object-oriented languages, C does not provide any built-in support for defining APIs, abstracting functionality, or enforcing that the caller can only access this abstraction. C only provides a mechanism to include files into other files.</p>
<p>The caller of your code could use that mechanism to simply include your implementation file. But then the caller could access all internal data in that file, such as variables or functions with file scope that you only intend to use internally. Once the caller uses this internal functionality, it might not be easy to change it later on, so the code becomes tightly coupled in places where you might not want that to happen. If the caller includes the implementation file,  the names of the internal variables and functions might clash with names used by the caller.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587920509312">
<h2>Solution</h2>
<p><strong>Provide function declarations in your API for any functionality you want to provide to your user. Hide<a data-primary="functions" data-secondary="hiding internal" data-type="indexterm" id="idm45587920507104"/> any internal functions, internal data, and your function definitions (the implementations) in your implementation file and don’t provide this implementation file to the user.</strong></p>
<p>In C, it is a common convention that anybody who uses functions of your software only uses functions defined in your header file (<em>*.h</em> file) and does not use other functions in your implementation (your <em>*.c</em> files). In some cases, this abstraction can be partially enforced (for example, you cannot use a <code>static</code> function from another file), but the C language does not support such enforcements to the full extent. Therefore, the convention of not accessing other implementation files is even more important than the enforcement mechanisms.</p>
<p>Within the header file, make sure to include all related artifacts needed by your functions in the header file. It should not be neccessary for your caller to include other header files in order to be able to use the functionality from your header file. If you have common declarations (like data types or <code>#defines</code>) that are needed in multiple header files, then put these declarations into a separate header file and include it in the other header files that need the declarations. To ensure that the header files are not included multiple times in a compilation unit, protect them with Include Guards.</p>
<p>Only put functions into the same header file if they are related. If the functions operate on the same Handle or perform an operation in the same domain (like math calculations), then that is an indicator to put them into the same header file. In general, if you can think of a relevant use case that requires all of the functions, then you should put them into the same header file.</p>
<p>Clearly document the behavior of your API in the header file. The user should not be required to have a look at the implementation in order to understand how the functions provided in the API work.</p>
<p>The following code shows an example of a Header File:</p>
<p><em>API (h-file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Sorts the numbers of the 'array' in ascending order.</code>
<code class="cm">   'length' defines the number of elements in the 'array'. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation (c-file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* here goes the implementation*/</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587920405792">
<h2>Consequences</h2>
<p>You have a very clear separation between the things relevant for your caller (the <em>*.h</em> file) and the implementation details that the caller does not have to care about (the <em>*.c</em> file). Thus, you abstracted some functionality for the caller.</p>
<p>Having many header files will influence your build times. On the one hand this enables you to split your implementations into separate files, and your toolchain will be able to have an incremental build that only rebuilds files that changed. On the other hand, a complete rebuild will have slightly increased build times compared to having all the code in one file, because all the files have to be opened and read for the build.</p>
<p>If you discover that your functions require more interaction between one another or that they have to be called in different contexts that require different internal state information, then you have to think about how to realize that with your API. A Handle can help in such cases.</p>
<p>The caller of your functions now relies on the abstraction and might rely on the fact that the behavior of these functions does not change. The API might have to be kept stable. To add new functionality, you can always add new functions to the API. But in some cases you might want to extend existing functions, and to be able to cope with such future changes, you have to consider how to make your functions flexible while keeping them stable. Handles, Dynamic Interfaces, or Function Controls can help in such cases.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587920424560">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>Pretty much every C program that is larger than a simple “Hello World” program contains header files.</p>
</li>
<li>
<p>Using a header file in C is analogous to using interfaces in Java or abstract classes in C++.</p>
</li>
<li>
<p>The Pimpl Idiom describes how to hide private implementation details and not put them into the header file. You can find a description of that idiom in the Portland Pattern Repository.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587920419424">
<h2>Applied to Running Example</h2>
<p>Your<a data-primary="APIs, flexible" data-secondary="Header Files pattern" data-startref="Aheafipat" data-type="indexterm" id="idm45587920417616"/><a data-primary="Header Files pattern" data-startref="heafilpat" data-type="indexterm" id="idm45587920416336"/> first device driver API looks like the following:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="kt">char</code><code class="w"> </code><code class="n">byte</code><code class="p">);</code><code class="w"/>
<code class="kt">char</code><code class="w"> </code><code class="nf">receiveByte</code><code class="p">();</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">setIpAddress</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">ip</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">setMacAddress</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">mac</code><code class="p">);</code><code class="w"/></pre>
<p>The user of your API does not have to cope with implementation details like how you access Ethernet registers, and you are free to change these details without affecting the user.</p>
<p>Now your requirements for your driver change. Your system has a second, identical Ethernet network interface card, and it should be possible to operate both of them. Here are two straightforward options to achieve this:</p>
<ul>
<li>
<p>You copy your code and have one piece of code for each network interface card. In the copied code, you only modify the address of the exact interface to be accessed. However, such code duplication is never a good idea and makes maintenance of your code much more difficult.</p>
</li>
<li>
<p>You add a parameter to address the network interface card (for example, a device name string) to each function. But it’s quite likely that more than just one parameter will have to be shared between the functions, and passing each of them to every function makes the usage of your API cumbersome.</p>
</li>
</ul>
<p>A better idea to support multiple Ethernet network interface cards is to introduce Handles to your API.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Handle" data-type="sect1"><div class="sect1" id="pattern_handle">
<h1>Handle</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587920364304">
<h2>Context</h2>
<p>You<a data-primary="APIs, flexible" data-secondary="Handle pattern" data-type="indexterm" id="Ahandpat"/><a data-primary="Handle pattern" data-type="indexterm" id="handpat"/> want to provide a set of functions to your caller, and these functions operate on shared resources or they share state information.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587920360064">
<h2>Problem</h2>
<p><strong>You<a data-primary="functions" data-secondary="sharing state information or resources" data-type="indexterm" id="idm45587920358096"/><a data-primary="resources" data-secondary="sharing" data-type="indexterm" id="idm45587920357120"/><a data-primary="state information, sharing" data-type="indexterm" id="idm45587920356176"/> have to share state information or operate on shared resources in your function implementations, but you don’t want your caller to see or even access all that state information and shared resources.</strong></p>
<p>That state information and shared resources should remain invisible to your caller because later on you might want to change it or add to it without requiring any changes to your caller’s code.</p>
<p>In object-oriented programming languages, such data on which functions can operate is realized by class member variables. These class member variables can be made private if the caller should not be able to access them. However, C does not natively support classes and private member variables.</p>
<p>Simply having a Software-Module with Global State holding static global variables in your implementation file for storing shared data between your functions is not an option for you, because it should be possible to call your functions in multiple 
<span class="keep-together">contexts</span>. The function calls for each of your callers should be able to build up their state information. And even though that information should remain invisible to your callers, you need a way to identify which information belongs to which specific caller and how to access that information in your function implementations.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587920352832">
<h2>Solution</h2>
<p><strong>Have a function to create the context on which the caller operates and return an<a data-primary="abstract pointers" data-type="indexterm" id="idm45587920350832"/> abstract pointer to internal data for that context. Require the caller to pass that pointer to all your functions, which can then use the internal data to store state information and resources.</strong></p>
<p>Your functions know how to interpret this abstract pointer, which is an opaque data type also called Handle. However, the data structure that you point to should not be part of the API. The API only provides the functionality to relay hidden data to the functions.</p>
<p>The Handle can be implemented as a pointer to an Aggregate Instance like a <code>struct</code>. The <code>struct</code> should contain all required state information or other variables—it usually holds variables similar to those you would declare as member variables for objects in object-oriented programming. The <code>struct</code> should be hidden in your implementation. The API only contains the definition of a pointer to the <code>struct</code> as shown in the following code:</p>
<p><em>API</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">SORT_STRUCT</code><code class="o">*</code><code class="w"> </code><code class="n">SORT_HANDLE</code><code class="p">;</code><code class="w"/>

<code class="n">SORT_HANDLE</code><code class="w"> </code><code class="nf">prepareSort</code><code class="p">(</code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="n">SORT_HANDLE</code><code class="w"> </code><code class="n">context</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">SORT_STRUCT</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="cm">/* other parameters like sort order */</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">SORT_HANDLE</code><code class="w"> </code><code class="nf">prepareSort</code><code class="p">(</code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">SORT_STRUCT</code><code class="o">*</code><code class="w"> </code><code class="n">context</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">malloc</code><code class="p">(</code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">SORT_STRUCT</code><code class="p">));</code><code class="w"/>
<code class="w">  </code><code class="n">context</code><code class="o">-&gt;</code><code class="n">array</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">array</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">context</code><code class="o">-&gt;</code><code class="n">length</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">length</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="cm">/* fill context with required data or state information */</code><code class="w"/>

<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">context</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="n">SORT_HANDLE</code><code class="w"> </code><code class="n">context</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* operate on context data */</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Have one function in your API for creating a Handle. That function returns the Handle to the caller. The caller can then call other functions of your API that require the Handle. In most cases, you also need a function to delete the Handle by cleaning up all the allocated resources.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587920352368">
<h2>Consequences</h2>
<p>You can now share state information and resources between your functions without requiring the caller to worry about it and without giving the caller the opportunity to make the code depend on these internals.</p>
<p>Multiple instances of data are supported. You can call the function that creates the Handle multiple times to obtain multiple contexts, and then you can work with these contexts independently from one another.</p>
<p>If your functions that operate on the Handle are changed at a later point in time and have to share different or additional data, the members of the <code>struct</code> can simply be changed without requiring any changes to the caller’s code.</p>
<p>The declarations of your functions explicitly show that they are tightly coupled, because they all require the Handle. This makes it, on one hand, easy to see which functions should go into the same Header File, and on the other hand, makes it very easy for the caller to spot which functions should be applied together.</p>
<p>With the Handle, you now require the caller to provide one additional parameter to all function calls, and each additional parameter makes the code harder to read.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587920131584">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul class="fix-tracking">
<li>
<p>The C standard library contains the definition of <code>FILE</code> in <em>stdio.h</em>. This <code>FILE</code> is defined in most implementations as a pointer to a <code>struct</code>, and the <code>struct</code> is not part of the header file. The <code>FILE</code> handle is created by the function <code>fopen</code>, and several other functions can then be called for an opened file (<code>fwrite</code>, <code>fread</code>, etc.).</p>
</li>
<li>
<p>The <code>struct</code> <code>AES_KEY</code> in the OpenSSL code is used to exchange the context between several functions related to AES encryption (<code>AES_set_decrypt_key</code>, <code>AES_​set_​encrypt_​key</code>). The <code>struct</code> and its members are not hidden in the 
<span class="keep-together">implementation</span>, but instead they are part of the header file because  some parts of other OpenSSL code need to know the size of the <code>struct</code>.</p>
</li>
<li>
<p>The code for the logging functionality of the Subversion project operates on a Handle. The <code>struct</code> <code>logger_t</code> is defined in the implementation file of the logging functionality, and a pointer to this <code>struct</code> is defined in the corresponding header file.</p>
</li>
<li>
<p>This pattern is described in <em>C Interfaces and Implementations</em> by David R. Hanson (Addison-Wesley, 1996) as Opaque Pointer Type and in <em>Patterns in C</em> by Adam Tornhill (Leanpub, 2014) as “First Class Abstract Data Type Pattern.”</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587920089136">
<h2>Applied to Running Example</h2>
<p>You<a data-primary="Handle pattern" data-startref="handpat" data-type="indexterm" id="idm45587920087392"/><a data-primary="APIs, flexible" data-secondary="Handle pattern" data-startref="Ahanpat" data-type="indexterm" id="idm45587920086384"/> can now support as many Ethernet interface cards as you want. Each created instance of your driver produces its own data-context that is then passed to the functions via the Handle. Now you have the following code for your device driver API:</p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* the INTERNAL_DRIVER_STRUCT contains data shared by the functions (like</code>
<code class="cm">   how to select the interface card the driver is responsible for) */</code><code class="w"/>
<code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">INTERNAL_DRIVER_STRUCT</code><code class="o">*</code><code class="w"> </code><code class="n">DRIVER_HANDLE</code><code class="p">;</code><code class="w"/>

<code class="cm">/* 'initArg' contains information for the implementation to identify</code>
<code class="cm">   the exact interface for the driver instance */</code><code class="w"/>
<code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="nf">driverCreate</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">initArg</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">driverDestroy</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">byte</code><code class="p">);</code><code class="w"/>
<code class="kt">char</code><code class="w"> </code><code class="nf">receiveByte</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">setIpAddress</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">ip</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">setMacAddress</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">mac</code><code class="p">);</code><code class="w"/></pre>
<p>Your requirements have changed again. Now you have to support multiple different Ethernet network interface cards, for example, from different vendors. The cards provide similar functionality, but they differ in the details of how the registers have to be accessed, and thus different implementations for the drivers are needed.
Two straightforward options to support this would be as follows:</p>
<ul class="less-space-list">
<li>
<p>You have two separate driver APIs. This approach has the drawback that it is cumbersome for the users to build mechanisms for selecting the driver at runtime. Also, having two separate APIs duplicates code because the two device drivers at minimum share a common control flow (for example, for creating or destroying the driver).</p>
</li>
<li>
<p>You add functions like <code>sendByteDriverA</code> and <code>sendByteDriverB</code> to your API. However, you usually want your API to be rather minimal because having all driver functions in a single API can be confusing for the API user. Also, the user’s code depends on all function signatures included via your API, and if code depends on something, that something should be rather minimal (as stated by the interface segregation principle).</p>
</li>
</ul>
<p>A better idea to support different Ethernet network interface cards is to provide a Dynamic Interface.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Dynamic Interface" data-type="sect1"><div class="sect1" id="pattern_dynamic_interface">
<h1>Dynamic Interface</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587920026016">
<h2>Context</h2>
<p>You<a data-primary="APIs, flexible" data-secondary="Dynamic Interface pattern" data-type="indexterm" id="Adyninpat"/><a data-primary="Dynamic Interface pattern" data-type="indexterm" id="dynintpat"/> or your caller want to implement multiple functionalities that follow a similar control logic, but that deviate in their behavior.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587920021840">
<h2>Problem</h2>
<p><strong>It should be possible to call implementations with slightly deviating behaviors, but it should not be necessary to duplicate any code, not even the control logic implementation and interface declaration.</strong></p>
<p>You want to be able to add additional implementation behaviors to the declared interface later on, without requiring callers who use the existing implementation behaviors to change anything in their code.</p>
<p>Maybe you do not only want to provide differing behaviors to your caller without duplicating your own code, but you also want to provide the callers a mechanism to bring in their own implementation behaviors.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587920019008">
<h2>Solution</h2>
<p><strong>Define a common interface for the deviating functionalities in your API and require the caller to provide a callback function for that functionality, which you then call in your function implementation.</strong></p>
<p>To implement such an interface in C, define function signatures in your API. The caller then implements functions according to these signatures and attaches them via function pointers. They can either be attached and stored permanently inside your software-module or they can be attached with each function call as shown in the following code:</p>
<p><em>API</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* The compare function should return true if x is smaller than y, else false */</code><code class="w"/>
<code class="k">typedef</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">COMPARE_FP</code><code class="p">)(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="n">COMPARE_FP</code><code class="w"> </code><code class="n">compare</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="n">COMPARE_FP</code><code class="w"> </code><code class="n">compare</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="n">j</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">length</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="p">(</code><code class="n">j</code><code class="o">=</code><code class="n">i</code><code class="p">;</code><code class="w"> </code><code class="n">j</code><code class="o">&lt;</code><code class="n">length</code><code class="p">;</code><code class="w"> </code><code class="n">j</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="cm">/* call provided user function */</code><code class="w"/>
<code class="w">      </code><code class="k">if</code><code class="p">(</code><code class="n">compare</code><code class="p">(</code><code class="n">array</code><code class="p">[</code><code class="n">i</code><code class="p">],</code><code class="w"> </code><code class="n">array</code><code class="p">[</code><code class="n">j</code><code class="p">]))</code><code class="w"/>
<code class="w">      </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">swap</code><code class="p">(</code><code class="o">&amp;</code><code class="n">array</code><code class="p">[</code><code class="n">i</code><code class="p">],</code><code class="w"> </code><code class="o">&amp;</code><code class="n">array</code><code class="p">[</code><code class="n">j</code><code class="p">]);</code><code class="w"/>
<code class="w">      </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><em>Caller</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#define ARRAY_SIZE 4</code>

<code class="kt">bool</code><code class="w"> </code><code class="nf">compareFunction</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="o">&lt;</code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">sortData</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">array</code><code class="p">[</code><code class="n">ARRAY_SIZE</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">};</code><code class="w"/>
<code class="w">  </code><code class="n">sort</code><code class="p">(</code><code class="n">compareFunction</code><code class="p">,</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="n">ARRAY_SIZE</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Make sure to clearly document, next to the definition of the function signature, what behavior the function implementations should have. Also, document the behavior in case no such function implementation is attached to your function call. Maybe then you’d abort the program (Samurai Principle) or maybe you’d provide some default functionalty as fallback.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587919712832">
<h2>Consequences</h2>
<p>The caller can use different implementations and there is still no code duplication. Neither the control logic, the interface, nor the interface documentation is duplicated.</p>
<p>Implementations can be added by the caller at a later point in time without changing the API. This means that the role of the API designer and the implementation provider can be completely separated.</p>
<p>In your code, you now execute the caller’s code. Thus, you must trust that the caller knows what the function has to do. In case of bugs in your caller’s code, it might still happen that your code will initially be suspected because, after all, the faulty behavior occurs in the context of your code.</p>
<p>Using function pointers implies that you have a platform-specific and programming-language-specific interface. You can use this pattern only if the caller’s code is also written in C. You cannot add marshaling functionality to this interface and provide it to a caller who is, for example, writing applications with Java code.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587919611056">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern</p>
<ul>
<li>
<p>James Grenning describes this pattern and a variant as Dynamic Interface and Per-Type Dynamic Interface in the article <a href="https://oreil.ly/kGZVG">“SOLID Design for Embedded C”</a>.</p>
</li>
<li>
<p>The presented solution is a C-version of the Strategy design pattern. You can find alternative C implementations of that pattern in the books <em>Patterns in C</em> by Adam Tornhill (Leanpub, 2014) and <em>C Interfaces and Implementations</em> by David R. Hanson (Addison-Wesley, 1996).</p>
</li>
<li>
<p>Device driver frameworks often use function pointers where the driver inserts its function at startup. The device drivers in the Linux kernel usually work that way.</p>
</li>
<li>
<p>The function <code>svn_sort__hash</code> of the source code of the Subversion project sorts a list according to some key value. The function takes the function pointer <code>comparison_func</code> as a parameter. The <code>comparison_func</code> has to return information, namely, which of two provided key values is greater than the other.</p>
</li>
<li>
<p>The OpenSSL function <code>OPENSSL_LH_new</code> creates a hash table. The caller has to provide a function pointer to a hash function that is used as a callback when operating on the hash table.</p>
</li>
<li>
<p>The Wireshark code contains the function pointer <code>proto_tree_foreach_func</code> that is provided as a function parameter when traversing tree structures. The function pointer is used to decide which actions to perform on the tree elements.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587919599440">
<h2>Applied to Running Example</h2>
<p>Your<a data-primary="APIs, flexible" data-secondary="Dynamic Interface pattern" data-startref="Adyninpat" data-type="indexterm" id="idm45587919597520"/><a data-primary="Dynamic Interface pattern" data-startref="dynintpat" data-type="indexterm" id="idm45587919596272"/> driver API now supports multiple different Ethernet network interface cards. The specific drivers for these network interface cards have to implement the send and receive functions and provide them in a separate header file. The API user can then include and attach these specific send and receive functions to the API.</p>
<p>You have the benefit that users of your API can bring in their own driver implementation. Thus, you as the API designer are independent from the provider of the driver implementation. Integrating new drivers does not require any API changes, which means it does not require any work from you as the API designer. All that is possible with the following API:</p>
<pre data-code-language="c" data-type="programlisting"><code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">INTERNAL_DRIVER_STRUCT</code><code class="o">*</code><code class="w"> </code><code class="n">DRIVER_HANDLE</code><code class="p">;</code><code class="w"/>
<code class="k">typedef</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">DriverSend_FP</code><code class="p">)(</code><code class="kt">char</code><code class="w"> </code><code class="n">byte</code><code class="p">);</code><code class="w">      </code><code class="cm">/* this is the           */</code><code class="w"/>
<code class="k">typedef</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">DriverReceive_FP</code><code class="p">)();</code><code class="w">            </code><code class="cm">/* interface definition */</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">DriverFunctions</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">DriverSend_FP</code><code class="w"> </code><code class="n">fpSend</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">DriverReceive_FP</code><code class="w"> </code><code class="n">fpReceive</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="nf">driverCreate</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">initArg</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">DriverFunctions</code><code class="w"> </code><code class="n">f</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">driverDestroy</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">byte</code><code class="p">);</code><code class="w">   </code><code class="cm">/* internally calls fpSend    */</code><code class="w"/>
<code class="kt">char</code><code class="w"> </code><code class="nf">receiveByte</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">);</code><code class="w">           </code><code class="cm">/* internally calls fpReceive */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">setIpAddress</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">ip</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">setMacAddress</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">mac</code><code class="p">);</code><code class="w"/></pre>
<p>Again, the requirements changed. Now you don’t just have to support Ethernet network interface cards, but also other interface cards (like USB interface cards). From the view of the API, these interfaces have some similar functionalities (the send and receive data functions), but they also have some completely different functionalities (for example, a USB interface has no IP address to set, but might require other configurations).</p>
<p>A straightforward solution for this would be to provide two different APIs for the different driver types. But this would duplicate code for the send/receive and create/destroy functions.</p>
<p>A better solution to support different kinds of device drivers in a single abstract API is to introduce Function Control.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Function Control" data-type="sect1"><div class="sect1" id="pattern_function_control">
<h1>Function Control</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587919434544">
<h2>Context</h2>
<p>You<a data-primary="APIs, flexible" data-secondary="Function Control pattern" data-type="indexterm" id="Afuncopat"/><a data-primary="Function Control pattern" data-type="indexterm" id="funcopat"/> want to implement multiple functionalities that follow a similar control logic, but that deviate in their behavior.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587919430240">
<h2>Problem</h2>
<p><strong>You want to call implementations with slightly deviating behaviors, but you don’t want to duplicate any code, not even the control logic implementation or the interface declaration.</strong></p>
<p>The caller should be able to use specific existing behaviors that you implemented. It should even be possible for you to add new behaviors later on without touching the existing implementations and without requiring changes to the existing caller’s code.</p>
<p class="pagebreak-before">Having a Dynamic Interface is not an option for you because you do not want to offer the callers the flexibility of attaching their own implementation. That might be because the interface should be easier to use for the caller. Or it might be because you cannot easily attach the implementations of your caller, which is the case if your caller, for example, uses another programming language to access your functionality.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587919426672">
<h2>Solution</h2>
<p><strong>Add<a data-primary="functions" data-secondary="passing meta-information about" data-type="indexterm" id="idm45587919424512"/> a parameter to your function that passes meta-information about the function call and that specifies the actual functionality to be performed.</strong></p>
<p>Compared to a Dynamic Interface, you do not require the caller to provide the implementation, but instead the caller selects from existing implementations.</p>
<p>To implement this pattern, you apply data-based abstraction by adding an additional parameter (for example, an <code>enum</code> or <code>#define</code> integer value) that specifies the function’s behavior. The parameter is then evaluated in the implementation, and depending on the value of the parameter, different implementations are called:</p>
<p><em>API</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#define QUICK_SORT 1</code>
<code class="cp">#define MERGE_SORT 2</code>
<code class="cp">#define RADIX_SORT 3</code>

<code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">algo</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">algo</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="k">switch</code><code class="p">(</code><code class="n">algo</code><code class="p">)</code><code class="w">
</code><code class="w">  </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="no">QUICK_SORT</code><code class="p">:</code><code class="w"> </code><a class="co" href="#callout_flexible_apis_CO1-1" id="co_flexible_apis_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="n">quicksort</code><code class="p">(</code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="n">length</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="k">break</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="no">MERGE_SORT</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="n">mergesort</code><code class="p">(</code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="n">length</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="k">break</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="no">RADIX_SORT</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="n">radixsort</code><code class="p">(</code><code class="n">array</code><code class="p">,</code><code class="w"> </code><code class="n">length</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="k">break</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="p">}</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_flexible_apis_CO1-1" id="callout_flexible_apis_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>When adding new functionality at a later point in time, you can simply add a new <code>enum</code> or <code>#define</code> value and select the corresponding new implementation.</p></dd>
</dl>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587919426208">
<h2>Consequences</h2>
<p>The caller can use different implementations and there is still no code duplication. Neither the control logic, the interface, nor the interface documentation is duplicated.</p>
<p>It is easy to add new functionality at a later time. Existing implementations do not have to be touched to do that, and the existing caller’s code is not affected by the change.</p>
<p>Compared to Dynamic Interface, this pattern is easier for selecting functionalities across different programs or platforms (for example, remote procedure calls) because no program-specific pointers are passed via the API.</p>
<p>When providing the selection of different implementation behaviors in one function, you might be tempted to pack multiple functionalities that do not closely belong together into a single function. This violates the single-responsibility principle.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587919261616">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>Device drivers often use Function Control to pass specific functionalities that do not fit into common init/read/write functions. For device drivers this pattern is commonly known as I/O-Control. That concept is described in the book <em>Making Embedded Systems: Design Patterns for Great Software</em> by Elecia White (O’Reilly, 2011).</p>
</li>
<li>
<p>Some Linux syscalls were extended to have flags that extend the syscalls’ functionality depending on the value of the flag without breaking old code.</p>
</li>
<li>
<p>The concept of data-driven APIs in general is described in the book <em>API Design for <i>C++</i></em> by Martin Reddy (Morgan Kaufmann, 2011).</p>
</li>
<li>
<p>The OpenSSL code uses the function <code>CTerr</code> to log errors. This function takes an <code>enum</code> parameter to specify how and where the error should be logged.</p>
</li>
<li>
<p>The POSIX socket function <code>ioctl</code> takes a numeric parameter <code>cmd</code> that determines which actual action will be performed on a socket. The allowed values for the parameter are defined and documented in a header file, and since the first release of that header file, many additional values and thus function behaviors were added.</p>
</li>
<li>
<p>The function <code>svn_fs_ioctl</code> of the Subversion project performs some filesystem-specific input or output operations. The function takes the <code>struct</code> <code>svn_fs_ioctl_code_t</code> as a parameter. This <code>struct</code> contains a numeric value that determines which kind of operation should be performed.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587919203184">
<h2>Applied to Running Example</h2>
<p>The<a data-primary="APIs, flexible" data-secondary="Function Control pattern" data-startref="Afuncopat" data-type="indexterm" id="idm45587919201376"/><a data-primary="Function Control pattern" data-startref="funcopat" data-type="indexterm" id="idm45587919200288"/> following code shows the final version of your device driver API:</p>
<p><em>Driver.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">INTERNAL_DRIVER_STRUCT</code><code class="o">*</code><code class="w"> </code><code class="n">DRIVER_HANDLE</code><code class="p">;</code><code class="w"/>
<code class="k">typedef</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">DriverSend_FP</code><code class="p">)(</code><code class="kt">char</code><code class="w"> </code><code class="n">byte</code><code class="p">);</code><code class="w"/>
<code class="k">typedef</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">DriverReceive_FP</code><code class="p">)();</code><code class="w"/>
<code class="k">typedef</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">DriverIOCTL_FP</code><code class="p">)(</code><code class="kt">int</code><code class="w"> </code><code class="n">ioctl</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">context</code><code class="p">);</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">DriverFunctions</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">DriverSend_FP</code><code class="w"> </code><code class="n">fpSend</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">DriverReceive_FP</code><code class="w"> </code><code class="n">fpReceive</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">DriverIOCTL_FP</code><code class="w"> </code><code class="n">fpIOCTL</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="nf">driverCreate</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">initArg</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">DriverFunctions</code><code class="w"> </code><code class="n">f</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">driverDestroy</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">byte</code><code class="p">);</code><code class="w"/>
<code class="kt">char</code><code class="w"> </code><code class="nf">receiveByte</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">driverIOCTL</code><code class="p">(</code><code class="n">DRIVER_HANDLE</code><code class="w"> </code><code class="n">h</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">ioctl</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">context</code><code class="p">);</code><code class="w"/>
<code class="cm">/* the parameter "context" is required to pass information like the</code>
<code class="cm">   value of the IP address to configure to the implementation */</code><code class="w"/></pre>
<p><br/><em>EthIOCTL.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#define SET_IP_ADDRESS  1</code>
<code class="cp">#define SET_MAC_ADDRESS 2</code></pre>
<p><br/><em>UsbIOCTL.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#define SET_USB_PROTOCOL_TYPE   3</code></pre>
<p>Users who want to use the Ethernet- or USB-specific functions (for example, the application actually sending or receiving data via the interface) have to know which driver type they operate on in order to call the right I/O-control and also have to include the <em>EthIOCTL.h</em> or <em>UsbIOCTL.h</em> files.</p>
<p><a data-type="xref" href="#fig_func_ctl">Figure 6-2</a> shows the include-relationships of the source code files of this final version of our device driver API. Note that the <em>EthApplication.c</em> code does not depend on USB-specific header files. If, for example, an additional USB-IOCTL is added, the <em>EthApplication.c</em> shown in the code does not even need to be recompiled, because none of the files it depends on are changed.</p>
<figure><div class="figure" id="fig_func_ctl">
<img alt="sketches/function-control.png" height="552" src="assets/fluc_0602.png" width="1441"/>
<h6><span class="label">Figure 6-2. </span>File relationships for function control</h6>
</div></figure>
<p>Keep in mind that of all the code snippets presented in this chapter, this last, most flexible code snippet of the device drivers might not always be what you are looking for. You buy increased flexibility with complexity of your interface, and while you have to make your code as flexible as needed, you should also always try to keep it as simple as possible.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45587919202592">
<h1>Summary</h1>
<p>This<a data-primary="APIs, flexible" data-secondary="overview of patterns for" data-type="indexterm" id="idm45587919016720"/> chapter discussed four API patterns for C and showed their application in a running example of how to design a device driver. Header Files tells you the basic concept of hiding implementation details in c-files while providing a well-defined interface in your h-files. The pattern Handle is about the well-known concept of passing opaque data types between functions to share state information. Dynamic Interface makes it possible to not duplicate program logic by allowing the injection of caller-specific code via a callback function. Function Control uses an additional function parameter that specifies the actual action that should be performed by the function call. These patterns showed basic C design options to make an interface more flexible by introducing abstractions.</p>
</div></section>
<section data-pdf-bookmark="Further Reading" data-type="sect1"><div class="sect1" id="idm45587918968944">
<h1>Further Reading</h1>
<p>If<a data-primary="APIs, flexible" data-secondary="further reading on" data-type="indexterm" id="idm45587918967760"/> you’re ready for more, here are some resources that can help you further your knowledge of designing APIs.</p>
<ul>
<li>
<p>The article <a href="https://oreil.ly/07SUX">“SOLID Design for Embedded C”</a> by James Grenning covers the five SOLID design principles in general and presents ways to implement flexibility for C interfaces. What makes this article unique is that it is the only article that covers the topic of interfaces specifically for C and also includes detailed code 
<span class="keep-together">snippets.</span></p>
</li>
<li>
<p>The book <em>Patterns in C</em> by Adam Tornhill (Leanpub, 2014) presents several patterns that include C code snippets. The patterns include C versions of Gang of Four patterns like Strategy or Observer as well as C-specific patterns and idioms. The book does not explicitly focus on interfaces, but some of the patterns describe interactions on an interface level.</p>
</li>
<li>
<p>The book <em>API Design for <i>C++</i></em> by Martin Reddy (Morgan Kaufmann, 2011) covers design principles for interfaces, object-oriented interface patterns with C++ examples, and interface quality issues with interfaces like testing and documentation. The book addresses C++ design, but some parts of the book are also relevant for C.</p>
</li>
<li>
<p>The book <em>C Interfaces and Implementations</em> by David R. Hanson (Addison-Wesley, 1996)
presents interface design, including C code for specific components implemented in C.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Outlook" data-type="sect1"><div class="sect1" id="idm45587918946896">
<h1>Outlook</h1>
<p>The next chapter goes into detail on how to find the right level of abstraction and the right interface for one very specific kind of application: it describes how to design and implement iterators.</p>
</div></section>
</div></section></div></body></html>