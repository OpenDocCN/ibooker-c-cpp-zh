- en: Preface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前言
- en: You picked up this book to move your programming skills one step forward. That
    is good, because you’ll definitely benefit from the hands-on knowledge provided
    in this book. If you have a lot of experience programming in C, you’ll learn the
    details of good design decisions and about their benefits and drawbacks. If you
    are fairly new to C programming, you’ll find guidance about design decisions,
    and you’ll see how these decisions are applied bit by bit to running code examples
    for building larger scale programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你拿起这本书是为了提升你的编程技能。这是好事，因为你肯定会从本书提供的实际知识中受益。如果您在C编程方面有丰富的经验，您将了解良好设计决策的细节及其利弊。如果您对C编程相对较新，您将找到有关设计决策的指导，并看到这些决策如何逐步应用于运行代码示例以构建规模较大的程序。
- en: 'The book answers questions such as how to structure a C program, how to cope
    with error handling, or how to design flexible interfaces. As you learn more about
    C programming, questions often pop up, such as the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书回答了如何结构化一个C程序、如何处理错误处理或如何设计灵活接口等问题。随着您对C编程的了解加深，通常会出现以下问题：
- en: Should I return any error information I have?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该返回任何错误信息吗？
- en: Should I use the global variable `errno` to do that?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该使用全局变量`errno`来做到这一点吗？
- en: Should I have few functions with many parameters or the other way around?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该选择少数带有许多参数的函数还是反之？
- en: How do I build a flexible interface?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何构建一个灵活的接口？
- en: How can I build basic things like an iterator?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何构建基本的事物，比如一个迭代器？
- en: 'For object-oriented languages, most of these questions are answered to a great
    extent by the Gang of Four book *Design Patterns: Elements of Reusable Object-Oriented
    Software* by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Prentice
    Hall, 1997). Design patterns provide a programmer with best practices on how objects
    should interact and which object owns which other kinds of objects. Also, design
    patterns show how such objects can be grouped together.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向对象的语言，这些问题的大部分在《设计模式：可重用面向对象软件的元素》（Erich Gamma，Richard Helm，Ralph Johnson和John
    Vlissides著，Prentice Hall出版，1997年）中得到了很大程度上的回答。设计模式为程序员提供了关于对象如何互动以及哪个对象拥有其他类型对象的最佳实践。此外，设计模式展示了如何将这些对象组合在一起。
- en: However, for procedural programming languages like C, most of these design patterns
    cannot be implemented in the way described by the Gang of Four. There are no native
    object-oriented mechanisms in C. It is possible to emulate inheritance or polymorphism
    in the C programming language, but that might not be the first choice, because
    such emulation makes things unfamiliar for programmers who are used to programming
    C and are not used to programming with object-oriented languages like C++ and
    using concepts like inheritance and polymorphism. Such programmers may want to
    stick to their native C programming style that they are used to. However, with
    the native C programming style, not all object-oriented design patterns guidance
    is usable, or at least the specific implementation of the idea presented in a
    design pattern is not provided for non-object-oriented programming languages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于像C这样的过程式编程语言，大部分这些设计模式无法像《四人帮》描述的那样实现。在C中没有本地的面向对象机制。在C编程语言中可以模拟继承或多态性，但这可能不是第一选择，因为这种模拟使得习惯于C编程而不习惯使用类似C++这样的面向对象语言及其继承和多态性概念的程序员感到陌生。这样的程序员可能希望坚持他们习惯的本地C编程风格。然而，使用本地C编程风格，不是所有面向对象设计模式的指导都可用，或者至少没有提供非面向对象编程语言的具体实现的想法。
- en: 'And that is where we stand: we want to program in C, but we cannot directly
    use most of the knowledge documented in design patterns. This book shows how to
    bridge this gap and implement hands-on design knowledge for the C programming
    language.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的立场：我们希望在C中编程，但我们不能直接使用设计模式文档中记录的大多数知识。本书展示了如何弥补这一差距，并为C编程语言实施实际设计知识。
- en: Why I Wrote This Book
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我写这本书
- en: Let me tell you why the knowledge gathered in this book turned out to be very
    important for me and why such knowledge is hard to find.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我告诉你为什么我收集在这本书中的知识对我来说非常重要，以及为什么这样的知识很难找到。
- en: In school I learned C programming as my first programming language. Just like
    every new C programmer, I wondered why arrays start with index 0, and I first
    rather randomly tried out how to place the operators `*` and `&` in order to finally
    get the C pointer magic working.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在学校里，我把C编程作为我的第一门编程语言。就像每个新的C程序员一样，我想知道为什么数组从索引0开始，我首先随机尝试如何放置操作符`*`和`&`，最终让C指针魔法起作用。
- en: 'At university I learned how C syntax actually works and how it translates to
    bits and bytes on the hardware. With that knowledge I was able to write small
    programs that worked very well. However, I still had trouble understanding why
    longer code looked the way it did, and I certainly wouldn’t have come up with
    solutions like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在大学里，我学习了C语法的实际工作原理，以及它如何在硬件上转换成位和字节。有了这些知识，我能够编写非常有效的小程序。然而，我仍然很难理解为什么更长的代码看起来像这样，而且我肯定不会想出以下的解决方案：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking at code like that prompted many questions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这样的代码引发了许多问题：
- en: Why have function pointers in the `struct`?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在`struct`中需要函数指针？
- en: Why do the functions need that `DRIVER_HANDLE`?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数为什么需要那个`DRIVER_HANDLE`？
- en: What is an IOCTL, and why would I not have separate functions instead?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IOCTL是什么，为什么我不能使用单独的函数来代替？
- en: Why have explicit create and destroy functions?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要显式的创建和销毁函数？
- en: 'These questions came up as I began writing industrial applications. I regularly
    came across situations where I realized I did not have the C programming knowledge,
    for example, to decide how to implement an iterator or to decide how to cope with
    error handling in my functions. I realized that although I knew C syntax, I had
    no clue how to apply it. I tried to achieve something but just managed to do it
    in a clumsy way or not at all. What I needed were best practices on how to achieve
    specific tasks with the C programming language. For example, I needed to know
    things like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始编写工业应用程序时，这些问题就出现了。我经常遇到这样的情况：我意识到我不具备如何在函数中实现迭代器或如何处理错误的C编程知识。我意识到，虽然我了解C语法，但我不知道如何应用它。我试图做些事情，但只是以笨拙的方式或根本不行。我需要的是关于如何用C编程语言实现特定任务的最佳实践。例如，我需要知道以下内容：
- en: How can I acquire and release resources in an easy way?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以简单的方式获取和释放资源？
- en: Is it a good idea to use `goto` for error handling?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于错误处理，使用`goto`是个好主意吗？
- en: Should I design my interface to be flexible, or should I simply change it when
    the need arises?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该设计我的界面以便灵活应对，还是应该在需要时直接更改？
- en: Should I use an `assert` statement, or should I return an error code?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该使用`assert`语句，还是应该返回错误代码？
- en: How is an iterator implemented in C?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C语言中，迭代器是如何实现的？
- en: It was very interesting for me to realize that while my experienced work colleagues
    had many different answers for these questions, nobody could point me to anything
    that documented these design decisions and their benefits and drawbacks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我意识到，虽然我的经验丰富的同事对这些问题有许多不同的答案，但没有人能指引我找到关于这些设计决策及其利弊的文件。
- en: 'So next I turned to the internet, and yet again I was surprised: it was very
    hard to find sound answers to these questions even though the C programming language
    has been around for decades. I found out that while there is much literature on
    the C programming language basics and its syntax, there’s not much on advanced
    C programming topics or how to write beautiful C code that holds up to industrial
    applications.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我转向互联网，再次感到惊讶：尽管C编程语言已经存在了几十年，但很难找到这些问题的正确答案。我发现，虽然有很多关于C编程语言基础和语法的文献，但在高级C编程主题或如何编写适合工业应用的优美C代码方面的内容并不多。
- en: And that is exactly where this book comes in. This book teaches you how to advance
    your programming skills from writing basic C programs to writing larger-scale
    C programs that consider error handling and that are flexible regarding certain
    future changes in requirements and design. This book uses the concept of design
    patterns to provide you bit by bit with design decisions and their benefits and
    drawbacks. These design patterns are applied to running code examples that teach
    you how code like the earlier example evolves and why it ends up looking the way
    it does.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书就是起作用的地方。它教会你如何从编写基本的C程序进阶到编写考虑错误处理并对需求和设计变化灵活的大规模C程序。这本书使用设计模式的概念逐步为你提供设计决策及其利弊。这些设计模式应用于运行代码示例，教你类似之前示例代码如何演化，以及为何最终呈现如此形式。
- en: The presented patterns can be applied to any C programming domains. As I come
    from the domain of embedded programming in a multithreaded real-time environment,
    some of the patterns are biased towards that domain. Anyways, you’ll see that
    the general idea of the patterns can be applied to other C programming domains
    and even beyond the scope of C programming.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的模式可以应用于任何C编程领域。由于我来自嵌入式编程多线程实时环境的领域，一些模式偏向于该领域。不过，你会看到这些模式的一般思想可以应用于其他C编程领域，甚至超出C编程的范围。
- en: Patterns Basics
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式基础
- en: 'The design guidance in this book is provided in the form of patterns. The idea
    of presenting knowledge and best practices in the form of patterns comes from
    the architect Christopher Alexander in *The Timeless Way of Building* (Oxford
    University Press, 1979). He uses small pieces of well-proven solutions to tackle
    a huge problem in his domain: how to design and construct cities. The approach
    of applying patterns was adopted by the software development domain, where pattern
    conferences like the conference on Pattern Languages of Programs (PLoP) are held
    to extend the body of knowledge of patterns. In particular, the book *Design Patterns:
    Elements of Reusable Object-Oriented Software* by the Gang of Four (Prentice Hall,
    1997) had a significant impact and made the concept of design patterns well known
    to software developers.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '本书提供的设计指导以模式的形式呈现。将知识和最佳实践以模式形式呈现的想法源自建筑师Christopher Alexander的作品*The Timeless
    Way of Building*（Oxford University Press，1979）。他使用经过验证的小片段解决他领域中的重大问题：如何设计和建造城市。这种应用模式的方法被软件开发领域采纳，其中模式会议如Pattern
    Languages of Programs（PLoP）会议旨在扩展模式知识体系。特别是Gang of Four的书籍*Design Patterns: Elements
    of Reusable Object-Oriented Software*（Prentice Hall，1997）产生了重大影响，并使设计模式的概念为软件开发人员所熟知。'
- en: 'But what exactly is a pattern? There are many definitions out there, and if
    you are deeply interested in the topic, then the book *Pattern-Oriented Software
    Architecture: On Patterns and Pattern Languages* by Frank Buschmann et al. (Wiley,
    2007) can provide you with accurate descriptions and details. For the purposes
    of this book, a pattern provides a well-proven solution to a real-life problem.
    The patterns presented in this book have the structure shown in [Table P-1](#tab_pattern_sections).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '但是模式究竟是什么？有很多定义，如果你对此深感兴趣，那么Frank Buschmann等人的书籍*Pattern-Oriented Software
    Architecture: On Patterns and Pattern Languages*（Wiley，2007）可以为你提供准确的描述和细节。对于本书的目的而言，模式为实际问题提供了经过验证的解决方案。本书展示的模式具有[表P-1](#tab_pattern_sections)所示的结构。'
- en: Table P-1\. How patterns are broken down in this book
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Table P-1\. 本书中模式的分解方式
- en: '| Pattern section | Description |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 模式部分 | 描述 |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name | This is the name of the pattern, which should be easy to remember.
    The aim is that this name will be used by programmers in their everyday language
    (as is the case with the Gang of Four patterns, where you hear programmers say,
    “And the Abstract Factory creates the object”). Pattern names are capitalized
    in this book. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 这是模式的名称，应易于记忆。目标是程序员在日常语言中使用这些名称（就像Gang of Four模式那样，程序员会说：“抽象工厂创建对象”）。本书中的模式名称均大写。'
- en: '| Context | The context section sets the scene for the pattern. It tells you
    under which circumstances this pattern can be applied. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 上下文 | 上下文部分为模式设定背景，告诉你在什么情况下可以应用该模式。 |'
- en: '| Problem | The problem section gives you information about the issue you want
    to tackle. It starts with the major problem statement written in bold font type
    and then adds details on why the problem is hard to solve. (In other pattern formats,
    these details go into a separate section called “forces.”) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 问题部分提供了关于你想解决的问题的信息。它以粗体字体类型开始主要的问题陈述，然后添加关于为什么这个问题难以解决的详细信息。（在其他模式格式中，这些详细信息会放入一个名为“forces”的单独部分。）'
- en: '| Solution | This section provides guidance on how to tackle the problem. It
    starts with stating the main idea of the solution written in bold font type and
    continues with details about the solution. It also provides a code example in
    order to give very concrete guidance. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 解决方案 | 本节提供了如何解决问题的指导。它以粗体字体类型陈述解决方案的主要思想，并继续详细说明解决方案。它还提供了一个代码示例，以便提供非常具体的指导。'
- en: '| Consequences | This section lists the benefits and drawbacks of applying
    the described solution. When applying a pattern, you should always confirm that
    the consequences that arise are OK with you. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 后果 | 本节列出了应用所描述解决方案的利弊。在应用一个模式时，你应该确认由此产生的后果是否可以接受。'
- en: '| Known uses | The known uses give you evidence that the proposed solution
    is good and actually works in real-life applications. They also show you concrete
    examples to help you understand how to apply the pattern. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 已知用途 | 已知用途为你提供了提议的解决方案是好的并且在实际应用中有效的证据。它们还向你展示了具体的例子，帮助你理解如何应用这个模式。'
- en: A major benefit of presenting design guidance in the form of patterns is that
    these patterns can be applied one after another. If you have a huge design problem,
    it’s hard to find the one guidance document and the one solution that addresses
    exactly that problem. Instead, you can think of your huge and very specific problem
    as a sum of many smaller and more generic problems, and you can tackle these problems
    bit by bit by applying one pattern after the other. You simply check the problem
    descriptions of the patterns and apply the one that fits your problem and that
    has consequences you can live with. These consequences might lead to another problem
    that you can then address by applying another pattern. That way you incrementally
    design your code instead of trying to come up with a complete up-front design
    before even writing the first line of code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将设计指导以模式的形式呈现的一个主要好处是，这些模式可以依次应用。如果你有一个庞大的设计问题，很难找到一个能够解决这个问题的指导文件和一个解决方案。相反，你可以将你的庞大和非常具体的问题看作许多较小和更通用问题的总和，并且可以通过依次应用一个又一个模式逐步解决这些问题。你只需检查模式的问题描述，并应用适合你的问题并且你可以接受其后果的模式。这些后果可能会导致另一个问题，然后你可以通过应用另一个模式来解决它。这样，你就可以逐步设计你的代码，而不是在甚至写下第一行代码之前就想出一个完整的前期设计。
- en: How to Read This Book
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何阅读本书
- en: You should already know C programming basics. You should know the C syntax and
    how it works—for example, this book won’t teach you what a pointer is or how to
    use it. This book delivers hints and guidance on advanced topics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经了解 C 编程的基础知识。你应该知道 C 的语法及其工作原理——例如，这本书不会教你什么是指针或者如何使用它。本书提供了关于高级主题的提示和指导。
- en: The chapters in this book are self-standing. You can read them in an arbitrary
    order, and you can simply pick out the topics you are interested in. You’ll find
    an overview of all patterns in the next section, and from there you can jump to
    the patterns you are interested in. So if you know exactly what you are looking
    for, you can start right there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的各章节都是独立的。你可以按任意顺序阅读它们，可以简单地挑选你感兴趣的主题。你将在下一节找到所有模式的概述，然后可以跳转到你感兴趣的模式。因此，如果你确切地知道你在寻找什么，你可以从那里开始。
- en: If you are not looking for one particular pattern, but instead want to get an
    overview of possible C design options, read through [Part I](part01.xhtml#part_1)
    of the book. Each chapter there focuses on a particular topic, starting with basic
    topics like error handling and memory managment, and then moving to more advanced
    and specific topics like interface design or platform-independent code. The chapters
    each present patterns related to that topic and a running code example that shows
    bit by bit how the patterns can be applied.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在寻找一个特定的模式，而是想要了解可能的 C 设计选项的概述，请阅读本书的[第一部分](part01.xhtml#part_1)。那里的每一章都专注于特定主题，从错误处理和内存管理等基础主题开始，然后转向更高级和具体的主题，如接口设计或跨平台代码。每章节都介绍了与该主题相关的模式，并提供了一个运行的代码示例，逐步展示这些模式如何应用。
- en: '[Part II](part02.xhtml#part_2) of this book shows two larger running examples
    that apply many of the patterns from [Part I](part01.xhtml#part_1). Here you can
    learn how to build up some larger piece of software bit by bit through the application
    of patterns.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的 [第二部分](part02.xhtml#part_2) 展示了两个应用了 [第一部分](part01.xhtml#part_1) 中许多模式的较大运行示例。在这里，您可以学习如何通过模式的应用逐步构建一些较大的软件部件。
- en: Overview of the Patterns
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式概览
- en: You’ll find an overview of all patterns presented in this book in Tables [P-2](#tab1a)
    through [P-10](#tab1i). The tables show a short form of the patterns that only
    contains a brief description of the core problem, followed by the keyword “Therefore,”
    followed by the core solution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书中介绍的所有模式概览都可以在表 [P-2](#tab1a) 到 [P-10](#tab1i) 中找到。这些表显示了模式的简短形式，仅包含核心问题的简要描述，后跟关键字“因此”，再后跟核心解决方案。
- en: Table P-2\. Patterns for error handling
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 P-2\. 错误处理模式
- en: '| Pattern name | Summary |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Function Split”](ch01.xhtml#pattern_function_split) | The function has
    several responsibilities, which makes the function hard to read and maintain.
    Therefore, split it up. Take a part of a function that seems useful on its own,
    create a new function with that, and call that function. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| [“函数分割”](ch01.xhtml#pattern_function_split) | 函数具有多个责任，这使得函数难以阅读和维护。因此，将其拆分。将看似有用的函数部分单独提取出来，创建一个新函数，并调用该函数。
    |'
- en: '| [“Guard Clause”](ch01.xhtml#pattern_guard_clause) | The function is hard
    to read and maintain because it mixes pre-condition checks with the main program
    logic of the function. Therefore, check if you have mandatory pre-conditions,
    and immediately return from the function if these pre-conditions are not met.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| [“守卫条款”](ch01.xhtml#pattern_guard_clause) | 函数由于将前置条件检查与函数的主要程序逻辑混合在一起而难以阅读和维护。因此，检查是否具有强制性的前置条件，如果这些前置条件不满足，则立即从函数中返回。
    |'
- en: '| [“Samurai Principle”](ch01.xhtml#pattern_samurai_principle) | When returning
    error information, you assume that the caller checks for this information. However,
    the caller can simply omit this check and the error might go unnoticed. Therefore,
    return from a function victorious or not at all. If there is a situation for which
    you know that an error cannot be handled, then abort the program. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| [“武士原则”](ch01.xhtml#pattern_samurai_principle) | 在返回错误信息时，您假设调用者会检查此信息。然而，调用者可以简单地忽略此检查，错误可能会被忽略。因此，要么从函数中胜利返回，要么干脆不返回。如果有一种情况，您知道无法处理错误，则中止程序。
    |'
- en: '| [“Goto Error Handling”](ch01.xhtml#pattern_goto) | Code gets difficult to
    read and maintain if it acquires and cleans up multiple resources at different
    places within a function. Therefore, have all resource cleanup and error handling
    at the end of the function. If a resource cannot be acquired, use the `goto` statement
    to jump to the resource cleanup code. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| [“Goto 错误处理”](ch01.xhtml#pattern_goto) | 如果函数在不同位置获取和清理多个资源，则代码变得难以阅读和维护。因此，将所有资源清理和错误处理放在函数末尾。如果无法获取资源，则使用
    `goto` 语句跳转到资源清理代码。 |'
- en: '| [“Cleanup Record”](ch01.xhtml#pattern_cleanup_record) | It is difficult to
    make a piece of code easy to read and maintain if this code acquires and cleans
    up multiple resources, particularly if those resources depend on one another.
    Therefore, call resource acquisition functions as long as they succeed, and store
    which functions require cleanup. Call the cleanup functions depending on these
    stored values. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| [“清理记录”](ch01.xhtml#pattern_cleanup_record) | 如果代码获取并清理多个资源，特别是这些资源彼此依赖，那么要使代码易于阅读和维护是很困难的。因此，只要成功，调用资源获取函数，并存储哪些函数需要清理。根据这些存储的值调用清理函数。
    |'
- en: '| [“Object-Based Error Handling”](ch01.xhtml#pattern_object_based_error_handling)
    | Having multiple responsibilities in one function, such as resource acquisition,
    resource cleanup, and usage of that resource, makes that code difficult to implement,
    read, maintain, and test. Therefore, put initialization and cleanup into separate
    functions, similar to the concept of constructors and destructors in object-oriented
    programming. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| [“基于对象的错误处理”](ch01.xhtml#pattern_object_based_error_handling) | 一个函数具有多个责任，如资源获取、资源清理和资源使用，使得该代码难以实现、阅读、维护和测试。因此，将初始化和清理放入单独的函数中，类似于面向对象编程中构造函数和析构函数的概念。
    |'
- en: Table P-3\. Patterns for returning error information
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 P-3\. 返回错误信息的模式
- en: '| Pattern name | Summary |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Return Status Codes”](ch02.xhtml#pattern_return_error_codes) | You want
    to have a mechanism to return status information to the caller, so that the caller
    can react to it. You want the mechanism to be simple to use, and the caller should
    be able to clearly distinguish between different error situations that could occur.
    Therefore, use the Return Value of a function to return status information. Return
    a value that represents a specific status. Both of you as the callee and the caller
    must have a mutual understanding of what the value means. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| [“返回状态码”](ch02.xhtml#pattern_return_error_codes) | 你需要一个机制来向调用者返回状态信息，以便调用者能够做出反应。你希望这个机制简单易用，并且调用者能够清楚地区分可能发生的不同错误情况。因此，使用函数的返回值来返回状态信息。返回一个代表特定状态的值。你和调用者必须对这个值的含义有共同的理解。
    |'
- en: '| [“Return Relevant Errors”](ch02.xhtml#pattern_return_relevant_errors) | On
    the one hand, the caller should be able to react to errors; on the other hand,
    the more error information you return, the more your code and the code of your
    caller have to deal with error handling, which makes the code longer. Longer code
    is harder to read and maintain and brings in the risk of additional bugs. Therefore,
    only return error information to the caller if that information is relevant to
    the caller. Error information is only relevant to the caller if the caller can
    react to that information. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| [“返回相关错误”](ch02.xhtml#pattern_return_relevant_errors) | 一方面，调用者应该能够对错误做出反应；另一方面，你返回的错误信息越多，你和调用者的代码处理错误的负担就越重，这会使代码变得更长。长代码更难阅读和维护，并带来额外错误的风险。因此，只有当信息对调用者是相关的时，才向调用者返回错误信息。错误信息只有在调用者能够对其做出反应时才是相关的。
    |'
- en: '| [“Special Return Values”](ch02.xhtml#pattern_special_return_values) | You
    want to return error information, but it’s not an option to explicitly Return
    Status Codes because that implies that you cannot use the Return Value of the
    function to return other data. You’d have to return that data via Out-Parameters,
    which would make calling your function more difficult. Therefore, use the Return
    Value of your function to return the data computed by the function. Reserve one
    or more special values to be returned if an error occurs. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| [“特殊返回值”](ch02.xhtml#pattern_special_return_values) | 你希望返回错误信息，但显式返回状态码并不是一个选项，因为这意味着你不能使用函数的返回值来返回其他数据。你必须通过输出参数返回这些数据，这会使调用函数更加困难。因此，使用函数的返回值来返回函数计算的数据。预留一个或多个特殊值在发生错误时返回。
    |'
- en: '| [“Log Errors”](ch02.xhtml#pattern_log_errors) | You want to make sure that
    in case of an error you can easily find out its cause. However, you don’t want
    your error-handling code to become complicated because of this. Therefore, use
    different channels to provide error information that is relevant for the calling
    code and error information that is relevant for the developer. For example, write
    debug error information into a log file and don’t return the detailed debug error
    information to the caller. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| [“记录错误”](ch02.xhtml#pattern_log_errors) | 你希望在发生错误时能够轻松找出其原因。然而，你不希望因此使你的错误处理代码变得复杂。因此，使用不同的渠道提供对调用代码和开发者相关的错误信息。例如，将调试错误信息写入日志文件，而不将详细的调试错误信息返回给调用者。
    |'
- en: Table P-4\. Patterns for memory management
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 P-4\. 内存管理模式
- en: '| Pattern name | Summary |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Stack First”](ch03.xhtml#pattern_stack_first) | Deciding the storage class
    and memory section (stack, heap, …) for variables is a decision every programmer
    has to make often. It gets exhausting if for each and every variable, the pros
    and cons of all possible alternatives have to be considered in detail. Therefore,
    simply put your variables on the stack by default to profit from automatic cleanup
    of stack variables. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| [“栈优先”](ch03.xhtml#pattern_stack_first) | 决定变量的存储类别和内存部分（栈、堆等）是每个程序员经常要做的决定。如果每个变量都要详细考虑所有可能的替代方案的利弊，这将是很费力的。因此，默认情况下将变量放在栈上，以便从栈变量的自动清理中获益。
    |'
- en: '| [“Eternal Memory”](ch03.xhtml#pattern_eternal_memory) | Holding large amounts
    of data and transporting it between function calls is difficult because you have
    to make sure that the memory for the data is large enough and that the lifetime
    extends across your function calls. Therefore, put your data into memory that
    is available throughout the whole lifetime of your program. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| [“永久内存”](ch03.xhtml#pattern_eternal_memory) | 持有大量数据并在函数调用之间传输数据很困难，因为必须确保数据的内存足够大且其生命周期跨越函数调用。因此，将数据放入整个程序生命周期都可用的内存中。
    |'
- en: '| [“Lazy Cleanup”](ch03.xhtml#pattern_screw_freeing) | Having dynamic memory
    is required if you need large amounts of memory and memory where you don’t know
    the required size beforehand. However, handling cleanup of dynamic memory is a
    hassle and is the source of many programming errors. Therefore, allocate dynamic
    memory and let the operating system cope with deallocation by the end of your
    program. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| [“延迟清理”](ch03.xhtml#pattern_screw_freeing) | 如果需要大量内存或者不知道所需大小的内存，则需要动态内存。然而，处理动态内存的清理是一件麻烦事，并且是许多编程错误的来源。因此，分配动态内存，并在程序结束时让操作系统处理释放。
    |'
- en: '| [“Dedicated Ownership”](ch03.xhtml#pattern_dedicated_ownership) | The great
    power of using dynamic memory comes with the great responsibility of having to
    properly clean that memory up. In larger programs, it becomes difficult to make
    sure that all dynamic memory is cleaned up properly. Therefore, right at the time
    when you implement memory allocation, clearly define and document where it’s going
    to be cleaned up and who is going to do that. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| [“专用所有权”](ch03.xhtml#pattern_dedicated_ownership) | 使用动态内存的巨大力量伴随着要正确清理内存的重大责任。在较大的程序中，确保所有动态内存正确清理变得困难。因此，在实现内存分配时，清晰地定义和记录将要进行清理的位置及执行清理的对象。
    |'
- en: '| [“Allocation Wrapper”](ch03.xhtml#pattern_allocation_wrapper) | Each allocation
    of dynamic memory might fail, so you should check allocations in your code to
    react accordingly. This is cumbersome because you have many places for such checks
    in your code. Therefore, wrap the allocation and deallocation calls, and implement
    error handling or additional memory management organization in these wrapper functions.
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| [“分配包装器”](ch03.xhtml#pattern_allocation_wrapper) | 每次动态内存分配可能会失败，因此应在代码中检查分配并做出相应反应。这很麻烦，因为您的代码中有许多这样的检查位置。因此，包装分配和释放调用，并在这些包装函数中实现错误处理或额外的内存管理组织。
    |'
- en: '| [“Pointer Check”](ch03.xhtml#pattern_pointer_check) | Programming errors
    that lead to accessing an invalid pointer cause uncontrolled program behavior,
    and such errors are difficult to debug. However, because your code works with
    pointers frequently, there is a good chance that you have introduced such programming
    errors. Therefore, explicitly invalidate uninitialized or freed pointers and always
    check pointers for validity before accessing them. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| [“指针检查”](ch03.xhtml#pattern_pointer_check) | 导致访问无效指针的编程错误会引发程序的不受控行为，此类错误难以调试。然而，因为您的代码频繁使用指针，存在引入此类编程错误的风险。因此，明确地使未初始化或已释放的指针无效，并始终在访问之前检查指针的有效性。
    |'
- en: '| [“Memory Pool”](ch03.xhtml#pattern_memory_pool) | Frequently allocating and
    deallocating objects from the heap leads to memory fragmentation. Therefore, hold
    a large piece of memory throughout the whole lifetime of your program. At runtime,
    retrieve fixed-size chunks of that memory pool instead of directly allocating
    new memory from the heap. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| [“内存池”](ch03.xhtml#pattern_memory_pool) | 频繁地从堆中分配和释放对象会导致内存碎片化。因此，持有整个程序生命周期中的大块内存。在运行时，从该内存池中检索固定大小的块，而不是直接从堆中分配新内存。
    |'
- en: Table P-5\. Patterns for returning data from C functions
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表 P-5\. 从 C 函数返回数据的模式
- en: '| Pattern name | Summary |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Return Value”](ch04.xhtml#pattern_return_value) | The function parts you
    want to split are not independent from one another. As usual in procedural programming,
    some part delivers a result that is then needed by some other part. The function
    parts that you want to split need to share some data. Therefore, simply use the
    one C mechanism intended to retrieve information about the result of a function
    call: the Return Value. The mechanism to return data in C copies the function
    result and provides the caller access to this copy. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| [“返回值”](ch04.xhtml#pattern_return_value) | 你希望分离的函数部分彼此不独立。与面向过程编程一样，一些部分产生的结果需要其他部分使用。你希望分离的函数部分需要共享一些数据。因此，简单地使用C语言机制来检索函数调用结果的信息：返回值。C语言中返回数据的机制会复制函数结果，并提供调用者访问此副本的方式。
    |'
- en: '| [“Out-Parameters”](ch04.xhtml#pattern_out_parameters) | C only supports returning
    a single type from a function call, and that makes it complicated to return multiple
    pieces of information. Therefore, return all the data with a single function call
    by emulating by-reference arguments with pointers. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| [“输出参数”](ch04.xhtml#pattern_out_parameters) | C只支持从函数调用返回单一类型，这使得返回多个信息变得复杂。因此，通过使用指针模拟按引用参数传递的方式，在单个函数调用中返回所有数据。
    |'
- en: '| [“Aggregate Instance”](ch04.xhtml#pattern_aggregate_instance) | C only supports
    returning a single type from a function call, and that makes it complicated to
    return multiple pieces of information. Therefore, put all data that is related
    into a newly defined type. Define this Aggregate Instance to contain all the related
    data that you want to share. Define it in the interface of your component to let
    the caller directly access all the data stored in the instance. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| [“聚合实例”](ch04.xhtml#pattern_aggregate_instance) | C只支持从函数调用返回单一类型，这使得返回多个信息变得复杂。因此，将所有相关数据放入一个新定义的类型中。定义这个聚合实例来包含你想要分享的所有相关数据。在你组件的接口中定义它，让调用者直接访问实例中存储的所有数据。
    |'
- en: '| [“Immutable Instance”](ch04.xhtml#pattern_immutable_instance) | You want
    to provide information held in large pieces of immutable data from your component
    to a caller. Therefore, have an instance (for example, a `struct`) containing
    the data to share in static memory. Provide this data to users who want to access
    it and make sure that they cannot modify it. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| [“不可变实例”](ch04.xhtml#pattern_immutable_instance) | 你希望从组件向调用者提供大块不可变数据中包含的信息。因此，有一个实例（例如一个`struct`），包含要在静态内存中共享的数据。将这些数据提供给希望访问它的用户，并确保他们无法修改它。
    |'
- en: '| [“Caller-Owned Buffer”](ch04.xhtml#pattern_caller_owned_buffer) | You want
    to provide complex or large data of known size to the caller, and that data is
    not immutable (it changes at runtime). Therefore, require the caller to provide
    a buffer and its size to the function that returns the large, complex data. In
    the function implementation, copy the required data into the buffer if the buffer
    size is large enough. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| [“调用者拥有的缓冲区”](ch04.xhtml#pattern_caller_owned_buffer) | 你希望向调用者提供复杂或大型数据（其大小已知），并且该数据不是不可变的（它在运行时会改变）。因此，要求调用者向返回大型复杂数据的函数提供缓冲区及其大小。在函数实现中，如果缓冲区大小足够大，将所需数据复制到缓冲区中。
    |'
- en: '| [“Callee Allocates”](ch04.xhtml#pattern_callee_allocates) | You want to provide
    complex or large data of unknown size to the caller, and that data is not immutable
    (it changes at runtime). Therefore, allocate a buffer with the required size inside
    the function that provides the large, complex data. Copy the required data into
    the buffer and return a pointer to that buffer. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| [“被调用者分配”](ch04.xhtml#pattern_callee_allocates) | 你希望向调用者提供复杂或大小未知的数据，并且该数据不是不可变的（它在运行时会改变）。因此，在提供大型复杂数据的函数内部分配一个具有所需大小的缓冲区。将所需数据复制到缓冲区中，并返回指向该缓冲区的指针。
    |'
- en: Table P-6\. Patterns for data lifetime and ownership
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Table P-6\. 数据生命周期和所有权的模式
- en: '| Pattern name | Summary |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Stateless Software-Module”](ch05.xhtml#pattern_stateless_software_module)
    | You want to provide logically related functionality to your caller and make
    that functionality as easy as possible for the caller to use. Therefore, keep
    your functions simple and don’t build up state information in your implementation.
    Put all related functions into one header file and provide the caller this interface
    to your software-module. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| [“无状态软件模块”](ch05.xhtml#pattern_stateless_software_module) | 你希望向调用者提供逻辑相关的功能，并尽可能地简化调用者使用该功能。因此，保持函数简单，在实现中不要建立状态信息。将所有相关函数放入一个头文件中，并向调用者提供你软件模块的接口。
    |'
- en: '| [“Software-Module with Global State”](ch05.xhtml#pattern_software_module_with_global_state)
    | You want to structure your logically related code that requires common state
    information and make that functionality as easy as possible for the caller to
    use. Therefore, have one global instance to let your related functions share common
    resources. Put all functions that operate on this instance into one header file,
    and provide the caller this interface to your software-module. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| [“带全局状态的软件模块”](ch05.xhtml#pattern_software_module_with_global_state) | 您希望结构化逻辑相关代码，这些代码需要共享状态信息，并使调用者尽可能轻松地使用该功能。因此，使用一个全局实例让相关函数共享公共资源。将所有操作此实例的函数放入一个头文件中，并向调用者提供这个软件模块的接口。
    |'
- en: '| [“Caller-Owned Instance”](ch05.xhtml#pattern_caller_owned_instance) | You
    want to provide multiple callers or threads access to functionality with functions
    that depend on one another, and the interaction of the caller with your functions
    builds up state information. Therefore, require the caller to pass an instance,
    which is used to store resource and state information, along to your functions.
    Provide explicit functions to create and destroy these instances, so that the
    caller can determine their lifetime. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| [“调用者拥有实例”](ch05.xhtml#pattern_caller_owned_instance) | 您希望提供多个调用者或线程访问依赖于彼此的功能，调用者与您的函数交互会构建状态信息。因此，要求调用者传递一个实例，用于存储资源和状态信息，并传递给您的函数。提供明确的函数来创建和销毁这些实例，以便调用者可以确定它们的生命周期。
    |'
- en: '| [“Shared Instance”](ch05.xhtml#pattern_shared_instance) | You want to provide
    multiple callers or threads access to functionality with functions that depend
    on one another, and the interaction of the caller with your functions builds up
    state information, which your callers want to share. Therefore, require the caller
    to pass an instance, which is used to store resource and state information, along
    to your functions. Use the same instance for multiple callers and keep the ownership
    of that instance in your software-module. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| [“共享实例”](ch05.xhtml#pattern_shared_instance) | 您希望提供多个调用者或线程访问依赖于彼此的功能，调用者与您的函数交互会构建状态信息，而调用者希望共享这些信息。因此，要求调用者传递一个实例，用于存储资源和状态信息，并传递给您的函数。在多个调用者之间使用相同的实例，并在您的软件模块中保持该实例的所有权。
    |'
- en: Table P-7\. Patterns for flexible APIs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 P-7\. 灵活API的模式
- en: '| Pattern name | Summary |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Header Files”](ch06.xhtml#pattern_header_files) | You want functionality
    that you implement to be accessible to code from other implementation files, but
    you want to hide your implementation details from the caller. Therefore, provide
    function declarations in your API for any functionality you want to provide to
    your user. Hide any internal functions, internal data, and your function definitions
    (the implementations) in your implementation file and don’t provide this implementation
    file to the user. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| [“头文件”](ch06.xhtml#pattern_header_files) | 您希望您实现的功能可以被其他实现文件中的代码访问，但希望隐藏调用者不应看到的实现细节。因此，在您的API中提供函数声明，为您希望向用户提供的任何功能提供接口。将任何内部函数、内部数据和函数定义（实现）隐藏在实现文件中，并不将此实现文件提供给用户。
    |'
- en: '| [“Handle”](ch06.xhtml#pattern_handle) | You have to share state information
    or operate on shared resources in your function implementations, but you don’t
    want your caller to see or even access all that state information and shared resources.
    Therefore, have a function to create the context on which the caller operates
    and return an abstract pointer to internal data for that context. Require the
    caller to pass that pointer to all your functions, which can then use the internal
    data to store state information and resources. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| [“句柄”](ch06.xhtml#pattern_handle) | 您需要在函数实现中共享状态信息或操作共享资源，但不希望调用者看到或甚至访问所有这些状态信息和共享资源。因此，提供一个函数来创建调用者操作的上下文，并返回该上下文内部数据的抽象指针。要求调用者将该指针传递给所有您的函数，然后这些函数可以使用内部数据来存储状态信息和资源。
    |'
- en: '| [“Dynamic Interface”](ch06.xhtml#pattern_dynamic_interface) | It should be
    possible to call implementations with slightly deviating behaviors, but it should
    not be necessary to duplicate any code, not even the control logic implementation
    and interface declaration. Therefore, define a common interface for the deviating
    functionalities in your API and require the caller to provide a callback function
    for that functionality, which you then call in your function implementation. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| [“动态接口”](ch06.xhtml#pattern_dynamic_interface) | 应该能够调用具有略有不同行为的实现，但不应该需要复制任何代码，甚至是控制逻辑实现和接口声明。因此，在你的API中为这些有差异的功能定义一个通用接口，并要求调用者提供一个回调函数，然后在你的函数实现中调用这个回调函数。
    |'
- en: '| [“Function Control”](ch06.xhtml#pattern_function_control) | You want to call
    implementations with slightly deviating behaviors, but you don’t want to duplicate
    any code, not even the control logic implementation or the interface declaration.
    Therefore, add a parameter to your function that passes meta-information about
    the function call and that specifies the actual functionality to be performed.
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| [“函数控制”](ch06.xhtml#pattern_function_control) | 你希望调用具有略有不同行为的实现，但不想重复任何代码，甚至是控制逻辑实现或接口声明。因此，在你的函数中添加一个参数，传递关于函数调用的元信息，并指定要执行的实际功能。
    |'
- en: Table P-8\. Patterns for flexible iterator interfaces
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 P-8\. 灵活迭代器接口的模式
- en: '| Pattern name | Summary |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 概要 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Index Access”](ch07.xhtml#pattern_index_access) | You want to make it possible
    for the user to iterate elements in your data structure in a convenient way, and
    it should be possible to change internals of the data structure without resulting
    in changes to the user’s code. Therefore, provide a function that takes an index
    to address the element in your underlying data structure and return the content
    of this element. The user calls this function in a loop to iterate over all elements.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| [“索引访问”](ch07.xhtml#pattern_index_access) | 你希望让用户以便捷的方式迭代你的数据结构中的元素，并且可以在内部更改数据结构而不需要更改用户代码。因此，提供一个函数，接受一个索引来访问底层数据结构中的元素，并返回此元素的内容。用户在循环中调用此函数来迭代所有元素。
    |'
- en: '| [“Cursor Iterator”](ch07.xhtml#pattern_cursor_iterator) | You want to provide
    an iteration interface to your user which is robust in case the elements change
    during the iteration and which enables you to change the underlying data structure
    at a later point without requiring any changes to the user’s code. Therefore,
    create an iterator instance that points to an element in the underlying data structure.
    An iteration function takes this iterator instance as argument, retrieves the
    element the iterator currently points to, and modifies the iteration instance
    to point to the next element. The user then iteratively calls this function to
    retrieve one element at a time. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| [“游标迭代器”](ch07.xhtml#pattern_cursor_iterator) | 你希望为用户提供一个迭代接口，即使在迭代过程中元素发生变化也能保持稳健，并且在稍后可以更改底层数据结构而无需更改用户代码。因此，创建一个迭代器实例，指向底层数据结构中的一个元素。一个迭代函数以此迭代器实例作为参数，检索迭代器当前指向的元素，并修改迭代实例以指向下一个元素。然后用户迭代调用此函数以逐个检索元素。
    |'
- en: '| [“Callback Iterator”](ch07.xhtml#pattern_callback_iterator) | You want to
    provide a robust iteration interface which does not require the user to implement
    a loop in the code for iterating over all elements and which enables you to change
    the underlying data structure at a later point without requiring any changes to
    the user’s code. Therefore, use your existing data structure—specific operations
    to iterate over all your elements within your implementation, and call some provided
    user-function on each element during this iteration. This user-function gets the
    element content as a parameter and can then perform its operations on this element.
    The user calls just one function to trigger the iteration, and the whole iteration
    takes place inside your implementation. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| [“回调迭代器”](ch07.xhtml#pattern_callback_iterator) | 你希望提供一个稳健的迭代接口，用户不需要在代码中实现循环来迭代所有元素，并且在稍后可以更改底层数据结构而无需更改用户代码。因此，使用你现有的数据结构特定操作来在你的实现内部迭代所有元素，并在此迭代过程中调用一些提供的用户函数处理每个元素。这个用户函数以元素内容作为参数，然后可以对这个元素执行操作。用户只需调用一个函数来触发迭代，整个迭代过程在你的实现内部完成。
    |'
- en: Table P-9\. Patterns for organizing files in modular programs
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表 P-9\. 模块化程序中文件组织的模式
- en: '| Pattern name | Summary |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Include Guard”](ch08.xhtml#pattern_include_guard) | It’s easy to include
    a header file multiple times, but including the same header file leads to compile
    errors if types or certain macros are part of it, because during compilation they
    get redefined. Therefore, protect the content of your header files against multiple
    inclusion so that the developer using the header files does not have to care whether
    it is included multiple times. Use an interlocked `#ifdef` statement or a `#pragma
    once` statement to achieve this. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| [“包含保护”](ch08.xhtml#pattern_include_guard) | 多次包含同一个头文件很容易，但如果其中包含类型或某些宏，则在编译时会导致重定义错误。因此，保护您的头文件内容免受多次包含的影响，以便使用头文件的开发人员不必关心它是否多次包含。使用交叉锁定的
    `#ifdef` 语句或 `#pragma once` 语句来实现这一点。 |'
- en: '| [“Software-Module Directories”](ch08.xhtml#pattern_software_module_directories)
    | Splitting code into different files increases the number of files in your codebase.
    Having all files in one directory makes it difficult to keep an overview of all
    the files, particularly for large codebases. Therefore, put header files and implementation
    files that belong to a tightly coupled functionality into one directory. Name
    that directory after the functionality that is provided via the header files.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| [“软件模块目录”](ch08.xhtml#pattern_software_module_directories) | 将代码分割为不同的文件会增加代码库中的文件数量。将所有文件放在一个目录中会使得在大型代码库中特别难以保持对所有文件的概览。因此，将属于紧密耦合功能的头文件和实现文件放入一个目录中。将该目录命名为通过头文件提供的功能的名称。
    |'
- en: '| [“Global Include Directory”](ch08.xhtml#pattern_global_include_directory)
    | To include files from other software-modules, you have to use relative paths
    like *../othersoftwaremodule/file.h*. You have to know the exact location of the
    other header file. Therefore, have one global directory in your codebase that
    contains all software-module APIs. Add this directory to the global include paths
    in your toolchain. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| [“全局包含目录”](ch08.xhtml#pattern_global_include_directory) | 要包含来自其他软件模块的文件，必须使用诸如
    *../othersoftwaremodule/file.h* 的相对路径。您必须知道其他头文件的确切位置。因此，在代码库中有一个全局目录，其中包含所有软件模块的
    API。将此目录添加到工具链中的全局包含路径中。 |'
- en: '| [“Self-Contained Component”](ch08.xhtml#pattern_self_contained_component)
    | From the directory structure it is not possible to see the dependencies in the
    code. Any software-module can simply include the header files from any other software-module,
    so it’s impossible to check dependencies in the code via the compiler. Therefore,
    identify software-modules that contain similar functionality and that should be
    deployed together. Put these software-modules into a common directory and have
    a designated subdirectory for their header files that are relevant for the caller.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| [“自包含组件”](ch08.xhtml#pattern_self_contained_component) | 从目录结构中不可能看到代码的依赖关系。任何软件模块都可以简单地包含来自任何其他软件模块的头文件，因此无法通过编译器检查代码的依赖关系。因此，识别包含类似功能的软件模块，并应将这些软件模块放入一个共同的目录中，并为调用者相关的头文件指定一个指定的子目录。
    |'
- en: '| [“API Copy”](ch08.xhtml#pattern_api_copy) | You want to develop, version,
    and deploy the parts of your codebase independently from one another. However,
    to do that, you need clearly defined interfaces between the code parts and the
    ability to separate that code into different repositories. Therefore, to use the
    functionality of another component, copy its API. Build that other component separately
    and copy the build artifacts and its public header files. Put these files into
    a directory inside your component and configure that directory as a global include
    path. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| [“API 复制”](ch08.xhtml#pattern_api_copy) | 您希望独立开发、版本化和部署代码库的各个部分。但是，为了实现这一目标，您需要明确定义代码部分之间的接口，并能够将该代码分隔到不同的存储库中。因此，为了使用另一个组件的功能，复制其
    API。分别构建该其他组件并复制构建产物及其公共头文件。将这些文件放入您的组件内的一个目录，并配置该目录为全局包含路径。 |'
- en: Table P-10\. Patterns for escaping `#ifdef` hell
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 P-10\. 逃离 `#ifdef` 地狱的模式
- en: '| Pattern name | Summary |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [“Avoid Variants”](ch09.xhtml#pattern_avoid_variants) | Using different functions
    for each platform makes the code harder to read and write. The programmer is required
    to initially understand, correctly use, and test these multiple functions in order
    to achieve a single functionality across multiple platforms. Therefore, use standardized
    functions that are available on all platforms. If there are no standardized functions,
    consider not implementing the functionality. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| [“避免变体”](ch09.xhtml#pattern_avoid_variants) | 在每个平台上使用不同的函数使得代码更难阅读和编写。程序员需要最初理解、正确使用和测试这些多个函数，以实现跨多个平台的单一功能。因此，请使用在所有平台上都可用的标准化函数。如果没有标准化函数，则考虑不实现该功能。
    |'
- en: '| [“Isolated Primitives”](ch09.xhtml#pattern_isolate_primitives) | Having code
    variants organized with `#ifdef` statements makes the code unreadable. It is very
    difficult to follow the program flow, because it is implemented multiple times
    for multiple platforms. Therefore, isolate your code variants. In your implementation
    file, put the code handling the variants into separate functions and call these
    functions from your main program logic, which then contains only platform-independent
    code. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| [“隔离原语”](ch09.xhtml#pattern_isolate_primitives) | 使用`#ifdef`语句组织的代码变体使得代码难以阅读。很难跟踪程序流程，因为为多个平台实现了多次。因此，请隔离您的代码变体。在实现文件中，将处理变体的代码放入单独的函数中，并从主程序逻辑中调用这些函数，这样主程序只包含平台无关的代码。
    |'
- en: '| [“Atomic Primitives”](ch09.xhtml#pattern_atomic_primitives) | The function
    that contains the variants and is called by the main program is still hard to
    comprehend because all the complex `#ifdef` code was only put into this function
    in order to get rid of it in the main program. Therefore, make your primitives
    atomic. Only handle exactly one kind of variant per function. If you handle multiple
    kinds of variants, for example, operating system variants and hardware variants,
    then have separate functions for that. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| [“原子原语”](ch09.xhtml#pattern_atomic_primitives) | 包含变体并由主程序调用的函数仍然很难理解，因为所有复杂的`#ifdef`代码只是为了在主程序中摆脱它。因此，请使您的原语是原子的。每个函数仅处理一种变体。如果处理多种变体，例如操作系统变体和硬件变体，则为其使用单独的函数。
    |'
- en: '| [“Abstraction Layer”](ch09.xhtml#pattern_abstraction_layer) | You want to
    use the functionality which handles platform variants at several places in your
    codebase, but you do not want to duplicate the code of that functionality. Therefore,
    provide an API for each functionality that requires platform-specific code. Define
    only platform-independent functions in the header file and put all platform-specific
    `#ifdef` code into the implementation file. The caller of your functions includes
    only your header file and does not have to include any platform-specific files.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| [“抽象层”](ch09.xhtml#pattern_abstraction_layer) | 您希望在代码库的多个位置使用处理平台变体的功能，但不希望复制该功能的代码。因此，请为每个需要平台特定代码的功能提供一个API。在头文件中仅定义平台无关的函数，并将所有平台特定的`#ifdef`代码放入实现文件中。函数的调用者仅需包含您的头文件，而不必包含任何平台特定文件。
    |'
- en: '| [“Split Variant Implementations”](ch09.xhtml#pattern_split_implementation_variants)
    | The platform-specific implementations still contain `#ifdef` statements to distinguish
    between code variants. That makes it difficult to see and select which part of
    the code should be built for which platform. Therefore, put each variant implementation
    into a separate implementation file and select per file what you want to compile
    for which platform. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| [“拆分变体实现”](ch09.xhtml#pattern_split_implementation_variants) | 平台特定的实现仍然包含`#ifdef`语句，用于区分代码变体。这使得很难看到并选择应该为哪个平台构建哪部分代码。因此，将每个变体实现放入单独的实现文件中，并根据需要选择为哪个平台编译。
    |'
- en: Conventions Used in This Book
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书中使用的约定
- en: 'The following typographical conventions are used in this book:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用以下排版约定：
- en: '*Italic*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*斜体*'
- en: Indicates new terms, URLs, email addresses, filenames, and file extensions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表示新术语、网址、电子邮件地址、文件名和文件扩展名。
- en: '**Bold**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**粗体**'
- en: Used to highlight the problem and solution for each pattern.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用于突出每种模式的问题和解决方案。
- en: '`Constant width`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`等宽字体`'
- en: Used for program listings, as well as within paragraphs to refer to program
    elements such as variable or function names, databases, data types, environment
    variables, statements, and keywords.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用于程序清单，以及段落中引用程序元素如变量或函数名、数据库、数据类型、环境变量、语句和关键字。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This element signifies a general note.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素表示一般注释。
- en: Warning
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This element indicates a warning or caution.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素指示警告或注意事项。
- en: Using Code Examples
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码示例
- en: The code examples in this book show short code snippets which focus on the core
    idea to showcase the patterns and their application. The code snippets by themselves
    won’t compile, because to keep it simple several things are omitted (for example,
    include files). If you are interested in getting the full code which does compile,
    you can download it from GitHub at [*https://github.com/christopher-preschern/fluent-c*](https://github.com/christopher-preschern/fluent-c).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码示例展示了重点在于展示模式及其应用的核心思想的短代码片段。这些代码片段本身不会编译，因为为了简化，省略了几个部分（例如，包含文件）。如果您有兴趣获取完全可编译的完整代码，可以从GitHub上下载，网址为[*https://github.com/christopher-preschern/fluent-c*](https://github.com/christopher-preschern/fluent-c)。
- en: If you have a technical question or a problem using the code examples, please
    send email to [*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用代码示例时有技术问题或疑问，请发送电子邮件至[*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com)。
- en: This book is here to help you get your job done. In general, if example code
    is offered with this book, you may use it in your programs and documentation.
    You do not need to contact us for permission unless you’re reproducing a significant
    portion of the code. For example, writing a program that uses several chunks of
    code from this book does not require permission. Selling or distributing examples
    from O’Reilly books does require permission. Answering a question by citing this
    book and quoting example code does not require permission. Incorporating a significant
    amount of example code from this book into your product’s documentation does require
    permission.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在帮助您完成工作。一般来说，如果本书提供了示例代码，您可以在您的程序和文档中使用它。除非您复制了大量代码，否则您无需联系我们请求许可。例如，编写一个使用本书中多个代码片段的程序不需要许可。销售或分发O'Reilly书籍中的示例代码需要许可。引用本书并引用示例代码回答问题不需要许可。将本书中大量示例代码整合到产品文档中需要许可。
- en: 'We appreciate, but generally do not require, attribution. An attribution usually
    includes the title, author, publisher, and ISBN. For example: “*Fluent C* by Christopher
    Preschern (O’Reilly). Copyright 2023 Christopher Preschern, 978-1-492-09733-4.”'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感谢您的使用，但通常不需要署名。署名通常包括标题、作者、出版商和ISBN。例如：“*Fluent C* by Christopher Preschern
    (O’Reilly). Copyright 2023 Christopher Preschern, 978-1-492-09733-4.”
- en: If you feel your use of code examples falls outside fair use or the permission
    given above, feel free to contact us at [*permissions@oreilly.com*](mailto:permissions@oreilly.com).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得您对代码示例的使用超出了合理使用范围或以上给出的许可，请随时与我们联系，电子邮件地址为[*permissions@oreilly.com*](mailto:permissions@oreilly.com)。
- en: 'The patterns in this book all present existing code examples which apply these
    patterns. The following list shows the references to these code examples:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的模式均展示了应用这些模式的现有代码示例。以下列表显示了这些代码示例的引用：
- en: '[The game NetHack](https://oreil.ly/nzO5W)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[游戏NetHack](https://oreil.ly/nzO5W)'
- en: '[OpenWrt Project](https://oreil.ly/qeppo)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenWrt项目](https://oreil.ly/qeppo)'
- en: '[OpenSSL library](https://oreil.ly/zzsMO)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenSSL库](https://oreil.ly/zzsMO)'
- en: '[Wireshark network sniffer](https://oreil.ly/M55B5)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Wireshark网络嗅探器](https://oreil.ly/M55B5)'
- en: '[Portland Pattern repository](https://oreil.ly/wkZzb)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[波特兰模式库](https://oreil.ly/wkZzb)'
- en: '[Git version control system](https://oreil.ly/7F9Oz)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Git版本控制系统](https://oreil.ly/7F9Oz)'
- en: '[Apache Portable Runtime](https://oreil.ly/ysaM6)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apache可移植运行时](https://oreil.ly/ysaM6)'
- en: '[Apache Webserver](https://oreil.ly/W6SMn)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apache Web服务器](https://oreil.ly/W6SMn)'
- en: B&R Automation Runtime operating system (proprietary and undisclosed code of
    the company B&R Industrial Automation GmbH)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B&R Automation Runtime操作系统（B&R工业自动化有限责任公司的专有和保密代码）
- en: B&R Visual Components automation system visualization editor (proprietary and
    undisclosed code of the company B&R Industrial Automation GmbH)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B&R Visual Components自动化系统可视化编辑器（B&R工业自动化有限责任公司的专有和保密代码）
- en: '[NetDRMS data management system](https://oreil.ly/eR0EV)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NetDRMS数据管理系统](https://oreil.ly/eR0EV)'
- en: '[MATLAB programming and numeric computing platform](https://oreil.ly/UpvJK)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MATLAB编程和数值计算平台](https://oreil.ly/UpvJK)'
- en: '[GLib library](https://oreil.ly/QoUwT)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GLib库](https://oreil.ly/QoUwT)'
- en: '[GoAccess real-time web analyzer](https://oreil.ly/L1Eij)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GoAccess实时Web分析器](https://oreil.ly/L1Eij)'
- en: '[Cloudy physical calculation software](https://oreil.ly/phLBb)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cloudy物理计算软件](https://oreil.ly/phLBb)'
- en: '[GNU Compiler Collection (GCC)](https://oreil.ly/KK4jY)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GNU编译器集合（GCC）](https://oreil.ly/KK4jY)'
- en: '[MySQL database system](https://oreil.ly/YKXxs)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 数据库系统](https://oreil.ly/YKXxs)'
- en: '[Android ION memory manager](https://oreil.ly/2JV7h)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Android ION 内存管理器](https://oreil.ly/2JV7h)'
- en: '[Windows API](https://oreil.ly/nnzyX)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Windows API](https://oreil.ly/nnzyX)'
- en: '[Apple’s Cocoa API](https://oreil.ly/sQuaI)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apple Cocoa API](https://oreil.ly/sQuaI)'
- en: '[VxWorks real-time operating system](https://oreil.ly/UMUaj)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[VxWorks 实时操作系统](https://oreil.ly/UMUaj)'
- en: '[sam text editor](https://oreil.ly/k3SQI)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sam 文本编辑器](https://oreil.ly/k3SQI)'
- en: '[C standard library functions: glibc implementation](https://oreil.ly/9Qr95)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C 标准库函数：glibc 实现](https://oreil.ly/9Qr95)'
- en: '[Subversion project](https://oreil.ly/sg9sz)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Subversion 项目](https://oreil.ly/sg9sz)'
- en: '[Netdata real-time performance monitoring and visualization system](https://oreil.ly/1sDZz)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Netdata 实时性能监控和可视化系统](https://oreil.ly/1sDZz)'
- en: '[Nmap network tool](https://oreil.ly/8Yz5R)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Nmap 网络工具](https://oreil.ly/8Yz5R)'
- en: '[OpenZFS file system](https://oreil.ly/VWeQL)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenZFS 文件系统](https://oreil.ly/VWeQL)'
- en: '[RIOT operating system](https://oreil.ly/LhZM4)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RIOT 操作系统](https://oreil.ly/LhZM4)'
- en: '[Radare reverse engineering framework](https://oreil.ly/TUYfh)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Radare 逆向工程框架](https://oreil.ly/TUYfh)'
- en: '[Education First digital learning products](https://www.ef.com)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Education First 数字学习产品](https://www.ef.com)'
- en: '[VIM text editor](https://github.com/vim/vim)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[VIM 文本编辑器](https://github.com/vim/vim)'
- en: '[GNUplot graphing utility](https://oreil.ly/PlQPj)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GNUplot 绘图实用工具](https://oreil.ly/PlQPj)'
- en: '[SQLite database engine](https://oreil.ly/5Knfz)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLite 数据库引擎](https://oreil.ly/5Knfz)'
- en: '[gzip data compression program](https://oreil.ly/it40Z)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[gzip 数据压缩程序](https://oreil.ly/it40Z)'
- en: '[lighttpd web server](https://github.com/lighttpd)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[lighttpd web 服务器](https://github.com/lighttpd)'
- en: '[U-Boot bootloader](https://oreil.ly/IKVYV)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[U-Boot 启动加载程序](https://oreil.ly/IKVYV)'
- en: '[Smpl discrete event simulation system](https://oreil.ly/NJnCH)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Smpl 离散事件模拟系统](https://oreil.ly/NJnCH)'
- en: '[Nokia’s Maemo platform](https://oreil.ly/RwDtt)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Nokia Maemo 平台](https://oreil.ly/RwDtt)'
- en: O’Reilly Online Learning
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: O’Reilly 在线学习
- en: Note
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For more than 40 years, [*O’Reilly Media*](https://oreilly.com) has provided
    technology and business training, knowledge, and insight to help companies succeed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 超过40年来，[*O’Reilly Media*](https://oreilly.com)为企业的成功提供技术和业务培训、知识和见解。
- en: Our unique network of experts and innovators share their knowledge and expertise
    through books, articles, and our online learning platform. O’Reilly’s online learning
    platform gives you on-demand access to live training courses, in-depth learning
    paths, interactive coding environments, and a vast collection of text and video
    from O’Reilly and 200+ other publishers. For more information, visit [*https://oreilly.com*](https://oreilly.com).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们独特的专家和创新者网络通过书籍、文章和我们的在线学习平台分享他们的知识和专长。O’Reilly 的在线学习平台为您提供按需访问的实时培训课程、深入学习路径、交互式编码环境以及来自O’Reilly和其他200多家出版商的大量文本和视频。欲了解更多信息，请访问[*https://oreilly.com*](https://oreilly.com)。
- en: How to Contact Us
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何联系我们
- en: 'Please address comments and questions concerning this book to the publisher:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请将有关本书的评论和问题发送至出版商：
- en: O’Reilly Media, Inc.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O’Reilly Media, Inc.
- en: 1005 Gravenstein Highway North
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1005 Gravenstein Highway North
- en: Sebastopol, CA 95472
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sebastopol, CA 95472
- en: 800-998-9938 (in the United States or Canada)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 800-998-9938（美国或加拿大）
- en: 707-829-0515 (international or local)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 707-829-0515（国际或当地电话）
- en: 707-829-0104 (fax)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 707-829-0104（传真）
- en: We have a web page for this book, where we list errata, examples, and any additional
    information. You can access this page at [*https://oreil.ly/fluent-c*](https://oreil.ly/fluent-c).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个关于本书的网页，上面列出勘误、示例和任何额外信息。您可以访问[*https://oreil.ly/fluent-c*](https://oreil.ly/fluent-c)。
- en: Email [*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com) to comment
    or ask technical questions about this book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件至[*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com)以评论或询问有关本书的技术问题。
- en: For news and information about our books and courses, visit [*https://oreilly.com*](https://oreilly.com).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解有关我们图书和课程的新闻和信息，请访问[*https://oreilly.com*](https://oreilly.com)。
- en: 'Find us on LinkedIn: [*https://linkedin.com/company/oreilly-media*](https://linkedin.com/company/oreilly-media)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在LinkedIn上找到我们：[*https://linkedin.com/company/oreilly-media*](https://linkedin.com/company/oreilly-media)
- en: 'Follow us on Twitter: [*https://twitter.com/oreillymedia*](https://twitter.com/oreillymedia)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twitter上关注我们：[*https://twitter.com/oreillymedia*](https://twitter.com/oreillymedia)
- en: 'Watch us on YouTube: [*https://www.youtube.com/oreillymedia*](https://www.youtube.com/oreillymedia)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在YouTube上关注我们：[*https://www.youtube.com/oreillymedia*](https://www.youtube.com/oreillymedia)
- en: Acknowledgments
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 致谢
- en: I want to thank my wife Silke who by now even knows what patterns are :-) and
    I want to thank my daughter Ylvi. They both make my life happier, and they both
    make sure that I don’t end up sitting in front of my computer working all the
    time, but that I instead enjoy life.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我要感谢我的妻子Silke，她现在甚至知道什么是模式 :-) 我也要感谢我的女儿Ylvi。她们两个让我的生活更加幸福，也确保我不会整天坐在电脑前工作，而是享受生活。
- en: 'This book would not have come to life without the help of many pattern enthusiasts.
    I want to thank all the participants of Writers’ Workshops at the European Conference
    on Pattern Languages of Programs for providing me with feedback on the patterns.
    In particular, I want to thank the following people, who provided me with very
    helpful feedback during the so-called shepherding process of that conference:
    Jari Rauhamäki, Tobias Rauter, Andrea Höller, James Coplien, Uwe Zdun, Thomas
    Raser, Eden Burton, Claudius Link, Valentino Vranić, and Sumit Kalra. Special
    thanks also to my work colleagues, in particular to Thomas Havlovec, who made
    sure that I got the C programming details in my patterns right. Robert Hanmer,
    Michael Weiss, David Griffiths, and Thomas Krug spent a lot of time for reviewing
    this book and provided me with additional ideas how to improve it—thank you very
    much! Thanks also to the whole team at O’Reilly who helped me a lot in making
    this book happen. In particular, I want to thank my development editor, Corbin
    Collins, and my production editor, Jonathon Owen.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书得益于许多模式爱好者的帮助而得以问世。我要感谢所有参与欧洲程序模式语言会议作家工作坊的参与者，他们为我的模式提供了反馈。特别感谢以下人员，在会议的指导过程中提供了非常有帮助的反馈：Jari
    Rauhamäki, Tobias Rauter, Andrea Höller, James Coplien, Uwe Zdun, Thomas Raser,
    Eden Burton, Claudius Link, Valentino Vranić, 和 Sumit Kalra。特别感谢我的工作同事，尤其是Thomas
    Havlovec，他确保我在模式中正确理解了C编程的细节。Robert Hanmer, Michael Weiss, David Griffiths, 和
    Thomas Krug花了很多时间审查这本书，并为我提供了改进的额外想法——非常感谢！同时也感谢O'Reilly团队的所有成员，在这本书的问世过程中给予了我很多帮助。特别要感谢我的开发编辑Corbin
    Collins和制作编辑Jonathon Owen。
- en: The content of this book is based on the following papers that were accepted
    at the European Conference on Pattern Languages of Programs and published with
    ACM. These papers can be accessed for free at the website [*http://www.preschern.com*](http://www.preschern.com).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的内容基于以下论文，这些论文在欧洲程序模式语言会议上被接受并由ACM出版。这些论文可以在网站[*http://www.preschern.com*](http://www.preschern.com)上免费获取。
- en: '“A Pattern Story About C Programming,” EuroPLoP ’21: 26th European Conference
    on Pattern Languages of Programs, July 2015, article no. 53, 1–10, [*https://dl.acm.org/doi/10.1145/3489449.3489978*](https://dl.acm.org/doi/10.1145/3489449.3489978).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “一个关于C编程的模式故事”，EuroPLoP ’21：程序模式语言欧洲会议第26届，2015年7月，文章编号53，1–10，[*https://dl.acm.org/doi/10.1145/3489449.3489978*](https://dl.acm.org/doi/10.1145/3489449.3489978)。
- en: '“Patterns for Organizing Files in Modular C Programs,” EuroPLoP ’20: Proceedings
    of the European Conference on Pattern Languages of Programs, July 2020, article
    no. 1, 1–15, [*https://dl.acm.org/doi/10.1145/3424771.3424772*](https://dl.acm.org/doi/10.1145/3424771.3424772).'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “模块化C程序中的文件组织模式”，EuroPLoP ’20：程序模式语言欧洲会议论文集，2020年7月，文章编号1，1–15，[*https://dl.acm.org/doi/10.1145/3424771.3424772*](https://dl.acm.org/doi/10.1145/3424771.3424772)。
- en: '“Patterns to Escape the #ifdef Hell,” EuroPLop ’19: Proceedings of the 24th
    European Conference on Pattern Languages of Programs, July 2019, article no. 2,
    1–12, [*https://dl.acm.org/doi/10.1145/3361149.3361151*](https://dl.acm.org/doi/10.1145/3361149.3361151).'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “摆脱#ifdef地狱的模式”，EuroPLoP ’19：程序模式语言欧洲会议第24届论文集，2019年7月，文章编号2，1–12，[*https://dl.acm.org/doi/10.1145/3361149.3361151*](https://dl.acm.org/doi/10.1145/3361149.3361151)。
- en: '“Patterns for Returning Error Information in C,” EuroPLop ’19: Proceedings
    of the 24th European Conference on Pattern Languages of Programs, July 2019, article
    no. 3, 1–14, [*https://dl.acm.org/doi/10.1145/3361149.3361152*](https://dl.acm.org/doi/10.1145/3361149.3361152).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在C中返回错误信息的模式”，EuroPLoP ’19：程序模式语言欧洲会议第24届论文集，2019年7月，文章编号3，1–14，[*https://dl.acm.org/doi/10.1145/3361149.3361152*](https://dl.acm.org/doi/10.1145/3361149.3361152)。
- en: '“Patterns for Returning Data from C Functions,” EuroPLop ’19: Proceedings of
    the 24th European Conference on Pattern Languages of Programs, July 2019, article
    no. 37, 1–13, [*https://dl.acm.org/doi/10.1145/3361149.3361188*](https://dl.acm.org/doi/10.1145/3361149.3361188).'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “从C函数返回数据的模式”，EuroPLoP ’19：程序模式语言欧洲会议第24届论文集，2019年7月，文章编号37，1–13，[*https://dl.acm.org/doi/10.1145/3361149.3361188*](https://dl.acm.org/doi/10.1145/3361149.3361188)。
- en: '“C Patterns on Data Lifetime and Ownership,” EuroPLop ’19: Proceedings of the
    24th European Conference on Pattern Languages of Programs, July 2019, article
    no. 36, 1–13, [*https://dl.acm.org/doi/10.1145/3361149.3361187*](https://dl.acm.org/doi/10.1145/3361149.3361187).'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “C 中关于数据生命周期和所有权的模式”，EuroPLoP ’19：《程序模式的第24届欧洲会议论文集》，2019年7月，文章编号36，1–13，[*https://dl.acm.org/doi/10.1145/3361149.3361187*](https://dl.acm.org/doi/10.1145/3361149.3361187)。
- en: '“Patterns for C Iterator Interfaces,” EuroPLoP ’17: Proceedings of the 22nd
    European Conference on Pattern Languages of Programs, July 2017, article no. 8,
    1–14, [*https://dl.acm.org/doi/10.1145/3147704.3147714*](https://dl.acm.org/doi/10.1145/3147704.3147714).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “C 迭代器接口的模式”，EuroPLoP ’17：《程序模式的第22届欧洲会议论文集》，2017年7月，文章编号8，1–14，[*https://dl.acm.org/doi/10.1145/3147704.3147714*](https://dl.acm.org/doi/10.1145/3147704.3147714)。
- en: '“API Patterns in C,” EuroPlop ’16: Proceedings of the 21st European Conference
    on Pattern Languages of Programs, July 2016, article no. 7, 1–11, [*https://dl.acm.org/doi/10.1145/3011784.3011791*](https://dl.acm.org/doi/10.1145/3011784.3011791).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “C 中的 API 模式”，EuroPlop ’16：《程序模式的第21届欧洲会议论文集》，2016年7月，文章编号7，1–11，[*https://dl.acm.org/doi/10.1145/3011784.3011791*](https://dl.acm.org/doi/10.1145/3011784.3011791)。
- en: '“Idioms for Error Handling in C,” EuroPLoP ’15: Proceedings of the 20th European
    Conference on Pattern Languages of Programs, July 2015, article no. 53, 1–10,
    [*https://dl.acm.org/doi/10.1145/2855321.2855377*](https://dl.acm.org/doi/10.1145/2855321.2855377).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “C 中的错误处理惯用语”，EuroPLoP ’15：《程序模式的第20届欧洲会议论文集》，2015年7月，文章编号53，1–10，[*https://dl.acm.org/doi/10.1145/2855321.2855377*](https://dl.acm.org/doi/10.1145/2855321.2855377)。
