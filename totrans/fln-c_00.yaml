- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You picked up this book to move your programming skills one step forward. That
    is good, because you’ll definitely benefit from the hands-on knowledge provided
    in this book. If you have a lot of experience programming in C, you’ll learn the
    details of good design decisions and about their benefits and drawbacks. If you
    are fairly new to C programming, you’ll find guidance about design decisions,
    and you’ll see how these decisions are applied bit by bit to running code examples
    for building larger scale programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The book answers questions such as how to structure a C program, how to cope
    with error handling, or how to design flexible interfaces. As you learn more about
    C programming, questions often pop up, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Should I return any error information I have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should I use the global variable `errno` to do that?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should I have few functions with many parameters or the other way around?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I build a flexible interface?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I build basic things like an iterator?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For object-oriented languages, most of these questions are answered to a great
    extent by the Gang of Four book *Design Patterns: Elements of Reusable Object-Oriented
    Software* by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Prentice
    Hall, 1997). Design patterns provide a programmer with best practices on how objects
    should interact and which object owns which other kinds of objects. Also, design
    patterns show how such objects can be grouped together.'
  prefs: []
  type: TYPE_NORMAL
- en: However, for procedural programming languages like C, most of these design patterns
    cannot be implemented in the way described by the Gang of Four. There are no native
    object-oriented mechanisms in C. It is possible to emulate inheritance or polymorphism
    in the C programming language, but that might not be the first choice, because
    such emulation makes things unfamiliar for programmers who are used to programming
    C and are not used to programming with object-oriented languages like C++ and
    using concepts like inheritance and polymorphism. Such programmers may want to
    stick to their native C programming style that they are used to. However, with
    the native C programming style, not all object-oriented design patterns guidance
    is usable, or at least the specific implementation of the idea presented in a
    design pattern is not provided for non-object-oriented programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is where we stand: we want to program in C, but we cannot directly
    use most of the knowledge documented in design patterns. This book shows how to
    bridge this gap and implement hands-on design knowledge for the C programming
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: Why I Wrote This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me tell you why the knowledge gathered in this book turned out to be very
    important for me and why such knowledge is hard to find.
  prefs: []
  type: TYPE_NORMAL
- en: In school I learned C programming as my first programming language. Just like
    every new C programmer, I wondered why arrays start with index 0, and I first
    rather randomly tried out how to place the operators `*` and `&` in order to finally
    get the C pointer magic working.
  prefs: []
  type: TYPE_NORMAL
- en: 'At university I learned how C syntax actually works and how it translates to
    bits and bytes on the hardware. With that knowledge I was able to write small
    programs that worked very well. However, I still had trouble understanding why
    longer code looked the way it did, and I certainly wouldn’t have come up with
    solutions like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at code like that prompted many questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Why have function pointers in the `struct`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do the functions need that `DRIVER_HANDLE`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an IOCTL, and why would I not have separate functions instead?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why have explicit create and destroy functions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These questions came up as I began writing industrial applications. I regularly
    came across situations where I realized I did not have the C programming knowledge,
    for example, to decide how to implement an iterator or to decide how to cope with
    error handling in my functions. I realized that although I knew C syntax, I had
    no clue how to apply it. I tried to achieve something but just managed to do it
    in a clumsy way or not at all. What I needed were best practices on how to achieve
    specific tasks with the C programming language. For example, I needed to know
    things like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How can I acquire and release resources in an easy way?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it a good idea to use `goto` for error handling?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should I design my interface to be flexible, or should I simply change it when
    the need arises?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should I use an `assert` statement, or should I return an error code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is an iterator implemented in C?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was very interesting for me to realize that while my experienced work colleagues
    had many different answers for these questions, nobody could point me to anything
    that documented these design decisions and their benefits and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'So next I turned to the internet, and yet again I was surprised: it was very
    hard to find sound answers to these questions even though the C programming language
    has been around for decades. I found out that while there is much literature on
    the C programming language basics and its syntax, there’s not much on advanced
    C programming topics or how to write beautiful C code that holds up to industrial
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: And that is exactly where this book comes in. This book teaches you how to advance
    your programming skills from writing basic C programs to writing larger-scale
    C programs that consider error handling and that are flexible regarding certain
    future changes in requirements and design. This book uses the concept of design
    patterns to provide you bit by bit with design decisions and their benefits and
    drawbacks. These design patterns are applied to running code examples that teach
    you how code like the earlier example evolves and why it ends up looking the way
    it does.
  prefs: []
  type: TYPE_NORMAL
- en: The presented patterns can be applied to any C programming domains. As I come
    from the domain of embedded programming in a multithreaded real-time environment,
    some of the patterns are biased towards that domain. Anyways, you’ll see that
    the general idea of the patterns can be applied to other C programming domains
    and even beyond the scope of C programming.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The design guidance in this book is provided in the form of patterns. The idea
    of presenting knowledge and best practices in the form of patterns comes from
    the architect Christopher Alexander in *The Timeless Way of Building* (Oxford
    University Press, 1979). He uses small pieces of well-proven solutions to tackle
    a huge problem in his domain: how to design and construct cities. The approach
    of applying patterns was adopted by the software development domain, where pattern
    conferences like the conference on Pattern Languages of Programs (PLoP) are held
    to extend the body of knowledge of patterns. In particular, the book *Design Patterns:
    Elements of Reusable Object-Oriented Software* by the Gang of Four (Prentice Hall,
    1997) had a significant impact and made the concept of design patterns well known
    to software developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what exactly is a pattern? There are many definitions out there, and if
    you are deeply interested in the topic, then the book *Pattern-Oriented Software
    Architecture: On Patterns and Pattern Languages* by Frank Buschmann et al. (Wiley,
    2007) can provide you with accurate descriptions and details. For the purposes
    of this book, a pattern provides a well-proven solution to a real-life problem.
    The patterns presented in this book have the structure shown in [Table P-1](#tab_pattern_sections).'
  prefs: []
  type: TYPE_NORMAL
- en: Table P-1\. How patterns are broken down in this book
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern section | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Name | This is the name of the pattern, which should be easy to remember.
    The aim is that this name will be used by programmers in their everyday language
    (as is the case with the Gang of Four patterns, where you hear programmers say,
    “And the Abstract Factory creates the object”). Pattern names are capitalized
    in this book. |'
  prefs: []
  type: TYPE_TB
- en: '| Context | The context section sets the scene for the pattern. It tells you
    under which circumstances this pattern can be applied. |'
  prefs: []
  type: TYPE_TB
- en: '| Problem | The problem section gives you information about the issue you want
    to tackle. It starts with the major problem statement written in bold font type
    and then adds details on why the problem is hard to solve. (In other pattern formats,
    these details go into a separate section called “forces.”) |'
  prefs: []
  type: TYPE_TB
- en: '| Solution | This section provides guidance on how to tackle the problem. It
    starts with stating the main idea of the solution written in bold font type and
    continues with details about the solution. It also provides a code example in
    order to give very concrete guidance. |'
  prefs: []
  type: TYPE_TB
- en: '| Consequences | This section lists the benefits and drawbacks of applying
    the described solution. When applying a pattern, you should always confirm that
    the consequences that arise are OK with you. |'
  prefs: []
  type: TYPE_TB
- en: '| Known uses | The known uses give you evidence that the proposed solution
    is good and actually works in real-life applications. They also show you concrete
    examples to help you understand how to apply the pattern. |'
  prefs: []
  type: TYPE_TB
- en: A major benefit of presenting design guidance in the form of patterns is that
    these patterns can be applied one after another. If you have a huge design problem,
    it’s hard to find the one guidance document and the one solution that addresses
    exactly that problem. Instead, you can think of your huge and very specific problem
    as a sum of many smaller and more generic problems, and you can tackle these problems
    bit by bit by applying one pattern after the other. You simply check the problem
    descriptions of the patterns and apply the one that fits your problem and that
    has consequences you can live with. These consequences might lead to another problem
    that you can then address by applying another pattern. That way you incrementally
    design your code instead of trying to come up with a complete up-front design
    before even writing the first line of code.
  prefs: []
  type: TYPE_NORMAL
- en: How to Read This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should already know C programming basics. You should know the C syntax and
    how it works—for example, this book won’t teach you what a pointer is or how to
    use it. This book delivers hints and guidance on advanced topics.
  prefs: []
  type: TYPE_NORMAL
- en: The chapters in this book are self-standing. You can read them in an arbitrary
    order, and you can simply pick out the topics you are interested in. You’ll find
    an overview of all patterns in the next section, and from there you can jump to
    the patterns you are interested in. So if you know exactly what you are looking
    for, you can start right there.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not looking for one particular pattern, but instead want to get an
    overview of possible C design options, read through [Part I](part01.xhtml#part_1)
    of the book. Each chapter there focuses on a particular topic, starting with basic
    topics like error handling and memory managment, and then moving to more advanced
    and specific topics like interface design or platform-independent code. The chapters
    each present patterns related to that topic and a running code example that shows
    bit by bit how the patterns can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[Part II](part02.xhtml#part_2) of this book shows two larger running examples
    that apply many of the patterns from [Part I](part01.xhtml#part_1). Here you can
    learn how to build up some larger piece of software bit by bit through the application
    of patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll find an overview of all patterns presented in this book in Tables [P-2](#tab1a)
    through [P-10](#tab1i). The tables show a short form of the patterns that only
    contains a brief description of the core problem, followed by the keyword “Therefore,”
    followed by the core solution.
  prefs: []
  type: TYPE_NORMAL
- en: Table P-2\. Patterns for error handling
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Function Split”](ch01.xhtml#pattern_function_split) | The function has
    several responsibilities, which makes the function hard to read and maintain.
    Therefore, split it up. Take a part of a function that seems useful on its own,
    create a new function with that, and call that function. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Guard Clause”](ch01.xhtml#pattern_guard_clause) | The function is hard
    to read and maintain because it mixes pre-condition checks with the main program
    logic of the function. Therefore, check if you have mandatory pre-conditions,
    and immediately return from the function if these pre-conditions are not met.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [“Samurai Principle”](ch01.xhtml#pattern_samurai_principle) | When returning
    error information, you assume that the caller checks for this information. However,
    the caller can simply omit this check and the error might go unnoticed. Therefore,
    return from a function victorious or not at all. If there is a situation for which
    you know that an error cannot be handled, then abort the program. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Goto Error Handling”](ch01.xhtml#pattern_goto) | Code gets difficult to
    read and maintain if it acquires and cleans up multiple resources at different
    places within a function. Therefore, have all resource cleanup and error handling
    at the end of the function. If a resource cannot be acquired, use the `goto` statement
    to jump to the resource cleanup code. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Cleanup Record”](ch01.xhtml#pattern_cleanup_record) | It is difficult to
    make a piece of code easy to read and maintain if this code acquires and cleans
    up multiple resources, particularly if those resources depend on one another.
    Therefore, call resource acquisition functions as long as they succeed, and store
    which functions require cleanup. Call the cleanup functions depending on these
    stored values. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Object-Based Error Handling”](ch01.xhtml#pattern_object_based_error_handling)
    | Having multiple responsibilities in one function, such as resource acquisition,
    resource cleanup, and usage of that resource, makes that code difficult to implement,
    read, maintain, and test. Therefore, put initialization and cleanup into separate
    functions, similar to the concept of constructors and destructors in object-oriented
    programming. |'
  prefs: []
  type: TYPE_TB
- en: Table P-3\. Patterns for returning error information
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Return Status Codes”](ch02.xhtml#pattern_return_error_codes) | You want
    to have a mechanism to return status information to the caller, so that the caller
    can react to it. You want the mechanism to be simple to use, and the caller should
    be able to clearly distinguish between different error situations that could occur.
    Therefore, use the Return Value of a function to return status information. Return
    a value that represents a specific status. Both of you as the callee and the caller
    must have a mutual understanding of what the value means. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Return Relevant Errors”](ch02.xhtml#pattern_return_relevant_errors) | On
    the one hand, the caller should be able to react to errors; on the other hand,
    the more error information you return, the more your code and the code of your
    caller have to deal with error handling, which makes the code longer. Longer code
    is harder to read and maintain and brings in the risk of additional bugs. Therefore,
    only return error information to the caller if that information is relevant to
    the caller. Error information is only relevant to the caller if the caller can
    react to that information. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Special Return Values”](ch02.xhtml#pattern_special_return_values) | You
    want to return error information, but it’s not an option to explicitly Return
    Status Codes because that implies that you cannot use the Return Value of the
    function to return other data. You’d have to return that data via Out-Parameters,
    which would make calling your function more difficult. Therefore, use the Return
    Value of your function to return the data computed by the function. Reserve one
    or more special values to be returned if an error occurs. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Log Errors”](ch02.xhtml#pattern_log_errors) | You want to make sure that
    in case of an error you can easily find out its cause. However, you don’t want
    your error-handling code to become complicated because of this. Therefore, use
    different channels to provide error information that is relevant for the calling
    code and error information that is relevant for the developer. For example, write
    debug error information into a log file and don’t return the detailed debug error
    information to the caller. |'
  prefs: []
  type: TYPE_TB
- en: Table P-4\. Patterns for memory management
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Stack First”](ch03.xhtml#pattern_stack_first) | Deciding the storage class
    and memory section (stack, heap, …) for variables is a decision every programmer
    has to make often. It gets exhausting if for each and every variable, the pros
    and cons of all possible alternatives have to be considered in detail. Therefore,
    simply put your variables on the stack by default to profit from automatic cleanup
    of stack variables. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Eternal Memory”](ch03.xhtml#pattern_eternal_memory) | Holding large amounts
    of data and transporting it between function calls is difficult because you have
    to make sure that the memory for the data is large enough and that the lifetime
    extends across your function calls. Therefore, put your data into memory that
    is available throughout the whole lifetime of your program. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Lazy Cleanup”](ch03.xhtml#pattern_screw_freeing) | Having dynamic memory
    is required if you need large amounts of memory and memory where you don’t know
    the required size beforehand. However, handling cleanup of dynamic memory is a
    hassle and is the source of many programming errors. Therefore, allocate dynamic
    memory and let the operating system cope with deallocation by the end of your
    program. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Dedicated Ownership”](ch03.xhtml#pattern_dedicated_ownership) | The great
    power of using dynamic memory comes with the great responsibility of having to
    properly clean that memory up. In larger programs, it becomes difficult to make
    sure that all dynamic memory is cleaned up properly. Therefore, right at the time
    when you implement memory allocation, clearly define and document where it’s going
    to be cleaned up and who is going to do that. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Allocation Wrapper”](ch03.xhtml#pattern_allocation_wrapper) | Each allocation
    of dynamic memory might fail, so you should check allocations in your code to
    react accordingly. This is cumbersome because you have many places for such checks
    in your code. Therefore, wrap the allocation and deallocation calls, and implement
    error handling or additional memory management organization in these wrapper functions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [“Pointer Check”](ch03.xhtml#pattern_pointer_check) | Programming errors
    that lead to accessing an invalid pointer cause uncontrolled program behavior,
    and such errors are difficult to debug. However, because your code works with
    pointers frequently, there is a good chance that you have introduced such programming
    errors. Therefore, explicitly invalidate uninitialized or freed pointers and always
    check pointers for validity before accessing them. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Memory Pool”](ch03.xhtml#pattern_memory_pool) | Frequently allocating and
    deallocating objects from the heap leads to memory fragmentation. Therefore, hold
    a large piece of memory throughout the whole lifetime of your program. At runtime,
    retrieve fixed-size chunks of that memory pool instead of directly allocating
    new memory from the heap. |'
  prefs: []
  type: TYPE_TB
- en: Table P-5\. Patterns for returning data from C functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Return Value”](ch04.xhtml#pattern_return_value) | The function parts you
    want to split are not independent from one another. As usual in procedural programming,
    some part delivers a result that is then needed by some other part. The function
    parts that you want to split need to share some data. Therefore, simply use the
    one C mechanism intended to retrieve information about the result of a function
    call: the Return Value. The mechanism to return data in C copies the function
    result and provides the caller access to this copy. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Out-Parameters”](ch04.xhtml#pattern_out_parameters) | C only supports returning
    a single type from a function call, and that makes it complicated to return multiple
    pieces of information. Therefore, return all the data with a single function call
    by emulating by-reference arguments with pointers. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Aggregate Instance”](ch04.xhtml#pattern_aggregate_instance) | C only supports
    returning a single type from a function call, and that makes it complicated to
    return multiple pieces of information. Therefore, put all data that is related
    into a newly defined type. Define this Aggregate Instance to contain all the related
    data that you want to share. Define it in the interface of your component to let
    the caller directly access all the data stored in the instance. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Immutable Instance”](ch04.xhtml#pattern_immutable_instance) | You want
    to provide information held in large pieces of immutable data from your component
    to a caller. Therefore, have an instance (for example, a `struct`) containing
    the data to share in static memory. Provide this data to users who want to access
    it and make sure that they cannot modify it. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Caller-Owned Buffer”](ch04.xhtml#pattern_caller_owned_buffer) | You want
    to provide complex or large data of known size to the caller, and that data is
    not immutable (it changes at runtime). Therefore, require the caller to provide
    a buffer and its size to the function that returns the large, complex data. In
    the function implementation, copy the required data into the buffer if the buffer
    size is large enough. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Callee Allocates”](ch04.xhtml#pattern_callee_allocates) | You want to provide
    complex or large data of unknown size to the caller, and that data is not immutable
    (it changes at runtime). Therefore, allocate a buffer with the required size inside
    the function that provides the large, complex data. Copy the required data into
    the buffer and return a pointer to that buffer. |'
  prefs: []
  type: TYPE_TB
- en: Table P-6\. Patterns for data lifetime and ownership
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Stateless Software-Module”](ch05.xhtml#pattern_stateless_software_module)
    | You want to provide logically related functionality to your caller and make
    that functionality as easy as possible for the caller to use. Therefore, keep
    your functions simple and don’t build up state information in your implementation.
    Put all related functions into one header file and provide the caller this interface
    to your software-module. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Software-Module with Global State”](ch05.xhtml#pattern_software_module_with_global_state)
    | You want to structure your logically related code that requires common state
    information and make that functionality as easy as possible for the caller to
    use. Therefore, have one global instance to let your related functions share common
    resources. Put all functions that operate on this instance into one header file,
    and provide the caller this interface to your software-module. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Caller-Owned Instance”](ch05.xhtml#pattern_caller_owned_instance) | You
    want to provide multiple callers or threads access to functionality with functions
    that depend on one another, and the interaction of the caller with your functions
    builds up state information. Therefore, require the caller to pass an instance,
    which is used to store resource and state information, along to your functions.
    Provide explicit functions to create and destroy these instances, so that the
    caller can determine their lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Shared Instance”](ch05.xhtml#pattern_shared_instance) | You want to provide
    multiple callers or threads access to functionality with functions that depend
    on one another, and the interaction of the caller with your functions builds up
    state information, which your callers want to share. Therefore, require the caller
    to pass an instance, which is used to store resource and state information, along
    to your functions. Use the same instance for multiple callers and keep the ownership
    of that instance in your software-module. |'
  prefs: []
  type: TYPE_TB
- en: Table P-7\. Patterns for flexible APIs
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Header Files”](ch06.xhtml#pattern_header_files) | You want functionality
    that you implement to be accessible to code from other implementation files, but
    you want to hide your implementation details from the caller. Therefore, provide
    function declarations in your API for any functionality you want to provide to
    your user. Hide any internal functions, internal data, and your function definitions
    (the implementations) in your implementation file and don’t provide this implementation
    file to the user. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Handle”](ch06.xhtml#pattern_handle) | You have to share state information
    or operate on shared resources in your function implementations, but you don’t
    want your caller to see or even access all that state information and shared resources.
    Therefore, have a function to create the context on which the caller operates
    and return an abstract pointer to internal data for that context. Require the
    caller to pass that pointer to all your functions, which can then use the internal
    data to store state information and resources. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Dynamic Interface”](ch06.xhtml#pattern_dynamic_interface) | It should be
    possible to call implementations with slightly deviating behaviors, but it should
    not be necessary to duplicate any code, not even the control logic implementation
    and interface declaration. Therefore, define a common interface for the deviating
    functionalities in your API and require the caller to provide a callback function
    for that functionality, which you then call in your function implementation. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Function Control”](ch06.xhtml#pattern_function_control) | You want to call
    implementations with slightly deviating behaviors, but you don’t want to duplicate
    any code, not even the control logic implementation or the interface declaration.
    Therefore, add a parameter to your function that passes meta-information about
    the function call and that specifies the actual functionality to be performed.
    |'
  prefs: []
  type: TYPE_TB
- en: Table P-8\. Patterns for flexible iterator interfaces
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Index Access”](ch07.xhtml#pattern_index_access) | You want to make it possible
    for the user to iterate elements in your data structure in a convenient way, and
    it should be possible to change internals of the data structure without resulting
    in changes to the user’s code. Therefore, provide a function that takes an index
    to address the element in your underlying data structure and return the content
    of this element. The user calls this function in a loop to iterate over all elements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [“Cursor Iterator”](ch07.xhtml#pattern_cursor_iterator) | You want to provide
    an iteration interface to your user which is robust in case the elements change
    during the iteration and which enables you to change the underlying data structure
    at a later point without requiring any changes to the user’s code. Therefore,
    create an iterator instance that points to an element in the underlying data structure.
    An iteration function takes this iterator instance as argument, retrieves the
    element the iterator currently points to, and modifies the iteration instance
    to point to the next element. The user then iteratively calls this function to
    retrieve one element at a time. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Callback Iterator”](ch07.xhtml#pattern_callback_iterator) | You want to
    provide a robust iteration interface which does not require the user to implement
    a loop in the code for iterating over all elements and which enables you to change
    the underlying data structure at a later point without requiring any changes to
    the user’s code. Therefore, use your existing data structure—specific operations
    to iterate over all your elements within your implementation, and call some provided
    user-function on each element during this iteration. This user-function gets the
    element content as a parameter and can then perform its operations on this element.
    The user calls just one function to trigger the iteration, and the whole iteration
    takes place inside your implementation. |'
  prefs: []
  type: TYPE_TB
- en: Table P-9\. Patterns for organizing files in modular programs
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Include Guard”](ch08.xhtml#pattern_include_guard) | It’s easy to include
    a header file multiple times, but including the same header file leads to compile
    errors if types or certain macros are part of it, because during compilation they
    get redefined. Therefore, protect the content of your header files against multiple
    inclusion so that the developer using the header files does not have to care whether
    it is included multiple times. Use an interlocked `#ifdef` statement or a `#pragma
    once` statement to achieve this. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Software-Module Directories”](ch08.xhtml#pattern_software_module_directories)
    | Splitting code into different files increases the number of files in your codebase.
    Having all files in one directory makes it difficult to keep an overview of all
    the files, particularly for large codebases. Therefore, put header files and implementation
    files that belong to a tightly coupled functionality into one directory. Name
    that directory after the functionality that is provided via the header files.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [“Global Include Directory”](ch08.xhtml#pattern_global_include_directory)
    | To include files from other software-modules, you have to use relative paths
    like *../othersoftwaremodule/file.h*. You have to know the exact location of the
    other header file. Therefore, have one global directory in your codebase that
    contains all software-module APIs. Add this directory to the global include paths
    in your toolchain. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Self-Contained Component”](ch08.xhtml#pattern_self_contained_component)
    | From the directory structure it is not possible to see the dependencies in the
    code. Any software-module can simply include the header files from any other software-module,
    so it’s impossible to check dependencies in the code via the compiler. Therefore,
    identify software-modules that contain similar functionality and that should be
    deployed together. Put these software-modules into a common directory and have
    a designated subdirectory for their header files that are relevant for the caller.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [“API Copy”](ch08.xhtml#pattern_api_copy) | You want to develop, version,
    and deploy the parts of your codebase independently from one another. However,
    to do that, you need clearly defined interfaces between the code parts and the
    ability to separate that code into different repositories. Therefore, to use the
    functionality of another component, copy its API. Build that other component separately
    and copy the build artifacts and its public header files. Put these files into
    a directory inside your component and configure that directory as a global include
    path. |'
  prefs: []
  type: TYPE_TB
- en: Table P-10\. Patterns for escaping `#ifdef` hell
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Summary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [“Avoid Variants”](ch09.xhtml#pattern_avoid_variants) | Using different functions
    for each platform makes the code harder to read and write. The programmer is required
    to initially understand, correctly use, and test these multiple functions in order
    to achieve a single functionality across multiple platforms. Therefore, use standardized
    functions that are available on all platforms. If there are no standardized functions,
    consider not implementing the functionality. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Isolated Primitives”](ch09.xhtml#pattern_isolate_primitives) | Having code
    variants organized with `#ifdef` statements makes the code unreadable. It is very
    difficult to follow the program flow, because it is implemented multiple times
    for multiple platforms. Therefore, isolate your code variants. In your implementation
    file, put the code handling the variants into separate functions and call these
    functions from your main program logic, which then contains only platform-independent
    code. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Atomic Primitives”](ch09.xhtml#pattern_atomic_primitives) | The function
    that contains the variants and is called by the main program is still hard to
    comprehend because all the complex `#ifdef` code was only put into this function
    in order to get rid of it in the main program. Therefore, make your primitives
    atomic. Only handle exactly one kind of variant per function. If you handle multiple
    kinds of variants, for example, operating system variants and hardware variants,
    then have separate functions for that. |'
  prefs: []
  type: TYPE_TB
- en: '| [“Abstraction Layer”](ch09.xhtml#pattern_abstraction_layer) | You want to
    use the functionality which handles platform variants at several places in your
    codebase, but you do not want to duplicate the code of that functionality. Therefore,
    provide an API for each functionality that requires platform-specific code. Define
    only platform-independent functions in the header file and put all platform-specific
    `#ifdef` code into the implementation file. The caller of your functions includes
    only your header file and does not have to include any platform-specific files.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [“Split Variant Implementations”](ch09.xhtml#pattern_split_implementation_variants)
    | The platform-specific implementations still contain `#ifdef` statements to distinguish
    between code variants. That makes it difficult to see and select which part of
    the code should be built for which platform. Therefore, put each variant implementation
    into a separate implementation file and select per file what you want to compile
    for which platform. |'
  prefs: []
  type: TYPE_TB
- en: Conventions Used in This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following typographical conventions are used in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Italic*'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates new terms, URLs, email addresses, filenames, and file extensions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bold**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to highlight the problem and solution for each pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '`Constant width`'
  prefs: []
  type: TYPE_NORMAL
- en: Used for program listings, as well as within paragraphs to refer to program
    elements such as variable or function names, databases, data types, environment
    variables, statements, and keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This element signifies a general note.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This element indicates a warning or caution.
  prefs: []
  type: TYPE_NORMAL
- en: Using Code Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this book show short code snippets which focus on the core
    idea to showcase the patterns and their application. The code snippets by themselves
    won’t compile, because to keep it simple several things are omitted (for example,
    include files). If you are interested in getting the full code which does compile,
    you can download it from GitHub at [*https://github.com/christopher-preschern/fluent-c*](https://github.com/christopher-preschern/fluent-c).
  prefs: []
  type: TYPE_NORMAL
- en: If you have a technical question or a problem using the code examples, please
    send email to [*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com).
  prefs: []
  type: TYPE_NORMAL
- en: This book is here to help you get your job done. In general, if example code
    is offered with this book, you may use it in your programs and documentation.
    You do not need to contact us for permission unless you’re reproducing a significant
    portion of the code. For example, writing a program that uses several chunks of
    code from this book does not require permission. Selling or distributing examples
    from O’Reilly books does require permission. Answering a question by citing this
    book and quoting example code does not require permission. Incorporating a significant
    amount of example code from this book into your product’s documentation does require
    permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'We appreciate, but generally do not require, attribution. An attribution usually
    includes the title, author, publisher, and ISBN. For example: “*Fluent C* by Christopher
    Preschern (O’Reilly). Copyright 2023 Christopher Preschern, 978-1-492-09733-4.”'
  prefs: []
  type: TYPE_NORMAL
- en: If you feel your use of code examples falls outside fair use or the permission
    given above, feel free to contact us at [*permissions@oreilly.com*](mailto:permissions@oreilly.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The patterns in this book all present existing code examples which apply these
    patterns. The following list shows the references to these code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The game NetHack](https://oreil.ly/nzO5W)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenWrt Project](https://oreil.ly/qeppo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenSSL library](https://oreil.ly/zzsMO)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wireshark network sniffer](https://oreil.ly/M55B5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Portland Pattern repository](https://oreil.ly/wkZzb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Git version control system](https://oreil.ly/7F9Oz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Apache Portable Runtime](https://oreil.ly/ysaM6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Apache Webserver](https://oreil.ly/W6SMn)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B&R Automation Runtime operating system (proprietary and undisclosed code of
    the company B&R Industrial Automation GmbH)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B&R Visual Components automation system visualization editor (proprietary and
    undisclosed code of the company B&R Industrial Automation GmbH)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NetDRMS data management system](https://oreil.ly/eR0EV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MATLAB programming and numeric computing platform](https://oreil.ly/UpvJK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GLib library](https://oreil.ly/QoUwT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GoAccess real-time web analyzer](https://oreil.ly/L1Eij)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cloudy physical calculation software](https://oreil.ly/phLBb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GNU Compiler Collection (GCC)](https://oreil.ly/KK4jY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MySQL database system](https://oreil.ly/YKXxs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Android ION memory manager](https://oreil.ly/2JV7h)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows API](https://oreil.ly/nnzyX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Apple’s Cocoa API](https://oreil.ly/sQuaI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[VxWorks real-time operating system](https://oreil.ly/UMUaj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sam text editor](https://oreil.ly/k3SQI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C standard library functions: glibc implementation](https://oreil.ly/9Qr95)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Subversion project](https://oreil.ly/sg9sz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Netdata real-time performance monitoring and visualization system](https://oreil.ly/1sDZz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nmap network tool](https://oreil.ly/8Yz5R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenZFS file system](https://oreil.ly/VWeQL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RIOT operating system](https://oreil.ly/LhZM4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Radare reverse engineering framework](https://oreil.ly/TUYfh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Education First digital learning products](https://www.ef.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[VIM text editor](https://github.com/vim/vim)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GNUplot graphing utility](https://oreil.ly/PlQPj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQLite database engine](https://oreil.ly/5Knfz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[gzip data compression program](https://oreil.ly/it40Z)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[lighttpd web server](https://github.com/lighttpd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[U-Boot bootloader](https://oreil.ly/IKVYV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Smpl discrete event simulation system](https://oreil.ly/NJnCH)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nokia’s Maemo platform](https://oreil.ly/RwDtt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O’Reilly Online Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For more than 40 years, [*O’Reilly Media*](https://oreilly.com) has provided
    technology and business training, knowledge, and insight to help companies succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Our unique network of experts and innovators share their knowledge and expertise
    through books, articles, and our online learning platform. O’Reilly’s online learning
    platform gives you on-demand access to live training courses, in-depth learning
    paths, interactive coding environments, and a vast collection of text and video
    from O’Reilly and 200+ other publishers. For more information, visit [*https://oreilly.com*](https://oreilly.com).
  prefs: []
  type: TYPE_NORMAL
- en: How to Contact Us
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please address comments and questions concerning this book to the publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: O’Reilly Media, Inc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1005 Gravenstein Highway North
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sebastopol, CA 95472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 800-998-9938 (in the United States or Canada)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 707-829-0515 (international or local)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 707-829-0104 (fax)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a web page for this book, where we list errata, examples, and any additional
    information. You can access this page at [*https://oreil.ly/fluent-c*](https://oreil.ly/fluent-c).
  prefs: []
  type: TYPE_NORMAL
- en: Email [*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com) to comment
    or ask technical questions about this book.
  prefs: []
  type: TYPE_NORMAL
- en: For news and information about our books and courses, visit [*https://oreilly.com*](https://oreilly.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Find us on LinkedIn: [*https://linkedin.com/company/oreilly-media*](https://linkedin.com/company/oreilly-media)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow us on Twitter: [*https://twitter.com/oreillymedia*](https://twitter.com/oreillymedia)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Watch us on YouTube: [*https://www.youtube.com/oreillymedia*](https://www.youtube.com/oreillymedia)'
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to thank my wife Silke who by now even knows what patterns are :-) and
    I want to thank my daughter Ylvi. They both make my life happier, and they both
    make sure that I don’t end up sitting in front of my computer working all the
    time, but that I instead enjoy life.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book would not have come to life without the help of many pattern enthusiasts.
    I want to thank all the participants of Writers’ Workshops at the European Conference
    on Pattern Languages of Programs for providing me with feedback on the patterns.
    In particular, I want to thank the following people, who provided me with very
    helpful feedback during the so-called shepherding process of that conference:
    Jari Rauhamäki, Tobias Rauter, Andrea Höller, James Coplien, Uwe Zdun, Thomas
    Raser, Eden Burton, Claudius Link, Valentino Vranić, and Sumit Kalra. Special
    thanks also to my work colleagues, in particular to Thomas Havlovec, who made
    sure that I got the C programming details in my patterns right. Robert Hanmer,
    Michael Weiss, David Griffiths, and Thomas Krug spent a lot of time for reviewing
    this book and provided me with additional ideas how to improve it—thank you very
    much! Thanks also to the whole team at O’Reilly who helped me a lot in making
    this book happen. In particular, I want to thank my development editor, Corbin
    Collins, and my production editor, Jonathon Owen.'
  prefs: []
  type: TYPE_NORMAL
- en: The content of this book is based on the following papers that were accepted
    at the European Conference on Pattern Languages of Programs and published with
    ACM. These papers can be accessed for free at the website [*http://www.preschern.com*](http://www.preschern.com).
  prefs: []
  type: TYPE_NORMAL
- en: '“A Pattern Story About C Programming,” EuroPLoP ’21: 26th European Conference
    on Pattern Languages of Programs, July 2015, article no. 53, 1–10, [*https://dl.acm.org/doi/10.1145/3489449.3489978*](https://dl.acm.org/doi/10.1145/3489449.3489978).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Patterns for Organizing Files in Modular C Programs,” EuroPLoP ’20: Proceedings
    of the European Conference on Pattern Languages of Programs, July 2020, article
    no. 1, 1–15, [*https://dl.acm.org/doi/10.1145/3424771.3424772*](https://dl.acm.org/doi/10.1145/3424771.3424772).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Patterns to Escape the #ifdef Hell,” EuroPLop ’19: Proceedings of the 24th
    European Conference on Pattern Languages of Programs, July 2019, article no. 2,
    1–12, [*https://dl.acm.org/doi/10.1145/3361149.3361151*](https://dl.acm.org/doi/10.1145/3361149.3361151).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Patterns for Returning Error Information in C,” EuroPLop ’19: Proceedings
    of the 24th European Conference on Pattern Languages of Programs, July 2019, article
    no. 3, 1–14, [*https://dl.acm.org/doi/10.1145/3361149.3361152*](https://dl.acm.org/doi/10.1145/3361149.3361152).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Patterns for Returning Data from C Functions,” EuroPLop ’19: Proceedings of
    the 24th European Conference on Pattern Languages of Programs, July 2019, article
    no. 37, 1–13, [*https://dl.acm.org/doi/10.1145/3361149.3361188*](https://dl.acm.org/doi/10.1145/3361149.3361188).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“C Patterns on Data Lifetime and Ownership,” EuroPLop ’19: Proceedings of the
    24th European Conference on Pattern Languages of Programs, July 2019, article
    no. 36, 1–13, [*https://dl.acm.org/doi/10.1145/3361149.3361187*](https://dl.acm.org/doi/10.1145/3361149.3361187).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Patterns for C Iterator Interfaces,” EuroPLoP ’17: Proceedings of the 22nd
    European Conference on Pattern Languages of Programs, July 2017, article no. 8,
    1–14, [*https://dl.acm.org/doi/10.1145/3147704.3147714*](https://dl.acm.org/doi/10.1145/3147704.3147714).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“API Patterns in C,” EuroPlop ’16: Proceedings of the 21st European Conference
    on Pattern Languages of Programs, July 2016, article no. 7, 1–11, [*https://dl.acm.org/doi/10.1145/3011784.3011791*](https://dl.acm.org/doi/10.1145/3011784.3011791).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Idioms for Error Handling in C,” EuroPLoP ’15: Proceedings of the 20th European
    Conference on Pattern Languages of Programs, July 2015, article no. 53, 1–10,
    [*https://dl.acm.org/doi/10.1145/2855321.2855377*](https://dl.acm.org/doi/10.1145/2855321.2855377).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
