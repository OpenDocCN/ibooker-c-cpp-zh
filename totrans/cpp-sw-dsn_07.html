<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 7. The Bridge, Prototype, and External Polymorphism Design Patterns" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_bridge_prototype_and_external_polymorphism_design_patterns">
<h1><span class="label">Chapter 7. </span>The Bridge, Prototype, and External Polymorphism Design Patterns</h1>
<p>In<a data-primary="Bridge design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043091949696"/><a data-primary="Prototype design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043091948816"/><a data-primary="External Polymorphism design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043091947872"/> this chapter, we will focus on two classic GoF design patterns: the Bridge design
pattern and the Prototype design pattern. Additionally,
we will study the <em>External Polymorphism</em> design pattern. At first glance, this selection
may appear as an illustrious, almost random choice of design patterns. However, I
picked these patterns for two reasons: first, in my experience, these three are among
the most useful in the catalog of design patterns. For that reason, you should have a
pretty good idea about their intent, advantages, and disadvantages. Second and equally
important: they will all play a vital role in <a data-type="xref" href="ch08.xhtml#type_erasure">Chapter 8</a>.</p>
<p>In <a data-type="xref" href="#build_bridges_to_remove_physical_dependencies">“Guideline 28: Build Bridges to Remove 
<span class="keep-together">Physical Dependencies</span>”</a>, I will acquaint you with
the Bridge design pattern and its simplest form, the <em>Pimpl idiom</em>. Most importantly,
I will demonstrate how you can use Bridges to reduce physical coupling by decoupling
an interface from implementation details.</p>
<p>In <a data-type="xref" href="#be_aware_of_the_performance_gains_and_losses_of_bridges">“Guideline 29: Be Aware of Bridge Performance Gains 
<span class="keep-together">and Losses</span>”</a>, we will take an explicit
look at the performance impact of Bridges. We will run benchmarks for
an implementation without Bridge, a Bridge-based implementation, and a “partial”
Bridge.</p>
<p>In <a data-type="xref" href="#apply_prototype_for_abstract_copy_operations">“Guideline 30: Apply Prototype for Abstract Copy Operations”</a>, I will introduce
you to the art of cloning. That is to say, that we will talk about copy operations and,
in particular, abstract copy operations. The pattern of choice for this intent will be
the Prototype design pattern.</p>
<p>In <a data-type="xref" href="#use_external_polymorphism_for_non_intrusive_runtime_polymorphism">“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”</a>,
we continue the journey of separating concerns by extracting the implementation details of
a function from a class. To further reduce dependencies, however, we will take this
separation of concerns to a whole new level: we will extract not only the implementation
details of virtual functions but also the complete functions themselves, with the
External Polymorphism design pattern.</p>
<section data-pdf-bookmark="Guideline 28: Build Bridges to Remove &#10;Physical Dependencies" data-type="sect1"><div class="sect1" id="build_bridges_to_remove_physical_dependencies">
<h1>Guideline 28: Build Bridges to Remove 
<span class="keep-together">Physical Dependencies</span></h1>
<p>According<a data-primary="Bridge design pattern" data-secondary="removing physical dependencies" data-type="indexterm" id="BDPphys07"/><a data-primary="dependencies" data-secondary="removing physical" data-see="Bridge design pattern" data-type="indexterm" id="idm45043091936128"/> to dictionaries, the term <em>bridge</em> expresses a time, a place, or
a means of connection or transition. If I were to ask what the term <em>bridge</em> means to you,
I’m pretty certain you would have a similar definition. You might implicitly think
about connecting two things, and thus bringing these things closer together. For instance,
you might think about a city divided by a river. A bridge would connect the two sides
of the city, bring them closer together, and save people a lot of time. You might
also think about electronics, where a bridge connects two independent parts of a circuit.
There are bridges in music and many more examples from the real world, where bridges help connect things. Yes, intuitively the term <em>bridge</em> suggests an increase in closeness
and proximity. So naturally, the Bridge design pattern is about the polar opposite: it<a data-primary="Bridge design pattern" data-secondary="purpose of" data-type="indexterm" id="idm45043091933424"/>
supports you in reducing physical dependencies and helps to decouple, i.e., it keeps two
pieces of functionality that need to work together but shouldn’t know too many details
about each other, at arm’s length.</p>
<section data-pdf-bookmark="A Motivating Example" data-type="sect2"><div class="sect2" id="idm45043091932320">
<h2>A Motivating Example</h2>
<p>To<a data-primary="Bridge design pattern" data-secondary="removing physical dependencies" data-tertiary="example problem" data-type="indexterm" id="idm45043091930688"/> explain what I have in mind, consider the following <code>ElectricCar</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;ElectricEngine.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ElectricEngine</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">start</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">stop</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;ElectricCar.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;ElectricEngine.h&gt;</code><code class="cp">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ElectricCar</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">ElectricCar</code><code class="p">(</code><code class="w"> </code><code class="cm">/*maybe some engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">drive</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">ElectricEngine</code><code class="w"> </code><code class="n">engine_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_1" id="code_g28_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... more car-specific data members (wheels, drivetrain, ...)
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;ElectricCar.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;ElectricCar.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="n">ElectricCar</code><code class="o">:</code><code class="o">:</code><code class="n">ElectricCar</code><code class="p">(</code><code class="w"> </code><code class="cm">/*maybe some engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">engine_</code><code class="p">{</code><code class="w"> </code><code class="cm">/*engine arguments*/</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Initialization of the other data members
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="c1">// ...
</code></pre>
<p>As the name suggests, the <code>ElectricCar</code> class is equipped with an <code>ElectricEngine</code>
(<a class="co" href="#code_g28_1" id="para_g28_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
However, while in reality such a car may be pretty attractive, the current implementation
details are concerning: because of the <code>engine_</code> data member, the 
<span class="keep-together"><code>&lt;ElectricCar.h&gt;</code></span>
header file needs to include the <code>&lt;ElectricEngine.h&gt;</code> header. The compiler needs to
see the class definition of <code>ElectricEngine</code>, because otherwise it would not be
able to determine the size of an <code>ElectricCar</code> instance. Including the <code>&lt;ElectricEngine.h&gt;</code>
header, however, easily results in transitive, physical coupling: every file that includes
the <code>&lt;ElectricCar.h&gt;</code> header will physically depend on the <code>&lt;ElectricEngine.h&gt;</code> header.
Thus, whenever something in the header changes, the <code>ElectricCar</code> class and potentially many
more classes are affected. They might have to be recompiled, retested, and, in the worst
case, even redeployed…<em>sigh</em>.</p>
<p>On top of that, this design reveals all implementation details to everyone. “What do you
mean? Isn’t it the point of the <code>private</code> section of the class to hide and to encapsulate
implementation details?” Yes, it may be <code>private</code>, but the <code>private</code> label is merely an
access label. It is <em>not</em> a visibility label. Therefore, everything in your class definition
(and I mean <em>everything</em>) is visible to everyone who sees the <code>ElectricCar</code> class
definition. This means that you cannot change the implementation details of this class
without anyone noticing. In particular, this may be a problem if you need to provide<a data-primary="ABI stability" data-type="indexterm" id="idm45043091750672"/> ABI
stability, i.e., if the in-memory representation of your class must not change.<sup><a data-type="noteref" href="ch07.xhtml#idm45043091750016" id="idm45043091750016-marker">1</a></sup></p>
<p>A slightly better approach would be to only store a pointer to <code>ElectricEngine</code>
(<a class="co" href="#code_g28_2" id="para_g28_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>):<sup><a data-type="noteref" href="ch07.xhtml#idm45043091745568" id="idm45043091745568-marker">2</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;ElectricCar.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="c1">// ...
</code><code class="k">struct</code><code class="w"> </code><code class="nc">ElectricEngine</code><code class="p">;</code><code class="w">  </code><code class="c1">// Forward declaration
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ElectricCar</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">ElectricCar</code><code class="p">(</code><code class="w"> </code><code class="cm">/*maybe some engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">drive</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">ElectricEngine</code><code class="o">&gt;</code><code class="w"> </code><code class="n">engine_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_2" id="code_g28_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... more car-specific data members (wheels, drivetrain, ...)
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;ElectricCar.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;ElectricCar.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;ElectricEngine.h&gt;</code><code class="c1">  </code><a class="co" href="#para_g28_3" id="code_g28_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="cp">
</code><code class="w">
</code><code class="n">ElectricCar</code><code class="o">:</code><code class="o">:</code><code class="n">ElectricCar</code><code class="p">(</code><code class="w"> </code><code class="cm">/*maybe some engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">engine_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">ElectricEngine</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="cm">/*engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Initialization of the other data members
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="c1">// ... Other 'ElectricCar' member functions, using the pointer to an
</code><code class="c1">//     'ElectricEngine'.
</code></pre>
<p>In this case, it is sufficient to provide only a forward declaration to the 
<span class="keep-together"><code>ElectricEngine</code></span>
class, since the compiler doesn’t need to know the class definition to be able to determine
the size of an <code>ElectricCar</code> instance. Also, the physical dependency is gone, since the
<code>&lt;ElectricEngine.h&gt;</code> header has been moved into the source file
(<a class="co" href="#code_g28_3" id="para_g28_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>).
Hence, from a dependency point of view, this solution is much better. What still remains is
the visibility of the implementation details. Everyone is still able to see that the <code>ElectricCar</code>
builds on an <code>ElectricEngine</code>, and thus everyone is still implicitly depending on these
implementation details. Consequently, any change to these details, such as an upgrade
to the new <code>PowerEngine</code>, would affect any class that works with the <code>&lt;ElectricCar.h&gt;</code> header
file. “And that’s bad, right?” Indeed it is, because change is to be expected (see
<a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>). To get rid of this dependency and gain the luxury of being able to easily change the implementation details at any
time without anyone noticing, we have to introduce an abstraction. The classic form of
abstraction is the introduction of an abstract class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Engine.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Engine</code><code class="w">  </code><a class="co" href="#para_g28_4" id="code_g28_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Engine</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">start</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">stop</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... more engine-specific functions
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;ElectricCar.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Engine.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ElectricCar</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">drive</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Engine</code><code class="o">&gt;</code><code class="w"> </code><code class="n">engine_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_5" id="code_g28_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... more car-specific data members (wheels, drivetrain, ...)
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;ElectricEngine.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Engine.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ElectricEngine</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Engine</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">start</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">stop</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;ElectricCar.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;ElectricCar.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;ElectricEngine.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="n">ElectricCar</code><code class="o">:</code><code class="o">:</code><code class="n">ElectricCar</code><code class="p">(</code><code class="w"> </code><code class="cm">/*maybe some engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">engine_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">ElectricEngine</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="cm">/*engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g28_6" id="code_g28_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ... Initialization of the other data members
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="c1">// ... Other 'ElectricCar' member functions, primarily using the 'Engine'
</code><code class="c1">//     abstraction, but potentially also explicitly dealing with an
</code><code class="c1">//     'ElectricEngine'.
</code></pre>
<p>With the <code>Engine</code> base class in place
(<a class="co" href="#code_g28_4" id="para_g28_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>),
we can implement our <code>ElectricCar</code> class using this abstraction
(<a class="co" href="#code_g28_5" id="para_g28_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
No one needs to be aware of the actual type of engine that we use. And no one needs to
know when we upgrade our engine. With this implementation, we can easily change
the implementation details at any time by only modifying the source file
(<a class="co" href="#code_g28_6" id="para_g28_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).
Therefore, with this approach, we’ve truly
minimized dependencies on the <code>ElectricEngine</code> implementation. We have made the
knowledge about this detail our own, secret implementation detail. And by doing that,
we have built ourselves a Bridge.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As stated in the introduction, counterintuitively, this Bridge isn’t about bringing
the <code>ElectricCar</code> and <code>Engine</code> classes closer together. On the contrary, it’s about
separating concerns and about loose coupling. Another example that shows that
<a href="https://oreil.ly/YfDpP">naming is hard</a> comes from Kate Gregory’s talk at CppCon.</p>
</div>
</div></section>
<section data-pdf-bookmark="The Bridge Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043091931728">
<h2>The Bridge Design Pattern Explained</h2>
<p>The<a data-primary="Bridge design pattern" data-secondary="removing physical dependencies" data-tertiary="Bridge explained" data-type="indexterm" id="idm45043091322192"/> Bridge design pattern is yet another one of the classic GoF design patterns
introduced in 1994. The<a data-primary="Bridge design pattern" data-secondary="purpose of" data-type="indexterm" id="idm45043091320704"/> purpose of a Bridge is
to minimize physical dependencies by encapsulating some implementation details behind
an abstraction. In C++, it acts as a compilation firewall, which enables
easy change:</p>
<div data-type="tip"><h1>The Bridge Design Pattern</h1>
<p>Intent: “Decouple<a data-primary="Bridge design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043091277024"/> an abstraction from its implementation so that the two can vary
independently.”<sup><a data-type="noteref" href="ch07.xhtml#idm45043091276160" id="idm45043091276160-marker">3</a></sup></p>
</div>
<p>In this formulation of the intent, the Gang of Four talks about an “abstraction” and an
“implementation.” In our example, the <code>ElectricCar</code> class represents the “abstraction,”
while the <code>Engine</code> class represents the “implementation”<a data-primary="Bridge design pattern" data-secondary="removing physical dependencies" data-tertiary="UML diagrams" data-type="indexterm" id="idm45043091273776"/> (see <a data-type="xref" href="#fig_bridge_car_1">Figure 7-1</a>).
Both of these should be able to vary independently; i.e., changes to either one should
have no effect on the other. The impediments to easy change are the physical dependencies
between the <code>ElectricCar</code> class and its engines. Thus, the idea is to extract and isolate
these dependencies. By isolating them in the form of the <code>Engine</code> abstraction, separating
concerns, and fulfilling the SRP, you gain the flexibility
to change, tune, or upgrade the engine any way you want (see <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>). The
change is no longer visible in the <code>ElectricCar</code> class. As a consequence, it is now easily
possible to add new kinds of engines without the “abstraction” noticing. This adheres to
the idea of the OCP (see <a data-type="xref" href="ch01.xhtml#design_for_extension">“Guideline 5: Design for Extension”</a>).</p>
<figure><div class="figure" id="fig_bridge_car_1">
<img alt="The UML representation of the basic Bridge design pattern." height="613" src="assets/cpsd_0701.png" width="1175"/>
<h6><span class="label">Figure 7-1. </span>The UML representation of the basic Bridge design pattern</h6>
</div></figure>
<p>While this provides us the ability to easily apply changes, and implements the idea of a Bridge, there is one more step that we can take to
further decouple and reduce duplication. Let’s assume that we are not just interested
in electric cars but also in cars with combustion engines. So for
every kind of car that we plan to implement, we are interested in introducing the same kind
of decoupling from engine details, i.e., the same kind of Bridge. To reduce
the duplication and follow the DRY principle, we can extract
the Bridge-related implementation details into the <code>Car</code> base class (see
<a data-type="xref" href="#fig_bridge_car_2">Figure 7-2</a>).</p>
<figure><div class="figure" id="fig_bridge_car_2">
<img alt="The UML representation of the full Bridge design pattern." height="613" src="assets/cpsd_0702.png" width="1175"/>
<h6><span class="label">Figure 7-2. </span>The UML representation of the full Bridge design pattern</h6>
</div></figure>
<p>The <code>Car</code> base class encapsulates the Bridge to the associated Engine:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Car.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Engine.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Car</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">protected</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Car</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Engine</code><code class="o">&gt;</code><code class="w"> </code><code class="n">engine</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g28_7" id="code_g28_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">engine</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Car</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">drive</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... more car-specific functions
</code><code class="w">
</code><code class="w"> </code><code class="k">protected</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">Engine</code><code class="o">*</code><code class="w">       </code><code class="n">getEngine</code><code class="p">(</code><code class="p">)</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g28_9" id="code_g28_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">Engine</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">getEngine</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Engine</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">;</code><code class="w">  </code><code class="c1">// Pointer-to-implementation (pimpl)  </code><a class="co" href="#para_g28_8" id="code_g28_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... more car-specific data members (wheels, drivetrain, ...)
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>With the addition of the <code>Car</code> class, both the “abstraction” and the “implementation”
offer the opportunity for easy extension and can vary independently. While the <code>Engine</code>
base class still represents the “implementation” in this Bridge relation, the <code>Car</code>
class now plays the role of the “abstraction.” The first noteworthy detail about the
<code>Car</code> class is the <code>protected</code> constructor
(<a class="co" href="#code_g28_7" id="para_g28_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).
This choice makes sure that only derived classes are able to specify the kind of engine.
The constructor takes <code>std::unique_ptr</code> to an <code>Engine</code> and moves it to its <code>pimpl_</code>
data member
(<a class="co" href="#code_g28_8" id="para_g28_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).
This<a data-primary="pimpl (pointer data member)" data-type="indexterm" id="idm45043091106912"/> pointer data member is the one <em>p</em>ointer-to-<em>impl</em>ementation for all kinds of
<code>Car</code>s and is commonly called the <em>pimpl</em>. This<a data-primary="opaque pointers" data-type="indexterm" id="idm45043091104480"/> <em>opaque pointer</em> represents the Bridge
to the encapsulated implementation details and essentially represents the Bridge
design pattern as a whole. For this reason, it’s a good idea to use the name <em>pimpl</em> in
the code as an indication of your intentions (remember
<a data-type="xref" href="ch03.xhtml#use_a_design_patterns_name_to_communicate_intent">“Guideline 14: Use a Design Pattern’s Name to Communicate Intent”</a>).</p>
<p>Note that <code>pimpl_</code> is declared in the <code>private</code> section of the class, despite the fact
that derived classes will have to use it. This choice is motivated by
<a href="https://oreil.ly/99sIG">Core Guideline C.133</a>:</p>
<blockquote>
<p>Avoid <code>protected</code> data.</p></blockquote>
<p>Indeed, experience shows that <code>protected</code> data members are barely better than 
<span class="keep-together"><code>public</code></span>
data members. Therefore, to grant access to the pimpl, the <code>Car</code> class instead
provides the <code>protected</code> <code>getEngine()</code> member functions
(<a class="co" href="#code_g28_9" id="para_g28_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).</p>
<p>The <code>ElectricCar</code> class is adapted accordingly:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;ElectricCar.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Engine.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ElectricCar</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Car</code><code class="w">  </code><a class="co" href="#para_g28_10" id="code_g28_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">ElectricCar</code><code class="p">(</code><code class="w"> </code><code class="cm">/*maybe some engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">drive</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;ElectricCar.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;ElectricCar.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;ElectricEngine.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="n">ElectricCar</code><code class="o">:</code><code class="o">:</code><code class="n">ElectricCar</code><code class="p">(</code><code class="w"> </code><code class="cm">/*maybe some engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">Car</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">ElectricEngine</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="cm">/*engine arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g28_11" id="code_g28_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="c1">// ...
</code></pre>
<p>Rather than implementing the Bridge itself, the <code>ElectricCar</code> class now inherits from the
<code>Car</code> base class
(<a class="co" href="#code_g28_10" id="para_g28_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).
This inheritance relationship introduces the requirement of initializing the <code>Car</code> base
by specifying an <code>Engine</code>. This task is performed in the 
<span class="keep-together"><code>ElectricCar</code></span> constructor
(<a class="co" href="#code_g28_11" id="para_g28_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>).</p>
</div></section>
<section data-pdf-bookmark="The Pimpl Idiom" data-type="sect2"><div class="sect2" id="idm45043091323264">
<h2>The Pimpl Idiom</h2>
<p>There<a data-primary="Bridge design pattern" data-secondary="removing physical dependencies" data-tertiary="Pimpl idiom" data-type="indexterm" id="idm45043090924016"/><a data-primary="Pimpl idiom" data-type="indexterm" id="Pimple07"/> is a much simpler form of the Bridge design pattern that has been very commonly
and successfully used in both C and C++ for decades. To see an example, let’s
consider the following <code>Person</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Person</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">year_of_birth</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Many more access functions</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">forename_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">surname_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">address_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">city_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">country_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">zip_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">year_of_birth_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Potentially many more data members</code>
<code class="p">};</code><code class="w"/></pre>
<p>A person consists of a lot of data members: <code>forename</code>, <code>surname</code>, the complete postal
address, <code>year_of_birth</code>, and potentially many more. There may be the need to add
further data members in the future: a mobile phone number, a Twitter account, or the account
information for the next social media fad. In other words, it stands to reason that
the <code>Person</code> class needs to be extended or changed over time, potentially even frequently.
This may come with a whole lot of inconveniences for users of this class: whenever <code>Person</code>
changes, the users of <code>Person</code> have to recompile their code. Not to mention ABI stability:
the size of a <code>Person</code> instance is going to change!</p>
<p>To hide all changes to the implementation details of <code>Person</code> and gain ABI stability, you can use the Bridge design pattern. In this particular case,
however, there is no need to provide an abstraction in the form of a base class: there is
one, and exactly one, implementation for <code>Person</code>. Therefore, all we do is introduce a
<code>private</code>, nested class called <code>Impl</code>
(<a class="co" href="#code_g28_12" id="para_g28_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Person.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Person</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">Impl</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_12" id="code_g28_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Impl</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_13" id="code_g28_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Person.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Person.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">Person</code><code class="o">:</code><code class="o">:</code><code class="n">Impl</code><code class="w">  </code><a class="co" href="#para_g28_14" id="code_g28_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">forename</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">surname</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">address</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">city</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">country</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="w"> </code><code class="n">zip</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">year_of_birth</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Potentially many more data members
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The sole task of the nested <code>Impl</code> class is to encapsulate the implementation details
of <code>Person</code>. Thus, the only data member remaining in the <code>Person</code> class is the <code>std::unique_ptr</code>
to an <code>Impl</code> instance
(<a class="co" href="#code_g28_13" id="para_g28_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).
All other data members, and potentially some non-<code>virtual</code> helper functions, are moved from
the <code>Person</code> class into the <code>Impl</code> class. Note that the <code>Impl</code> class is only declared in
the <code>Person</code> class but not defined. Instead, it is defined in the corresponding source file
(<a class="co" href="#code_g28_14" id="para_g28_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>).
Only due to this, all details and all changes that you apply to the details, such as adding or
removing data members, changing the type of data members, etc., are hidden from the users
of <code>Person</code>.</p>
<p>This implementation of <code>Person</code> uses the Bridge design pattern in its simplest form:
this local, nonpolymorphic form of Bridge is called the
<a href="https://oreil.ly/7QULb"><em>Pimpl idiom</em></a>. It comes with all the
decoupling advantages of the Bridge pattern but, despite its simplicity, it still results
in a bit more complex implementation of the 
<span class="keep-together"><code>Person</code></span> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Person.h&gt; ----------------
</code><code class="w">
</code><code class="c1">//#include &lt;memory&gt;
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Person</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="n">Person</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">   </code><a class="co" href="#para_g28_15" id="code_g28_15_2"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="o">~</code><code class="n">Person</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_16" id="code_g28_16_2"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Person</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_17" id="code_g28_17_2"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">Person</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_18" id="code_g28_18_2"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Person</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_19" id="code_g28_19_2"><img alt="19" height="12" src="assets/19.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">Person</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_20" id="code_g28_20_2"><img alt="20" height="12" src="assets/20.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="nf">year_of_birth</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_21" id="code_g28_21_2"><img alt="21" height="12" src="assets/21.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ... Many more access functions
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">Impl</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Impl</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Person.cpp&gt; ----------------
</code><code class="w">
</code><code class="c1">//#include &lt;Person.h&gt;
</code><code class="c1">//#include &lt;string&gt;
</code><code class="w">
</code><code class="k">struct</code><code class="w"> </code><code class="nc">Person</code><code class="o">:</code><code class="o">:</code><code class="n">Impl</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="n">Person</code><code class="o">:</code><code class="o">:</code><code class="n">Person</code><code class="p">(</code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g28_15" id="code_g28_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Impl</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="n">Person</code><code class="o">:</code><code class="o">:</code><code class="o">~</code><code class="n">Person</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g28_16" id="code_g28_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="n">Person</code><code class="o">:</code><code class="o">:</code><code class="n">Person</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g28_17" id="code_g28_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Impl</code><code class="o">&gt;</code><code class="p">(</code><code class="o">*</code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="n">Person</code><code class="o">&amp;</code><code class="w"> </code><code class="n">Person</code><code class="o">:</code><code class="o">:</code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g28_18" id="code_g28_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="o">*</code><code class="n">pimpl_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="n">Person</code><code class="o">:</code><code class="o">:</code><code class="n">Person</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g28_19" id="code_g28_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Impl</code><code class="o">&gt;</code><code class="p">(</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="o">*</code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="n">Person</code><code class="o">&amp;</code><code class="w"> </code><code class="n">Person</code><code class="o">:</code><code class="o">:</code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Person</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g28_20" id="code_g28_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="o">*</code><code class="n">pimpl_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="o">*</code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="n">Person</code><code class="o">:</code><code class="o">:</code><code class="n">year_of_birth</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w">  </code><a class="co" href="#para_g28_21" id="code_g28_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">pimpl_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">year_of_birth</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="c1">// ... Many more Person member functions
</code></pre>
<p>The <code>Person</code> constructor initializes the <code>pimpl_</code> data member by <code>std::make_unique()</code>
(<a class="co" href="#code_g28_15" id="para_g28_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>).
This, of course, involves a dynamic memory allocation, which means that the dynamic memory
needs to be cleaned up again. “And that is why we use <code>std::unique_ptr</code>,” you say.
Correct. But perhaps surprisingly, although we use <code>std::unique_ptr</code> for that purpose, it’s still necessary to manually deal with the destructor
(<a class="co" href="#code_g28_16" id="para_g28_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>).</p>
<p>“Why on earth do we have to do this? Isn’t the point of <code>std::unique_ptr</code> that we don’t
have to deal with cleanup?” Well, we still have to. Let me explain: if you don’t write
the destructor, the compiler feels obliged to generate the destructor for you. Unfortunately,
it would generate the destructor in the <code>&lt;Person.h&gt;</code> header file. The destructor of <code>Person</code>
would trigger the instantiation of the destructor of 
<span class="keep-together">the <code>std::unique_ptr</code></span> data member,
which in turn would require the definition of the destructor of the <code>Impl</code> class. The
definition of <code>Impl</code>, however, is not available in the header file. On the contrary, it
needs to be defined in the source file or it would defeat the purpose of the Bridge. Thus,
the compiler emits an error about the incomplete type <code>Impl</code>. Fortunately, you do not have
to let go of the <code>std::unique_ptr</code> to resolve the issue (and in fact you <em>should</em> not let go
of it). The problem is rather simple to solve. All you have to do is move the definition
of the <code>Person</code> destructor to the source file: you declare the destructor in the class
definition and define it via <code>=default</code> in the source file.</p>
<p>Since <code>std::unique_ptr</code> cannot be copied, you will have to implement the copy constructor
to preserve the copy semantics of the <code>Person</code> class
(<a class="co" href="#code_g28_17" id="para_g28_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>).
The same is true for the copy assignment operator
(<a class="co" href="#code_g28_18" id="para_g28_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>).
Note that this operator is implemented under the assumption that every instance of <code>Person</code>
will <em>always</em> have a valid <code>pimpl_</code>. This assumption explains the implementation of the move
constructor: instead of simply moving <code>std::unique_ptr</code>, it performs a potentially
failing, or throwing, dynamic memory allocation with <code>std::make_unique()</code>. For
that reason, it is <em>not</em> declared as <code>noexcept</code>
(<a class="co" href="#code_g28_19" id="para_g28_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a>).<sup><a data-type="noteref" href="ch07.xhtml#idm45043090164320" id="idm45043090164320-marker">4</a></sup> This assumption also explains why
the <code>pimpl_</code> data member is declared as <code>const</code>. Once it’s initialized, the pointer will
not be changed anymore, not even in the move operations, including the move assignment
operator
(<a class="co" href="#code_g28_20" id="para_g28_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a>).</p>
<p>The last detail worth noting is that the definition of the <code>year_of_birth()</code> member
function is located in the source file
(<a class="co" href="#code_g28_21" id="para_g28_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a>).
Despite the fact that this simple getter function is a great
<code>inline</code> candidate, the definition has to be moved to the source file. The reason is that
in the header file, <code>Impl</code> is an
<a href="https://oreil.ly/wg10k">incomplete type</a>.
Which means that within the header file, you are not able to access any members (both data
and functions). This is possible only in the source file, or generally speaking, as soon as
the compiler knows the definition of <code>Impl</code>.<a data-primary="" data-startref="Pimple07" data-type="indexterm" id="idm45043090009680"/></p>
</div></section>
<section data-pdf-bookmark="Comparison Between Bridge and Strategy" data-type="sect2"><div class="sect2" id="idm45043090925120">
<h2>Comparison Between Bridge and Strategy</h2>
<p>“I have<a data-primary="Bridge design pattern" data-secondary="removing physical dependencies" data-tertiary="Bridge versus Strategy design patterns" data-type="indexterm" id="idm45043090007392"/><a data-primary="Strategy design pattern" data-secondary="versus Bridge design pattern" data-secondary-sortas="Bridge design pattern" data-type="indexterm" id="SDPvbridge07"/> a question,” you say. “I see a strong resemblance between the Bridge
and the Strategy design pattern. I know you said that design patterns are sometimes
structurally very similar and that the only difference is their intent. But what exactly is
the distinction between these two?”<sup><a data-type="noteref" href="ch07.xhtml#idm45043090004848" id="idm45043090004848-marker">5</a></sup> I understand your
question. The similarity between these two is truly a little confusing. However, there is
something you can use to tell them apart: how the corresponding data member is
initialized is a strong indicator about which one you’re using.</p>
<p>If a class does not want to know about some implementation detail, and if for that reason
it provides the opportunity to configure the behavior by passing in details from the outside
(for instance, via a constructor or via a setter function), then you are most likely dealing with
the Strategy design pattern. Because the flexible configuration of behavior, i.e., the
reduction of <em>logical</em> dependencies, is its primary focus, Strategy falls into the category
of a<a data-primary="behavioral design patterns" data-type="indexterm" id="idm45043090002448"/><a data-primary="design patterns" data-secondary="behavioral design patterns" data-type="indexterm" id="idm45043090001840"/> <em>behavioral design pattern</em>. For instance, in the following code snippet, the constructor
of the <code>Database</code> class is a telltale sign:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">DatabaseEngine</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">DatabaseEngine</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Many database-specific functions
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Database</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Database</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DatabaseEngine</code><code class="o">&gt;</code><code class="w"> </code><code class="n">engine</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Many database-specific functions
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DatabaseEngine</code><code class="o">&gt;</code><code class="w"> </code><code class="n">engine_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="c1">// The database is unaware of any implementation details and requests them
</code><code class="c1">//   via its constructor from outside -&gt; Strategy design pattern
</code><code class="n">Database</code><code class="o">:</code><code class="o">:</code><code class="n">Database</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DatabaseEngine</code><code class="o">&gt;</code><code class="w"> </code><code class="n">engine</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g28_22" id="code_g28_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">engine_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">engine</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code></pre>
<p>The actual type of <code>DatabaseEngine</code> is passed in from the outside
(<a class="co" href="#code_g28_22" id="para_g28_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a>),
making this a good example of the Strategy design pattern.</p>
<p><a data-type="xref" href="#fig_strategy_dependency_graph_database">Figure 7-3</a> shows the<a data-primary="Strategy design pattern" data-secondary="dependency graph" data-type="indexterm" id="idm45043089896848"/> dependency graph for this example.
Most importantly, the 
<span class="keep-together"><code>Database</code></span> class is on the same architectural level as the <code>DatabaseEngine</code>
abstraction, thus providing others with the opportunity to implement the behavior (e.g.,
in the form of the <code>ConcreteDatabaseEngine</code>). Since <code>Database</code> is depending only on the
abstraction, there is no dependency on any specific implementation.</p>
<figure><div class="figure" id="fig_strategy_dependency_graph_database">
<img alt="The dependency graph for the Strategy design pattern." height="660" src="assets/cpsd_0703.png" width="1439"/>
<h6><span class="label">Figure 7-3. </span>Dependency graph for the Strategy design pattern</h6>
</div></figure>
<p>If, however, a class knows about the implementation details but primarily wants to
reduce the <em>physical</em> dependencies on these details, then you’re most likely dealing with
the Bridge design pattern. In that case, the class does not provide any opportunity to
set the pointer from outside, i.e., the pointer is an implementation detail and set internally. Since the Bridge design pattern primarily focuses on the physical
dependencies of the implementation details, not the logical dependencies, Bridge falls
into the category of<a data-primary="structural design patterns" data-type="indexterm" id="idm45043089890816"/><a data-primary="design patterns" data-secondary="structural design patterns" data-type="indexterm" id="idm45043089890144"/> <em>structural design patterns</em>. As an example, consider the following
code snippet:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">Database</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Database</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DatabaseEngine</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="c1">// The database knows about the required implementation details, but does
</code><code class="c1">//   not want to depend too strongly on it -&gt; Bridge design pattern
</code><code class="n">Database</code><code class="o">:</code><code class="o">:</code><code class="n">Database</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">ConcreteDatabaseEngine</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g28_23" id="code_g28_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="p">}</code><code class="w">
</code></pre>
<p>Again, there is a telltale sign for the application of the Bridge design pattern: instead
of accepting an engine from outside, the constructor of the <code>Database</code> class is aware of the
<code>ConcreteDatabaseEngine</code> and sets it internally
(<a class="co" href="#code_g28_23" id="para_g28_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a>).</p>
<p><a data-type="xref" href="#fig_bridge_dependency_graph_database">Figure 7-4</a> shows<a data-primary="Bridge design pattern" data-secondary="removing physical dependencies" data-tertiary="dependency graph" data-type="indexterm" id="idm45043089774352"/> the dependency graph for the Bridge
implementation of the 
<span class="keep-together"><code>Database</code></span> example. Most notably, the <code>Database</code> class is on the
same architectural level as the <code>ConcreteDatabaseEngine</code> class and does not leave
any opportunity for others to provide different implementations. This shows that in
contrast to the Strategy design pattern, a Bridge is logically coupled to a specific
implementation but only physically decoupled via the <code>DatabaseEngine</code> abstraction.<a data-primary="" data-startref="SDPvbridge07" data-type="indexterm" id="idm45043089770672"/></p>
<figure><div class="figure" id="fig_bridge_dependency_graph_database">
<img alt="The dependency graph for the Bridge design pattern." height="702" src="assets/cpsd_0704.png" width="1439"/>
<h6><span class="label">Figure 7-4. </span>Dependency graph for the Bridge design pattern</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the Bridge Design Pattern" data-type="sect2"><div class="sect2" id="idm45043090008368">
<h2>Analyzing the Shortcomings of the Bridge Design Pattern</h2>
<p>“I can<a data-primary="Bridge design pattern" data-secondary="removing physical dependencies" data-tertiary="Bridge shortcomings" data-type="indexterm" id="idm45043089722704"/> totally see why the Bridge design pattern is so popular in the community. The
decoupling properties are really great!” you exclaim. “However, you keep telling me that
every design has its pros and cons. I expect there is a performance penalty?” Good, you
remember that there are always some disadvantages. And of course this includes the
Bridge design pattern, although it proves to be very useful. And yes, you’re
correct to assume that there is some performance overhead involved.</p>
<p>The first of five types of overhead results from
the fact that Bridge introduces an additional indirection: the pimpl pointer making all access to the implementation details more expensive. However,
how much of the performance penalty this pointer causes is an issue that I will discuss
separately in <a data-type="xref" href="#be_aware_of_the_performance_gains_and_losses_of_bridges">“Guideline 29: Be Aware of Bridge Performance Gains 
<span class="keep-together">and Losses</span>”</a>. This is not
the only source of 
<span class="keep-together">performance overhead</span>, though; there are more. Depending on whether you use an abstraction, you also might have to pay for the virtual function call overhead.
Additionally, you’ll have to pay more due to the lack of inlining of even the simplest
function accessing data members. And, of course, you will have to pay for an additional
dynamic memory allocation whenever you create a new instance of a class implemented in
terms of Bridge.<sup><a data-type="noteref" href="ch07.xhtml#idm45043089719744" id="idm45043089719744-marker">6</a></sup> Last but not least, you should also take into account
the memory overhead caused by introducing the pimpl pointer. So, yes, isolating
the physical dependencies and hiding implementation details is not free but results
in a considerable overhead. Still, this shouldn’t be a reason to generally discard the
Bridge solution: it always depends. For instance, if the underlying implementation
performs slow, expensive tasks, such as system calls, then this overhead might
not be measurable at all. In other words, whether or not to use a Bridge should be
decided on a case-by-case basis and backed up with performance benchmarks.</p>
<p>Furthermore, you have seen the implementation details and realized that the code
complexity has increased. Since simplicity and readability of code are a virtue, this should
be considered a downside. It’s true that this affects only the internals of a class,
not the user code. But still, some of the details (e.g., the need to define the destructor
in the source file) might be confusing for less-experienced developers.</p>
<p>In summary, the Bridge design pattern is one of the most valuable and most commonly used
solutions for reducing physical dependencies. Still, you should be aware of the overhead and
the complexity that a Bridge introduces.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043089717728">
<h5>Guideline 28: Build Bridges to Remove Physical Dependencies</h5>
<ul>
<li>
<p>Be aware of physical dependencies introduced by data members or includes.</p>
</li>
<li>
<p>Apply the Bridge design pattern with the intent to isolate physical dependencies from implementation details;</p>
</li>
<li>
<p>Prefer using a pimpl data member to communicate the use of a Bridge.</p>
</li>
</ul>
<ul class="less_space pagebreak-before">
<li>
<p>Understand the strengths and the weaknesses of the Bridge design pattern.</p>
</li>
<li>
<p>Know the difference between reducing physical dependencies (Bridge) and reducing logical dependencies (Strategy).<a data-primary="" data-startref="BDPphys07" data-type="indexterm" id="idm45043089711360"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 29: Be Aware of Bridge Performance Gains &#10;and Losses" data-type="sect1"><div class="sect1" id="be_aware_of_the_performance_gains_and_losses_of_bridges">
<h1>Guideline 29: Be Aware of Bridge Performance Gains 
<span class="keep-together">and Losses</span></h1>
<p>In<a data-primary="Bridge design pattern" data-secondary="performance" data-type="indexterm" id="BDPperform07"/> <a data-type="xref" href="#build_bridges_to_remove_physical_dependencies">“Guideline 28: Build Bridges to Remove 
<span class="keep-together">Physical Dependencies</span>”</a>, we took a detailed look at the
Bridge design pattern. While I imagine the design and decoupling aspect of Bridge left
a positive impression on you, I must make you aware that using this pattern may introduce
a performance penalty. “Yes, and that worries me. Performance is important to me, and it
sounds like a Bridge will create a massive performance overhead,” you say. And this
is a pretty common expectation. Since performance matters, I really should give you an
idea of how much overhead you have to expect when using a Bridge. However, I should also
demonstrate how to use Bridges wisely to improve the performance of your code.
Sounds unbelievable? Well, let me show you how.</p>
<section data-pdf-bookmark="The Performance Impact of Bridges" data-type="sect2"><div class="sect2" id="idm45043089705328">
<h2>The Performance Impact of Bridges</h2>
<p>As<a data-primary="Bridge design pattern" data-secondary="performance" data-tertiary="impact on" data-type="indexterm" id="idm45043089703728"/> discussed in <a data-type="xref" href="#build_bridges_to_remove_physical_dependencies">“Guideline 28: Build Bridges to Remove 
<span class="keep-together">Physical Dependencies</span>”</a>, the performance of a
Bridge implementation is influenced by many factors: access through an indirection,
virtual function calls, inlining, dynamic memory allocations, etc. Because of these
factors and the huge amount of possible combinations, there is no definitive
answer to how much performance a Bridge will cost you. There simply is no shortcut, no
substitute for assembling a couple of benchmarks for your own code and running them to evaluate a definitive answer. What I want to demonstrate, though, is that there is indeed
a performance penalty of accessing through an indirection, but you can still use a
Bridge to actually improve performance.</p>
<p>Let’s get started with giving you an idea about the benchmark. To form an
opinion on how costly the pointer indirection is, let’s compare the following two
implementations of a <code>Person</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp"/>

<code class="c1">//---- &lt;Person1.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Person1</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w"> </code><code class="k">private</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">forename_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">surname_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">address_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">city_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">country_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">zip_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">year_of_birth_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>The <code>Person1</code> struct represents a type that is <em>not</em> implemented in terms of a Bridge. All
seven data members (six <code>std::string</code>s and one <code>int</code>) are directly part of the struct
itself. Altogether, and assuming a 64-bit machine, the total size of one instance of <code>Person1</code>
is 152 bytes with Clang 11.1 and 200 bytes with GCC 11.1.<sup><a data-type="noteref" href="ch07.xhtml#idm45043089618368" id="idm45043089618368-marker">7</a></sup></p>
<p>The <code>Person2</code> struct, on the other hand, is implemented with the Pimpl idiom:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Person2.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Person2</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Person2</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...various person arguments...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="o">~</code><code class="n">Person2</code><code class="p">();</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">Impl</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Impl</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Person2.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Person2.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">Person2</code><code class="o">::</code><code class="n">Impl</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">forename</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">surname</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">address</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">city</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">country</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">zip</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">year_of_birth</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">Person2</code><code class="o">::</code><code class="n">Person2</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...various person arguments...*/</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Impl</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...various person arguments...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">{}</code><code class="w"/>

<code class="n">Person2</code><code class="o">::~</code><code class="n">Person2</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/></pre>
<p>All seven data members have been moved into the nested <code>Impl</code> struct and can
be accessed only via the <code>pimpl</code> pointer. While the total size of the nested <code>Impl</code> struct is
identical to the size of <code>Person1</code>, the size of the <code>Person2</code> struct is only 8 bytes
(again, assuming a 64-bit machine).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Via the Bridge design, you can reduce the size of a type, sometimes even significantly.
This can prove to be very valuable, for instance, if you want to use the type as an
alternative in <code>std::variant</code> (see
<a data-type="xref" href="ch04.xhtml#consider_std_variant_for_implementing_visitors">“Guideline 17: Consider std::variant for 
<span class="keep-together">Implementing Visitor</span>”</a>).</p>
</div>
<p>So let me outline the benchmark: I will create two <code>std::vector</code>s of 25,000 persons, one
for each of the two <code>Person</code> implementations. This number of elements will make certain
that we work beyond the size of the inner caches of the underlying CPU (i.e., we will use
a total of 3.2 MB with Clang 11.1 and 4.2 MB with GCC 11.1). All of these persons are given
arbitrary names and addresses and a year of birth between 1957 and 2004 (at the
time of writing, this would represent a reasonable range of ages of employees in an
organization). Then we will traverse both person vectors five thousand times, and each time determine
the oldest person with <code>std::min_element()</code>. The result will be
fairly uninteresting due to the repetitive nature of the benchmark. After one hundred
iterations, you’ll be too bored to watch. The only thing that matters is seeing the performance
difference between accessing a data member directly (<code>Person1</code>) or indirectly (<code>Person2</code>).
<a data-type="xref" href="#table_bridge_benchmark_results_1">Table 7-1</a> shows the performance results, normalized to the
performance of the <code>Person1</code> implementation.</p>
<table id="table_bridge_benchmark_results_1">
<caption><span class="label">Table 7-1. </span>Performance results for different <code>Person</code> implementations (normalized performance)</caption>
<thead>
<tr>
<th>Person implementation</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Person1 (no pimpl)</p></td>
<td><p>1.0</p></td>
<td><p>1.0</p></td>
</tr>
<tr>
<td><p>Person2 (complete Pimpl idiom)</p></td>
<td><p>1.1099</p></td>
<td><p>1.1312</p></td>
</tr>
</tbody>
</table>
<p class="less_space pagebreak-before">It’s fairly obvious that in this particular benchmark, the Bridge implementation incurs
a pretty significant performance penalty: 11.0% for GCC and 13.1% for Clang. This sounds like
a lot! However, don’t take these numbers too seriously: clearly, the result heavily depends on
the actual number of elements, the actual number and type of data members, the system we’re
running on, and the actual computation we perform in the benchmark. If you change any
of these details, the numbers will change as well. Thus, these numbers only demonstrate that
there is some, and potentially even some more, overhead due to the indirect access to data
members.</p>
</div></section>
<section data-pdf-bookmark="Improving Performance with Partial Bridges" data-type="sect2"><div class="sect2" id="idm45043089704736">
<h2>Improving Performance with Partial Bridges</h2>
<p>“OK, but<a data-primary="Bridge design pattern" data-secondary="performance" data-tertiary="improving" data-type="indexterm" id="idm45043089386288"/><a data-primary="partial Bridge design pattern" data-type="indexterm" id="parbridge07"/> this is an expected result, right? What should I learn from that?” you ask.
Well, I admit that this benchmark is fairly specific and does not answer all questions. However,
it does provide us with the opportunity to actually use a Bridge to improve performance.
If you take a closer look at the implementation of <code>Person1</code>, you might realize that for the
given benchmark, the achievable performance is pretty limited: while the total size of <code>Person1</code>
is 152 bytes (Clang 11.1) or 200 bytes (GCC 11.1), respectively, we use only 4 bytes, i.e.,
a single <code>int</code>, out of the total data structure. This proves to be rather wasteful and
inefficient: since in cache-based architectures memory is always loaded as cache
lines, a lot of the data that we load from memory is actually not used at all. In fact,
almost <em>all</em> of the data that we load from memory is not used at all: assuming a cache line
length of 64 bytes, we only use approximately 6% of the loaded data. Hence, despite the
fact that we determine the oldest person based on the year of birth of all persons, which
sounds like a compute-bound operation, we are in fact completely memory bound: the machine
simply cannot deliver data fast enough, and the integer unit will idle most of the time.</p>
<p>This setting gives us the opportunity to improve the performance with a Bridge.
Let’s assume that we can distinguish between data that is used often (such as <code>forename</code>, <code>surname</code>, and <code>year_of_birth</code>) and data that is used infrequently (for instance, the
postal address). Based on this distinction, we now arrange the data members accordingly:
all data members that are used often are stored directly in the <code>Person</code> class. All
data members that are used infrequently are stored inside the <code>Impl</code> struct. This leads
to the <code>Person3</code> implementation:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Person3.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Person3</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Person3</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...various person arguments...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="o">~</code><code class="n">Person3</code><code class="p">();</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">forename_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">surname_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">year_of_birth_</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">Impl</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Pimpl</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Person3.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Person3.h&gt;</code><code class="cp"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">Person3</code><code class="o">::</code><code class="n">Impl</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">address</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">city</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">country</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">zip</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">Person3</code><code class="o">::</code><code class="n">Person3</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...various person arguments...*/</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="n">forename_</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="p">,</code><code class="w"> </code><code class="n">surname_</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="p">,</code><code class="w"> </code><code class="n">year_of_birth_</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="p">,</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Impl</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...address-related arguments...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">{}</code><code class="w"/>

<code class="n">Person3</code><code class="o">::~</code><code class="n">Person3</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/></pre>
<p>The total size of a <code>Person3</code> instance is 64 bytes for Clang 11.1 (two 24-byte
<code>std::string</code>s, one integer, one pointer, and four padding bytes due to alignment
restrictions) and 80 bytes on GCC 11.1 (two 32-byte <code>std::string</code>s, one integer,
one pointer, and some padding). Thus, a <code>Person3</code> instance is only approximately half
as big as a <code>Person1</code> instance. This difference in size is measurable:
<a data-type="xref" href="#table_bridge_benchmark_results_2">Table 7-2</a> shows the performance result for all <code>Person</code>
implementations, including <code>Person3</code>. Again, the results are normalized to the
performance of the <code>Person1</code> implementation.</p>
<table id="table_bridge_benchmark_results_2">
<caption><span class="label">Table 7-2. </span>Performance results for different <code>Person</code> implementations (normalized performance)</caption>
<thead>
<tr>
<th>Person implementation</th>
<th>GCC 10.3</th>
<th>Clang 12.0</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Person1 (no pimpl)</p></td>
<td><p>1.0</p></td>
<td><p>1.0</p></td>
</tr>
<tr>
<td><p>Person2 (complete Pimpl idiom)</p></td>
<td><p>1.1099</p></td>
<td><p>1.1312</p></td>
</tr>
<tr>
<td><p>Person3 (partial Pimpl idiom)</p></td>
<td><p>0.8597</p></td>
<td><p>0.9353</p></td>
</tr>
</tbody>
</table>
<p>In comparison to the <code>Person1</code> implementation, the performance for <code>Person3</code> is improved by
14.0% for GCC 11.1 and 6.5% for Clang 11.1. And, as stated before, this is only because we
reduced the size of the <code>Person3</code> implementation. “Wow, this was unexpected. I see, a Bridge
is not necessarily all bad for performance,” you say. Yes, indeed. Of course, it always
depends on the specific setup, but distinguishing between data members that are used frequently
and those that are used infrequently, and reducing the size of a data structure by implementing a “partial” Bridge
may have a very positive impact on performance.<sup><a data-type="noteref" href="ch07.xhtml#idm45043089228000" id="idm45043089228000-marker">8</a></sup></p>
<p>“The performance gain is huge, that’s great, but isn’t that running against the intention
of a Bridge?” you ask. Indeed, you realize that there is a dichotomy between hiding
implementation details and “inlining” data members for the sake of performance. As always,
it depends: you will have to decide from case to case which aspect to favor. You hopefully
also realize that there is an entire range of solutions in between the two extremes: it is
not necessary to hide <em>all</em> data members behind a Bridge. In the end, you are the one to
find the optimum for a given problem.</p>
<p>In summary, while Bridges in general will very likely incur a performance penalty, given
the right circumstances, implementing a partial Bridge may have a very positive effect
on your performance. However, this is only one of many aspects that influence performance.
Therefore, you should always check to see if a Bridge results in a performance bottleneck or if a
partial Bridge is addressing a performance issue. The best way to confirm this is with a representative benchmark, based on the actual code and actual
data as much as possible.<a data-primary="" data-startref="parbridge07" data-type="indexterm" id="idm45043089224288"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043089223184">
<h5>Guideline 29: Be Aware of Bridge Performance Gains and Losses</h5>
<ul>
<li>
<p>Keep in mind that Bridges can have a negative performance impact.</p>
</li>
<li>
<p>Be aware that a partial Bridge can have a positive impact on performance when separating frequently used data from infrequently used data.</p>
</li>
<li>
<p>Always confirm performance bottlenecks or improvements by representative benchmarks; do not rely on your gut feeling.<a data-primary="" data-startref="BDPperform07" data-type="indexterm" id="idm45043089057824"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 30: Apply Prototype for Abstract Copy Operations" data-type="sect1"><div class="sect1" id="apply_prototype_for_abstract_copy_operations">
<h1>Guideline 30: Apply Prototype for Abstract Copy Operations</h1>
<p>Imagine<a data-primary="Prototype design pattern" data-secondary="abstract copy operations" data-type="indexterm" id="PDPabstract07"/><a data-primary="abstract copy operations" data-see="Prototype design pattern" data-type="indexterm" id="idm45043089053184"/><a data-primary="copy operations" data-see="Prototype design pattern" data-type="indexterm" id="idm45043089052208"/> yourself sitting in a fancy Italian restaurant and studying
the menu. Oh my, they offer so many great things; the lasagna sounds great. But the
selection of pizza they offer is also amazing. So hard to choose…However, your
thoughts are interrupted as the waiter walks by carrying this incredible-looking
dish. Unfortunately, it’s not meant for you but for someone at another table.
Oh wow, the smell…At this moment, you know that you no longer have to think
about what you want to eat: you want the same thing, no matter what it is. And so you
order: “Ah, waiter, I’ll have whatever they are having.”</p>
<p>The same problem may occur in your code. In C++ terms, what you are asking the
waiter for is a copy of the other person’s dish. Copying an object, i.e., creating an
exact replica of an instance, is a fundamentally important operation in C++.
So important that classes are, by default, equipped with a copy constructor
and a copy assignment operator—two of the so-called <em>special member
functions</em>.<sup><a data-type="noteref" href="ch07.xhtml#idm45043089050320" id="idm45043089050320-marker">9</a></sup> However, when asking for a copy of the dish, you
are unfortunately not aware what dish it is. In C++ terms, all you have is a
pointer-to-base (say, a <code>Dish*</code>). And unfortunately, trying to copy via <code>Dish*</code> with the copy constructor or copy assignment operator usually doesn’t work. Still,
you want an exact copy. The solution to this problem is another classic GoF design
pattern: the Prototype design pattern.</p>
<section data-pdf-bookmark="A Sheep-ish Example: Copying Animals" data-type="sect2"><div class="sect2" id="idm45043089045440">
<h2>A Sheep-ish Example: Copying Animals</h2>
<p>As<a data-primary="Prototype design pattern" data-secondary="abstract copy operations" data-tertiary="problem example" data-type="indexterm" id="idm45043089043968"/> an example, let’s consider the following <code>Animal</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Animal.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Animal</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Animal</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">makeSound</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... more animal-specific functions</code>
<code class="p">};</code><code class="w"/></pre>
<p>Apart from the virtual destructor, which indicates that <code>Animal</code> is supposed to be
a base class, the class provides only the <code>makeSound()</code> function,
which deals with printing cute animal sounds. One example of such an animal is the
<code>Sheep</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Sheep.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Animal.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Sheep</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Animal</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Sheep</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">name_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">makeSound</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... more animal-specific functions</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">name_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Sheep.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Sheep.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;iostream&gt;</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">Sheep::makeSound</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"baa</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In the <code>main()</code> function, we can now create a sheep and have it make sounds:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Sheep.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// Creating the one and only Dolly</code>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Animal</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">dolly</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Sheep</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="s">"Dolly"</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Triggers Dolly's beastly sound</code>
<code class="w">   </code><code class="n">dolly</code><code class="o">-&gt;</code><code class="n">makeSound</code><code class="p">();</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Dolly is great, right? And so cute! In fact, she’s so much fun that we want another
Dolly. However, all we have is a pointer-to-base—an <code>Animal*</code>.
We can’t copy via the <code>Sheep</code> copy constructor or the copy assignment operator, because
we (technically) don’t even know that we are dealing with a <code>Sheep</code>. It could be any
kind of animal (e.g., dog, cat, sheep, etc.). And we don’t want to copy just the <code>Animal</code>
part of <code>Sheep</code>, as this is what we call<a data-primary="slicing" data-type="indexterm" id="idm45043088721824"/> <em>slicing</em>.</p>
<p>Oh my, I just realized that this may be a particularly bad example for explaining the
Prototype design pattern. Slicing animals. This sounds bad. So let’s swiftly move
on. Where were we? Ah yes, we want a copy of Dolly, but we only have an <code>Animal*</code>. This
is where the Prototype design pattern comes into play.</p>
</div></section>
<section data-pdf-bookmark="The Prototype Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043088719744">
<h2>The Prototype Design Pattern Explained</h2>
<p>The<a data-primary="Prototype design pattern" data-secondary="abstract copy operations" data-tertiary="Prototype explained" data-type="indexterm" id="idm45043088718112"/> Prototype design pattern is one of the five creational design patterns collected
by the Gang of Four. It<a data-primary="Prototype design pattern" data-secondary="purpose of" data-type="indexterm" id="idm45043088716640"/> is focused on providing an abstract way of creating copies of
some abstract entity.</p>
<div data-type="tip"><h1>The Prototype Design Pattern</h1>
<p>Intent: “Specify<a data-primary="Prototype design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043088714368"/> the kind of objects to create using a prototypical instance, and
create new objects by copying this prototype.”<sup><a data-type="noteref" href="ch07.xhtml#idm45043088713040" id="idm45043088713040-marker">10</a></sup></p>
</div>
<p><a data-type="xref" href="#fig_prototype_original">Figure 7-5</a> shows<a data-primary="Prototype design pattern" data-secondary="abstract copy operations" data-tertiary="UML diagram" data-type="indexterm" id="idm45043088710848"/> the original UML formulation, taken from the GoF book.</p>
<figure><div class="figure" id="fig_prototype_original">
<img alt="The UML representation of the Prototype design pattern." height="684" src="assets/cpsd_0705.png" width="1139"/>
<h6><span class="label">Figure 7-5. </span>The UML representation of the Prototype design pattern</h6>
</div></figure>
<p class="less_space pagebreak-before">The Prototype design pattern is commonly implemented by a virtual <code>clone()</code>
function in the base class. Consider the updated <code>Animal</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Animal.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Animal</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Animal</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">makeSound</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Animal</code><code class="o">&gt;</code><code class="w"> </code><code class="n">clone</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="c1">// Prototype design pattern</code>
<code class="p">};</code><code class="w"/></pre>
<p>Via this <code>clone()</code> function, anyone can ask for an abstract copy of the given (prototype)
animal, without having to know about any specific type of animal (<code>Dog</code>, <code>Cat</code>, or <code>Sheep</code>).
When the <code>Animal</code> base class is properly assigned to the high level of your architecture,
it follows the DIP<a data-primary="Prototype design pattern" data-secondary="abstract copy operations" data-tertiary="dependency graph" data-type="indexterm" id="idm45043088658816"/> (see <a data-type="xref" href="#fig_prototype_dependency_graph">Figure 7-6</a>).</p>
<figure><div class="figure" id="fig_prototype_dependency_graph">
<img alt="The dependency graph for the Prototype design pattern." height="890" src="assets/cpsd_0706.png" width="1441"/>
<h6><span class="label">Figure 7-6. </span>Dependency graph for the Prototype design pattern</h6>
</div></figure>
<p>The <code>clone()</code> function is declared as a pure virtual function, which means that deriving
classes are required to implement it. However, deriving classes cannot simply implement
the function any way they want, but are expected to return an exact copy of themselves
(any other result would violate the LSP; see
<a data-type="xref" href="ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>). This copy is
commonly created dynamically by <code>new</code> and returned by a pointer-to-base.
This, of course, results not only in a pointer but also in the need to explicitly
<code>delete</code> the copy again. Since 
<span class="keep-together">manual</span> cleanup is considered to be very bad practice in
Modern C++, the pointer is returned as the <code>std::unique_ptr</code> to
<code>Animal</code>.<sup><a data-type="noteref" href="ch07.xhtml#idm45043088650448" id="idm45043088650448-marker">11</a></sup></p>
<p>The <code>Sheep</code> class is updated accordingly:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Sheep.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Animal.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Sheep</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Animal</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Sheep</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">name_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">makeSound</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Animal</code><code class="o">&gt;</code><code class="w"> </code><code class="n">clone</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">  </code><code class="c1">// Prototype design pattern</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">name_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Sheep.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Sheep.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;iostream&gt;</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">Sheep::makeSound</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"baa</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Animal</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Sheep</code><code class="o">::</code><code class="n">clone</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Sheep</code><code class="o">&gt;</code><code class="p">(</code><code class="o">*</code><code class="k">this</code><code class="p">);</code><code class="w">  </code><code class="c1">// Copy-construct a sheep</code>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>Sheep</code> class is now required to implement the <code>clone()</code> function and return an
exact copy of the <code>Sheep</code>: Inside its own <code>clone()</code> function, it makes use of the
<code>std::make_unique()</code> function and its own copy constructor, which is always assumed to
do the right thing, even if the <code>Sheep</code> class changes in the future. This approach
helps avoid unnecessary duplication and thus follows the DRY principle (see
<a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>).</p>
<p>Note that the <code>Sheep</code> class neither deletes nor hides its copy constructor and copy
assignment operator. Hence, if you have a sheep, you can still copy the sheep with the special member functions. That is perfectly OK: the <code>clone()</code> merely adds one
more way to create a copy—a way to perform <code>virtual</code> copying.</p>
<p>With the <code>clone()</code> function in place, we can now create an exact copy of Dolly.
And we can do this so much easier than we could have back in 1996 when they cloned the first Dolly:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Sheep.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Animal</code><code class="o">&gt;</code><code class="w"> </code><code class="n">dolly</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Sheep</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="s">"Dolly"</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Animal</code><code class="o">&gt;</code><code class="w"> </code><code class="n">dollyClone</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dolly</code><code class="o">-&gt;</code><code class="n">clone</code><code class="p">();</code><code class="w"/>

<code class="w">   </code><code class="n">dolly</code><code class="o">-&gt;</code><code class="n">makeSound</code><code class="p">();</code><code class="w">       </code><code class="c1">// Triggers the first Dolly's beastly sound</code>
<code class="w">   </code><code class="n">dollyClone</code><code class="o">-&gt;</code><code class="n">makeSound</code><code class="p">();</code><code class="w">  </code><code class="c1">// The clone sounds just like Dolly</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Comparison Between Prototype and std::variant" data-type="sect2"><div class="sect2" id="idm45043088719120">
<h2>Comparison Between Prototype and std::variant</h2>
<p>The<a data-primary="Prototype design pattern" data-secondary="abstract copy operations" data-tertiary="Prototype versus std::variant" data-type="indexterm" id="idm45043088297216"/> Prototype design pattern really is a classic, very OO-centric design pattern, and
since its publication in 1994, it is <em>the</em> go-to solution for providing <code>virtual</code>
copying. Because of this, the function name <code>clone()</code> can almost be considered a keyword
for identifying the Prototype design pattern.</p>
<p>Because of the specific use case, there is no “modern” implementation (except perhaps for
the slight update to use <code>std::unique_ptr</code> instead of a raw pointer). In comparison to
other design patterns, there is also no value semantics solution: as soon as we
have a value, the most natural and intuitive solution would be to build on the two copy
operations (the copy constructor and the copy assignment operator).</p>
<p>“Are you sure that there is no value semantics solution? Consider the following
example using <code>std::variant</code>:”</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;variant&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Dog</code><code class="w"> </code><code class="p">{};</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">Cat</code><code class="w"> </code><code class="p">{};</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">Sheep</code><code class="w"> </code><code class="p">{};</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">variant</code><code class="o">&lt;</code><code class="n">Dog</code><code class="p">,</code><code class="n">Cat</code><code class="p">,</code><code class="n">Sheep</code><code class="o">&gt;</code><code class="w"> </code><code class="n">animal1</code><code class="p">{</code><code class="w"> </code><code class="cm">/* ... */</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">animal2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">animal1</code><code class="p">;</code><code class="w">  </code><code class="c1">// Creating a copy of the animal</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>“Aren’t we performing an abstract copy operation in this case? And isn’t this copy
operation performed by the copy constructor? So isn’t this an example of
the Prototype design pattern but without the <code>clone()</code> function?” No. Although
it sounds like you have a compelling argument, this is not an example of the
Prototype design pattern. There is a very important difference between our two
examples: in your example, you have a closed set of types (typical of the Visitor
design pattern). The <code>std::variant</code> <code>animal1</code> contains a dog, a cat, or a sheep,
but nothing else. Therefore, it is possible to perform an explicit copy with the
copy constructor. In my example, I have an open set of types. In other words, I haven’t the slightest clue what kind of animal I have to copy. It could be a dog, a cat,
or a sheep, but it could also be an elephant, a zebra, or a sloth. Anything is possible.
Therefore, I can’t build on the copy constructor but can only copy using a virtual
<code>clone()</code> function.</p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the Prototype Design Pattern" data-type="sect2"><div class="sect2" id="idm45043088232416">
<h2>Analyzing the Shortcomings of the Prototype Design Pattern</h2>
<p>Yes, there<a data-primary="Prototype design pattern" data-secondary="abstract copy operations" data-tertiary="Prototype shortcomings" data-type="indexterm" id="idm45043088230848"/> is no value semantics solution for the Prototype design pattern, but
it’s a domestic beast from the realm of reference semantics. Hence, whenever the need arises
to apply the Prototype design pattern, we have to live with the few drawbacks that come
with it.</p>
<p>Arguably, the first disadvantage is the negative performance impact that comes with the
indirection due to pointers. However, since we only require cloning if we have an
inheritance hierarchy, it would be unfair to consider this a drawback of Prototype itself.
It is rather a consequence of the basic setup of the problem. Since it’s also hard to imagine
another implementation without pointers and the associated indirections, it seems
to be an intrinsic property of the Prototype design pattern.</p>
<p>The second potential disadvantage is that, very often, the pattern is implemented by dynamic memory. The allocation itself, and also the possible resulting fragmented memory,
causes further performance deficiencies. Dynamic memory is not a requirement, however, and
you will see in <a data-type="xref" href="ch08.xhtml#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a> that in
certain contexts, you can also build on in-class memory. Still, this optimization applies
to only a few special situations, and in most cases, the pattern builds on dynamic memory.</p>
<p>In comparison to the ability to perform an abstract copy operation, the few downsides are
easily acceptable. However, as discussed in <a data-type="xref" href="ch05.xhtml#prefer_value_semantics_to_reference_semantics">“Guideline 22: Prefer Value Semantics over 
<span class="keep-together">Reference Semantics</span>”</a>,
our <code>Animal</code> hierarchy would be simpler and more comprehensible if you could replace
it with a value semantics approach and therefore avoid having to apply the reference semantics–based Prototype design pattern. Still, whenever you encounter the need to create an abstract
copy, the Prototype design pattern with a corresponding <code>clone()</code> function is the right choice.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043088150272">
<h5>Guideline 30: Apply Prototype for Abstract Copy Operations</h5>
<ul>
<li>
<p>Apply the Prototype design pattern with the intent to create copies of abstract entities.</p>
</li>
<li>
<p>Prefer building on the two copy operations for value types.</p>
</li>
<li>
<p>Keep in mind the performance drawbacks resulting from pointer indirections and memory allocations.<a data-primary="" data-startref="PDPabstract07" data-type="indexterm" id="idm45043088146384"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism" data-type="sect1"><div class="sect1" id="use_external_polymorphism_for_non_intrusive_runtime_polymorphism">
<h1>Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism</h1>
<p>In <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>, we<a data-primary="External Polymorphism design pattern" data-secondary="nonintrusive runtime polymorphism" data-type="indexterm" id="EPDPpoly07"/> saw the enormous benefits of the separation of concerns
design principle. In <a data-type="xref" href="ch05.xhtml#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>,
we used this power to extract the drawing implementation details from a set of shapes
with the Strategy design pattern. However, although this has significantly reduced
dependencies, and despite the fact that we modernized the solution in
<a data-type="xref" href="ch05.xhtml#prefer_a_value_based_implementation_of_strategy_and_command">“Guideline 23: Prefer a Value-Based Implementation of Strategy and Command”</a> with the
help of <code>std::function</code>, some disadvantages remained. In particular, the shape classes were
still forced to deal with the <code>draw()</code> operation, although for coupling reasons, it is
undesirable to deal with the implementation details. Additionally, and most importantly,
the Strategy approach proved to be a little impractical for extracting multiple, polymorphic
operations. To further reduce coupling and extract polymorphic operations from
our shapes, we are now continuing this journey and taking the separation of concerns principle
to a completely new, potentially unfamiliar level: we are separating the polymorphic behavior
as a whole. For that purpose, we will apply the External Polymorphism design pattern.</p>
<section data-pdf-bookmark="The External Polymorphism Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043088138304">
<h2>The External Polymorphism Design Pattern Explained</h2>
<p>Let’s<a data-primary="External Polymorphism design pattern" data-secondary="nonintrusive runtime polymorphism" data-tertiary="External Polymorphism explained" data-type="indexterm" id="idm45043088136336"/> return to our example of drawing shapes and our latest version of our <code>Circle</code>
class from
<a data-type="xref" href="ch05.xhtml#prefer_a_value_based_implementation_of_strategy_and_command">“Guideline 23: Prefer a Value-Based Implementation of Strategy and Command”</a>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Shape</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_1" id="code_g31_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Circle.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;functional&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">function</code><code class="o">&lt;</code><code class="kt">void</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="p">)</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_2" id="code_g31_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given radius is valid and that
         the given 'std::function' instance is not empty */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g31_3" id="code_g31_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p class="less_space pagebreak-before">With the Strategy design pattern, we have overcome the initial strong coupling to
the implementation details of the <code>draw()</code> member function
(<a class="co" href="#code_g31_1" id="para_g31_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
We’ve also found a value semantics solution based on <code>std::function</code>
(<a class="co" href="#code_g31_2" id="para_g31_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
However, the <code>draw()</code> member function is still part of the public interface of all classes
deriving from the <code>Shape</code> base class, and all shapes inherit the obligation to implement it
(<a class="co" href="#code_g31_3" id="para_g31_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>).
This is a clear imperfection: arguably, the drawing functionality should be separate,
an isolated aspect of shapes, and shapes in general should be oblivious to the fact
that they can be drawn.<sup><a data-type="noteref" href="ch07.xhtml#idm45043087922656" id="idm45043087922656-marker">12</a></sup> The fact that we have already extracted the implementation
details considerably strengthens this argument.</p>
<p>“Well, then, let’s just extract the <code>draw()</code> member function, right?” you argue. And you’re right. Unfortunately, this appears to be a hard thing to do at first sight. I hope you
remember <a data-type="xref" href="ch04.xhtml#design_for_the_addition_of_types_or_operations">“Guideline 15: Design for the Addition of 
<span class="keep-together">Types or Operations</span>”</a>, where we came to the conclusion
that you should prefer an object-oriented solution when you primarily want to add types.
From this perspective, it appears as if we are stuck with the virtual <code>draw()</code> function and
the <code>Shape</code> base class, which represents the set of available operations of all shapes, i.e.,
the list of requirements.</p>
<p>There is a solution, though. A pretty astonishing one: we can extract the complete
polymorphic behavior with the External Polymorphism design pattern. The pattern
was introduced in a paper by Chris Cleeland, Douglas C. Schmidt, and Timothy H. Harrison in
1996.<sup><a data-type="noteref" href="ch07.xhtml#idm45043087918336" id="idm45043087918336-marker">13</a></sup> Its intent is to enable the polymorphic treatment of
nonpolymorphic types (types without a single virtual function).</p>
<div data-type="tip"><h1>The External Polymorphism Design Pattern</h1>
<p>Intent: “Allow<a data-primary="External Polymorphism design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043087915984"/> C++ classes unrelated by inheritance and/or having no virtual methods to
be treated polymorphically. These unrelated classes can be treated in a common manner by
software that uses them.”</p>
</div>
<p><a data-type="xref" href="#fig_external_polymorphism_shape">Figure 7-7</a> gives<a data-primary="External Polymorphism design pattern" data-secondary="nonintrusive runtime polymorphism" data-tertiary="UML diagram" data-type="indexterm" id="idm45043087822656"/> a first impression of how the design pattern
achieves this goal. One of the first striking details is that there is no <code>Shape</code> base
class anymore. In the External Polymorphism design pattern, the different kinds of shapes
(<code>Circle</code>, <code>Square</code>, etc.) are assumed to be plain, nonpolymorphic types. Also, the shapes
are not expected to know anything about drawing. Instead of requiring the shapes to inherit
from a <code>Shape</code> base class, the design pattern introduces a separate inheritance hierarchy
in the form of the <code>ShapeConcept</code> and <code>ShapeModel</code> classes. This external hierarchy

<span class="keep-together">introduces</span> the polymorphic behavior for the shapes by introducing all the operations and
requirements that are expected for shapes.</p>
<figure><div class="figure" id="fig_external_polymorphism_shape">
<img alt="The UML representation of the _External Polymorphism_ design pattern." height="518" src="assets/cpsd_0707.png" width="938"/>
<h6><span class="label">Figure 7-7. </span>The UML representation of the <em>External Polymorphism</em> design pattern</h6>
</div></figure>
<p>In our simple example, the polymorphic behavior consists of only the <code>draw()</code> function.
However, the set of requirements could, of course, be larger (e.g., <code>rotate()</code>, <code>serialize()</code>, etc.). This set of virtual functions has been moved into the abstract <code>ShapeConcept</code> class, which now takes the place of the previous <code>Shape</code> base class. The major difference is that concrete shapes are not required to know about 
<span class="keep-together"><code>ShapeConcept</code></span> and, in particular, are not expected to inherit
from it. Thus, the shapes are completely decoupled from the set of virtual functions. The
only class inheriting from <code>ShapeConcept</code> is the <code>ShapeModel</code> class template. This class is
instantiated for a specific kind of shape (<code>Circle</code>, <code>Square</code>, etc.) and acts as a wrapper
for it. However, 
<span class="keep-together"><code>ShapeModel</code></span> does not implement the logic of the virtual functions itself
but delegates the request to the desired implementation.</p>
<p>“Wow, that’s amazing! I get the point: this external hierarchy extracts the whole set of
virtual functions and, by that, the entire polymorphic behavior of the shapes.” Yes, exactly.
Again, this is an example of separation of concerns and the SRP. In this case, the complete polymorphic behavior is identified as a
<em>variation point</em> and extracted from the shapes. And again, SRP acts as an enabler for
the OCP: with the <code>ShapeModel</code> class template, you can easily add any new, nonpolymorphic shape type into the <code>ShapeConcept</code> hierarchy.
This works as long as the new type fulfills all of the required operations.</p>
<p>“I’m really impressed. However, I’m not certain what you mean by fulfilling all of the
required operations. Could you please elaborate?” Absolutely! I think the benefits
will become clear when I show you a concrete code example. So let’s refactor the complete drawing
of the shapes example with the External Polymorphism design pattern.</p>
</div></section>
<section data-pdf-bookmark="Drawing of Shapes Revisited" data-type="sect2"><div class="sect2" id="idm45043087808256">
<h2>Drawing of Shapes Revisited</h2>
<p>Let’s<a data-primary="External Polymorphism design pattern" data-secondary="nonintrusive runtime polymorphism" data-tertiary="drawing of shapes revisited" data-type="indexterm" id="idm45043087806304"/> start with the <code>Circle</code> and <code>Square</code> classes:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Circle.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="cm">/* Checking that the given radius is valid */</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Several more getters and circle-specific utility functions */</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Several more data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Square.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Square</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">side_</code><code class="p">(</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="cm">/* Checking that the given side length is valid */</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Several more getters and square-specific utility functions */</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Several more data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>Both classes have been reduced to basic geometric entities. Both are completely
nonpolymorphic, i.e., there is no base class anymore and not a single virtual function.
Most importantly, however, the two classes are completely oblivious to any kind of
operation, like drawing, rotating, serialization, etc., that could introduce an artificial
dependency.</p>
<p>Instead, all of this functionality is introduced in the <code>ShapeConcept</code> base
class and implemented by the <code>ShapeModel</code> class template:<sup><a data-type="noteref" href="ch07.xhtml#idm45043087693424" id="idm45043087693424-marker">14</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;functional&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;stdexcept&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConcept</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">ShapeConcept</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_4" id="code_g31_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Potentially more polymorphic operations
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeModel</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w">  </code><a class="co" href="#para_g31_5" id="code_g31_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">function</code><code class="o">&lt;</code><code class="kt">void</code><code class="p">(</code><code class="n">ShapeT</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="p">)</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_7" id="code_g31_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">ShapeModel</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">shape_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given 'std::function' is not empty */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="n">shape_</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g31_9" id="code_g31_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Potentially more polymorphic operations
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_6" id="code_g31_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_8" id="code_g31_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p class="less_space pagebreak-before">The <code>ShapeConcept</code> class introduces a pure virtual <code>draw()</code> member function
(<a class="co" href="#code_g31_4" id="para_g31_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>).
In our example, this one virtual function represents the entire set of requirements for
shapes. Despite the small size of the set, the <code>ShapeConcept</code> class represents a classic
abstraction in the sense of the LSP (see
<a data-type="xref" href="ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>). This abstraction is implemented
within the <code>Shape​Model</code> class template
(<a class="co" href="#code_g31_5" id="para_g31_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
It is noteworthy that instantiations of 
<span class="keep-together"><code>ShapeModel</code></span> are the only classes to ever inherit
from <code>ShapeConcept</code>; no other class is expected to enter in this relationship. The

<span class="keep-together"><code>ShapeModel</code></span> class template will be instantiated for every desired type of shape, i.e.,
the <code>ShapeT</code> template parameter is a stand-in for types like <code>Circle</code>, <code>Square</code>, etc.
Note that <code>ShapeModel</code> stores an instance of the corresponding shape
(<a class="co" href="#code_g31_6" id="para_g31_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>)
(composition, not inheritance; remember <a data-type="xref" href="ch05.xhtml#favor_composition_over_inheritance">“Guideline 20: Favor Composition over Inheritance”</a>).
It acts as a wrapper that augments the specific shape type with the required
polymorphic behavior (in our case, the <code>draw()</code> function).</p>
<p>Since <code>ShapeModel</code> implements the <code>ShapeConcept</code> abstraction, it needs to provide an
implementation for the <code>draw()</code> function. However, it is not the responsibility of the
<code>ShapeModel</code> to implement the <code>draw()</code> details itself. Instead, it should forward a
drawing request to the actual implementation. For that purpose, we can again reach for
the Strategy design pattern and the abstracting power of <code>std::function</code>
(<a class="co" href="#code_g31_7" id="para_g31_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).
This choice nicely decouples both the implementation details of drawing and all the necessary drawing data (colors, textures, transparency, etc.), which can be
stored inside the callable. Hence, <code>ShapeModel</code> stores an instance of <code>DrawStrategy</code>
(<a class="co" href="#code_g31_8" id="para_g31_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>)
and uses that strategy whenever the <code>draw()</code> function is triggered
(<a class="co" href="#code_g31_9" id="para_g31_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).</p>
<p>The Strategy design pattern and the <code>std::function</code> are not
your only choices, though. Within the <code>ShapeModel</code> class template, you have complete
flexibility to implement drawing as you see fit. In other words, within the
<code>ShapeModel::draw()</code> function, you define the actual requirements for the specific
shape types. For instance, you could alternatively forward to a member function of
the <code>ShapeT</code> shape (which does not have to be named <code>draw()</code>!), or you could forward
to a free function of the shape.
You just need to make sure that you do not impose artificial requirements on either the
<code>ShapeModel</code> or the <code>ShapeConcept</code> abstraction. Either way, any type used to instantiate
<code>ShapeModel</code> must fulfill these requirements to make the code compile.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>From a design perspective, building on a member function would introduce a more restrictive
requirement on the given type, and therefore introduce stronger coupling. Building on a free
function, however, would enable you to invert dependencies, similar to the use of the
Strategy design pattern (see <a data-type="xref" href="ch02.xhtml#pay_attention_to_the_ownership_of_abstractions">“Guideline 9: Pay Attention to the Ownership of Abstractions”</a>).
If you prefer the free function approach, just remember
<a data-type="xref" href="ch02.xhtml#understand_the_semantic_requirements_of_overload_sets">“Guideline 8: Understand the Semantic Requirements of Overload Sets”</a>.</p>
</div>
<p>“Isn’t <code>ShapeModel</code> some kind of generalization of the initial <code>Circle</code> and <code>Square</code>
classes? The ones that were also holding the <code>std::function</code> instance?” Yes, this is
an excellent realization. Indeed, you could say that <code>ShapeModel</code> is kind of a templated
version of the initial shape classes. For this reason it helps to reduce the boilerplate
code necessary to introduce the Strategy behavior and improves the implementation with
respect to the DRY principle (see <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>). However, you gain a lot more:
for instance, since <code>ShapeModel</code> is already a class template, you can easily switch from
the current runtime Strategy implementation to a compile-time Strategy implementation
(i.e., policy-based design; see
<a data-type="xref" href="ch05.xhtml#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g31_10" id="code_g31_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeModel</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">ShapeModel</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">shape_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="n">shape_</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Instead of building on <code>std::function</code>, you can pass an additional template parameter
to the <code>ShapeModel</code> class template, which represents the drawing Strategy
(<a class="co" href="#code_g31_10" id="para_g31_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).
This template parameter could even have a default:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">DefaultDrawer</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="k">operator</code><code class="p">()(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">obj</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">draw</code><code class="p">(</code><code class="n">obj</code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w"/>
<code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DefaultDrawer</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">ShapeModel</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">ShapeModel</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DefaultDrawer</code><code class="p">{}</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... as before</code>
<code class="p">};</code><code class="w"/></pre>
<p>In comparison to applying policy-based design to the <code>Circle</code> and <code>Square</code> classes
directly, the compile-time approach in this context holds only benefits and comes with no
disadvantages. First, you gain performance due to fewer runtime indirections (the expected
performance disadvantage of <code>std::function</code>). Second, you do not artificially augment
<code>Circle</code>, <code>Square</code>, and all the other shape classes with a template argument to configure
the drawing behavior. You now only do this for the wrapper, which augments the drawing
behavior, and you do this in exactly one place (which again very nicely adheres to the DRY principle).
Third, you do not force additional code into a header file by turning a regular class
into a class template. Only the slim <code>ShapeModel</code> class, which is already a class template,
needs to reside in a header file. Therefore, you avoid creating additional dependencies.</p>
<p>“Wow, this design pattern is getting better and better. This seriously is a very compelling
combination of inheritance and templates!” Yes, I completely agree. This is 
<span class="keep-together">an exemplar</span>
for combining runtime and compile-time polymorphism: the 
<span class="keep-together"><code>ShapeConcept</code></span> base class provides
the abstraction for all possible types, while the deriving <code>ShapeModel</code> class template provides
the code generation for shape-specific code. Most impressively, however, this combination comes
with huge benefits for the reduction of dependencies.</p>
<p>Take a look at
<a data-type="xref" href="#fig_external_polymorphism_dependency_graph">Figure 7-8</a>, which shows the dependency graph for our
implementation of the External Polymorphism design pattern. On the highest level of our
architecture are the <code>ShapeConcept</code> and <code>ShapeModel</code> classes, which together represent
the abstraction of shapes. <code>Circle</code> and <code>Square</code> are possible implementations of this abstraction
but are still completely independent: no inheritance relationship, no composition, nothing. Only
the instantiation of the <code>ShapeModel</code> class template for a specific kind of shape and a specific
<code>DrawStrategy</code> implementation brings all aspects together. However, specifically note that all
of this happens on the lowest level of our architecture: the template code is generated at the
point where all dependencies are known and “injected” into the right level of our
architecture. Thus, we truly have a proper architecture: all dependency connections run toward
the higher levels with an almost automatic adherence to<a data-primary="External Polymorphism design pattern" data-secondary="nonintrusive runtime polymorphism" data-tertiary="dependency graph" data-type="indexterm" id="idm45043087021952"/> the DIP.</p>
<figure><div class="figure" id="fig_external_polymorphism_dependency_graph">
<img alt="The dependency graph for the _External Polymorphism_ design pattern." height="1240" src="assets/cpsd_0708.png" width="1439"/>
<h6><span class="label">Figure 7-8. </span>Dependency graph for the <em>External Polymorphism</em> design pattern</h6>
</div></figure>
<p>With this functionality in place, we are now free to implement any desired drawing behavior.
For instance, we are free to use OpenGL again:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;OpenGLDrawStrategy.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Circle&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Square&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include </code><code class="cm">/* OpenGL graphics library headers */</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">OpenGLDrawStrategy</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">OpenGLDrawStrategy</code><code class="p">(</code><code class="w"> </code><code class="cm">/* Drawing related arguments */</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">operator</code><code class="p">(</code><code class="p">)</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">circle</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_11" id="code_g31_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">operator</code><code class="p">(</code><code class="p">)</code><code class="p">(</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_12" id="code_g31_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="cm">/* Drawing related data members, e.g. colors, textures, ... */</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Since <code>OpenGLDrawStrategy</code> does not have to inherit from any base class, you are free to
implement it as you see fit. If you want to, you can combine the implementation
of drawing circles and drawing squares into one class. This does not create any artificial
dependencies, similar to what we experienced in
<a data-type="xref" href="ch05.xhtml#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>, where we combined these
functionalities into the base class.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Note that combining drawing circles and squares in one class represents the same thing as
inheriting the class from two Strategy base classes. On that level of the architecture,
it does not create any artificial dependencies and is merely an implementation detail.</p>
</div>
<p>The only convention you need to follow is to provide a function call operator for <code>Circle</code>
(<a class="co" href="#code_g31_11" id="para_g31_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>)
and <code>Square</code>
(<a class="co" href="#code_g31_12" id="para_g31_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>),
as this is the defined calling convention in the 
<span class="keep-together"><code>ShapeModel</code></span> class template.</p>
<p>In the <code>main()</code> function, we put all of the details together:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Square.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;OpenGLDrawStrategy.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;vector&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">Shapes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">ShapeConcept</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_13" id="code_g31_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">CircleModel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ShapeModel</code><code class="o">&lt;</code><code class="n">Circle</code><code class="p">,</code><code class="n">OpenGLDrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_14" id="code_g31_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">SquareModel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ShapeModel</code><code class="o">&lt;</code><code class="n">Square</code><code class="p">,</code><code class="n">OpenGLDrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_15" id="code_g31_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Shapes</code><code class="w"> </code><code class="n">shapes</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Creating some shapes, each one
</code><code class="w">   </code><code class="c1">//   equipped with an OpenGL drawing strategy
</code><code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">CircleModel</code><code class="o">&gt;</code><code class="p">(</code><code class="w">
</code><code class="w">         </code><code class="n">Circle</code><code class="p">{</code><code class="mf">2.3</code><code class="p">}</code><code class="p">,</code><code class="w"> </code><code class="n">OpenGLDrawStrategy</code><code class="p">(</code><code class="cm">/*...red...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">SquareModel</code><code class="o">&gt;</code><code class="p">(</code><code class="w">
</code><code class="w">         </code><code class="n">Square</code><code class="p">{</code><code class="mf">1.2</code><code class="p">}</code><code class="p">,</code><code class="w"> </code><code class="n">OpenGLDrawStrategy</code><code class="p">(</code><code class="cm">/*...green...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">CircleModel</code><code class="o">&gt;</code><code class="p">(</code><code class="w">
</code><code class="w">         </code><code class="n">Circle</code><code class="p">{</code><code class="mf">4.1</code><code class="p">}</code><code class="p">,</code><code class="w"> </code><code class="n">OpenGLDrawStrategy</code><code class="p">(</code><code class="cm">/*...blue...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Drawing all shapes
</code><code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">shape</code><code class="o">-</code><code class="o">&gt;</code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>Again, we first create an empty vector of shapes (this time a vector of <code>std::unique_ptr</code>s
of <code>ShapeConcept</code>)
(<a class="co" href="#code_g31_13" id="para_g31_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>)
before we add three shapes. Within the calls to <code>std::make_unique()</code>, we instantiate the
<code>ShapeModel</code> class for <code>Circle</code> and <code>Square</code> (called <code>CircleModel</code>
(<a class="co" href="#code_g31_14" id="para_g31_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>)
and <code>SquareModel</code>
(<a class="co" href="#code_g31_15" id="para_g31_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>)
to improve readability) and pass the necessary details (the concrete shape and the
corresponding 
<span class="keep-together"><code>OpenGLDrawStrategy</code></span>). After that, we are able to draw all shapes in the desired way.</p>
<p>Altogether, this approach gives you a lot of awesome advantages:</p>
<ul>
<li>
<p>Due to separating concerns and extracting the polymorphic behavior from the shape types,
you remove all dependencies on graphics libraries, etc. This creates a very loose coupling
and beautifully adheres to the <em>SRP</em>.</p>
</li>
<li>
<p>The shape types become simpler and nonpolymorphic.</p>
</li>
<li>
<p>You’re able to easily add new kinds of shapes. These might even be third-party types,
as you are no longer required to intrusively inherit from a <code>Shape</code> base class or
create an Adapter (see <a data-type="xref" href="ch06.xhtml#use_adapters_to_standardize_interfaces">“Guideline 24: Use Adapters to Standardize Interfaces”</a>).
Thus, you perfectly adhere to the OCP.</p>
</li>
<li>
<p>You significantly reduce the usual inheritance-related boilerplate code and implement it
in exactly one place, which very nicely follows the DRY principle.</p>
</li>
<li>
<p>Since the <code>ShapeConcept</code> and <code>ShapeModel</code> class belong together and together form
the abstraction, it’s much easier to adhere to the DIP.</p>
</li>
<li>
<p>By reducing the number of indirections by exploiting the available class template,
you can improve performance.</p>
</li>
</ul>
<p>There is one more advantage, which I consider to be the most impressive benefit of the
External Polymorphism design pattern: you can, nonintrusively, equip any type with
polymorphic behavior. Really, <em>any</em> type, even something as simple as an <code>int</code>. To demonstrate
this, let’s take a look at the following code snippet, which assumes that <code>ShapeModel</code>
is equipped with a <code>DefaultDrawer</code>, which expects the wrapped type to provide a free
<code>draw()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="kt">int</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g31_16" id="code_g31_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... drawing an int, for instance by printing it to the command line
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">ShapeModel</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="mi">42</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g31_17" id="code_g31_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">shape</code><code class="o">-</code><code class="o">&gt;</code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Drawing the integer  </code><a class="co" href="#para_g31_18" id="code_g31_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>We first provide a free <code>draw()</code> function for an <code>int</code>
(<a class="co" href="#code_g31_16" id="para_g31_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>).
In the <code>main()</code> function, we now instantiate a <code>ShapeModel</code> for <code>int</code>
(<a class="co" href="#code_g31_17" id="para_g31_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>).
This line will compile, as the <code>int</code> satisfies all the requirements: it provides a free
<code>draw()</code> function. Therefore, in the next line we can “draw” the integer
(<a class="co" href="#code_g31_18" id="para_g31_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>).</p>
<p>“Do you really want me to do something like this?” you ask, frowning. No, I do not
want you to do this at home. Please consider this a technical demonstration, not a
recommendation. But nonetheless, this is impressive: we have just nonintrusively equipped an
<code>int</code> with polymorphic behavior. Really impressive indeed!</p>
</div></section>
<section data-pdf-bookmark="Comparison Between External Polymorphism and Adapter" data-type="sect2"><div class="sect2" id="idm45043086436096">
<h2>Comparison Between External Polymorphism and Adapter</h2>
<p>“Since you<a data-primary="External Polymorphism design pattern" data-secondary="nonintrusive runtime polymorphism" data-tertiary="External Polymorphism versus Adapter design pattern" data-type="indexterm" id="idm45043086390656"/><a data-primary="Adapter design pattern" data-secondary="versus External Polymorphism design pattern" data-secondary-sortas="External Polymorphism design pattern" data-type="indexterm" id="idm45043086389568"/> just mentioned the Adapter design pattern, I
feel like it’s very similar to the External Polymorphism design pattern. What is the
difference between the two?” Excellent point! You address an issue that the original paper
by Cleeland, Schmidt, and Harrison also addresses. Yes, these two design patterns are
indeed pretty similar, yet there is a very distinctive difference: while the Adapter
design pattern is focused on standardizing interfaces and adapts a type or function to an
existing interface, the External Polymorphism design pattern creates a new, external
hierarchy to abstract from a set of related, nonpolymorphic types. So if you adapt
something to an existing interface, you (most probably) apply the Adapter design pattern.
If, however, you create a new abstraction for the purpose of treating a set of existing
types polymorphically, then you (most likely) apply the External Polymorphism design
pattern.</p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the External Polymorphism &#10;Design Pattern" data-type="sect2"><div class="sect2" id="idm45043086388096">
<h2>Analyzing the Shortcomings of the External Polymorphism 
<span class="keep-together">Design Pattern</span></h2>
<p>“I get<a data-primary="External Polymorphism design pattern" data-secondary="nonintrusive runtime polymorphism" data-tertiary="External Polymorphism shortcomings" data-type="indexterm" id="idm45043086386032"/> the feeling that you like the External Polymorphism design pattern a lot, am I
right?” you wonder. Oh yes, indeed, I’m amazed by this design pattern. From
my point of view, this design pattern is key to loose coupling, and it’s a shame that it
is not more widely known. Perhaps this is because many developers have not fully embraced
the separation of concerns and tend to put everything into only a few classes.
Still, despite my enthusiasm, I do not want to create the impression that everything about
External Polymorphism is perfect. No, as stated many times before, every design has its
advantages and its disadvantages. The same is true for the External Polymorphism
design pattern.</p>
<p>There is only one major disadvantage, though: the External Polymorphism design pattern
does not really fulfill the expectations of a clean and simple solution, and definitely
not the expectations of a value semantics–based solution. It does not help to reduce
pointers, does not reduce the number of manual allocations, does not lower the number
of inheritance hierarchies, and does not help to simplify user code. On the contrary,
since it is necessary to explicitly instantiate the <code>ShapeModel</code> class, user code has
to be rated as slightly more complicated. However, if you consider this a severe
drawback, or if you’re thinking something along the lines of “This should be automated
somehow,” I have very good news for you: in
<a data-type="xref" href="ch08.xhtml#consider_replacing_inheritance_hierarchies_with_type_erasure">“Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure”</a>, we will take a look
at the modern C++ solution that will elegantly resolve this issue.</p>
<p>Apart from that, I have only two reminders that you should consider as words of caution. The first point to keep in mind is that the application of External Polymorphism does
not save you from thinking about a proper abstraction. The <code>ShapeConcept</code> base class is
just as much subject to the ISP as any other base
class. For instance, we could easily apply External Polymorphism to the <code>Document</code>
example from<a data-type="xref" href="ch01.xhtml#separate_interfaces_to_avoid_artificial_coupling">“Guideline 3: Separate Interfaces to Avoid 
<span class="keep-together">Artificial Coupling</span>”</a>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">DocumentConcept</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Document</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DocumentT</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">DocumentModel</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">DocumentT</code><code class="w"> </code><code class="n">document_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>The <code>DocumentConcept</code> class takes the role of the <code>ShapeConcept</code> base class, while the
<code>DocumentModel</code> class template takes the role of the <code>ShapeModel</code> class template. However,
this externalized hierarchy exhibits the same problem as the original hierarchy: for all
code requiring only the <code>exportToJSON()</code> functionality, it introduces the artificial
dependency on <code>ByteStream</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">exportDocument</code><code class="p">(</code><code class="w"> </code><code class="n">DocumentConcept</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">doc</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">doc</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
<p>The correct approach would be to separate concerns by segregating the interface
into the two orthogonal aspects of JSON export and serialization:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">JSONExportable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">JSONExportable</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Serializable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Serializable</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DocumentT</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">DocumentModel</code><code class="w"/>
<code class="w">   </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">JSONExportable</code><code class="w"/>
<code class="w">   </code><code class="p">,</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Serializable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">DocumentT</code><code class="w"> </code><code class="n">document_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>Any function exclusively interested in JSON export can now specifically ask for that
functionality:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">exportDocument</code><code class="p">(</code><code class="w"> </code><code class="n">JSONExportable</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">exportable</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">exportable</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
<p>Second, be aware that External Polymorphism, just as the Adapter design pattern,
makes it very easy to wrap types that do not fulfill the semantic expectations. Similar
to the duck typing example in
<a data-type="xref" href="ch06.xhtml#use_adapters_to_standardize_interfaces">“Guideline 24: Use Adapters to Standardize Interfaces”</a>, where we pretended that a
turkey is a duck, we also pretended that an <code>int</code> is a shape. All we had to do
to fulfill the requirements was provide a free <code>draw()</code> function. Easy. Perhaps too
easy. Therefore, keep in mind that the classes used to instantiate the <code>ShapeModel</code>
class template (e.g., <code>Circle</code>, <code>Square</code>, etc.) <em>have</em> to adhere to the LSP. After all, the
<code>ShapeModel</code> class acts just as a wrapper and passes on the requirements defined by the
<code>ShapeConcept</code> class to the concrete shapes. Thus, the concrete shapes take the
responsibility to properly implement the expected behavior (see
<a data-type="xref" href="ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>). Any failure to completely fulfill
the expectations may lead to (potentially subtle) misbehavior. Unfortunately, because these requirements have been externalized, it is a little harder to communicate
the expected behavior.</p>
<p>However, in the <code>int</code> example it was maybe our own fault to be honest. Perhaps the
<code>ShapeConcept</code> base class doesn’t really represent an abstraction of a shape. It is
reasonable to argue that shapes are more than just drawing. Perhaps we should have named
the abstraction <code>Drawable</code>, and the LSP would have been satisfied. Perhaps not. So in the
end, it all comes down to the choice of abstraction. Which brings us back to the title of
<a data-type="xref" href="ch02.xhtml#the_art_of_building_abstractions">Chapter 2</a>: “The Art of Building Abstractions.” No, it isn’t easy, but perhaps these examples demonstrate that it is important. Very important.
It may be the essence of software design.</p>
<p>In summary, although the External Polymorphism design pattern may not satisfy your
expectation in a simple or value-based solution, it must be considered a very important step
toward decoupling software entities. From the perspective of reducing dependencies, this
design pattern appears to be a key ingredient to loose coupling, and is a marvelous example
of the power of separation of concerns. It also gives us one key insight: using this
design pattern, you can nonintrusively equip any type with polymorphic behavior,
e.g., virtual functions, so <em>any</em> type can behave polymorphically, even a simple value type
such as <code>int</code>. This realization opens up a completely new, exciting design space,
which we will continue to explore in the next chapter.</p>
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043085831024">
<h5>Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism</h5>
<ul>
<li>
<p>Apply the External Polymorphism design pattern with the intent to enable the polymorphic treatment of nonpolymorphic types.</p>
</li>
<li>
<p>Consider the External Polymorphism design pattern as a key player to achieve loose coupling.</p>
</li>
<li>
<p>Exploit the design flexibilities of the externalized inheritance hierarchy.</p>
</li>
<li>
<p>Understand the differences between External Polymorphism and Adapter.</p>
</li>
<li>
<p>Prefer nonintrusive solutions to intrusive solutions.<a data-primary="" data-startref="EPDPpoly07" data-type="indexterm" id="idm45043085825120"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45043091750016"><sup><a href="ch07.xhtml#idm45043091750016-marker">1</a></sup> ABI stability is an important and often debated topic in the C++ community, in particular just before the release of C++20. If this sounds interesting to you, I recommend the CppCast interviews with <a href="https://oreil.ly/8rgkm">Titus Winters</a> and <a href="https://oreil.ly/R1XYJ">Marshall Clow</a> to get an impression of both sides.</p><p data-type="footnote" id="idm45043091745568"><sup><a href="ch07.xhtml#idm45043091745568-marker">2</a></sup> Remember that <code>std::unique_ptr</code> cannot be copied. Thus, switching from <code>ElectricEngine</code> to <code>std::unique_ptr&lt;ElectricEngine&gt;</code> renders your class noncopyable. To preserve copy semantics, you have to implement the copy operations manually. When doing this, please keep in mind that the copy operations disable the move operations. In other words, prefer to stick to the <a href="https://oreil.ly/fzS3f">Rule of 5</a>.</p><p data-type="footnote" id="idm45043091276160"><sup><a href="ch07.xhtml#idm45043091276160-marker">3</a></sup> Erich Gamma et al., <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p><p data-type="footnote" id="idm45043090164320"><sup><a href="ch07.xhtml#idm45043090164320-marker">4</a></sup> Usually, the move operations are expected to be <code>noexcept</code>. This is explained by <a href="https://oreil.ly/luKRb">Core Guideline C.66</a>. However, sometimes this might not be possible, for instance, under the assumption that some <code>std::unique_ptr</code> data member is never <code>nullptr</code>.</p><p data-type="footnote" id="idm45043090004848"><sup><a href="ch07.xhtml#idm45043090004848-marker">5</a></sup> See <a data-type="xref" href="ch03.xhtml#understand_the_purpose_of_design_patterns">“Guideline 11: Understand the Purpose of Design Patterns”</a> for my statement about the structural similarity of design patterns.</p><p data-type="footnote" id="idm45043089719744"><sup><a href="ch07.xhtml#idm45043089719744-marker">6</a></sup> If this dynamic allocation turns out to be a severe impediment or a reason not to use a Bridge, you might look into the Fast-Pimpl idiom, which is based on in-class memory. For that, you might refer to Herb Sutter’s first book: <em>Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Exception-Safety Solutions</em> (Pearson).</p><p data-type="footnote" id="idm45043089618368"><sup><a href="ch07.xhtml#idm45043089618368-marker">7</a></sup> The difference in size of <code>Person1</code> is easily explained by the different sizes of <code>std::string</code> implementations for different compilers. Since compiler vendors optimize <code>std::string</code> for different use cases, on Clang 11.1, a single <code>std::string</code> occupies 24 bytes, and on GCC 11.1, it occupies 32 bytes. Therefore, the total size of one instance of <code>Person1</code> is 152 bytes with Clang 11.1 (six 24-byte <code>std::string</code>s, plus one 4-byte <code>int</code>, plus 4 bytes of padding) or 200 bytes with GCC 11.1 (six 32-byte <code>std::string</code>s, plus one 4-byte <code>int</code>, plus 4 bytes of  <span class="keep-together">padding</span>).</p><p data-type="footnote" id="idm45043089228000"><sup><a href="ch07.xhtml#idm45043089228000-marker">8</a></sup> You may be aware that we are still <em>far</em> away from optimal performance. To move in the direction of optimal performance, we could arrange the data based on how it is used. For this benchmark, this would mean to store all <code>year_of_birth</code> values from all persons in one big static vector of integers. This kind of data arrangement would move us in the direction of <em>data-oriented design</em>. For more information on this paradigm, see for instance Richard Fabian’s book on the subject, <em>Data-Oriented Design: Software Engineering for Limited Resources and Short Schedules</em>.</p><p data-type="footnote" id="idm45043089050320"><sup><a href="ch07.xhtml#idm45043089050320-marker">9</a></sup> The rules when a compiler will generate these two copy operations are beyond the scope of this book, but here is a short summary: <em>every</em> class has these two operations, meaning they always exist. They have been generated by the compiler, or you have explicitly declared or even defined them (potentially in the <code>private</code> section of the class or via <code>=delete</code>), or they are implicitly deleted. Note that deleting these functions does not mean that they’re gone, but <code>=delete</code> serves as a definition. As these two functions are <em>always</em> part of a class, they will <em>always</em> participate in overload resolution.</p><p data-type="footnote" id="idm45043088713040"><sup><a href="ch07.xhtml#idm45043088713040-marker">10</a></sup> Erich Gamma et al., <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p><p data-type="footnote" id="idm45043088650448"><sup><a href="ch07.xhtml#idm45043088650448-marker">11</a></sup> <a href="https://oreil.ly/YeCHE">Core Guideline R.3</a> clearly states that a raw pointer (a <code>T*</code>) is nonowning. From this perspective, it would even be incorrect to return a raw pointer-to-base. However, this means that you cannot directly exploit the language feature of covariant return types anymore. If this is desirable or required, a common solution would be to follow the Template Method design pattern and split the <code>clone()</code> function into a <code>private</code> <code>virtual</code> function returning a raw pointer, and a <code>public</code> non-<code>virtual</code> function calling the <code>private</code> function and returning <code>std::unique_ptr</code>.</p><p data-type="footnote" id="idm45043087922656"><sup><a href="ch07.xhtml#idm45043087922656-marker">12</a></sup> See <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a> for a similar example with different kinds of documents.</p><p data-type="footnote" id="idm45043087918336"><sup><a href="ch07.xhtml#idm45043087918336-marker">13</a></sup> Chris Cleeland, Douglas C. Schmidt, and Timothy H. Harrison, “External Polymorphism—An Object Structural Pattern for Transparently Extending C++ Concrete Data Types,” Proceedings of the 3rd Pattern Languages of Programming Conference, Allerton Park, Illinois, September 4–6, 1996.</p><p data-type="footnote" id="idm45043087693424"><sup><a href="ch07.xhtml#idm45043087693424-marker">14</a></sup> The names <code>Concept</code> and <code>Model</code> are chosen based on the common terminology in the Type Erasure design pattern, where External Polymorphism plays a major role; see <a data-type="xref" href="ch08.xhtml#type_erasure">Chapter 8</a>.</p></div></div></section></div></body></html>