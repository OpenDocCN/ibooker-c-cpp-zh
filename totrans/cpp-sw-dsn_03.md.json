["```cpp\nnamespace std {\n\ntemplate< typename T, typename... Args >\nunique_ptr<T> make_unique( Args&&... args );\n\n} // namespace std\n```", "```cpp\n// This will create a 'Widget' by means of calling 'new'\nauto ptr = std::make_unique<Widget>( /* some Widget arguments */ );\n```", "```cpp\nclass Circle\n{\n public:\n   void draw( /*...*/ );  // Implemented in terms of some graphics library\n   // ...\n};\n```", "```cpp\n#include <Circle.h>\n#include <OpenGLStrategy.h>\n#include <cstdlib>\n#include <utility>\n\nint main()\n{\n   // ...\n\n   // Creating the desired drawing strategy for a circle.\n   auto strategy =\n      std::make_unique_ptr<OpenGLStrategy>( /* OpenGL-specific arguments */ );\n\n   // Injecting the strategy into the circle; the circle does not have to know\n   // about the specific kind of strategy, but can with blissful ignorance use\n   // it via the 'DrawStrategy' abstraction.\n   Circle circle( 4.2, std::move(strategy) );\n   circle.draw( /*...*/ );\n\n   // ...\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\ntemplate< typename DrawStrategy >\nclass Circle\n{\n public:\n   void draw( /*...*/ );\n};\n```", "```cpp\nstd::vector<int> v{ 1, 2, 3, 4, 5 };\nauto const sum =\n   std::accumulate( begin(v), end(v), int{0} );\n```", "```cpp\nstd::vector<int> v{ 1, 2, 3, 4, 5 };\nauto const sum =\n   std::accumulate( begin(v), end(v), int{0}, std::plus<>{} );\nauto const product =\n   std::accumulate( begin(v), end(v), int{1}, std::multiplies<>{} );\n```", "```cpp\nnamespace std {\n\ntemplate< class T\n        , class Allocator = std::allocator<T> >\nclass vector;\n\ntemplate< class Key\n        , class Compare = std::less<Key>\n        , class Allocator = std::allocator<Key> >\nclass set;\n\n} // namespace std\n```", "```cpp\n#include <array>\n#include <cstddef>\n#include <cstdlib>\n#include <memory_resource>\n#include <string>\n#include <vector>\n\nint main()\n{\n   std::array<std::byte,1000> raw;  // Note: not initialized! ![1](assets/1.png)\n\n   std::pmr::monotonic_buffer_resource\n      buffer{ raw.data(), raw.size(), std::pmr::null_memory_resource() };  ![2](assets/2.png)\n\n   std::pmr::vector<std::pmr::string> strings{ &buffer };  ![3](assets/3.png)\n\n   strings.emplace_back( \"String longer than what SSO can handle\" );\n   strings.emplace_back( \"Another long string that goes beyond SSO\" );\n   strings.emplace_back( \"A third long string that cannot be handled by SSO\" );\n\n   // ... \n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nnamespace std::pmr {\n\nclass memory_resource\n{\n public:\n   // ... a virtual destructor, some constructors and assignment operators\n\n   [[nodiscard]] void* allocate(size_t bytes, size_t alignment);\n   void deallocate(void* p, size_t bytes, size_t alignment);\n   bool is_equal(memory_resource const& other) const noexcept;\n\n private:\n   virtual void* do_allocate(size_t bytes, size_t alignment) = 0;\n   virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;\n   virtual bool do_is_equal(memory_resource const& other) const noexcept = 0;\n};\n\n} // namespace std::pmr\n```", "```cpp\nstd::pmr::monotonic_buffer_resource\n   buffer{ raw.data(), raw.size(), std::pmr::null_memory_resource() };\n```", "```cpp\nnamespace std::pmr {\n\ntemplate< class CharT, class Traits = std::char_traits<CharT> >\nusing basic_string =\n   std::basic_string< CharT, Traits,\n                      std::pmr::polymorphic_allocator<CharT> >;\n\ntemplate <class T>\nusing vector =\n   std::vector< T, std::pmr::polymorphic_allocator<T> >;\n\n} // namespace std::pmr\n```", "```cpp\ntemplate< class InputIt, class T, class BinaryOperation >\nconstexpr T accumulate( InputIt first, InputIt last, T init,\n                        BinaryOperation op );\n```", "```cpp\ntemplate< class InputIt, class T, class BinaryReductionStrategy >\nconstexpr T accumulate( InputIt first, InputIt last, T init,\n                        BinaryReductionStrategy op );\n```", "```cpp\ntemplate< class InputIt, class UnaryCommand >\nconstexpr UnaryCommand\n   for_each( InputIt first, InputIt last, UnaryCommand f );\n```", "```cpp\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <variant>\n\nstruct Print\n{\n   void operator()(int i) const {\n      std::cout << \"int: \" << i << '\\n';\n   }\n   void operator()(double d) const {\n      std::cout << \"double: \" << d << '\\n';\n   }\n   void operator()(std::string const& s) const {\n      std::cout << \"string: \" << s << '\\n';\n   }\n};\n\nint main()\n{\n   std::variant<int,double,std::string> v{};  ![1](assets/1.png)\n\n   v = \"C++ Variant example\";  ![2](assets/2.png)\n\n   std::visit(Print{}, v);  ![3](assets/3.png)\n\n   return EXIT_SUCCESS;\n}\n\n```"]