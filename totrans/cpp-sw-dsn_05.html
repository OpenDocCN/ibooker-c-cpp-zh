<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 5. The Strategy and Command &#10;Design Patterns" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_strategy_and_command_design_patterns">
<h1><span class="label">Chapter 5. </span>The Strategy and Command 
<span class="keep-together">Design Patterns</span></h1>
<p>This<a data-primary="Strategy design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043110424992"/><a data-primary="Command design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043110423984"/> chapter is devoted to two of the most commonly used design patterns: the
Strategy design pattern and the <em>Command</em> design pattern. Most commonly used indeed:
the C++ Standard Library itself uses both of them dozens of times, and it’s
very likely that you have used them many times yourself. Both of these can be considered fundamental tools for every developer.</p>
<p>In <a data-type="xref" href="#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>, I will introduce
you to the Strategy design pattern. I will demonstrate why this is one of the
most useful and most important design patterns and why you will find it useful in many
situations.</p>
<p>In <a data-type="xref" href="#favor_composition_over_inheritance">“Guideline 20: Favor Composition over Inheritance”</a>, we will take a 
<span class="keep-together">look at</span> inheritance and why
so many people complain about it. You will see that it’s not bad per se, but like
everything else, it has its benefits as well as limitations. Most importantly, however,
I will explain that many of the classic design patterns do not draw their power from
inheritance but rather from composition.</p>
<p>In <a data-type="xref" href="#use_commands_to_isolate_what_things_are_done">“Guideline 21: Use Command to Isolate What Things 
<span class="keep-together">Are Done</span>”</a>, I 
<span class="keep-together">will introduce</span> you to the Command design pattern. I will show you how to use that
design pattern productively, and also give you an idea of how Command and Strategy
compare.</p>
<p>In <a data-type="xref" href="#prefer_value_semantics_to_reference_semantics">“Guideline 22: Prefer Value Semantics over 
<span class="keep-together">Reference Semantics</span>”</a>, we take a trip into the
realm of <em>reference semantics</em>. However, we will find that this realm is not
particularly friendly and hospitable and makes us worry about the quality of
our code. Thus, we will resettle into the realm of <em>value semantics</em>, which
will welcome us with many benefits for our codebase.</p>
<p>In <a data-type="xref" href="#prefer_a_value_based_implementation_of_strategy_and_command">“Guideline 23: Prefer a Value-Based Implementation of Strategy and Command”</a>,
we will revisit the Strategy and Command patterns. I will demonstrate 
<span class="keep-together">how we can</span>
apply the insight we gained in the realm of value semantics and implement both design
patterns based on <code>std::function</code>.</p>
<section data-pdf-bookmark="Guideline 19: Use Strategy to Isolate How Things Are Done" data-type="sect1"><div class="sect1" id="use_strategy_to_isolate_how_things_are_done">
<h1>Guideline 19: Use Strategy to Isolate How Things Are Done</h1>
<p>Let’s<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-type="indexterm" id="SDPisopro05"/> imagine that you and your team are about to implement a new 2D graphics tool.
Among other requirements, it needs to deal with simple geometric primitives, such as circles,
squares, and so on, which need to be drawn<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="example inheritance hierarchy" data-type="indexterm" id="idm45043110408352"/><a data-primary="inheritance" data-secondary="example inheritance hierarchy" data-type="indexterm" id="idm45043110407200"/> (see <a data-type="xref" href="#fig_strategy_shape_hierarchy_1">Figure 5-1</a>).</p>
<figure><div class="figure" id="fig_strategy_shape_hierarchy_1">
<img alt="The initial +Shape+ inheritance hierarchy." height="486" src="assets/cpsd_0501.png" width="701"/>
<h6><span class="label">Figure 5-1. </span>The initial <code>Shape</code> inheritance hierarchy</h6>
</div></figure>
<p>A couple of classes have already been implemented, such as a <code>Shape</code> base class, a 
<span class="keep-together"><code>Circle</code></span> class,
and a <code>Square</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Shape</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_1" id="code_g19_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Circle.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Point.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given radius is valid */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">Point</code><code class="w">  </code><code class="n">center</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">center_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_2" id="code_g19_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Point</code><code class="w"> </code><code class="n">center_</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Circle.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include </code><code class="cm">/* some graphics library */</code><code class="cp">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">Circle::draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Implementing the logic for drawing a circle
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Square.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Point.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Square</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">side_</code><code class="p">(</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given side length is valid */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="w">  </code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">Point</code><code class="w">  </code><code class="n">center</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">center_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_3" id="code_g19_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Point</code><code class="w"> </code><code class="n">center_</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Square.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Square.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include </code><code class="cm">/* some graphics library */</code><code class="cp">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">Square::draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Implementing the logic for drawing a square
</code><code class="p">}</code><code class="w">
</code></pre>
<p>The most important aspect is the pure virtual <code>draw()</code> member function of the <code>Shape</code> base class
(<a class="co" href="#code_g19_1" id="para_g19_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
While you were on vacation, one of your team members already implemented this <code>draw()</code>
member function for both the <code>Circle</code> and the <code>Square</code> classes using OpenGL
(<a class="co" href="#code_g19_2" id="para_g19_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
and <a class="co" href="#code_g19_3" id="para_g19_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>).
The tool is already able to draw circles and squares, and the entire team agrees
that the resulting graphics look pretty neat. Everyone is happy!</p>
<section data-pdf-bookmark="Analyzing the Design Issues" data-type="sect2"><div class="sect2" id="idm45043109930208">
<h2>Analyzing the Design Issues</h2>
<p>Everyone, except you, that is. Returning<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="design issues" data-type="indexterm" id="idm45043109928544"/> from your vacation, you of course immediately
realize that the implemented solution violates the Single-Responsibility Principle
(SRP).<sup><a data-type="noteref" href="ch05.xhtml#idm45043109967248" id="idm45043109967248-marker">1</a></sup> As it is, the <code>Shape</code> hierarchy is not designed
for change. First, it’s not easy to change the way a shape is drawn. In the current
implementation, there is only one fixed way of drawing shapes, and it’s not possible to change
these details nonintrusively. Since you already predict that the tool will have to support
multiple graphic libraries, this is definitely a problem.<sup><a data-type="noteref" href="ch05.xhtml#idm45043109965312" id="idm45043109965312-marker">2</a></sup>
And second, if you eventually perform the change, you need to change the behavior
in multiple, unrelated places.</p>
<p>But there is more. Since the drawing functionality is implemented inside <code>Circle</code>
and <code>Square</code>, the <code>Circle</code> and <code>Square</code> classes depend on the implementation details of
<code>draw()</code>, meaning they depend on OpenGL. Despite the fact that circles and squares should
primarily be some simple geometric primitives, these two classes now carry the burden of
having to use OpenGL everywhere they are used.</p>
<p>When pointing this out to your colleagues, they are, at first, a little dumbfounded. And
also a little annoyed, since they didn’t expect you to point out any flaws in their
beautiful solution. However, you have a very nice way of explaining the problem, and eventually they agree with you and start to think about a better solution.</p>
<p>It doesn’t take them long to come up with a better approach. In the next team meeting a
few days later, they present their new idea: another layer in the inheritance hierarchy<a data-primary="inheritance" data-secondary="example inheritance hierarchy" data-type="indexterm" id="idm45043109959856"/>
(see <a data-type="xref" href="#fig_strategy_shape_hierarchy_2">Figure 5-2</a>).</p>
<figure><div class="figure" id="fig_strategy_shape_hierarchy_2">
<img alt="The extended +Shape+ inheritance hierarchy." height="811" src="assets/cpsd_0502.png" width="701"/>
<h6><span class="label">Figure 5-2. </span>The extended <code>Shape</code> inheritance hierarchy</h6>
</div></figure>
<p>To demonstrate the idea, they have already implemented the <code>OpenGLCircle</code> and

<span class="keep-together"><code>OpenGLSquare</code></span> classes:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Circle.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... No implementation of the draw() member function anymore</code>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;OpenGLCircle.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">OpenGLCircle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Circle</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">OpenGLCircle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;OpenGLCircle.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;OpenGLCircle.h&gt;</code><code class="cp"/>
<code class="cp">#include </code><code class="cm">/* OpenGL graphics library headers */</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">OpenGLCircle::draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Implementing the logic for drawing a circle by means of OpenGL</code>
<code class="p">}</code><code class="w"/>


<code class="c1">//---- &lt;Square.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... No implementation of the draw() member function anymore</code>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;OpenGLSquare.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Square.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">OpenGLSquare</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Square</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">OpenGLSquare</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">Square</code><code class="p">(</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;OpenGLSquare.cpp&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;OpenGLSquare.h&gt;</code><code class="cp"/>
<code class="cp">#include </code><code class="cm">/* OpenGL graphics library headers */</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">OpenGLSquare::draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Implementing the logic for drawing a square by means of OpenGL</code>
<code class="p">}</code><code class="w"/></pre>
<p>Inheritance! Of course! By simply deriving from <code>Circle</code> and <code>Square</code>, and by moving the
implementation of the <code>draw()</code> function further down the hierarchy, it is easily possible
to implement the drawing in different ways. For instance, there could be a <code>MetalCircle</code>
and a <code>VulkanCircle</code>, assuming that the <a href="https://developer.apple.com/metal">Metal</a> and
<a href="https://www.vulkan.org">Vulkan</a> libraries need to be supported. Suddenly, change is easy,
right?</p>
<p>While your colleagues are still very proud about their new solution, you already realize
that this approach will not work well for long. And it is easy to demonstrate the
shortcomings: all you have to do is consider another requirement, for instance, a
<code>serialize()</code> member 
<span class="keep-together">function:</span></p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Shape</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_4" id="code_g19_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The <code>serialize()</code> member function
(<a class="co" href="#code_g19_4" id="para_g19_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>)
is supposed to transform a shape into a byte sequence, which can be stored in a file or a
database. From there, it’s possible to deserialize the byte sequence to re-create the
exact same shape. And just like the <code>draw()</code> member function, the <code>serialize()</code> member function
can be implemented in various ways. For instance, you could reach for the
<a href="https://oreil.ly/Q71oF">protobuf</a> or
<a href="https://oreil.ly/1m84h">Boost.serialization</a>
libraries.</p>
<p>Using the same strategy of moving the implementation details down the inheritance hierarchy,
this will quickly lead to a pretty complex and rather artificial hierarchy (see
<a data-type="xref" href="#fig_strategy_shape_hierarchy_3">Figure 5-3</a>). Consider the class names: <code>OpenGLProtobufCircle</code>,
<code>MetalBoostSerial​Square</code>, and so on. Ridiculous, right? And how should we structure this: should
we add another layer in the hierarchy (see the <code>Square</code> branch)? That approach would quickly
lead to a deep and complex hierarchy. Or should we rather flatten the hierarchy out (as in
the <code>Circle</code> branch of the hierarchy)? And what about reusing implementation details? For
instance, how would it be possible to reuse the OpenGL code between the <code>OpenGLProtobufCircle</code>
and the <code>OpenGLBoostSerialCircle</code> classes?</p>
<figure><div class="figure" id="fig_strategy_shape_hierarchy_3">
<img alt="Adding the +serialize()+ member function results in a deep and complex inheritance hierarchy." height="1149" src="assets/cpsd_0503.png" width="1447"/>
<h6><span class="label">Figure 5-3. </span>Adding the <code>serialize()</code> member function results in a deep and complex inheritance hierarchy</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="The Strategy Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043109929616">
<h2>The Strategy Design Pattern Explained</h2>
<p>You<a data-primary="inheritance" data-secondary="example inheritance hierarchy" data-type="indexterm" id="idm45043109527072"/><a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="variation points" data-type="indexterm" id="idm45043109526224"/><a data-primary="variation points" data-secondary="in Strategy design pattern" data-secondary-sortas="Strategy design pattern" data-type="indexterm" id="idm45043109525136"/><a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="Strategy explained" data-type="indexterm" id="idm45043109524048"/> realize that your colleagues are just too enamored with inheritance, and that it’s up
to you to save the day. They appear to need someone to show them how to properly design
for this kind of change and present them a proper solution to the problem. As the
two pragmatic programmers remarked:<sup><a data-type="noteref" href="ch05.xhtml#idm45043109522832" id="idm45043109522832-marker">3</a></sup></p>
<blockquote>
<p>Inheritance is rarely the answer.</p></blockquote>
<p>The problem is still the violation of the SRP. Since you have to plan for
changing how the different shapes are drawn, you should identify the drawing aspect as a
<em>variation point</em>. With this realization, the correct approach is to design for change,
follow the SRP, and thus extract the variation point. That is the intent of the
Strategy design pattern, one of the classic GoF design patterns.</p>
<div data-type="tip"><h1>The Strategy Design Pattern</h1>
<p>Intent: “Define<a data-primary="Strategy design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043109518864"/> a family of algorithms, encapsulate each one, and make them interchangeable.
Strategy lets the algorithm vary independently from clients that use it.”<sup><a data-type="noteref" href="ch05.xhtml#idm45043109517728" id="idm45043109517728-marker">4</a></sup></p>
</div>
<p>Instead of implementing the virtual <code>draw()</code> function in a derived class, you introduce another
class for the purpose of drawing shapes. In the case of the classic, object-oriented (OO) form of
the Strategy design pattern, this is achieved by introducing the <code>DrawStrategy</code> base class<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="UML diagram" data-type="indexterm" id="idm45043109515248"/> (see
<a data-type="xref" href="#fig_strategy_shape_2">Figure 5-4</a>).</p>
<figure><div class="figure" id="fig_strategy_shape_2">
<img alt="The UML representation of the _Strategy_ design pattern." height="486" src="assets/cpsd_0504.png" width="1062"/>
<h6><span class="label">Figure 5-4. </span>The UML representation of the <em>Strategy</em> design pattern</h6>
</div></figure>
<p>The isolation of the drawing aspect now allows us to change the implementation of drawing
without having to modify the shape classes. This fulfills the idea of the SRP. You are
now also able to introduce new implementations of <code>draw()</code> without modification of any
other code. That fulfills the Open-Closed Principle (OCP). Once again, in this OO setting,
SRP is the enabler of the OCP.</p>
<p>The following code snippet shows a naive implementation of the <code>DrawStrategy</code> base
class:<sup><a data-type="noteref" href="ch05.xhtml#idm45043109508880" id="idm45043109508880-marker">5</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;DrawStrategy.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="p">;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">DrawStrategy</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_5" id="code_g19_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">square</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_6" id="code_g19_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The <code>DrawStrategy</code> class comes with a virtual destructor and two pure virtual <code>draw()</code>
functions, one for circles
(<a class="co" href="#code_g19_5" id="para_g19_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>)
and one for squares
(<a class="co" href="#code_g19_6" id="para_g19_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).
For this base class to compile, you need to forward declare the <code>Circle</code> and the
<code>Square</code> classes.</p>
<p>The <code>Shape</code> base class does not change due to the Strategy design pattern. It still
represents an abstraction for all shapes and thus offers a pure virtual <code>draw()</code> member
function. Strategy aims at extracting implementation details and thus affects only the
derived classes:<sup><a data-type="noteref" href="ch05.xhtml#idm45043109417808" id="idm45043109417808-marker">6</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Shape.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Shape</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Potentially other functions, e.g. a 'serialize()' member function</code>
<code class="p">};</code><code class="w"/></pre>
<p>While the <code>Shape</code> base class does not change due to Strategy, the <code>Circle</code> and <code>Square</code>
classes are affected:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Circle.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;DrawStrategy.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g19_7" id="code_g19_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g19_8" id="code_g19_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given radius is valid and that
         the given std::unique_ptr instance is not nullptr */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">drawer_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_10" id="code_g19_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_9" id="code_g19_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Square.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;DrawStrategy.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Square</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g19_7" id="code_g19_7_2"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">side_</code><code class="p">(</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g19_8" id="code_g19_8_2"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given side length is valid and that
         the given std::unique_ptr instance is not nullptr */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">drawer_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_10" id="code_g19_10_2"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_9" id="code_g19_9_2"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Both <code>Circle</code> and <code>Square</code> are now expecting a <code>unique_ptr</code> to a <code>DrawStrategy</code> in their
constructors
(<a class="co" href="#code_g19_7" id="para_g19_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).
This allows us to configure the drawing behavior from the outside, commonly called <em>dependency injection</em>. The <code>unique_ptr</code> is moved
(<a class="co" href="#code_g19_8" id="para_g19_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>)
into a new data member of the same type
(<a class="co" href="#code_g19_9" id="para_g19_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).
It is also possible to provide corresponding setter 
<span class="keep-together">functions</span>, which would allow
you to change the drawing behavior at a later point. The <code>draw()</code> member function now doesn’t have to implement the drawing itself but simply has to call the <code>draw()</code> function for
the given <code>DrawStrategy</code>
(<a class="co" href="#code_g19_10" id="para_g19_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).<sup><a data-type="noteref" href="ch05.xhtml#idm45043108959024" id="idm45043108959024-marker">7</a></sup></p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the Naive Solution" data-type="sect2"><div class="sect2" id="idm45043108931824">
<h2>Analyzing the Shortcomings of the Naive Solution</h2>
<p>Wonderful! With<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="naive implementation shortcomings" data-type="indexterm" id="idm45043108954752"/> this implementation in place, you are now able to locally, in isolation,
change the behavior of how shapes are drawn, and you enable everyone to implement the new
drawing behavior. However, as it is right now, our Strategy implementation has a serious
design flaw. To analyze this flaw, let’s assume that you have to add a new kind
of shape, maybe a <code>Triangle</code>. This should be easy, because, as we have discussed in
<a data-type="xref" href="ch04.xhtml#design_for_the_addition_of_types_or_operations">“Guideline 15: Design for the Addition of 
<span class="keep-together">Types or Operations</span>”</a>, the strength of OOP is the addition of new types.</p>
<p>As you’re starting to introduce this <code>Triangle</code>, you realize that it’s not as easy to add
the new kind of shape as expected. First, you need to write the new class. That is to be
expected and not a problem at all. But then you have to update the <code>DrawStrategy</code> base class to also enable the drawing of triangles. This, in turn, will have an unfortunate impact
on circles and squares: both the <code>Circle</code> and <code>Square</code> classes need to be recompiled, retested,
and potentially redeployed. More generally speaking, <em>all</em> shapes are affected in this way.
And that should strike you as problematic. Why should circles and squares have to recompile
if you add a <code>Triangle</code> class?</p>
<p>The technical reason is that via the <code>DrawStrategy</code> base class, all shapes implicitly
know about one another. Adding a new shape therefore affects all other shapes.
The underlying design reason is a violation of the Interface Segregation Principle (ISP)
(see <a data-type="xref" href="ch01.xhtml#separate_interfaces_to_avoid_artificial_coupling">“Guideline 3: Separate Interfaces to Avoid 
<span class="keep-together">Artificial Coupling</span>”</a>). By defining a single
<code>DrawStrategy</code> base class, you have artificially coupled circles,
squares, and triangles together. Due to this coupling, you have made it more difficult
to add new types and thus have limited the strength of OOP. In comparison, you
have created a very similar situation as we had when we talked about a procedural
solution for the drawing of shapes (see <a data-type="xref" href="ch04.xhtml#design_for_the_addition_of_types_or_operations">“Guideline 15: Design for the Addition of 
<span class="keep-together">Types or Operations</span>”</a>).</p>
<p>“Didn’t we unintentionally reimplement the Visitor design pattern?” you are wondering.
I see your point: the <code>DrawStrategy</code> looks very similar to a Visitor indeed. But
unfortunately, it does not fulfill the intent of a Visitor, since you cannot easily
add other operations. To do so, you would have to intrusively add a virtual
member 
<span class="keep-together">function</span> in the <code>Shape</code> hierarchy. “And it is not a Strategy either, because
we cannot add types, right?” Yes, correct. You see, from a design perspective, this is
the worst kind of situation.</p>
<p>To properly implement the Strategy design pattern, you have to extract the
implementation details of each shape separately. You have to introduce
one <code>DrawStrategy</code> class for each kind of shape:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;DrawCircleStrategy.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">DrawCircleStrategy</code><code class="w">  </code><a class="co" href="#para_g19_11" id="code_g19_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">DrawCircleStrategy</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Circle.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;DrawCircleStrategy.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawCircleStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given radius is valid and that
         the given 'std::unique_ptr' is not a nullptr */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">drawer_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawCircleStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;DrawSquareStrategy.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">DrawSquareStrategy</code><code class="w">  </code><a class="co" href="#para_g19_12" id="code_g19_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">DrawSquareStrategy</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">square</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Square.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;DrawSquareStrategy.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Square</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawSquareStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">side_</code><code class="p">(</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given side length is valid and that
         the given 'std::unique_ptr' is not a nullptr */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">drawer_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawSquareStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>For the <code>Circle</code> class, you have to introduce the <code>DrawCircleStrategy</code> base class
(<a class="co" href="#code_g19_11" id="para_g19_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>),
and for the <code>Square</code> class, it is the <code>DrawSquareStrategy</code>
(<a class="co" href="#code_g19_12" id="para_g19_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>)
base class. And with the addition of a <code>Triangle</code> class,
you will also have to add a <code>DrawTriangleStrategy</code> base class. Only in this way can you properly separate concerns and still allow everyone to add new types and new
implementations for the drawing of shapes.</p>
<p>With this functionality in place, you can easily implement new Strategy classes
for drawing circles, squares, and eventually triangles. As an example, consider the

<span class="keep-together"><code>OpenGLCircleStrategy</code></span>, which implements the <code>DrawCircleStrategy</code> interface:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;OpenGLCircleStrategy.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;DrawCircleStrategy.h&gt;</code><code class="cp"/>
<code class="cp">#include </code><code class="cm">/* OpenGL graphics library */</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">OpenGLCircleStrategy</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">DrawCircleStrategy</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">OpenGLCircleStrategy</code><code class="p">(</code><code class="w"> </code><code class="cm">/* Drawing related arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Drawing related data members, e.g. colors, textures, ... */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>In <a data-type="xref" href="#fig_strategy_dependency_graph">Figure 5-5</a> you can see the dependency graph for the <code>Circle</code>
class. Note that the <code>Circle</code> and <code>DrawCircleStrategy</code> classes are on the same
architectural level. Even more noteworthy is the cyclic dependency between them: <code>Circle</code>
depends on the <code>DrawCircleStrategy</code>, but the <code>DrawCircleStrategy</code> also depends on <code>Circle</code>.
But don’t worry: although this may look like a problem at first sight, it isn’t. It is
a necessary relationship that shows that <code>Circle</code> really owns the <code>DrawCircleStrategy</code>
and by that creates the desired dependency inversion, as discussed in
<a data-type="xref" href="ch02.xhtml#pay_attention_to_the_ownership_of_abstractions">“Guideline 9: Pay Attention to the Ownership of Abstractions”</a>.</p>
<p>“Wouldn’t it<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="dependency graph" data-type="indexterm" id="idm45043108777088"/> be possible to implement the different draw Strategy classes using a class template? I’m imagining something similar to the Visitor class used for the
Acyclic Visitor”:<sup><a data-type="noteref" href="ch05.xhtml#idm45043108775712" id="idm45043108775712-marker">8</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;DrawStrategy.h&gt; ----------------</code>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">DrawStrategy</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<figure><div class="figure" id="fig_strategy_dependency_graph">
<img alt="The dependency graph for the _Strategy_ design pattern." height="1026" src="assets/cpsd_0505.png" width="1443"/>
<h6><span class="label">Figure 5-5. </span>Dependency graph for the <em>Strategy</em> design pattern</h6>
</div></figure>
<p>This is a great idea and exactly what you should do. By means of this class template,
you can lift the <code>DrawStrategy</code> up into a higher architectural level, reuse code, and
follow the DRY principle (see <a data-type="xref" href="#fig_strategy_dependency_graph_2">Figure 5-6</a>). Additionally,
if we would have used this approach from the start, we would not have fallen into
the trap of artificially coupling the different shape types. Yes, I really like that!</p>
<p>Although<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="dependency graph, updated" data-type="indexterm" id="idm45043108429728"/> this is how we would implement such a Strategy class, you still should
not expect that this will reduce the number of base classes (it’s still the same, just
generated) or that it will save you a lot of work. The implementations of <code>DrawStrategy</code>, such as the <code>OpenGLCircleStrategy</code> class, represent most of the work and will hardly change:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;OpenGLCircleStrategy.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;DrawStrategy.h&gt;</code><code class="cp"/>
<code class="cp">#include </code><code class="cm">/* OpenGL graphics library */</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">OpenGLCircleStrategy</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="o">&lt;</code><code class="n">Circle</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<figure><div class="figure" id="fig_strategy_dependency_graph_2">
<img alt="The updated dependency graph for the _Strategy_ design pattern." height="1026" src="assets/cpsd_0506.png" width="1443"/>
<h6><span class="label">Figure 5-6. </span>Updated dependency graph for the <em>Strategy</em> design pattern</h6>
</div></figure>
<p>Assuming a similar implementation for the <code>OpenGLSquareStrategy</code>, we can now put
everything together and draw shapes again but this time properly decoupled with the Strategy design pattern:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Square.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;OpenGLCircleStrategy.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;OpenGLSquareStrategy.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;vector&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">Shapes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Shape</code><code class="o">&gt;&gt;</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="n">Shapes</code><code class="w"> </code><code class="n">shapes</code><code class="p">{};</code><code class="w"/>

<code class="w">   </code><code class="c1">// Creating some shapes, each one</code>
<code class="w">   </code><code class="c1">//   equipped with the corresponding OpenGL drawing strategy</code>
<code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Circle</code><code class="o">&gt;</code><code class="p">(</code><code class="w"/>
<code class="w">         </code><code class="mf">2.3</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">OpenGLCircleStrategy</code><code class="o">&gt;</code><code class="p">(</code><code class="cm">/*...red...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Square</code><code class="o">&gt;</code><code class="p">(</code><code class="w"/>
<code class="w">         </code><code class="mf">1.2</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">OpenGLSquareStrategy</code><code class="o">&gt;</code><code class="p">(</code><code class="cm">/*...green...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Circle</code><code class="o">&gt;</code><code class="p">(</code><code class="w"/>
<code class="w">         </code><code class="mf">4.1</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">OpenGLCircleStrategy</code><code class="o">&gt;</code><code class="p">(</code><code class="cm">/*...blue...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Drawing all shapes</code>
<code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">shape</code><code class="o">-&gt;</code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Comparison Between Visitor and Strategy" data-type="sect2"><div class="sect2" id="idm45043108955568">
<h2>Comparison Between Visitor and Strategy</h2>
<p>As<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="Visitor versus Strategy design patterns" data-type="indexterm" id="idm45043108486400"/><a data-primary="Visitor design pattern" data-secondary="versus Strategy design pattern" data-secondary-sortas="Strategy design pattern" data-type="indexterm" id="idm45043108485248"/> you have now learned about both the Visitor and Strategy design patterns, you might
wonder what the difference between the two is. After all, the implementation looks fairly
similar. But while there are parallels in implementation, the properties of the two design
patterns are very different. With the Visitor design pattern, we have identified
the <em>general</em> addition of operations as the<a data-primary="variation points" data-secondary="in Visitor design pattern" data-secondary-sortas="Visitor design pattern" data-type="indexterm" id="idm45043107796416"/> <em>variation point</em>. Therefore, we created
an abstraction for operations in general, which in turn allowed everyone to add operations.
The unfortunate side effect was that it was no longer easy to add new shape types.</p>
<p>With the Strategy design pattern, we have identified the implementation details
of a <em>single</em> function as a <em>variation point</em>. After introducing an abstraction for these
implementation details, we’re still able to easily add new types of shapes, but we are
not able to easily add new operations. Adding an operation would still
require you to intrusively add a virtual member function. Hence, the intent of the
Strategy design pattern is the opposite of the intent of the Visitor design pattern.</p>
<p>It may sound promising to combine the two design patterns to gain the advantages
of both ideas (making it easy to add both types <em>and</em> operations). Unfortunately, this does
not work: whichever of the two design patterns you apply first will fix one of the two
axes of freedom.<sup><a data-type="noteref" href="ch05.xhtml#idm45043107792496" id="idm45043107792496-marker">9</a></sup>
Therefore, you should just remember the strengths and weaknesses of these two design
patterns and apply them based on your expectations of how your codebase will evolve.</p>
</div></section>
<section class="less_space pagebreak-before" data-pdf-bookmark="Analyzing the Shortcomings of the Strategy Design Pattern" data-type="sect2"><div class="sect2" id="idm45043107791552">
<h2>Analyzing the Shortcomings of the Strategy Design Pattern</h2>
<p>I<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="Strategy shortcomings" data-type="indexterm" id="idm45043107789760"/> have shown you the advantages of the Strategy design pattern: it allows you to
reduce the dependencies on a particular implementation detail by introducing an
abstraction for that detail. However, there is no silver bullet in software design,
and every design comes with a number of drawbacks. The Strategy design pattern
is no exception, and it’s important to also take potential disadvantages into account.</p>
<p>First, while the implementation details of a certain operation have been extracted and
isolated, the operation itself is still part of the concrete type. This fact is
evidence of the aforementioned limitation that we are still not able to easily add
operations. Strategy, in contrast to Visitor, preserves the strength of OOP and
enables you to easily add new types.</p>
<p>Second, it pays off to<a data-primary="variation points" data-secondary="identifying early on" data-type="indexterm" id="idm45043107787536"/> identify such variation points early. Otherwise a large refactoring
is required. Of course, this doesn’t mean you should implement everything with
Strategy up front, just in case, to avoid a refactoring. This could quickly
result in overengineering. But at the first indication
that an implementation detail might change, or that there is a desire to have multiple
implementations, you should rather quickly implement the necessary modifications. The
best, but of course a little insubstantial, advice is to keep things as simple<a data-primary="KISS (Keep It Simple, Stupid) principle" data-type="indexterm" id="idm45043107786400"/><a data-primary="design principles" data-secondary="KISS (Keep It Simple, Stupid) principle" data-type="indexterm" id="idm45043107785712"/> as
possible (the <a href="https://oreil.ly/YVUhD"><em>KISS</em> principle</a>;
Keep It Simple, Stupid).</p>
<p>Third, if you implement Strategy by means of a base class, the performance will
certainly take a hit by the additional runtime indirection. The performance is also
affected by the many manual allocations (the <code>std::make_unique()</code> calls), the
resulting memory fragmentation, and the various indirections due to numerous pointers.
This is to be expected, yet the flexibility of your implementation and the opportunity
for everyone to add new implementations may outweigh this performance penalty. Of course,
it depends, and you will have to decide on a case-by-case basis. If you implement
Strategy using templates (see the discussion about <a data-type="xref" href="#policy_based_design">“Policy-Based Design”</a>),
this disadvantage is of no concern.</p>
<p>Last but not least, the major disadvantage of the Strategy design pattern is that
a single Strategy should deal with either a single operation or a small group of
cohesive functions. Otherwise you would again violate the SRP. If the implementation details of multiple operations need to be extracted, there
will have to be multiple Strategy base classes and multiple data members, which can
be set via <em>dependency injection</em>. Consider, for instance, the situation with an
additional <code>serialize()</code> member 
<span class="keep-together">function:</span></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;DrawCircleStrategy.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="p">;</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">DrawCircleStrategy</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">DrawCircleStrategy</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;SerializeCircleStrategy.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="p">;</code><code class="w"/>

<code class="k">class</code><code class="w"> </code><code class="nc">SerializeCircleStrategy</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">SerializeCircleStrategy</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Circle.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;DrawCircleStrategy.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;SerializeCircleStrategy.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="w"/>
<code class="w">                  </code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawCircleStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer</code><code class="w"/>
<code class="w">                  </code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">SerializeCircleStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">serializer</code><code class="w"/>
<code class="w">                  </code><code class="cm">/* potentially more strategy-related arguments */</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">serializer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">serializer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="cm">/* Checking that the given radius is valid and that</code>
<code class="cm">         the given std::unique_ptrs are not nullptrs */</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">drawer_</code><code class="o">-&gt;</code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">serialize</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">serializer_</code><code class="o">-&gt;</code><code class="n">serialize</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">DrawCircleStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">SerializeCircleStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">serializer_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Potentially more strategy-related data members</code>
<code class="p">};</code><code class="w"/></pre>
<p>While this leads to a very unfortunate proliferation of base classes and larger instances
due to multiple pointers, it also raises the question of how to design the class so that
it’s possible to conveniently assign multiple different strategies. Therefore, the Strategy
design pattern appears to be strongest in situations where you need to isolate a small
number of implementation details. If you encounter a situation where you need to
extract the details of many operations, it might be better to consider other approaches
(see, for instance, the External Polymorphism design pattern in <a data-type="xref" href="ch07.xhtml#the_bridge_prototype_and_external_polymorphism_design_patterns">Chapter 7</a> or the Type Erasure design pattern in <a data-type="xref" href="ch08.xhtml#type_erasure">Chapter 8</a>).</p>
</div></section>
<section data-pdf-bookmark="Policy-Based Design" data-type="sect2"><div class="sect2" id="policy_based_design">
<h2>Policy-Based Design</h2>
<p>As<a data-primary="Strategy design pattern" data-secondary="isolating how things are done" data-tertiary="policy-based design" data-type="indexterm" id="idm45043107353568"/><a data-primary="policy-based design" data-type="indexterm" id="policybased05"/><a data-primary="design principles" data-secondary="policy-based design" data-type="indexterm" id="DPpolicy05"/> already demonstrated in previous chapters, the Strategy design pattern is not
limited to dynamic polymorphism. On the contrary, the intent of Strategy can be implemented perfectly in static polymorphism using templates. Consider, for
instance, the following two algorithms from the Standard Library:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">namespace</code><code class="w"> </code><code class="nn">std</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ForwardIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">UnaryPredicate</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">constexpr</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w">
</code><code class="w">   </code><code class="n">partition</code><code class="p">(</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">UnaryPredicate</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_13" id="code_g19_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">RandomIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Compare</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">constexpr</code><code class="w"> </code><code class="kt">void</code><code class="w">
</code><code class="w">   </code><code class="n">sort</code><code class="p">(</code><code class="w"> </code><code class="n">RandomIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">RandomIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">Compare</code><code class="w"> </code><code class="n">comp</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_14" id="code_g19_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace std
</code></pre>
<p>Both the <code>std::partition()</code> and the <code>std::sort()</code> algorithm make use of the
Strategy design pattern. The <code>UnaryPredicate</code> argument of <code>std::partition()</code>
(<a class="co" href="#code_g19_13" id="para_g19_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>)
and the 
<span class="keep-together"><code>Compare</code></span> argument of <code>std::sort()</code>
(<a class="co" href="#code_g19_14" id="para_g19_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>)
represent a means to inject part of the behavior from outside. More specifically,
both arguments allow you to specify how elements are ordered. Hence, both algorithms
extract a specific part of their behavior and provide an abstraction for it in the
form of a concept (see <a data-type="xref" href="ch02.xhtml#understand_the_similarities_between_base_classes_and_concepts">“Guideline 7: Understand the Similarities Between 
<span class="keep-together">Base Classes and Concepts</span>”</a>).
This, in contrast to the OO form of Strategy, does not incur any runtime performance
penalty.</p>
<p>A similar approach can be seen in the <code>std::unique_ptr</code> class template:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">namespace</code><code class="w"> </code><code class="nn">std</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Deleter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">default_delete</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g19_15" id="code_g19_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">unique_ptr</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Deleter</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g19_16" id="code_g19_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">unique_ptr</code><code class="o">&lt;</code><code class="n">T</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code class="w"> </code><code class="n">Deleter</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace std
</code></pre>
<p>For both the base template
(<a class="co" href="#code_g19_15" id="para_g19_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>)
and its specialization for arrays
(<a class="co" href="#code_g19_16" id="para_g19_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>),
it is possible to specify an explicit <code>Deleter</code> as the second template argument. With
this argument, you can decide whether you want to free the resource by means of <code>delete</code>,
<code>free()</code>, or any other deallocation function. It’s even possible to “abuse”
<code>std::unique_ptr</code> to perform a completely different kind of cleanup.</p>
<p>This flexibility is also evidence for the Strategy design pattern. The template
argument allows you to inject some cleanup behavior into the class. This form of
Strategy is also called <em>policy-based design</em>, based on a design philosophy
introduced by Andrei Alexandrescu in 2001.<sup><a data-type="noteref" href="ch05.xhtml#idm45043107080048" id="idm45043107080048-marker">10</a></sup> The idea is the same: extract and isolate specific behavior
of class templates to improve changeability, extensibility, testability,
and reusability. Thus, policy-based design can be considered the static polymorphism
form of the Strategy design pattern. And evidently, the design works really well, as
the many applications of this idea in the Standard Library demonstrate.</p>
<p>You can also apply policy-based design to the shape-drawing example. Consider
the following implementation of the <code>Circle</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Circle.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;DrawCircleStrategy.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawCircleStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g19_17" id="code_g19_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">,</code><code class="w"> </code><code class="n">DrawCircleStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given radius is valid */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g19_18" id="code_g19_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">DrawCircleStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">  </code><code class="c1">// Could possibly be omitted, if the given
</code><code class="w">                                </code><code class="c1">// strategy is presumed to be stateless.
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Instead of passing <code>std::unique_ptr</code> to a <code>DrawCircleStrategy</code> base class in the
constructor, you could specify the Strategy with a template argument
(<a class="co" href="#code_g19_17" id="para_g19_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>).
The biggest advantage would be the performance improvement due to fewer pointer
indirections: instead of calling through <code>std::unique_ptr</code>, you could directly call to
the concrete implementation provided by the <code>DrawCircleStrategy</code>
(<a class="co" href="#code_g19_18" id="para_g19_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>).
On the downside, you would lose the flexibility to adapt the drawing Strategy of a
specific <code>Circle</code> instance at runtime. Also, you wouldn’t have a single <code>Circle</code> class
anymore. You would have one instantiation of <code>Circle</code> for every drawing strategy. And
last but not least, you should keep in mind that class templates usually completely reside
in header files. You could therefore lose the opportunity to hide implementation details
in a source file. As always, there is no perfect solution, and the choice of the “right”
solution depends on the actual context.</p>
<p>In summary, the Strategy design pattern is one of the most versatile examples in the
catalog of design patterns. You will find it useful in many situations in the realm of dynamic as well as static polymorphism. However, it
is not the ultimate solution for every problem—be aware of its potential disadvantages.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043106881200">
<h5>Guideline 19: Use Strategy to Isolate How Things Are Done</h5>
<ul>
<li>
<p>Understand that inheritance is rarely the answer.</p>
</li>
<li>
<p>Apply the Strategy design pattern with the intent to extract the implementation details of a cohesive set of functions.</p>
</li>
<li>
<p>Implement one Strategy for each operation to avoid artificial coupling.</p>
</li>
<li>
<p>Consider policy-based design as the compile-time form of the Strategy design pattern.<a data-primary="" data-startref="SDPisopro05" data-type="indexterm" id="idm45043106876544"/><a data-primary="" data-startref="policybased05" data-type="indexterm" id="idm45043106875568"/><a data-primary="" data-startref="DPpolicy05" data-type="indexterm" id="idm45043106801984"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 20: Favor Composition over Inheritance" data-type="sect1"><div class="sect1" id="favor_composition_over_inheritance">
<h1>Guideline 20: Favor Composition over Inheritance</h1>
<p>After<a data-primary="Strategy design pattern" data-secondary="composition versus inheritance" data-type="indexterm" id="SDPcomp05"/><a data-primary="inheritance" data-secondary="versus composition" data-secondary-sortas="composition" data-type="indexterm" id="INcomp05"/><a data-primary="composition, versus inheritance" data-type="indexterm" id="comp05"/> the enormous surge of enthusiasm for OOP in the 90s and
early 2000s, OOP today is on the defensive. The voices that argue against OOP and highlight
its disadvantages grow stronger and louder. This is not limited to the C++
communities but is also in other programming language communities. While OOP
in its entirety indeed has some limitations, let’s focus on the one feature that appears
to generate most of the heat: inheritance. As Sean Parent remarked:<sup><a data-type="noteref" href="ch05.xhtml#idm45043106795536" id="idm45043106795536-marker">11</a></sup></p>
<blockquote>
<p>Inheritance is the base class of evil.</p></blockquote>
<p>While inheritance is sold as a very natural and intuitive way of modeling real-world
relations, it turns out to be much harder to use than promised. You have already seen
the subtle failures of using inheritance when we talked about the Liskov Substitution
Principle (LSP) in <a data-type="xref" href="ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>. But there are other
aspects of inheritance that are often misunderstood.</p>
<p>First and foremost, inheritance is always described as simplifying reusability. This
seems intuitive, since it appears obvious that you can reuse code
easily if you just inherit from another class. Unfortunately, that’s not the kind of
reuse inheritance brings to you. Inheritance is not about reusing code in a base
class; instead, it is about being reused by other code that uses the base class
polymorphically. For instance, assuming a slightly extended <code>Shape</code> base class,
the following functions work for all kinds of shapes and thus can be reused by all
implementations of the <code>Shape</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Shape</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">translate</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">rotate</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Potentially other member functions ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">rotateAroundPoint</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g20_1" id="code_g20_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">mergeShapes</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="n">s1</code><code class="p">,</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="n">s2</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g20_2" id="code_g20_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">writeToFile</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g20_3" id="code_g20_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">sendViaRPC</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g20_4" id="code_g20_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="c1">// ...
</code></pre>
<p>All four functions
(<a class="co" href="#code_g20_1" id="para_g20_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>,
<a class="co" href="#code_g20_2" id="para_g20_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>,
<a class="co" href="#code_g20_3" id="para_g20_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>, and
<a class="co" href="#code_g20_4" id="para_g20_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>)
are built on the <code>Shape</code> abstraction. All of these functions are coupled only to
the common interface of all kinds of shapes but not to any specific shape.
All kinds of shapes can be rotated around a point, merged,
written to file, and sent via RPC. Every shape “reuses” this functionality.</p>
<p>It is the ability to express functionality by means of an abstraction that creates
the opportunity to reuse code. This functionality is expected to create a vast
amount of code, in comparison to the small amount of code the base class contains.
Real reusability, therefore, is created by the polymorphic use of a type, not by
polymorphic types.<sup><a data-type="noteref" href="ch05.xhtml#idm45043106632784" id="idm45043106632784-marker">12</a></sup></p>
<p>Second, inheritance is said to help in decoupling software entities. While that is
most certainly true (remember, for instance, the discussion about the Dependency
Inversion Principle (DIP) in <a data-type="xref" href="ch02.xhtml#pay_attention_to_the_ownership_of_abstractions">“Guideline 9: Pay Attention to the Ownership of Abstractions”</a>),
it’s often not explained that inheritance also creates
coupling. You’ve seen evidence of that before. While implementing the Visitor
design pattern, you experienced that inheritance forces certain implementation
details on you. In a classic Visitor, you have to implement the pure virtual
functions of a <code>Visitor</code> base class as they are required, even if this is not
optimal for your application. You also don’t have a lot of choices
with respect to the function arguments or return types. These things are
fixed.<sup><a data-type="noteref" href="ch05.xhtml#idm45043106629568" id="idm45043106629568-marker">13</a></sup></p>
<p>You also experienced this coupling at the beginning of the discussion on
the Strategy design pattern. In this case, inheritance forced a structural
coupling that caused a deep(er) inheritance hierarchy, resulted in questionable
naming of classes, and impaired reuse.</p>
<p>At this point, you might get the impression that I’m trying to discredit
inheritance completely. Well, to be honest, I am trying to make it look
just a little bad, but only as much as necessary. To state it clearly:
inheritance is not bad, nor is it wrong to use it. On the contrary:
inheritance is a very powerful feature, and if used properly you can
do incredible things with it. However, of course you remember the Peter
Parker 
<span class="keep-together">Principle</span>:</p>
<blockquote>
<p>With great power comes great responsibility.</p>
<p data-type="attribution">Peter Parker, <cite>aka Spider-Man</cite></p>
</blockquote>
<p>The problem is the “if used properly” part.
Inheritance has proven to be hard to use properly (definitely harder
than we are led to believe; see my previous reasonings), and thus is misused
unintentionally. It is also overused, as many developers have the
habit of using it for every kind of problem.<sup><a data-type="noteref" href="ch05.xhtml#idm45043106561024" id="idm45043106561024-marker">14</a></sup> This
overuse appears to be the source of many problems, as Michael Feathers
remarks:<sup><a data-type="noteref" href="ch05.xhtml#idm45043106560240" id="idm45043106560240-marker">15</a></sup></p>
<blockquote>
<p>[Programming by difference]<sup><a data-type="noteref" href="ch05.xhtml#idm45043106558560" id="idm45043106558560-marker">16</a></sup> fell out of favor in the 1990s when many people in the OO community
noticed that inheritance can be rather problematic if it is overused.</p></blockquote>
<p>In many situations, inheritance is neither the right approach nor the right
tool. Most of the time it is preferable to use composition instead.
You should not be surprised by that revelation, though, because you have
already seen it to be true. Composition is the reason the OO form of the
Strategy design pattern works so well, not inheritance. It is the introduction
of an abstraction and the aggregation of corresponding data members that make
the Strategy design pattern so powerful, not the inheritance-based
implementation of different strategies. In fact, you will find that many
design patterns are firmly based on composition, not on inheritance.<sup><a data-type="noteref" href="ch05.xhtml#idm45043106557328" id="idm45043106557328-marker">17</a></sup>
All of these enable extension by means of inheritance but are themselves enabled
by means of 
<span class="keep-together">composition</span>.</p>
<blockquote>
<p>Delegate to Services: Has-A Trumps Is-A.</p>
<p data-type="attribution">Andrew Hunt and David Thomas, <cite>The Pragmatic Programmer</cite></p>
</blockquote>
<p>This is a general takeaway for many design patterns. I suggest you keep this
insight close at hand, as it will prove very useful in understanding the design
patterns that you will see in the remainder of this book, and will improve
the quality of your implementations.</p>
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043106549376">
<h5>Guideline 20: Favor Composition over Inheritance</h5>
<ul>
<li>
<p>Understand that inheritance is often overused and sometimes even misused.</p>
</li>
<li>
<p>Keep in mind that inheritance creates a tight coupling.</p>
</li>
<li>
<p>Realize that many design patterns are enabled by composition, not by 
<span class="keep-together">inheritance</span>.<a data-primary="" data-startref="SDPcomp05" data-type="indexterm" id="idm45043106544368"/><a data-primary="" data-startref="INcomp05" data-type="indexterm" id="idm45043106543360"/><a data-primary="" data-startref="comp05" data-type="indexterm" id="idm45043106542416"/></p>
</li>
</ul>
</div></aside>
</div></section>
<section data-pdf-bookmark="Guideline 21: Use Command to Isolate What Things &#10;Are Done" data-type="sect1"><div class="sect1" id="use_commands_to_isolate_what_things_are_done">
<h1>Guideline 21: Use Command to Isolate What Things 
<span class="keep-together">Are Done</span></h1>
<p>Before<a data-primary="Command design pattern" data-secondary="isolating what things are done" data-type="indexterm" id="CDPwhat05"/> we get started with this guideline, let’s try an experiment. Open your preferred
email client and write an email to me. Add the following content: “I love your book! It
keeps me up all night and makes me forget all my troubles.” OK, great. Now click Send.
Good job! Give me a second to check my emails…No, it’s not here yet…No, still not
here…Let’s try again: Click Resend. No, nothing. Hmm, I guess some server must
be down. Or all of my Commands simply failed: the <code>WriteCommand</code>, the 
<span class="keep-together"><code>SendCommand</code></span>,
the <code>ResendCommand</code>, and so on. How unfortunate. But despite this failed experiment, you now have
a pretty good idea of another GoF design pattern: the Command design pattern.</p>
<section data-pdf-bookmark="The Command Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043106535536">
<h2>The Command Design Pattern Explained</h2>
<p>The<a data-primary="Command design pattern" data-secondary="isolating what things are done" data-tertiary="Command explained" data-type="indexterm" id="idm45043106533552"/> Command design pattern focuses on the abstraction and isolation of work
packages that (most often) are executed once and (usually) immediately. For that
purpose, it recognizes the existence of different kinds of work packages<a data-primary="Command design pattern" data-secondary="isolating what things are done" data-tertiary="variation points" data-type="indexterm" id="idm45043106532208"/><a data-primary="variation points" data-secondary="in Command design pattern" data-secondary-sortas="Command design pattern" data-type="indexterm" id="idm45043106531024"/> as <em>variation
points</em> and introduces the corresponding abstraction that allows the easy implementation of
new kinds of work packages.</p>
<div data-type="tip"><h1>The Command Design Pattern</h1>
<p>Intent: “Encapsulate<a data-primary="Command design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043106527904"/> a request as an object, thereby letting you parameterize clients
with different requests, queue or log requests, and support undoable operations.”<sup><a data-type="noteref" href="ch05.xhtml#idm45043106526608" id="idm45043106526608-marker">18</a></sup></p>
</div>
<p><a data-type="xref" href="#fig_command_original">Figure 5-7</a> shows<a data-primary="Command design pattern" data-secondary="isolating what things are done" data-tertiary="UML diagram of" data-type="indexterm" id="idm45043106524416"/> the original UML formulation,
taken from the GoF book.</p>
<figure><div class="figure" id="fig_command_original">
<img alt="The UML representation of the _Command_ design pattern." height="524" src="assets/cpsd_0507.png" width="1437"/>
<h6><span class="label">Figure 5-7. </span>The UML representation of the <em>Command</em> design pattern</h6>
</div></figure>
<p>In this OO-based form, the Command pattern introduces an abstraction in the form
of the <code>Command</code> base class. This enables anyone to implement a new kind of

<span class="keep-together"><code>ConcreteCommand</code></span>. That <code>ConcreteCommand</code> can do anything, even perform an action
on some kind of <code>Receiver</code>. The effect of a command is triggered via the abstract
base class by a particular kind of <code>Invoker</code>.</p>
<p>As a concrete example of the Command design pattern, let’s consider the following
implementation of a calculator. The first code snippet shows the implementation of a
<code>CalculatorCommand</code> base class, which represents the abstraction of a mathematical
operation on a given integer:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;CalculatorCommand.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">CalculatorCommand</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">CalculatorCommand</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">execute</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_1" id="code_g21_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">undo</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_2" id="code_g21_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The <code>CalculatorCommand</code> class expects derived classes to implement both the pure virtual
<code>execute()</code> function
(<a class="co" href="#code_g21_1" id="para_g21_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>)
and the pure virtual <code>undo()</code> function
(<a class="co" href="#code_g21_2" id="para_g21_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
The expectation for <code>undo()</code> is that it implements the necessary actions to reverse the
effect of the <code>execute()</code> function.</p>
<p>The <code>Add</code> and <code>Subtract</code> classes both represent possible commands for a
calculator and therefore implement the <code>CalculatorCommand</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Add.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;CalculatorCommand.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Add</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">CalculatorCommand</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Add</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">operand</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">operand_</code><code class="p">(</code><code class="n">operand</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">execute</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g21_3" id="code_g21_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">operand_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">undo</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g21_4" id="code_g21_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">operand_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">operand_</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Subtract.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;CalculatorCommand.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Subtract</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">CalculatorCommand</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Subtract</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">operand</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">operand_</code><code class="p">(</code><code class="n">operand</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">execute</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g21_5" id="code_g21_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">operand_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">undo</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g21_6" id="code_g21_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">operand_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">operand_</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p><code>Add</code> implements the <code>execute()</code> function using an addition operation
(<a class="co" href="#code_g21_3" id="para_g21_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>)
and the <code>undo()</code> function using a subtraction operation
(<a class="co" href="#code_g21_4" id="para_g21_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>).
<code>Subtract</code> implements the inverse
(<a class="co" href="#code_g21_5" id="para_g21_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
and <a class="co" href="#code_g21_6" id="para_g21_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).</p>
<p>Thanks to the <code>CalculatorCommand</code> hierarchy, the <code>Calculator</code> class itself can be kept
rather simple:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Calculator.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;CalculatorCommand.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;stack&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Calculator</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">compute</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">CalculatorCommand</code><code class="o">&gt;</code><code class="w"> </code><code class="n">command</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_7" id="code_g21_7_2"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">undoLast</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_8" id="code_g21_8_2"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="nf">result</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">clear</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">CommandStack</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">stack</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">CalculatorCommand</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">current_</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_9" id="code_g21_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">CommandStack</code><code class="w"> </code><code class="n">stack_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_10" id="code_g21_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Calculator.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Calculator.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">Calculator::compute</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">CalculatorCommand</code><code class="o">&gt;</code><code class="w"> </code><code class="n">command</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g21_7" id="code_g21_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">current_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">command</code><code class="o">-</code><code class="o">&gt;</code><code class="n">execute</code><code class="p">(</code><code class="w"> </code><code class="n">current_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">stack_</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">command</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">Calculator::undoLast</code><code class="p">(</code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g21_8" id="code_g21_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">stack_</code><code class="p">.</code><code class="n">empty</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">return</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">command</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">stack_</code><code class="p">.</code><code class="n">top</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">stack_</code><code class="p">.</code><code class="n">pop</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">current_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">command</code><code class="o">-</code><code class="o">&gt;</code><code class="n">undo</code><code class="p">(</code><code class="n">current_</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">Calculator::result</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">current_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">Calculator::clear</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">current_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">CommandStack</code><code class="p">{</code><code class="p">}</code><code class="p">.</code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">stack_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Clearing the stack
</code><code class="p">}</code><code class="w">
</code></pre>
<p>The only functions we need for the computing activities are <code>compute()</code>
(<a class="co" href="#code_g21_7" id="para_g21_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>)
and <code>undoLast()</code>
(<a class="co" href="#code_g21_8" id="para_g21_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).
The <code>compute()</code> function is passed a <code>CalculatorCommand</code> instance, immediately executes
it to update the current value
(<a class="co" href="#code_g21_9" id="para_g21_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>),
and stores it on the stack
(<a class="co" href="#code_g21_10" id="para_g21_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).
The <code>undoLast()</code> function reverts the last executed command by popping it from the stack
and calling <code>undo()</code>.</p>
<p>The <code>main()</code> function combines all of the pieces:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Main.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Calculator.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Add.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Subtract.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">Calculator</code><code class="w"> </code><code class="n">calculator</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_11" id="code_g21_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">op1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Add</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="mi">3</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_12" id="code_g21_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">op2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Add</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="mi">7</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_13" id="code_g21_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">op3</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Subtract</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="mi">4</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_14" id="code_g21_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">op4</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Subtract</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_15" id="code_g21_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">calculator</code><code class="p">.</code><code class="n">compute</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">op1</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Computes 0 + 3, stores and returns 3
</code><code class="w">   </code><code class="n">calculator</code><code class="p">.</code><code class="n">compute</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">op2</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Computes 3 + 7, stores and returns 10
</code><code class="w">   </code><code class="n">calculator</code><code class="p">.</code><code class="n">compute</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">op3</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Computes 10 - 4, stores and returns 6
</code><code class="w">   </code><code class="n">calculator</code><code class="p">.</code><code class="n">compute</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">op4</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Computes 6 - 2, stores and returns 4
</code><code class="w">
</code><code class="w">   </code><code class="n">calculator</code><code class="p">.</code><code class="n">undoLast</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Reverts the last operation,
</code><code class="w">                           </code><code class="c1">// stores and returns 6
</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">calculator</code><code class="p">.</code><code class="n">result</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Get the final result: 6
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>We first create a <code>calculator</code>
(<a class="co" href="#code_g21_11" id="para_g21_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>)
and a series of operations
(<a class="co" href="#code_g21_12" id="para_g21_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>,
<a class="co" href="#code_g21_13" id="para_g21_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>,
<a class="co" href="#code_g21_14" id="para_g21_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>, and
<a class="co" href="#code_g21_15" id="para_g21_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>),
which we apply one after another. After that, we revert <code>op4</code> by means of the
<code>undo()</code> operation before we query the final result.</p>
<p>This design very nicely follows the SOLID principles.<sup><a data-type="noteref" href="ch05.xhtml#idm45043105484832" id="idm45043105484832-marker">19</a></sup> It<a data-primary="variation points" data-secondary="in Command design pattern" data-secondary-sortas="Command design pattern" data-type="indexterm" id="idm45043105483344"/> adheres to the SRP since  the <em>variation point</em> has already
been extracted by means of the Command design pattern. As a result, both
<code>compute()</code> and <code>undo()</code> do not have to be virtual functions. The SRP also
acts as an enabler for the OCP, which allows us to add
new operations without having to modify any existing code. Last, but not least,
if the ownership for the 
<span class="keep-together"><code>Command</code></span> base class is properly assigned to the high
level, then the design also adheres to the DIP<a data-primary="Command design pattern" data-secondary="isolating what things are done" data-tertiary="dependency graph" data-type="indexterm" id="idm45043105479792"/> (see <a data-type="xref" href="#fig_command_dependency_graph">Figure 5-8</a>).</p>
<figure><div class="figure" id="fig_command_dependency_graph">
<img alt="The dependency graph for the _Command_ design pattern." height="752" src="assets/cpsd_0508.png" width="1439"/>
<h6><span class="label">Figure 5-8. </span>Dependency graph for the <em>Command</em> design pattern</h6>
</div></figure>
<p>There is a second example of the Command design pattern that belongs in the
category of classic examples: a <a href="https://oreil.ly/jGZd5">thread pool</a>.
The purpose of a thread pool is to maintain multiple threads waiting for tasks to be
executed in parallel. This idea is implemented by the following <code>ThreadPool</code> class:
it provides a couple of member functions to offload certain tasks to a specific
number of available threads:⁠<sup><a data-type="noteref" href="ch05.xhtml#idm45043105381936" id="idm45043105381936-marker">20</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">Command</code><code class="w">  </code><a class="co" href="#para_g21_17" id="code_g21_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w"> </code><code class="cm">/* Abstract interface to perform and undo any kind of action. */</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ThreadPool</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">ThreadPool</code><code class="p">(</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">numThreads</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kr">inline</code><code class="w"> </code><code class="kt">bool</code><code class="w">   </code><code class="nf">isEmpty</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kr">inline</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="nf">size</code><code class="p">(</code><code class="p">)</code><code class="w">    </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kr">inline</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="nf">active</code><code class="p">(</code><code class="p">)</code><code class="w">  </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kr">inline</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="nf">ready</code><code class="p">(</code><code class="p">)</code><code class="w">   </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">schedule</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Command</code><code class="o">&gt;</code><code class="w"> </code><code class="n">command</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_16" id="code_g21_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">wait</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Most importantly, the <code>ThreadPool</code> allows you to schedule a task via the <code>schedule()</code>
function
(<a class="co" href="#code_g21_16" id="para_g21_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>).
This can be <em>any</em> task: the <code>ThreadPool</code> is not at all concerned about what kind of work
its threads will have to perform. With the <code>Command</code> base class, it is completely
decoupled from the actual kind of task you schedule
(<a class="co" href="#code_g21_17" id="para_g21_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>).</p>
<p>By simply deriving from <code>Command</code>, you can formulate arbitrary tasks:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">FormattingCommand</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Command</code><code class="w">  </code><a class="co" href="#para_g21_18" id="code_g21_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w"> </code><code class="cm">/* Implementation of formatting a disk */</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">PrintCommand</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Command</code><code class="w">  </code><a class="co" href="#para_g21_19" id="code_g21_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w"> </code><code class="cm">/* Implementation of performing a printer job */</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// Creating a thread pool with initially two working threads
</code><code class="w">   </code><code class="n">ThreadPool</code><code class="w"> </code><code class="nf">threadpool</code><code class="p">(</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Scheduling two concurrent tasks
</code><code class="w">   </code><code class="n">threadpool</code><code class="p">.</code><code class="n">schedule</code><code class="p">(</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">FormattingCommand</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">threadpool</code><code class="p">.</code><code class="n">schedule</code><code class="p">(</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">PrintCommand</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Waiting for the thread pool to complete both commands
</code><code class="w">   </code><code class="n">threadpool</code><code class="p">.</code><code class="n">wait</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>One possible example of such a task is a <code>FormattingCommand</code>
(<a class="co" href="#code_g21_18" id="para_g21_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>).
This task would get the necessary information to trigger the formatting of a disk via
the operating system. Alternatively, you can imagine a <code>PrintCommand</code> that receives all
data to trigger a printer job
(<a class="co" href="#code_g21_19" id="para_g21_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a>).</p>
<p>Also in this <code>ThreadPool</code> example, you recognize the effect of the Command design pattern: the
different kinds of tasks are identified as a<a data-primary="variation points" data-secondary="in Command design pattern" data-secondary-sortas="Command design pattern" data-type="indexterm" id="idm45043105114640"/> <em>variation point</em> and are extracted (which again follows
the SRP), which enables you to implement different kinds of tasks without the need to modify
existing code (adherence to the OCP).</p>
<p>Of course, there are also some examples from the Standard Library. For instance, you will
see the Command design pattern in action in the <code>std::for_each()</code>
(<a class="co" href="#code_g21_20" id="para_g21_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a>)

<span class="keep-together">algorithm:</span></p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">namespace</code><code class="w"> </code><code class="nn">std</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">InputIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">UnaryFunction</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">constexpr</code><code class="w"> </code><code class="n">UnaryFunction</code><code class="w">
</code><code class="w">   </code><code class="n">for_each</code><code class="p">(</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">UnaryFunction</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_20" id="code_g21_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace std
</code></pre>
<p>With the third argument, you can specify <em>what</em> task the algorithm is
supposed to perform on all of the given elements. This can be any action, ranging from
manipulating the elements to printing them, and can be specified by something as
simple as a function pointer to something as powerful as a lambda:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;algorithms&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">multBy10</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="o">&amp;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">i</code><code class="w"> </code><code class="o">*=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">v</code><code class="p">{</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="c1">// Multiplying all integers with 10</code>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">for_each</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">v</code><code class="p">),</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">v</code><code class="p">),</code><code class="w"> </code><code class="n">multBy10</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Printing all integers</code>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">for_each</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">v</code><code class="p">),</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">v</code><code class="p">),</code><code class="w"> </code><code class="p">[](</code><code class="w"> </code><code class="kt">int</code><code class="o">&amp;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">){</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="sc">'\n'</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="The Command Design Pattern Versus the Strategy Design Pattern" data-type="sect2"><div class="sect2" id="idm45043106534592">
<h2>The Command Design Pattern Versus the Strategy Design Pattern</h2>
<p>“Wait a second!” I<a data-primary="Command design pattern" data-secondary="isolating what things are done" data-tertiary="versus Strategy design pattern" data-tertiary-sortas="Strategy design pattern" data-type="indexterm" id="idm45043104881120"/><a data-primary="Strategy design pattern" data-secondary="versus Command design pattern" data-secondary-sortas="Command design pattern" data-type="indexterm" id="idm45043104879664"/> can hear you cry out. “Didn’t you just explain that the algorithms
of the Standard Library are implemented by means of the Strategy design pattern?
Isn’t this a complete contradiction of the previous statement?” Yes, you are
correct. Just a few pages back, I did explain that the <code>std::partition()</code>
and <code>std::sort()</code> algorithms are implemented by means of the Strategy design pattern.
And therefore, I admit that it appears as if I am now contradicting myself. However,
I did not claim that <em>all</em> the algorithms are based on Strategy. So let me explain.</p>
<p>From a structural point of view, the Strategy and Command design patterns are
identical: whether you’re using dynamic or static polymorphism, from an implementation
point of view, there is no difference between Strategy and Command.<sup><a data-type="noteref" href="ch05.xhtml#idm45043104876160" id="idm45043104876160-marker">21</a></sup> The difference
lies entirely in the intent of the two design patterns. Whereas the Strategy
design 
<span class="keep-together">pattern</span> specifies <em>how</em> something should be done, the Command design
pattern specifies <em>what</em> should be done. Consider, for instance, the <code>std::partition()</code>
and <code>std::for_each()</code> algorithms:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">namespace</code><code class="w"> </code><code class="nn">std</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ForwardIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">UnaryPredicate</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">constexpr</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w">
</code><code class="w">   </code><code class="n">partition</code><code class="p">(</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">UnaryPredicate</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_21" id="code_g21_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">InputIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">UnaryFunction</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">constexpr</code><code class="w"> </code><code class="n">UnaryFunction</code><code class="w">
</code><code class="w">   </code><code class="n">for_each</code><code class="p">(</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">UnaryFunction</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_22" id="code_g21_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace std
</code></pre>
<p>Whereas you can only control <em>how</em> to select elements in the <code>std::partition()</code> algorithm
(<a class="co" href="#code_g21_21" id="para_g21_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a>),
the <code>std::for_each()</code> algorithm gives you control over <em>what</em> operation is applied
to each element in the given range
(<a class="co" href="#code_g21_22" id="para_g21_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a>).
And whereas in the shapes example you could only specify <em>how</em> to draw a certain kind of
shape, in the <code>ThreadPool</code> example you are completely in charge of deciding <em>what</em>
operation is scheduled.<sup><a data-type="noteref" href="ch05.xhtml#idm45043104697792" id="idm45043104697792-marker">22</a></sup></p>
<p>There are two other indicators for the two design patterns you have applied. First,
if you have an object and configure it using an action (you perform
<em>dependency injection</em>), then you are (most likely) using the Strategy design pattern.
If you don’t use the action to configure an object, but if instead the action is
performed directly, then you are (most likely) using the Command design pattern.
In our <code>Calculator</code> example, we did not pass an action to configure the <code>Calculator</code>,
but instead the action was evaluated immediately. Therefore, we built on the
Command pattern.</p>
<p>Alternatively, we could also implement <code>Calculator</code> by means of Strategy:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;CalculatorStrategy.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">CalculatorStrategy</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">CalculatorStrategy</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">compute</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Calculator.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;CalculatorStrategy.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Calculator</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">set</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">CalculatorStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">operation</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_23" id="code_g21_23_2"><img alt="23" height="12" src="assets/23.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">compute</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g21_24" id="code_g21_24_2"><img alt="24" height="12" src="assets/24.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">current_</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">CalculatorStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">operation_</code><code class="p">;</code><code class="w">  </code><code class="c1">// Requires a default!
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Calculator.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Calculator.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">set</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">CalculatorStrategy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">operation</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g21_23" id="code_g21_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">operation_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">operation</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">Calculator::compute</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g21_24" id="code_g21_24"><img alt="24" height="12" src="assets/24.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">current_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">operation_</code><code class="p">.</code><code class="n">compute</code><code class="p">(</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>In this implementation of a <code>Calculator</code>, the Strategy is injected by means of a <code>set()</code>
function
(<a class="co" href="#code_g21_23" id="para_g21_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a>).
The <code>compute()</code> function uses the injected Strategy to perform a computation
(<a class="co" href="#code_g21_24" id="para_g21_24"><img alt="24" height="12" src="assets/24.png" width="12"/></a>).
Note, however, that this approach makes it more difficult to implement a reasonable
undo mechanism.</p>
<p>The second indicator to see whether you are using Command or Strategy is the
<code>undo()</code> operation. If your action provides an <code>undo()</code> operation
to roll back <em>what</em> it has done and encapsulates everything that is needed to perform
the <code>undo()</code>, then you are—most likely—dealing with the Command design pattern.
If your action doesn’t provide an <code>undo()</code> operation, because it’s focused on <em>how</em>
something is done or because it lacks the information to roll back the operation, then
you are—most 
<span class="keep-together">likely—dealing</span> with the Strategy design pattern. However, I should
explicitly point out that the lack of an <code>undo()</code> operation is not conclusive evidence
of Strategy. It could still be an implementation of Command if the intent is to
specify <em>what</em> should be done. For instance, the <code>std::for_each()</code> algorithm still
expects a <code>Command</code>, despite the fact that there is no need for
an <code>undo()</code> operation. The <code>undo()</code> operation should be considered an optional feature
of the Command design pattern, not a defining one. In my opinion,
<code>undo()</code> is not a strength of the Command design pattern but a pure necessity: if
an action has complete freedom to do whatever it desires, then only this action alone
will be able to roll the operation back (of course, assuming that you don’t want to
store a complete copy of everything for every call to a Command).</p>
<p>I admit there is no clear separation between these two patterns and that there
is a gray area between them. However, there’s no point in arguing about
whether something is a Command or a Strategy and losing a couple of friends in
the process. More important than agreeing on which one of the two you are using
is exploiting their ability to extract implementation details and separate concerns. Both design patterns help you isolate changes and extensions
and thus help you follow the SRP and OCP. After all, this ability may be
the reason why there are so many examples of these two design patterns in the
C++ Standard Library.</p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the Command Design Pattern" data-type="sect2"><div class="sect2" id="idm45043104804832">
<h2>Analyzing the Shortcomings of the Command Design Pattern</h2>
<p>The<a data-primary="Command design pattern" data-secondary="isolating what things are done" data-tertiary="Command shortcomings" data-type="indexterm" id="idm45043104369328"/> advantages of the Command design pattern are similar to those of
the Strategy design pattern: Command helps you decouple from the implementation
details of concrete tasks by introducing some form of abstraction (for instance,
a base class or a concept). This abstraction allows you to easily add new tasks.
Thus, Command satisfies both the SRP and the OCP.</p>
<p>However, the Command design pattern also has its disadvantages. In
comparison to the Strategy design pattern, the list of disadvantages is
pretty short, though. The only real disadvantage is the added runtime performance
overhead due to the additional indirection if you implement Command by means
of a base class (the classic GoF style). Again, it’s up to you to decide
whether the increased flexibility outweighs the loss of runtime performance.</p>
<p>In summary, just like the Strategy design pattern, the Command design pattern is
one of the most basic and useful ones in the catalog of design patterns. You will
encounter implementations of Command in many different situations, both static
and dynamic. Thus, understanding the intent, advantages, and disadvantages of
Command will prove useful many times.</p>
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043104367216">
<h5>Guideline 21: Use Command to Isolate What Things Are Done</h5>
<ul>
<li>
<p>Apply the Command design pattern with the intent to abstract and encapsulate an (possibly undoable) action.</p>
</li>
<li>
<p>Be aware that the line between the Command and the Strategy design pattern is fluid.</p>
</li>
<li>
<p>Use Command for both dynamic and static applications.<a data-primary="" data-startref="CDPwhat05" data-type="indexterm" id="idm45043104363664"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 22: Prefer Value Semantics over &#10;Reference Semantics" data-type="sect1"><div class="sect1" id="prefer_value_semantics_to_reference_semantics">
<h1>Guideline 22: Prefer Value Semantics over 
<span class="keep-together">Reference Semantics</span></h1>
<p>In<a data-primary="Strategy design pattern" data-secondary="value semantics versus reference semantics" data-type="indexterm" id="SDPvsem05"/><a data-primary="Command design pattern" data-secondary="value semantics versus reference semantics" data-type="indexterm" id="CDPvsem05"/> <a data-type="xref" href="#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a> and
<a data-type="xref" href="#use_commands_to_isolate_what_things_are_done">“Guideline 21: Use Command to Isolate What Things 
<span class="keep-together">Are Done</span>”</a>, I introduced you to the Strategy and Command design pattern, respectively.
In both cases, the examples were firmly built on the classic GoF style:
they used dynamic polymorphism by means of an inheritance hierarchy.
With that classic object-oriented style lacking a modern touch, I imagine
that by now all your nail-biting has gotten you in trouble with your manicurist.
And you might be wondering: “Isn’t there another, better way to implement
Strategy and Command? A more ‘modern’ approach?” Yes, rest assured; there
is. And this approach is so important for the philosophy of what we commonly call
“Modern C++” that it definitely justifies a separate guideline to explain
the advantages. I’m pretty sure your manicurist will understand the reason
for this little detour.</p>
<section data-pdf-bookmark="The Shortcomings of the GoF Style: Reference Semantics" data-type="sect2"><div class="sect2" id="idm45043104355680">
<h2>The Shortcomings of the GoF Style: Reference Semantics</h2>
<p>The<a data-primary="value semantics, versus reference semantics" data-secondary="shortcomings of GoF style" data-type="indexterm" id="VSshort05"/><a data-primary="reference semantics, versus value semantics" data-secondary="shortcomings of GoF style" data-type="indexterm" id="RSshort05"/><a data-primary="Gang of Four (GoF)" data-type="indexterm" id="idm45043104351296"/><a data-primary="Strategy design pattern" data-secondary="value semantics versus reference semantics" data-tertiary="shortcomings of GoF style" data-type="indexterm" id="idm45043104350624"/><a data-primary="Command design pattern" data-secondary="value semantics versus reference semantics" data-tertiary="shortcomings of GoF style" data-type="indexterm" id="idm45043104349408"/><a data-primary="object-oriented programming (OOP)" data-secondary="GoF style" data-type="indexterm" id="idm45043104348192"/> design patterns collected by the Gang of Four and presented in their book were introduced as object-oriented design
patterns. Almost all of
the 23 design patterns described in their book are using at least one
inheritance hierarchy and thus are firmly rooted in the realm of OO
programming. Templates, the obvious second choice, did not play any part
in the GoF book. This pure OO style is what I refer to as the <em>GoF style</em>.
From today’s perspective, that style may appear to be an old, outdated way
of doing things in C++, but of course we need to remember that the
book was released in October 1994. At that time,
templates may already have been a part of the language (at least they were
officially described in the <em>Annotated Reference Manual (ARM)</em>), but we didn’t have template-related idioms, and C++ was still commonly
perceived as an OO programming language.<sup><a data-type="noteref" href="ch05.xhtml#idm45043104345904" id="idm45043104345904-marker">23</a></sup> Hence, the common way to use C++ was
to primarily use inheritance.</p>
<p>Today we know that the GoF style comes with a number of
disadvantages. One of the most important, and usually one of the most-often
mentioned, is performance:<sup><a data-type="noteref" href="ch05.xhtml#idm45043104344576" id="idm45043104344576-marker">24</a></sup></p>
<ul>
<li>
<p>Virtual functions increase the runtime overhead and diminish the compiler’s
opportunities to optimize.</p>
</li>
<li>
<p>Many allocations of small polymorphic objects cost extra runtime, fragment
the memory, and lead to suboptimal cache usage.</p>
</li>
<li>
<p>The way data is arranged is often counterproductive with respect to
data access schemes.<sup><a data-type="noteref" href="ch05.xhtml#idm45043104340000" id="idm45043104340000-marker">25</a></sup></p>
</li>
</ul>
<p>Performance truly is not one of the strong aspects of the GoF style. Without
going into a complete discussion about all the possible shortcomings of the GoF
style, let’s instead focus on one other disadvantage that I consider of
particular interest: the GoF style falls into what we today call <em>reference
semantics</em> (or sometimes also<a data-primary="pointer semantics" data-type="indexterm" id="idm45043104337536"/> <em>pointer semantics</em>). This style got its name
because it works primarily with pointers and references. To demonstrate term reference semantics means and why it usually comes with a rather
negative connotation, let’s take a look at the following code example using
the C++20 <code>std::span</code> class template:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;iostream&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;span&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;vector&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">print</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">span</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g22_1" id="code_g22_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s"> (</code><code class="s">"</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="sc">'</code><code class="sc"> </code><code class="sc">'</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s"> )</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">v</code><code class="p">{</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_2" id="code_g22_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">w</code><code class="p">{</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_3" id="code_g22_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">span</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">s</code><code class="p">{</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_4" id="code_g22_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">w</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">99</code><code class="p">;</code><code class="w">  </code><code class="c1">// Compilation error!  </code><a class="co" href="#para_g22_5" id="code_g22_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="c1">
</code><code class="w">   </code><code class="n">s</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">99</code><code class="p">;</code><code class="w">  </code><code class="c1">// Works!  </code><a class="co" href="#para_g22_6" id="code_g22_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Prints ( 1 2 99 4 );
</code><code class="w">   </code><code class="n">print</code><code class="p">(</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_7" id="code_g22_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_8" id="code_g22_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">s</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">99</code><code class="p">;</code><code class="w">  </code><code class="c1">// Works!  </code><a class="co" href="#para_g22_9" id="code_g22_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Prints ?
</code><code class="w">   </code><code class="n">print</code><code class="p">(</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_10" id="code_g22_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>The <code>print()</code> function
(<a class="co" href="#code_g22_1" id="para_g22_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>)
demonstrates the purpose of <code>std::span</code>. The <code>std::span</code> class template
represents an abstraction for an array. The <code>print()</code> function can be called
with any kind of array
(built-in arrays, <code>std::array</code>, <code>std::vector</code>, etc.) without coupling to any
specific type of array. In the demonstrated example of <code>std::span</code> with a
dynamic extent (no second template argument representing the size of
the array), a typical implementation of <code>std::span</code> contains two data members:
a pointer to the first element of the array, and the size of the array. For
that reason, <code>std::span</code> is considered easy to copy and is usually
passed by value. Apart from that, <code>print()</code> simply traverses the elements
of the <code>std::span</code> (in our case, integers) and prints them via <code>std::cout</code>.</p>
<p>In the <code>main()</code> function, we first create the <code>std::vector&lt;int&gt;</code> <code>v</code> and
immediately fill it with the integers <code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code>
(<a class="co" href="#code_g22_2" id="para_g22_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
Then we create another <code>std::vector</code> <code>w</code> as a copy of <code>v</code>
(<a class="co" href="#code_g22_3" id="para_g22_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>)
and the <code>std::span</code> <code>s</code>
(<a class="co" href="#code_g22_4" id="para_g22_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>).
Both <code>w</code> and <code>s</code> are qualified with <code>const</code>. Directly after that, we try to
modify both <code>w</code> and <code>s</code> at index <code>2</code>. The attempt to change <code>w</code> fails with
a compilation error: <code>w</code> is declared <code>const</code>, and for that reason it’s not
possible to change the contained elements
(<a class="co" href="#code_g22_5" id="para_g22_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
The attempt to change <code>s</code>, however, works fine. There will be no compilation
error, despite the fact that <code>s</code> is declared <code>const</code>
(<a class="co" href="#code_g22_6" id="para_g22_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).</p>
<p>The reason for this is that <code>s</code> is not a copy of <code>v</code> and does not represent a
value. Instead, it represents a reference to <code>v</code>. It essentially acts as a pointer
to the first element of <code>v</code>. Thus, the <code>const</code> qualifier semantically has
the same effect as declaring a pointer <code>const</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="n">std</code><code class="o">::</code><code class="n">span</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">s</code><code class="p">{</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// s acts as pointer to the first element of v</code>
<code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">ptr</code><code class="p">{</code><code class="w"> </code><code class="n">v</code><code class="p">.</code><code class="n">data</code><code class="p">()</code><code class="w"> </code><code class="p">};</code><code class="w">   </code><code class="c1">// Equivalent semantical meaning</code></pre>
<p>While the pointer <code>ptr</code> cannot be changed and will refer to the first
element of <code>v</code> throughout its lifetime, the referenced integer can be easily
modified. To prevent an assignment to the integer, you would need
to add an additional <code>const</code> qualifier for the <code>int</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="n">std</code><code class="o">::</code><code class="n">span</code><code class="o">&lt;</code><code class="kt">int</code><code class="w"> </code><code class="k">const</code><code class="o">&gt;</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">s</code><code class="p">{</code><code class="n">v</code><code class="p">};</code><code class="w">   </code><code class="c1">// s represents a const pointer to a const int</code>
<code class="kt">int</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">ptr</code><code class="p">{</code><code class="w"> </code><code class="n">v</code><code class="p">.</code><code class="n">data</code><code class="p">()</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// Equivalent semantical meaning</code></pre>
<p>Since the semantics of a pointer and <code>std::span</code> are equivalent,
<code>std::span</code> obviously falls into the category of reference semantics.
And this comes with a number of additional dangers, as demonstrated in
the remainder of the <code>main()</code> function. As a next step, we print the
elements referred to by <code>s</code>
(<a class="co" href="#code_g22_7" id="para_g22_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).
Note that instead, you could also pass the vector <code>v</code> directly, as the
<code>std::span</code> provides the necessary conversion constructors to accept <code>std::vector</code>. The <code>print()</code> function will correctly result in the following
output:</p>
<pre data-type="programlisting">( 1 2 99 4 )</pre>
<p>Because we can (and because by now, the numbers 1 through 4 probably start
to sound a little boring), we now assign a new set of numbers to the vector <code>v</code>
(<a class="co" href="#code_g22_8" id="para_g22_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).
Admittedly, the choice of <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, and <code>9</code> is neither particularly
creative nor entertaining, but it will serve its purpose. Directly afterward,
we again write to the second index by means of <code>s</code>
(<a class="co" href="#code_g22_9" id="para_g22_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>)
and again print the elements referred to by <code>s</code>
(<a class="co" href="#code_g22_10" id="para_g22_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).
Of course, we expect the output to be <code>( 5 6 99 8 9 )</code>, but unfortunately that
is not the case. We might get the following output:<sup><a data-type="noteref" href="ch05.xhtml#idm45043103810576" id="idm45043103810576-marker">26</a></sup></p>
<pre data-type="programlisting">( 1 2 99 4 )</pre>
<p>Maybe this completely shocks you and you end up with a few more gray
hairs.<sup><a data-type="noteref" href="ch05.xhtml#idm45043103808768" id="idm45043103808768-marker">27</a></sup> Perhaps you are merely surprised. Or you knowingly smile and
nod: yes, of course, undefined behavior! When assigning new values to the
<code>std::vector</code> <code>v</code>, we haven’t just changed the values but also the size
of the vector. Instead of four values, it now needs to store five elements.
For that reason, the vector has (possibly) performed a reallocation
and has thus changed the address of its first element. Unfortunately, the
<code>std::span</code> <code>s</code> didn’t get the note and still firmly holds onto the
address of the previous first element. Hence, when we try to write to <code>v</code>
by means of <code>s</code>, we do not write into the current array of <code>v</code> but to
an already discarded piece of memory that used to be the internal array
of <code>v</code>. Classic undefined behavior, and a classic problem of reference
semantics.</p>
<p>“Hey, are you trying to discredit <code>std::span</code>?” you ask. No,
I am not trying to suggest that <code>std::span</code>, and also <code>std::string_view</code>,
are bad. On the contrary, I actually like these two a lot since they
provide remarkably simple and cheap abstractions from all kinds of arrays
and strings, respectively. However, remember that every tool has advantages
and disadvantages. When I use them, I use them consciously, fully aware that
any nonowning reference type requires careful attention to the lifetime
of the value it references. For instance, while I consider both to be very
useful tools for function arguments, I tend to not use them as data members.
The danger of lifetime issues is just too high.<a data-primary="" data-startref="VSshort05" data-type="indexterm" id="idm45043103802832"/><a data-primary="" data-startref="RSshort05" data-type="indexterm" id="idm45043103801856"/></p>
</div></section>
<section data-pdf-bookmark="Reference Semantics: A Second Example" data-type="sect2"><div class="sect2" id="idm45043104355088">
<h2>Reference Semantics: A Second Example</h2>
<p>“Well, of course I knew that,” you<a data-primary="value semantics, versus reference semantics" data-secondary="reference semantics example" data-type="indexterm" id="VSrsex05"/><a data-primary="reference semantics, versus value semantics" data-secondary="reference semantics example" data-type="indexterm" id="RSrsex05"/><a data-primary="Strategy design pattern" data-secondary="value semantics versus reference semantics" data-tertiary="reference semantics example" data-type="indexterm" id="idm45043103796560"/><a data-primary="Command design pattern" data-secondary="value semantics versus reference semantics" data-tertiary="reference semantics example" data-type="indexterm" id="idm45043103795344"/> argue. “I also wouldn’t store <code>std::span</code>
for a longer period of time. However, I’m still not convinced that references
and pointers are a problem.” OK, if that first example wasn’t startling enough,
I have a second example. This time I use one of the STL algorithms, <code>std::remove()</code>.
The <code>std::remove()</code> algorithm takes three arguments: a pair of iterators for
the range that is traversed to remove all elements of a particular value,
and a third argument that represents the value to be removed. In particular,
note that the third argument is passed by a reference-to-<code>const</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ForwardIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">constexpr</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">remove</code><code class="p">(</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">ForwardIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>Let’s take a look at the following code example:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">vec</code><code class="p">{</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">-3</code><code class="p">,</code><code class="w"> </code><code class="mi">27</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">-8</code><code class="p">,</code><code class="w"> </code><code class="mi">22</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="p">,</code><code class="w"> </code><code class="mi">37</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">18</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_11" id="code_g22_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">max_element</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_12" id="code_g22_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="n">vec</code><code class="p">.</code><code class="n">erase</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">remove</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">pos</code><code class="w"> </code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_13" id="code_g22_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code></pre>
<p>We start with the <code>std::vector</code> <code>v</code>, which is initialized with a few random numbers
(<a class="co" href="#code_g22_11" id="para_g22_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>).
Now we are interested in removing all the elements that represent the greatest value
stored in the vector. In our example, that is the value <code>42</code>, which is stored
in the vector twice. The first step in performing the removal is to determine the
greatest value using the <code>std::max_element()</code> algorithm. <code>std::max_element()</code>
returns an iterator to the greatest value. If several elements in the range are
equivalent to the greatest element, it returns the iterator to the first such element
(<a class="co" href="#code_g22_12" id="para_g22_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>).</p>
<p>The second step in removing the greatest values is a call to <code>std::remove()</code>
(<a class="co" href="#code_g22_13" id="para_g22_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).
We pass the range of elements using <code>begin(vec)</code> and <code>end(vec)</code>, and the
greatest value by dereferencing the <code>pos</code> iterator. Last but not least,
we finish the operation with a call to the <code>erase()</code> member function:
we erase all the values between the position returned by the <code>std::remove()</code>
algorithm and the end of the vector. This<a data-primary="erase-remove idiom" data-type="indexterm" id="idm45043103614272"/><a data-primary="idioms" data-secondary="erase-remove" data-type="indexterm" id="idm45043103558208"/> sequence of operations is commonly known as the <a href="https://oreil.ly/fc50R"><em>erase-remove idiom</em></a>.</p>
<p>We expect that both <code>42</code> values are removed from the vector, and therefore we expect
to get the following result:</p>
<pre data-type="programlisting">( 1 -3 27 4 -8 22 37 4 18 9 )</pre>
<p>Unfortunately, this expectation does not hold. Instead, the vector now
contains the following values:</p>
<pre data-type="programlisting">( 1 -3 27 4 -8 22 42 37 18 9 )</pre>
<p>Note that the vector still contains a <code>42</code> but is now missing a <code>4</code>
instead. The underlying reason for this misbehavior is, again, reference
semantics: by passing the dereferenced iterator to the <code>remove()</code>
algorithm, we implicitly state that the value stored in that location
should be removed. However, after removing the first <code>42</code>, this location holds the value <code>4</code>. The
<code>remove()</code> algorithm removes all elements with the value
<code>4</code>. Hence, the next value that is removed is not the next <code>42</code> but the
next <code>4</code>, and so on.<sup><a data-type="noteref" href="ch05.xhtml#idm45043103549472" id="idm45043103549472-marker">28</a></sup></p>
<p>“OK, I got it! But that problem is history! Today we don’t use the
erase-remove idiom anymore. C++20 finally provided us with
the free <code>std::erase()</code> function!” Well, I would love to agree with that
statement, but unfortunately I can only acknowledge the existence
of the <code>std::erase()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Alloc</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">U</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">constexpr</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Alloc</code><code class="o">&gt;::</code><code class="n">size_type</code><code class="w"/>
<code class="w">   </code><code class="n">erase</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">Alloc</code><code class="o">&gt;&amp;</code><code class="w"> </code><code class="n">c</code><code class="p">,</code><code class="w"> </code><code class="n">U</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>The <code>std::erase()</code> function also takes its second argument, the value that is to be
removed, by means of a reference-to-<code>const</code>. Therefore, the problem that I just described
remains. The only way to resolve this problem is to explicitly determine the greatest
element and pass it to the <code>std::remove()</code> algorithm
(<a class="co" href="#code_g22_14" id="para_g22_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">vec</code><code class="p">{</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">-3</code><code class="p">,</code><code class="w"> </code><code class="mi">27</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">-8</code><code class="p">,</code><code class="w"> </code><code class="mi">22</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="p">,</code><code class="w"> </code><code class="mi">37</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">18</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">max_element</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">greatest</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">pos</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_14" id="code_g22_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="n">vec</code><code class="p">.</code><code class="n">erase</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">remove</code><code class="p">(</code><code class="w"> </code><code class="n">begin</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">greatest</code><code class="w"> </code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">(</code><code class="n">vec</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code></pre>
<p>“Are you seriously suggesting that we shouldn’t use reference parameters
anymore?” No, absolutely not! Of course you should use reference parameters,
for instance, for performance reasons. However, I hope to have raised a
certain awareness. Hopefully, you now understand the problem:
references, and especially pointers, make our life so much harder.
It’s harder to understand the code, and therefore it is easier to
introduce bugs into our code. And pointers in particular raise so
many more questions: is it a valid pointer or a <code>nullptr</code>? Who owns
the resource behind the pointer and manages the lifetime? Of course,
lifetime issues are not much of an issue since we have
expanded our toolbox and have smart pointers at our disposal. As
<a href="https://oreil.ly/keyuZ">Core Guideline R.3</a>
clearly states:</p>
<blockquote>
<p>A raw pointer (a T*) is non-owning.</p></blockquote>
<p>In combination with knowing that smart pointers are taking on the
responsibility of ownership, this cleans up the semantics of pointers
quite significantly. But still, despite the fact that smart pointers
are of course an immensely valuable tool and, for good reasons, are
celebrated as a huge achievement of “Modern C++,” in the end
they are only a fix for the holes that reference semantics has torn
in the fabric of our ability to reason about code. Yes, reference
semantics makes it harder to understand code and to reason about the
important details, and thus is something we would like to
avoid.<a data-primary="" data-startref="VSrsex05" data-type="indexterm" id="idm45043103328736"/><a data-primary="" data-startref="RSrsex05" data-type="indexterm" id="idm45043103348864"/></p>
</div></section>
<section data-pdf-bookmark="The Modern C++ Philosophy: Value Semantics" data-type="sect2"><div class="sect2" id="idm45043103800320">
<h2>The Modern C++ Philosophy: Value Semantics</h2>
<p>“But wait,” I<a data-primary="Strategy design pattern" data-secondary="value semantics versus reference semantics" data-tertiary="value semantics" data-type="indexterm" id="idm45043103346416"/><a data-primary="Command design pattern" data-secondary="value semantics versus reference semantics" data-tertiary="value semantics" data-type="indexterm" id="idm45043103345168"/><a data-primary="value semantics, versus reference semantics" data-secondary="value semantics" data-type="indexterm" id="VSVRvalue05"/><a data-primary="reference semantics, versus value semantics" data-secondary="value semantics" data-type="indexterm" id="RSVS05"/> can hear you object, “what other choice do we have?
What should we do? And how else should we cope with inheritance
hierarchies? We can’t avoid pointers there, right?” If you’re thinking something along these lines, then I have very good news
for you: yes, there is a better solution. A solution that makes your
code easier to understand and easier to reason about, and might even
have a positive impact on its performance (remember
we also talked about the negative performance aspects of reference
semantics). The solution is value semantics.</p>
<p>Value semantics is nothing new in C++. The idea was already
part of the original STL. Let’s consider the most famous of the STL
containers, <code>std::vector</code>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">v1</code><code class="p">{</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">auto</code><code class="w"> </code><code class="n">v2</code><code class="p">{</code><code class="w"> </code><code class="n">v1</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_15" id="code_g22_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">v1</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="n">v2</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_16" id="code_g22_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">v1</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="n">v2</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_17" id="code_g22_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="n">v2</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">99</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_18" id="code_g22_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">v1</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="n">v2</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_19" id="code_g22_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">v3</code><code class="p">{</code><code class="w"> </code><code class="n">v1</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g22_20" id="code_g22_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="n">v3</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">99</code><code class="p">;</code><code class="w">  </code><code class="c1">// Compilation error!
</code></pre>
<p>We start with a <code>std::vector</code> called <code>v1</code>, filled with five integers. In the
next line, we create a copy of <code>v1</code>, called <code>v2</code>
(<a class="co" href="#code_g22_15" id="para_g22_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>).
Vector <code>v2</code> is a real copy, sometimes also referred to as a <em>deep copy</em>, which now contains its own chunk of memory and its own integers, and doesn’t refer to the integers in <code>v1</code>.<sup><a data-type="noteref" href="ch05.xhtml#idm45043103166160" id="idm45043103166160-marker">29</a></sup> We can assert
that by comparing the two vectors (they prove to be equal; see
<a class="co" href="#code_g22_16" id="para_g22_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>),
but the addresses of the first elements are 
<span class="keep-together">different</span>
(<a class="co" href="#code_g22_17" id="para_g22_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>).
And changing one element in <code>v2</code> (<a class="co" href="#code_g22_18" id="para_g22_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>)
has the effect that the two vectors are not equal anymore
(<a class="co" href="#code_g22_19" id="para_g22_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a>).
Yes, both vectors have their own arrays. They do not share their content, i.e.,
they do not try to “optimize” the copy operation. You might have heard about
such techniques, for instance, the
<a href="https://oreil.ly/lZae0">copy-on-write</a>
technique. And yes, you might even be aware that this was a common implementation
for <code>std::string</code> prior to C++11. Since C++11, however,
<code>std::string</code> is
<a href="https://oreil.ly/hYbsO">no longer allowed to use copy-on-write</a>
due to its <a href="https://oreil.ly/lW1kV">requirements</a>
formulated in the C++ standard. The reason is that this
“optimization” easily proves to be a pessimization in a multithreaded world.
Hence, we can count on the fact that copy construction creates a real copy.</p>
<p>Last but not least, we create another copy called <code>v3</code>, which we declare as
<code>const</code>
(<a class="co" href="#code_g22_20" id="para_g22_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a>).
If we now try to change a value of <code>v3</code>, we will get a compilation error. This
shows that a <code>const</code> vector does not just prevent adding and removing elements
but that all elements are also considered to be <code>const</code>.</p>
<p>From a semantic perspective, this means that <code>std::vector</code>, just as any
container in the STL, is considered to be a value. Yes, a value, like an <code>int</code>. If we copy a value, we don’t copy just a part of the
value but the entire value. If we make a value <code>const</code>, it is not just
partially <code>const</code> but completely <code>const</code>. That is the rationale of value
semantics. And we’ve seen a couple of advantages already: values are
easier to reason about than pointers and references. For instance, changing
a value does not have an impact on some other value. The change happens
locally, not somewhere else. This is an advantage that compilers heavily
exploit for their optimization efforts. Also, values don’t make us think
about ownership. A value is in charge of its own content. A value also makes
it (much) easier to think about threading issues. That does not mean that
there are no problems anymore (you wish!), but the code is definitely easier
to understand. Values just don’t leave us with a lot of questions.</p>
<p>“OK, I get the point about code clarity,” you argue, “but what about performance?
Isn’t it super expensive to deal with copy operations all the time?” Well,
you are correct; copy operations can be expensive. However, they are only
expensive if they really happen. In real code, we can often rely on
<a href="https://oreil.ly/Bc4jM">copy elision</a>, move
semantics, and well…pass-by-reference.<sup><a data-type="noteref" href="ch05.xhtml#idm45043103081488" id="idm45043103081488-marker">30</a></sup> Also, we have already
seen that, from a performance point of view, value semantics might give us a
performance boost. Yes, of course I am referring to the <code>std::variant</code> example
in <a data-type="xref" href="ch04.xhtml#consider_std_variant_for_implementing_visitors">“Guideline 17: Consider std::variant for 
<span class="keep-together">Implementing Visitor</span>”</a>. In
that example, the use of values of type <code>std::variant</code> has significantly
improved our performance because of fewer indirections due to pointers and a
much better memory layout and access pattern.</p>
</div></section>
<section data-pdf-bookmark="Value Semantics: A Second Example" data-type="sect2"><div class="sect2" id="idm45043103078128">
<h2>Value Semantics: A Second Example</h2>
<p>Let’s take a look at a second example. This time we consider the following
<code>to_int()</code> function:<sup><a data-type="noteref" href="ch05.xhtml#idm45043103076080" id="idm45043103076080-marker">31</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">to_int</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string_view</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>This function parses the given string (and yes, I am using <code>std::string_view</code>
for the purpose of performance) and converts it to an <code>int</code>. The most interesting
question for us now is how the function should deal with errors, or in other
words, what the function should do if the string cannot be converted to an <code>int</code>.
The first option would be to return <code>0</code> for that case. This approach, however,
is questionable, because <code>0</code> is a valid return from the <code>to_int()</code> function. We
would not be able to distinguish success from failure.<sup><a data-type="noteref" href="ch05.xhtml#idm45043103053328" id="idm45043103053328-marker">32</a></sup> Another possible approach would be to throw an exception. Although
exceptions may be the C++ native tool to signal error cases, for this
particular problem, depending on your personal style and preferences, this may
appear as overkill to you. Also, knowing that exceptions cannot be used in a large
fraction of the C++ community, that choice might limit the usability
of the function.<sup><a data-type="noteref" href="ch05.xhtml#idm45043103051664" id="idm45043103051664-marker">33</a></sup></p>
<p>A third possibility is change the signature by a little bit:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">bool</code><code class="w"> </code><code class="nf">to_int</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string_view</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="o">&amp;</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>Now the function takes a reference to a mutable <code>int</code> as the second parameter
and returns a <code>bool</code>. If it succeeds, the function returns <code>true</code> and sets
the passed integer; if it fails, the function returns <code>false</code> and leaves
the <code>int</code> alone. While this may seem like a reasonable compromise to you, I
would argue that we have now strayed further into the realm of reference
semantics (including all potential misuse). At the same time, the clarity of
the code has diminished: the most natural way to return a result is via the
return value, but now the result is produced by an output value. This,
for instance, prevents us from assigning the result to a <code>const</code> value. Therefore,
I would rate this as the least favorable approach so far.</p>
<p>The fourth approach is to return by pointer:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">to_int</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string_view</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>Semantically, this approach is pretty attractive: if it succeeds, the
function returns a valid pointer to an <code>int</code>; if it fails, it returns
a <code>nullptr</code>. Hence, code clarity is improved, as we can clearly distinguish
between these two cases. However, we gain this advantage at the cost of a
dynamic memory allocation, the need to deal with lifetime management using <code>std::unique_ptr</code>, and we’re still lingering in the realm of
reference semantics. So the question is: how can we leverage the
semantic advantages but stick to value semantics? The solution comes
in the form of <code>std::optional</code>:<sup><a data-type="noteref" href="ch05.xhtml#idm45043102967280" id="idm45043102967280-marker">34</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="n">std</code><code class="o">::</code><code class="n">optional</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">to_int</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string_view</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p><a href="https://oreil.ly/6p55b"><code>std::optional</code></a> is a
value type, which represents any other value, in our example, an <code>int</code>.
Therefore, <code>std::optional</code> can take all the values that an <code>int</code> can take.
The specialty of <code>std::optional</code>, however, is that it adds one more state
to the wrapped value, a state that represents no value. Thus, our
<code>std::optional</code> is an <code>int</code> that may or may not be present:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;charconv&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;optional&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;sstream&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string_view&gt;</code><code class="cp"/>

<code class="n">std</code><code class="o">::</code><code class="n">optional</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">to_int</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">string_view</code><code class="w"> </code><code class="n">sv</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">optional</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">oi</code><code class="p">{};</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">{};</code><code class="w"/>

<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">from_chars</code><code class="p">(</code><code class="w"> </code><code class="n">sv</code><code class="p">.</code><code class="n">data</code><code class="p">(),</code><code class="w"> </code><code class="n">sv</code><code class="p">.</code><code class="n">data</code><code class="p">()</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">sv</code><code class="p">.</code><code class="n">size</code><code class="p">(),</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">result</code><code class="p">.</code><code class="n">ec</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">errc</code><code class="o">::</code><code class="n">invalid_argument</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">oi</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">oi</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="n">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"42"</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="n">optional_int</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">to_int</code><code class="p">(</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ... Success: the returned std::optional contains an integer value</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">else</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ... Failure: the returned std::optional does not contain a value</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Semantically, this is equivalent to the pointer approach, but we don’t pay
the cost of dynamic memory allocation, and we don’t have to deal with lifetime
management.<sup><a data-type="noteref" href="ch05.xhtml#idm45043102922992" id="idm45043102922992-marker">35</a></sup> This solution
is semantically clear, understandable, and efficient.</p>
</div></section>
<section data-pdf-bookmark="Prefer to Use Value Semantics to Implement Design Patterns" data-type="sect2"><div class="sect2" id="idm45043103077536">
<h2>Prefer to Use Value Semantics to Implement Design Patterns</h2>
<p>“And what about design patterns?” you ask. “Almost all GoF patterns are based
on inheritance hierarchies and therefore reference semantics. How should we
deal with this?” That is an excellent question. And it provides us with a perfect
bridge to the next guideline. To give a short answer here: you should prefer
to implement design patterns using a value semantics solution. Yes, seriously!
These solutions usually lead to more comprehensive, maintainable code and (often)
better performance.<a data-primary="" data-startref="VSVRvalue05" data-type="indexterm" id="idm45043102714688"/><a data-primary="" data-startref="RSVS05" data-type="indexterm" id="idm45043102713712"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043102712640">
<h5>Guideline 22: Prefer Value Semantics to Reference Semantics</h5>
<ul>
<li>
<p>Be aware that reference semantics make it harder to understand code;</p>
</li>
<li>
<p>Prefer the semantic clarity of value semantics.<a data-primary="" data-startref="SDPvsem05" data-type="indexterm" id="idm45043102709872"/><a data-primary="" data-startref="CDPvsem05" data-type="indexterm" id="idm45043102708896"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 23: Prefer a Value-Based Implementation of Strategy and Command" data-type="sect1"><div class="sect1" id="prefer_a_value_based_implementation_of_strategy_and_command">
<h1>Guideline 23: Prefer a Value-Based Implementation of Strategy and Command</h1>
<p>In <a data-type="xref" href="#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>, I<a data-primary="Strategy design pattern" data-secondary="value-based implementation of" data-type="indexterm" id="SDPvaluebased05"/><a data-primary="Command design pattern" data-secondary="value-based implementation of" data-type="indexterm" id="CDPvaluebased05"/><a data-primary="value semantics, versus reference semantics" data-secondary="value-based Strategy and Command design patterns" data-type="indexterm" id="VSVRstratcom05"/><a data-primary="reference semantics, versus value semantics" data-secondary="value-based Strategy and Command design patterns" data-type="indexterm" id="RSVSstratcom05"/> introduced you to the Strategy design pattern, and in
<a data-type="xref" href="#use_commands_to_isolate_what_things_are_done">“Guideline 21: Use Command to Isolate What Things 
<span class="keep-together">Are Done</span>”</a>, I introduced you to the Command design pattern. I demonstrated that
these two design patterns are essential decoupling tools in your daily toolbox. However, in <a data-type="xref" href="#prefer_value_semantics_to_reference_semantics">“Guideline 22: Prefer Value Semantics over 
<span class="keep-together">Reference Semantics</span>”</a>, I gave you the idea that it’s preferable to use value semantics instead
of reference semantics. And this of course raises the question: how can you
apply that wisdom for the Strategy and Command design patterns? Well, here
is one possible value semantics solution: draw on the abstracting
power of <code>std::function</code>.</p>
<section data-pdf-bookmark="Introduction to std::function" data-type="sect2"><div class="sect2" id="idm45043102696928">
<h2>Introduction to std::function</h2>
<p>In<a data-primary="Strategy design pattern" data-secondary="value-based implementation of" data-tertiary="std::function introduction" data-type="indexterm" id="idm45043102640384"/><a data-primary="Command design pattern" data-secondary="value-based implementation of" data-tertiary="std::function introduction" data-type="indexterm" id="idm45043102639296"/> case you have not yet heard about <code>std::function</code>, allow me to introduce you.
<code>std::function</code> represents an
abstraction for a callable (e.g., a function pointer, 
<span class="keep-together">function</span> object, or lambda).
The only requirement is that the callable satisfies a specific function type,
which is passed as the only template parameter to <code>std::function</code>. The
following code gives an impression:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;functional&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">foo</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s">foo: </code><code class="s">"</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="sc">'</code><code class="sc">\n</code><code class="sc">'</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a default std::function instance. Calling it results
</code><code class="w">   </code><code class="c1">// in a std::bad_function_call exception
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">function</code><code class="o">&lt;</code><code class="kt">void</code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="n">f</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g23_1" id="code_g23_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="p">{</code><code class="w">  </code><code class="c1">// Assigning a callable to 'f'  </code><a class="co" href="#para_g23_2" id="code_g23_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="c1">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="s">"</code><code class="s">lambda: </code><code class="s">"</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="o">&lt;</code><code class="w"> </code><code class="sc">'</code><code class="sc">\n</code><code class="sc">'</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">f</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Calling 'f' with the integer '1'  </code><a class="co" href="#para_g23_3" id="code_g23_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">g</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">f</code><code class="p">;</code><code class="w">  </code><code class="c1">// Copying 'f' into 'g'  </code><a class="co" href="#para_g23_4" id="code_g23_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">foo</code><code class="p">;</code><code class="w">  </code><code class="c1">// Assigning a different callable to 'f'  </code><a class="co" href="#para_g23_5" id="code_g23_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="n">f</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Calling 'f' with the integer '2'  </code><a class="co" href="#para_g23_6" id="code_g23_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="c1">
</code><code class="w">   </code><code class="n">g</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Calling 'g' with the integer '3'  </code><a class="co" href="#para_g23_7" id="code_g23_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>In the <code>main()</code> function, we create an instance of <code>std::function</code>, called <code>f</code>
(<a class="co" href="#code_g23_1" id="para_g23_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
The template parameter specifies the required function type. In our example, this
is <code>void(int)</code>. “Function type…” you say. “Don’t you mean function <em>pointer</em>
type?” Well, since this is indeed something that you might have rarely seen
before, allow me to explain what a function type is and contrast it
with the thing you’ve probably seen more often: function pointers. The
following example uses both a function type and a function pointer type:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">using</code><code class="w"> </code><code class="n">FunctionType</code><code class="w">        </code><code class="o">=</code><code class="w"> </code><code class="kt">double</code><code class="p">(</code><code class="kt">double</code><code class="p">);</code><code class="w"/>
<code class="k">using</code><code class="w"> </code><code class="n">FunctionPointerType</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">double</code><code class="p">(</code><code class="o">*</code><code class="p">)(</code><code class="kt">double</code><code class="p">);</code><code class="w"/>
<code class="c1">// Alternatively:</code>
<code class="c1">// using FunctionPointerType = FunctionType*;</code></pre>
<p>The first line shows a function type. This type represents <em>any</em> function that
takes a <code>double</code> and returns a <code>double</code>. Examples for this function type are
the corresponding overloads of
<a href="https://oreil.ly/1n7fa"><code>std::sin</code></a>,
<a href="https://oreil.ly/LuGeK"><code>std::cos</code></a>,
<a href="https://oreil.ly/ZBNt3"><code>std::log</code></a>, or
<a href="https://oreil.ly/V1XOS"><code>std::sqrt</code></a>.
The second line shows a function pointer type. Note the little asterisk in
parentheses—that makes it a pointer type. This type represents the address
of <em>one</em> function of function type <code>FunctionType</code>. Hence, the relationship between
function types and function pointer types is pretty much like the relationship between
an <code>int</code> and a pointer to an <code>int</code>: while there are many <code>int</code> values, a pointer
to an <code>int</code> stores the address of exactly <em>one</em> <code>int</code>.</p>
<p>Back to the <code>std::function</code> example: initially, the instance is empty, therefore
you cannot call it. If you still try to do so, the <code>std::function</code> instance
will throw the <code>std::bad_function_call</code> exception at you. Better not provoke
it. Let’s rather assign some callable that fulfills the function type
requirements, for instance, a (possibly stateful) lambda
(<a class="co" href="#code_g23_2" id="para_g23_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
The lambda takes an <code>int</code> and doesn’t return anything. Instead, it prints that
it has been called by means of a descriptive output message
(<a class="co" href="#code_g23_3" id="para_g23_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>):</p>
<pre data-type="programlisting">lambda: 1</pre>
<p>OK, that worked well. Let’s try something else: we now create another

<span class="keep-together"><code>std::function</code></span> instance <code>g</code> by means of <code>f</code>
(<a class="co" href="#code_g23_4" id="para_g23_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>).
Then we assign another callable to <code>f</code>
(<a class="co" href="#code_g23_5" id="para_g23_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
This time, we assign a pointer to the function <code>foo()</code>. Again, this callable
fulfills the requirements of the <code>std::function</code> instance: it takes an <code>int</code>
and returns nothing. Directly after the assignment, you call <code>f</code> with the
<code>int</code> <code>2</code>, which triggers the expected output
(<a class="co" href="#code_g23_6" id="para_g23_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>):</p>
<pre data-type="programlisting">foo: 2</pre>
<p>That was probably an easy one. However, the next function call is much more
interesting. If you call <code>g</code> with the integer <code>3</code>
(<a class="co" href="#code_g23_7" id="para_g23_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>),
the output demonstrates that 
<span class="keep-together"><code>std::function</code></span> is firmly based on value semantics:</p>
<pre data-type="programlisting">lambda: 3</pre>
<p>During the initialization of <code>g</code>, the instance <code>f</code> was copied. And it was
copied as a value should be copied: it does not perform a “shallow copy,”
which would result in <code>g</code> being affected when <code>f</code> is subsequently changed,
but it performs a complete copy (deep copy), which includes a copy of
the lambda.<sup><a data-type="noteref" href="ch05.xhtml#idm45043102297200" id="idm45043102297200-marker">36</a></sup> Thus, changing <code>f</code> does not affect <code>g</code>. That’s the benefit of value semantics: the code is easy and intuitive, and you don’t have to be afraid that you are accidentally breaking something anywhere else.</p>
<p>At this point, the functionality of <code>std::function</code> may feel a little
like magic: how is it possible that the <code>std::function</code> instance can take
any kind of callable, including things like lambdas? How can it store
any possible type, even types that it can’t know, and even though these
types apparently have nothing in common? Don’t worry: in <a data-type="xref" href="ch08.xhtml#type_erasure">Chapter 8</a>,
I will give you a thorough introduction to a technique called <em>Type Erasure</em>,
which is the magic behind <code>std::function</code>.</p>
</div></section>
<section data-pdf-bookmark="Refactoring the Drawing of Shapes" data-type="sect2"><div class="sect2" id="idm45043102641456">
<h2>Refactoring the Drawing of Shapes</h2>
<p><code>std::function</code> provides<a data-primary="Strategy design pattern" data-secondary="value-based implementation of" data-tertiary="refactoring drawing of shapes" data-type="indexterm" id="idm45043102289216"/> everything we need to refactor our shape-drawing
example from <a data-type="xref" href="#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>:
it represents the abstraction of a single callable, which is pretty much exactly
what we need to replace the <code>DrawCircleStrategy</code> and <code>DrawSquareStrategy</code>
hierarchies, which each contain a single virtual function. Hence, we rely on the
abstracting power of <code>std::function</code>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Shape</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Circle.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;functional&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">function</code><code class="o">&lt;</code><code class="kt">void</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="p">)</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g23_8" id="code_g23_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g23_10" id="code_g23_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g23_11" id="code_g23_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given radius is valid and that
         the given 'std::function' instance is not empty */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g23_12" id="code_g23_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Square.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;functional&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">function</code><code class="o">&lt;</code><code class="kt">void</code><code class="p">(</code><code class="n">Square</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="p">)</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g23_9" id="code_g23_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Square</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g23_10" id="code_g23_10_2"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">side_</code><code class="p">(</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g23_11" id="code_g23_11_2"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="cm">/* Checking that the given side length is valid and that
         the given 'std::function' instance is not empty */</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g23_12" id="code_g23_12_2"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>First, in the <code>Circle</code> class, we add a type alias for the expected type of
<code>std::function</code>
(<a class="co" href="#code_g23_8" id="para_g23_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).
This <code>std::function</code> type represents any callable that can take a <code>Circle</code>, and
potentially several more drawing-related arguments, and does not return
anything. Of course, we also add the corresponding type alias in the <code>Square</code> class
(<a class="co" href="#code_g23_9" id="para_g23_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).
In the constructors of both <code>Circle</code> and <code>Square</code>, we now take an instance of
type 
<span class="keep-together"><code>std::function</code></span>
(<a class="co" href="#code_g23_10" id="para_g23_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>)
as a replacement for the pointer to a Strategy base class (<code>Draw​Cir⁠cleStrategy</code>
or <code>DrawSquareStrategy</code>). This instance is immediately moved
(<a class="co" href="#code_g23_11" id="para_g23_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>)
into the data member <code>drawer_</code>, which is also of type <code>DrawStrategy</code>
(<a class="co" href="#code_g23_12" id="para_g23_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>).</p>
<p>“Hey, why are you taking the <code>std::function</code> instance by value? Isn’t that
terribly inefficient? Shouldn’t we prefer to pass by reference-to-<code>const</code>?”
In short: no, passing by value is not inefficient, but an elegant compromise
to the alternatives. I admit, though, that this may be surprising. Since this
is definitely an implementation detail worth noting, let’s take a closer
look.</p>
<p>If we used a reference-to-<code>const</code>, we would experience the disadvantage that
<em>rvalues</em> would be unnecessarily copied. If we were passed an rvalue, this
rvalue would bind to the (<em>lvalue</em>) reference-to-<code>const</code>. However, when passing this
reference-to-<code>const</code> to the data member, it would be copied. Which is
not our intention: naturally we want it to be moved. The simple reason is that
we cannot move from <code>const</code> objects (even when using <code>std::move</code>). So, to efficiently deal with rvalues, we would have to provide
overloads of the <code>Circle</code> and <code>Square</code> constructors that would take a
<code>DrawStrategy</code> by means of an rvalue reference (<code>DrawStrategy&amp;&amp;</code>).
For the sake of performance, we would provide two constructors for both <code>Circle</code>
and <code>Square</code>.<sup><a data-type="noteref" href="ch05.xhtml#idm45043101840800" id="idm45043101840800-marker">37</a></sup></p>
<p>The approach to provide two constructors (one for lvalues, one for rvalues) does
work and is efficient, but I would not necessarily call it elegant. Also, we
should probably save our colleagues the trouble of having to deal with
that.<sup><a data-type="noteref" href="ch05.xhtml#idm45043101839408" id="idm45043101839408-marker">38</a></sup> For this reason,
we exploit the implementation of <code>std::function</code>. <code>std::function</code> provides both a
copy constructor and a move constructor, and so we know that it can be moved
efficiently. When we pass a <code>std::function</code> by value, either the copy constructor
or the move constructor will be called. If we are passed an lvalue, the
copy constructor is called, copying the lvalue. Then we would move that copy into
the data member. In total, we would perform one copy and one move to initialize the
<code>drawer_</code> data member. If we are passed an rvalue, the move constructor is
called, moving the rvalue. The resulting argument <code>strategy</code> is then moved into
the data member <code>drawer_</code>. In total, we would perform two move operations to
initialize the <code>drawer_</code> data member. Therefore, this form represents a great
compromise: it is elegant, and there is hardly any difference in efficiency.</p>
<p>Once we’ve refactored the <code>Circle</code> and <code>Square</code> classes, we can implement
different drawing strategies in any form we like (in the form of a function,
a function object, or a lambda). For instance, we can implement the following
<code>OpenGLCircleStrategy</code> as a function object:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;OpenGLCircleStrategy.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">OpenGLCircleStrategy</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">OpenGLCircleStrategy</code><code class="p">(</code><code class="w"> </code><code class="cm">/* Drawing related arguments */</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">operator</code><code class="p">(</code><code class="p">)</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g23_13" id="code_g23_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="cm">/* Drawing related data members, e.g. colors, textures, ... */</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The only convention we need to follow is that we need to provide a call operator
that takes a <code>Circle</code> and potentially several more drawing-related arguments, and doesn’t return anything (fulfill the function type <code>void(Circle const&amp;, /*…*/)</code>)
(<a class="co" href="#code_g23_13" id="para_g23_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).</p>
<p>Assuming a similar implementation for an <code>OpenGLSquareStrategy</code>, we can now create
different kinds of shapes, configure them with the desired drawing behavior, and
finally draw them:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Square.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;OpenGLCircleStrategy.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;OpenGLSquareStrategy.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;vector&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">Shapes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">Shape</code><code class="o">&gt;&gt;</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="n">Shapes</code><code class="w"> </code><code class="n">shapes</code><code class="p">{};</code><code class="w"/>

<code class="w">   </code><code class="c1">// Creating some shapes, each one</code>
<code class="w">   </code><code class="c1">//   equipped with the corresponding OpenGL drawing strategy</code>
<code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Circle</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="mf">2.3</code><code class="p">,</code><code class="w"> </code><code class="n">OpenGLCircleStrategy</code><code class="p">(</code><code class="cm">/*...red...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Square</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="mf">1.2</code><code class="p">,</code><code class="w"> </code><code class="n">OpenGLSquareStrategy</code><code class="p">(</code><code class="cm">/*...green...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">shapes</code><code class="p">.</code><code class="n">emplace_back</code><code class="p">(</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Circle</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="mf">4.1</code><code class="p">,</code><code class="w"> </code><code class="n">OpenGLCircleStrategy</code><code class="p">(</code><code class="cm">/*...blue...*/</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Drawing all shapes</code>
<code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">shape</code><code class="o">-&gt;</code><code class="n">draw</code><code class="p">();</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>main()</code> function is very similar to the original implementation using the
classic Strategy implementation (see
<a data-type="xref" href="#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>). However,
this nonintrusive, base class–free approach with <code>std::function</code> further
reduces the coupling. This becomes evident in the 
<span class="keep-together">dependency</span> graph for this
solution<a data-primary="Command design pattern" data-secondary="value-based implementation of" data-tertiary="std::function dependency graph" data-type="indexterm" id="idm45043101418752"/><a data-primary="Strategy design pattern" data-secondary="value-based implementation of" data-tertiary="std::function dependency graph" data-type="indexterm" id="idm45043101417632"/> (see <a data-type="xref" href="#fig_function_dependency_graph">Figure 5-9</a>): we can implement the drawing
functionality in any form we want (as a free function, a function object, or a
lambda) and we don’t have to abide by the requirements of a base class. Also, by
means of 
<span class="keep-together"><code>std::function</code></span> we have automatically inverted the dependencies
(see <a data-type="xref" href="ch02.xhtml#pay_attention_to_the_ownership_of_abstractions">“Guideline 9: Pay Attention to the Ownership of Abstractions”</a>).</p>
<figure><div class="figure" id="fig_function_dependency_graph">
<img alt="Dependency graph for the +std::function+ solution." height="984" src="assets/cpsd_0509.png" width="1443"/>
<h6><span class="label">Figure 5-9. </span>Dependency graph for the <code>std::function</code> solution</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Performance Benchmarks" data-type="sect2"><div class="sect2" id="idm45043102290768">
<h2>Performance Benchmarks</h2>
<p>“I like the flexibility, the freedom. This<a data-primary="Strategy design pattern" data-secondary="value-based implementation of" data-tertiary="performance benchmarks" data-type="indexterm" id="idm45043101409952"/><a data-primary="Command design pattern" data-secondary="value-based implementation of" data-tertiary="performance benchmarks" data-type="indexterm" id="idm45043101408736"/> is great! But what about
performance?” Yes, spoken like a true C++ developer. Of course
performance is important. Before showing you the performance results, though,
let me remind you of the benchmark scenario that we also used to
get the numbers for <a data-type="xref" href="ch04.xhtml#table_cyclic_visitor_benchmark_results">Table 4-2</a> in
<a data-type="xref" href="ch04.xhtml#use_visitors_to_extend_operations">“Guideline 16: Use Visitor to Extend Operations”</a>. For the benchmark,
I have implemented four different kinds of shapes (circles, squares, ellipses,
and rectangles). Again, I’m running 25,000 translate operations on 10,000
randomly created shapes. I use both GCC 11.1 and Clang 11.1, and for both
compilers I’m adding only the <code>-O3</code> and <code>-DNDEBUG</code> compilation flags. The
platform I’m using is macOS Big Sur (version 11.4) on an 8-Core Intel Core i7
with 3.8 GHz, 64 GB of main memory.</p>
<p>With this information in mind, you are ready for the performance results.
<a data-type="xref" href="#table_strategy_benchmark_results">Table 5-1</a> shows the performance numbers for the
Strategy-based implementation of the drawing example and the resulting
solution using <code>std::function</code>.</p>
<table id="table_strategy_benchmark_results">
<caption><span class="label">Table 5-1. </span>Performance results for different <em>Strategy</em> implementations</caption>
<thead>
<tr>
<th>Strategy implementations</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Object-oriented solution</p></td>
<td><p>1.5205 s</p></td>
<td><p>1.1480 s</p></td>
</tr>
<tr>
<td><p><code>std::function</code></p></td>
<td><p>2.1782 s</p></td>
<td><p>1.4884 s</p></td>
</tr>
<tr>
<td><p>Manual implementation of <code>std::function</code></p></td>
<td><p>1.6354 s</p></td>
<td><p>1.4465 s</p></td>
</tr>
<tr>
<td><p>Classic Strategy</p></td>
<td><p>1.6372 s</p></td>
<td><p>1.4046 s</p></td>
</tr>
</tbody>
</table>
<p>For<a data-primary="object-oriented programming (OOP)" data-secondary="Strategy design pattern" data-type="indexterm" id="idm45043101389344"/> reference purposes, the first line shows the performance of the
object-oriented solution from <a data-type="xref" href="ch04.xhtml#design_for_the_addition_of_types_or_operations">“Guideline 15: Design for the Addition of 
<span class="keep-together">Types or Operations</span>”</a>.
As you can see, this solution gives the best performance. This is not unexpected,
however: since the Strategy design pattern, irrespective of the actual
implementation, introduces additional overhead, the performance is anticipated
to be reduced.</p>
<p>What is not expected, though, is that the <code>std::function</code> implementation
incurs a performance overhead (even a significant one in case of GCC). But
wait, before you throw this approach into your mental trash can, consider the
third line. It shows a manual implementation of <code>std::function</code> using
Type Erasure, the technique I will explain in <a data-type="xref" href="ch08.xhtml#type_erasure">Chapter 8</a>. This
implementation performs much
better, in fact as good (or nearly as good for Clang) as a classic implementation
of the Strategy design pattern (see the fourth line). This result
demonstrates that the problem is not value semantics but the specific
implementation details of <code>std::function</code>.<sup><a data-type="noteref" href="ch05.xhtml#idm45043101384208" id="idm45043101384208-marker">39</a></sup> In summary, a value semantics approach is not worse in terms of performance than the classic approach, but
instead, as shown before, it improves many important aspects of your code.</p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the std::function Solution" data-type="sect2"><div class="sect2" id="idm45043101382944">
<h2>Analyzing the Shortcomings of the std::function Solution</h2>
<p>Overall, the<a data-primary="Strategy design pattern" data-secondary="value-based implementation of" data-tertiary="std::function shortcomings" data-type="indexterm" id="idm45043101381312"/><a data-primary="Command design pattern" data-secondary="value-based implementation of" data-tertiary="std::function shortcomings" data-type="indexterm" id="idm45043101380080"/> <code>std::function</code> implementation of the Strategy design pattern
provides a number of benefits. First, your code gets cleaner and more readable
since you don’t have to deal with pointers and the associated lifetime management
(for instance, using <code>std::unique_ptr</code>), and since you don’t experience
the usual problems with 
<span class="keep-together">reference</span> semantics (see
<a data-type="xref" href="#prefer_value_semantics_to_reference_semantics">“Guideline 22: Prefer Value Semantics over 
<span class="keep-together">Reference Semantics</span>”</a>). Second, you promote loose
coupling. Very loose coupling, actually. In this context, <code>std::function</code> acts like
a compilation firewall, which protects you from the implementation details of the
different Strategy implementations but at the same time provides enormous
flexibility for developers on how to implement the different Strategy solutions.</p>
<p>Despite these upsides, no solution comes without downsides—even the 
<span class="keep-together"><code>std::function</code></span> approach has its disadvantages. I have already
pointed out the potential performance disadvantage if you rely on the standard
implementation. While there are solutions to minimize this effect (see
<a data-type="xref" href="ch08.xhtml#type_erasure">Chapter 8</a>), it’s still something to consider in your codebase.</p>
<p>There is also a design-related issue. <code>std::function</code> can
replace only a single virtual function. If you need to abstract multiple virtual
functions, which could occur if you want to configure multiple aspects
using the Strategy design pattern, or if you need an <code>undo()</code> function
in the Command design pattern, you would have to use multiple <code>std::function</code>
instances. This would not only increase the size of a class due to the multiple data
members, but also incur an interface burden due to the question of how to
elegantly handle passing multiple <code>std::function</code> instances. For this reason, the
<code>std::function</code> approach works best for replacing a single or a very small
number of virtual functions. Still, this does not mean that you can’t use a
value-based approach for multiple virtual functions: if you encounter that
situation, consider generalizing the approach by applying the technique used for
<code>std::function</code> directly to your type. I will explain how to do that in
<a data-type="xref" href="ch08.xhtml#type_erasure">Chapter 8</a>.</p>
<p>Despite these shortcomings, the value semantics approach proves to be a terrific choice for the Strategy design pattern. The same is
true for the Command design pattern. Therefore, keep this guideline in mind as an essential step towards modern 
<span class="keep-together">C++.</span></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="guideline_23_prefer_a_value_based">
<h5>Guideline 23: Prefer a Value-Based Implementation of Strategy 
<span class="keep-together">and Command</span></h5>
<ul>
<li>
<p>Consider using <code>std::function</code> to implement the Strategy or Command design pattern.</p>
</li>
<li>
<p>Take the performance disadvantages of <code>std::function</code> into account.</p>
</li>
<li>
<p>Be aware that Type Erasure is a generalization of the value semantics approach for Strategy and Command.<a data-primary="" data-startref="SDPvaluebased05" data-type="indexterm" id="idm45043101362880"/><a data-primary="" data-startref="CDPvaluebased05" data-type="indexterm" id="idm45043101361904"/><a data-primary="" data-startref="VSVRstratcom05" data-type="indexterm" id="idm45043101360960"/><a data-primary="" data-startref="RSVSstratcom05" data-type="indexterm" id="idm45043101360016"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45043109967248"><sup><a href="ch05.xhtml#idm45043109967248-marker">1</a></sup> See <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>.</p><p data-type="footnote" id="idm45043109965312"><sup><a href="ch05.xhtml#idm45043109965312-marker">2</a></sup> You may correctly argue that there are multiple solutions for this problem: you could have one source file per graphics library, you could rely on the preprocessor by sprinkling a couple of <code>#ifdef</code>s across the code, or you could implement an abstraction layer around the graphics libraries. The first two options feel like technical workarounds to a flawed design. The latter option, however, is a reasonable, alternative solution to the one that I will propose. It’s a solution based on the <em>Facade</em> design pattern, which, unfortunately, I don’t cover in this book.</p><p data-type="footnote" id="idm45043109522832"><sup><a href="ch05.xhtml#idm45043109522832-marker">3</a></sup> David Thomas and Andrew Hunt, <em>The Pragmatic Programmer</em>.</p><p data-type="footnote" id="idm45043109517728"><sup><a href="ch05.xhtml#idm45043109517728-marker">4</a></sup> Erich Gamma et al., <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p><p data-type="footnote" id="idm45043109508880"><sup><a href="ch05.xhtml#idm45043109508880-marker">5</a></sup> Please explicitly note that I said <em>naive</em>. Although the code example is didactically a little questionable, I will show a common misconception before showing a proper implementation. My hope is that this way you will never fall into this common trap.</p><p data-type="footnote" id="idm45043109417808"><sup><a href="ch05.xhtml#idm45043109417808-marker">6</a></sup> Although this is not a book about implementation details, please allow me to highlight one implementation detail that I find to be the source of many questions in my training classes. I’m certain you’ve heard about the Rule of 5—if not, please see the <a href="https://oreil.ly/fzS3f">C++ Core Guidelines</a>. Hence, you realize that the declaration of a virtual destructor disables the move operations. Strictly speaking, this is a violation of the Rule of 5. However, as <a href="https://oreil.ly/fzS3f">Core Guideline C.21</a> explains, for base classes this is not considered to be a problem, as long as the base class does not contain any data members.</p><p data-type="footnote" id="idm45043108959024"><sup><a href="ch05.xhtml#idm45043108959024-marker">7</a></sup> As I have referenced Core Guideline C.21 before, it is also worth mentioning that both the <code>Circle</code> and <code>Square</code> classes fulfill the <em>Rule of 0</em>; see <a href="https://oreil.ly/Gt5Sz">Core Guideline C.20</a>. By not falling into the habit of adding a destructor, the compiler itself generates all special member functions for both classes. And yes, worry not—the destructor is still virtual since the base class destructor is virtual.</p><p data-type="footnote" id="idm45043108775712"><sup><a href="ch05.xhtml#idm45043108775712-marker">8</a></sup> See <a data-type="xref" href="ch04.xhtml#beware_the_performance_of_acyclic_visitors">“Guideline 18: Beware the Performance of Acyclic Visitor”</a> for a discussion about the Acyclic Visitor design pattern.</p><p data-type="footnote" id="idm45043107792496"><sup><a href="ch05.xhtml#idm45043107792496-marker">9</a></sup> I should explicitly state that it does not work in dynamic polymorphism. It does work in static polymorphism, even quite well. Consider, for instance, templates and function overloading.</p><p data-type="footnote" id="idm45043107080048"><sup><a href="ch05.xhtml#idm45043107080048-marker">10</a></sup> Andrei Alexandrescu, <em>Modern C++ Design: Generic Programming and Design Patterns Applied</em> (Addison-Wesley, 2001).</p><p data-type="footnote" id="idm45043106795536"><sup><a href="ch05.xhtml#idm45043106795536-marker">11</a></sup> Sean Parent, <a href="https://oreil.ly/F8FDL">“Inheritance Is the Base Class Of Evil”</a>, GoingNative, 2013.</p><p data-type="footnote" id="idm45043106632784"><sup><a href="ch05.xhtml#idm45043106632784-marker">12</a></sup> According to Sean Parent, there are no polymorphic types, only polymorphic usage of similar types; see <a href="https://oreil.ly/5HwgM">“Better Code: Runtime Polymorphism”</a> from the NDC London conference in 2017. My statement supports that opinion.</p><p data-type="footnote" id="idm45043106629568"><sup><a href="ch05.xhtml#idm45043106629568-marker">13</a></sup> Another example of inheritance creating coupling is discussed in Herb Sutter’s <em>Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Exception-Safety Solutions</em> (Pearson Education).</p><p data-type="footnote" id="idm45043106561024"><sup><a href="ch05.xhtml#idm45043106561024-marker">14</a></sup> Are they really to blame for this habit? Since they’ve been taught that this is the way to go for decades, who can blame them for thinking this way?</p><p data-type="footnote" id="idm45043106560240"><sup><a href="ch05.xhtml#idm45043106560240-marker">15</a></sup> Michael C. Feathers, <em>Working Effectively with Legacy Code</em>.</p><p data-type="footnote" id="idm45043106558560"><sup><a href="ch05.xhtml#idm45043106558560-marker">16</a></sup> Programming by difference is a rather extreme form of inheritance-based programming, where even small differences are expressed by introducing a new derived class. See Michael’s book for more details.</p><p data-type="footnote" id="idm45043106557328"><sup><a href="ch05.xhtml#idm45043106557328-marker">17</a></sup> See, for instance, the Strategy design pattern in <a data-type="xref" href="#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>, the Observer design pattern in <a data-type="xref" href="ch06.xhtml#apply_observers_as_an_abstract_notification_mechanism">“Guideline 25: Apply Observers as an Abstract Notification Mechanism”</a>, the Adapter design pattern in <a data-type="xref" href="ch06.xhtml#use_adapters_to_standardize_interfaces">“Guideline 24: Use Adapters to Standardize Interfaces”</a>, the Decorator design pattern in <a data-type="xref" href="ch09.xhtml#use_decorators_to_add_customization_hierarchically">“Guideline 35: Use Decorators to Add Customization Hierarchically”</a>, or the Bridge design pattern in <a data-type="xref" href="ch07.xhtml#build_bridges_to_remove_physical_dependencies">“Guideline 28: Build Bridges to Remove 
<span class="keep-together">Physical Dependencies</span>”</a>.</p><p data-type="footnote" id="idm45043106526608"><sup><a href="ch05.xhtml#idm45043106526608-marker">18</a></sup> Erich Gamma et al., <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p><p data-type="footnote" id="idm45043105484832"><sup><a href="ch05.xhtml#idm45043105484832-marker">19</a></sup> Yes, it follows the SOLID principles, although of course by means of the classic form of the Command design pattern. If you are right now biting your fingernails in frustration or simply wondering if there isn’t a better way, then please be patient. I will demonstrate a much nicer, much more “modern” solution in <a data-type="xref" href="#prefer_value_semantics_to_reference_semantics">“Guideline 22: Prefer Value Semantics over 
<span class="keep-together">Reference Semantics</span>”</a>.</p><p data-type="footnote" id="idm45043105381936"><sup><a href="ch05.xhtml#idm45043105381936-marker">20</a></sup> The given <code>ThreadPool</code> class is far from being complete and primarily serves as an illustration for the Command design pattern. For a working, professional implementation of a thread pool, please refer to Anthony William’s book <em>C++ Concurrency in Action</em>, 2nd ed. (Manning).</p><p data-type="footnote" id="idm45043104876160"><sup><a href="ch05.xhtml#idm45043104876160-marker">21</a></sup> This is another example of my statement that design patterns are not about implementation details; see <a data-type="xref" href="ch03.xhtml#beware_of_design_pattern_misconceptions">“Guideline 12: Beware of Design Pattern Misconceptions”</a>.</p><p data-type="footnote" id="idm45043104697792"><sup><a href="ch05.xhtml#idm45043104697792-marker">22</a></sup> For the complete shape example, see <a data-type="xref" href="#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>.</p><p data-type="footnote" id="idm45043104345904"><sup><a href="ch05.xhtml#idm45043104345904-marker">23</a></sup> Margaret A. Ellis and Bjarne Stroustrup, <em>The Annotated C++ Reference Manual</em> (Addison-Wesley, 1990).</p><p data-type="footnote" id="idm45043104344576"><sup><a href="ch05.xhtml#idm45043104344576-marker">24</a></sup> To get an overview of C++ performance aspects in general and performance-related issues with inheritance hierarchies in particular, refer to Kurt Guntheroth’s book, <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/optimized-c/9781491922057/"><em>Optimized C{plus}{plus}</em></a> (O’Reilly).</p><p data-type="footnote" id="idm45043104340000"><sup><a href="ch05.xhtml#idm45043104340000-marker">25</a></sup> A possible solution for that is to employ techniques from data-oriented design; see Richard Fabian, <em>Data-Oriented Design: Software Engineering for Limited Resources and Short Schedules</em>.</p><p data-type="footnote" id="idm45043103810576"><sup><a href="ch05.xhtml#idm45043103810576-marker">26</a></sup> Mark my choice of words: “We might get the following output.” Indeed, we might get this output but also something else. It depends, as we have inadvertently entered the realm of undefined behavior. Therefore, this output is my best guess, not a guarantee.</p><p data-type="footnote" id="idm45043103808768"><sup><a href="ch05.xhtml#idm45043103808768-marker">27</a></sup> Now not only your manicurist but also your hairdresser has work to do…</p><p data-type="footnote" id="idm45043103549472"><sup><a href="ch05.xhtml#idm45043103549472-marker">28</a></sup> More gray hairs, more work for your hairdresser.</p><p data-type="footnote" id="idm45043103166160"><sup><a href="ch05.xhtml#idm45043103166160-marker">29</a></sup> I should explicitly point out that the notion of a “deep copy” depends on the type <code>T</code> of elements in the vector: if <code>T</code> performs a deep copy, then so does the <code>std::vector</code>, but if <code>T</code> performs a shallow copy, then semantically <code>std::vector</code> also performs a shallow copy.</p><p data-type="footnote" id="idm45043103081488"><sup><a href="ch05.xhtml#idm45043103081488-marker">30</a></sup> The best and most complete introduction to move semantics is Nicolai Josuttis’s book on the subject, <em>C++ Move Semantics - The Complete Guide</em> (NicoJosuttis, 2020).</p><p data-type="footnote" id="idm45043103076080"><sup><a href="ch05.xhtml#idm45043103076080-marker">31</a></sup> See Patrice Roy’s CppCon 2016 talk, <a href="https://oreil.ly/REqOG">“The Exception Situation”</a>, for a similar example and discussion.</p><p data-type="footnote" id="idm45043103053328"><sup><a href="ch05.xhtml#idm45043103053328-marker">32</a></sup> Yet this is exactly the approach taken by the <a href="https://oreil.ly/fByFB"><code>std::atoi()</code> function</a>.</p><p data-type="footnote" id="idm45043103051664"><sup><a href="ch05.xhtml#idm45043103051664-marker">33</a></sup> In his standard proposal <a href="https://oreil.ly/E6Qd7">P0709</a>, Herb Sutter explains that 52% of C++ developers have no or limited access to exceptions.</p><p data-type="footnote" id="idm45043102967280"><sup><a href="ch05.xhtml#idm45043102967280-marker">34</a></sup> The experienced C++ developer also knows that C++23 will bless us with a very similar type called <code>std::expected</code>. In a few years, this might be the appropriate way to write the <code>to_int()</code> function.</p><p data-type="footnote" id="idm45043102922992"><sup><a href="ch05.xhtml#idm45043102922992-marker">35</a></sup> From a functional programming point of view, <code>std::optional</code> represents a <a href="https://oreil.ly/IowBp"><em>monad</em></a>. You’ll find much more valuable information on <em>monad</em>s and functional programming in general in Ivan Čukić’s book, <em>Functional Programming in C++</em>.</p><p data-type="footnote" id="idm45043102297200"><sup><a href="ch05.xhtml#idm45043102297200-marker">36</a></sup> In this example, the <code>std::function</code> object performs a deep copy, but generally speaking, <code>std::function</code> copies the contained callable according to its copy semantics (“deep” or “shallow”). <code>std::function</code> has no way of forcing a deep copy.</p><p data-type="footnote" id="idm45043101840800"><sup><a href="ch05.xhtml#idm45043101840800-marker">37</a></sup> This implementation detail is explained thoroughly by Nicolai Josuttis in this CppCon 2017 talk, <a href="https://oreil.ly/IbZHb">“The Nightmare of Move Semantics for Trivial Classes”</a>.</p><p data-type="footnote" id="idm45043101839408"><sup><a href="ch05.xhtml#idm45043101839408-marker">38</a></sup> One more example of the <a href="https://oreil.ly/N7c3B"><em>KISS</em> principle</a>.</p><p data-type="footnote" id="idm45043101384208"><sup><a href="ch05.xhtml#idm45043101384208-marker">39</a></sup> A discussion about the reasons for the performance deficiencies of some <code>std::function</code> implementations would go beyond the scope and purpose of this book. Still, please keep this detail in mind for performance-critical sections of your code.</p></div></div></section></div></body></html>