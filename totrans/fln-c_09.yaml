- en: Chapter 8\. Organizing Files in Modular Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章\. 模块化程序中的文件组织
- en: 'Any programmer who implements a larger piece of software and wants to make
    that software maintainable confronts the question of how to make the software
    modular. The most important part of that question that is related to dependencies
    between software-modules is answered, for example, by the SOLID design principles
    described in the book *Clean Code: A Handbook of Agile Software Craftsmanship*
    by Robert C. Martin (Prentice Hall, 2008) or by the design patterns described
    in the book *Design Patterns: Elements of Reusable Object-Oriented Software* by
    the Gang of Four (Prentice Hall, 1997).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '任何实现较大软件并希望使该软件易于维护的程序员都会面临如何使软件模块化的问题。这个问题的最重要部分与软件模块之间的依赖关系有关，例如，由Robert
    C. Martin在《Clean Code: A Handbook of Agile Software Craftsmanship》（Prentice Hall，2008）中描述的SOLID设计原则或由Gang
    of Four在《Design Patterns: Elements of Reusable Object-Oriented Software》（Prentice
    Hall，1997）中描述的设计模式提供了相关答案。'
- en: However, making software modular also raises the question of how to organize
    the source files in a way that allows someone to make the software modular. That
    question has not yet been answered very well, which results in bad file structures
    in codebases. It is difficult to make such codebases modular later on, because
    you don’t know which files you should separate into different software-modules
    or into different codebases. Also, as a programmer, it is difficult to find the
    files containing APIs that you are supposed to use, and thus you might bring in
    dependencies to APIs that you are not supposed to use. This is an issue for C
    in particular because C does not support any mechanism to mark APIs for internal
    use only and restrict access to them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使软件模块化也引发了如何组织源文件的问题，使得某人能够使软件模块化的问题尚未得到很好的解答，这导致代码库中存在糟糕的文件结构。稍后将这样的代码库变得模块化是很困难的，因为您不知道应该将哪些文件分隔成不同的软件模块或不同的代码库。此外，作为程序员，找到包含您应该使用的API的文件也很困难，因此您可能会引入不应使用的API的依赖关系。这对于C语言来说尤为严重，因为C语言不支持标记仅供内部使用的API并限制对其的访问的任何机制。
- en: There are such mechanisms in other programming languages, and there is advice
    on how to structure files. For example, the Java programming language comes with
    the concept of *packages*. Java provides a default way for the developer to organize
    the classes for these packages and thus the files within the package. For other
    programming languages, such as C, there is no such advice on how to structure
    files. Developers have to come up with their own approach for how to structure
    the header files containing the C function declarations and the implementation
    files containing the C function definitions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其他编程语言中有这样的机制，并且有关如何结构化文件的建议。例如，Java编程语言提供了*包*的概念。Java为开发人员提供了一种默认的方式来组织这些包的类以及包内的文件。对于其他编程语言，如C语言，没有关于如何结构化文件的这样的建议。开发人员必须自行决定如何结构化包含C函数声明的头文件以及包含C函数定义的实现文件。
- en: This chapter shows how to tackle this problem by providing guidance for C programmers
    on how to structure implementation files, in particular, how to structure header
    files (APIs) in order to allow the development of large, modular C programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何通过为C程序员提供指导来解决这个问题，特别是如何结构化实现文件，特别是如何结构化头文件（API），以便允许开发大型、模块化的C程序。
- en: '[Figure 8-1](#overview_directory) shows an overview of the patterns covered
    in this chapter, and [Table 8-1](#tab_directory) provides a short description
    of these patterns.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](#overview_directory) 显示了本章涵盖的模式概述，而 [表 8-1](#tab_directory) 提供了这些模式的简短描述。'
- en: '![Overview of patterns on how to organize your code files](assets/fluc_0801.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![如何组织您的代码文件的模式概述](assets/fluc_0801.png)'
- en: Figure 8-1\. Overview of patterns for how to organize your code files
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 如何组织您的代码文件的模式概述
- en: Table 8-1\. Patterns for how to organize your code files
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. 如何组织您的代码文件的模式
- en: '|  | Pattern name | Summary |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|  | 模式名称 | 摘要 |'
- en: '| --- | --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  | Include Guard | It’s easy to include a header file multiple times, but
    including the same header file leads to compile errors if types or certain macros
    are part of it, because during compilation they get redefined. Therefore, protect
    the content of your header files against multiple inclusion so that the developer
    using the header files does not have to care whether it is included multiple times.
    Use an interlocked `#ifdef` statement or a `#pragma once` statement to achieve
    this. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  | 包含保护 | 多次包含头文件很容易，但如果包含同一个头文件，则会导致编译错误，因为其中的类型或某些宏在编译过程中会被重新定义。因此，请保护您的头文件内容，防止多次包含，这样使用头文件的开发人员就无需担心是否多次包含。使用互锁的`#ifdef`语句或`#pragma
    once`语句来实现此功能。 |'
- en: '|  | Software-Module Directories | Splitting code into different files increases
    the number of files in your codebase. Having all files in one directory makes
    it difficult to keep an overview of all the files, particularly for large codebases.
    Therefore, put header files and implementation files that belong to a tightly
    coupled functionality into one directory. Name that directory after the functionality
    that is provided via the header files. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  | 软件模块目录 | 将代码拆分为不同的文件会增加代码库中的文件数量。将所有文件放在一个目录中将使得难以对所有文件进行概览，特别是对于大型代码库而言。因此，将属于紧密耦合功能的头文件和实现文件放在一个目录中。将该目录命名为提供通过头文件提供的功能的名称。
    |'
- en: '|  | Global Include Directory | To include files from other software-modules,
    you have to use relative paths like *../othersoftwaremodule/file.h*. You have
    to know the exact location of the other header file. Therefore, have one global
    directory in your codebase that contains all software-module APIs. Add this directory
    to the global include paths in your toolchain. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  | 全局包含目录 | 要包含来自其他软件模块的文件，您必须使用类似*../othersoftwaremodule/file.h*的相对路径。您必须知道其他头文件的确切位置。因此，在您的代码库中有一个全局目录，包含所有软件模块的API。将此目录添加到工具链中的全局包含路径中。
    |'
- en: '|  | Self-Contained Components | From the directory structure it is not possible
    to see the dependencies in the code. Any software-module can simply include the
    header files from any other software-module, so it’s impossible to check dependencies
    in the code via the compiler. Therefore, identify software-modules that contain
    similar functionality and that should be deployed together. Put these software-modules
    into a common directory and have a designated subdirectory for their header files
    that are relevant for the caller. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  | 自包含组件 | 从目录结构中无法看出代码的依赖关系。任何软件模块都可以简单地包含来自任何其他软件模块的头文件，因此无法通过编译器检查代码中的依赖关系。因此，请识别包含类似功能并应一起部署的软件模块。将这些软件模块放入共同目录，并为调用者相关的头文件设立一个指定的子目录。
    |'
- en: '|  | API Copy | You want to develop, version, and deploy the parts of your
    codebase independently from one another. However, to do that, you need clearly
    defined interfaces between the code parts and the ability to separate that code
    into different repositories. Therefore, to use the functionality of another component,
    copy its API. Build that other component separately and copy the build artifacts
    and its public header files. Put these files into a directory inside your component
    and configure that directory as a global include path. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  | API复制 | 您希望独立开发、版本化和部署代码库的各个部分。然而，为了实现这一点，您需要在代码部分之间有清晰定义的接口，并能够将该代码分开到不同的存储库中。因此，要使用另一个组件的功能，请复制其API。单独构建该其他组件并复制构建产物及其公共头文件。将这些文件放入组件内的一个目录，并将该目录配置为全局包含路径。
    |'
- en: Running Example
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'Imagine you want to implement a piece of software that prints the hash value
    for some file content. You start with the following code for a simple hash function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您希望实现一个打印某些文件内容哈希值的软件片段。您可以从以下简单哈希函数的代码开始：
- en: '*main.c*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.c*'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code simply prints the hash output of a fixed string to the console
    output. Next, you want to extend that code. You want to read the content of a
    file and print the hash of the file content. You could simply add all this code
    to the *main.c* file, but that would make the file very long, and it would make
    the code more unmaintainable the more it grows.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码简单地将固定字符串的哈希输出打印到控制台输出。接下来，您希望扩展该代码。您希望读取文件的内容并打印文件内容的哈希值。您可以简单地将所有这些代码添加到*main.c*文件中，但这将使文件变得非常长，并且随着代码的增长，它将使代码更加难以维护。
- en: 'Instead, it is much better to have separate implementation files and access
    their functionality with Header Files. You now have the following code for reading
    the content of a file and printing the hash of the file content. To make it easier
    to see which parts of the code changed, the implementations that did not change
    are skipped:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，最好拥有单独的实现文件，并使用头文件访问它们的功能。现在，您可以通过以下代码读取文件内容并打印文件内容的哈希值。为了更容易看到哪些代码部分发生了变化，跳过未更改的实现：
- en: '*main.c*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.c*'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*hash.h*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash.h*'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*hash.c*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash.c*'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*filereader.h*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*filereader.h*'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*filereader.c*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*filereader.c*'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Organizing the code in separate files made the code more modular because dependencies
    in the code can now be made explicit as all related functionality is put into
    the same file. Your codebase files are currently all stored in the same directory,
    as shown in [Figure 8-2](#fig_dir1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码组织成单独的文件使代码更加模块化，因为代码中的依赖关系现在可以显式地放入同一文件中。您的代码库文件当前都存储在同一个目录中，如[图8-2](#fig_dir1)所示。
- en: '![fluc 0802](assets/fluc_0802.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0802](assets/fluc_0802.png)'
- en: Figure 8-2\. File overview
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-2\. 文件概述
- en: Now that you have separate header files, you can include these header files
    in your implementation files. However, you’ll soon end up with the problem that
    you get a build error if the header files are included multiple times. To help
    out with this issue, you can install Include Guards.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了单独的头文件，可以在实现文件中包含这些头文件。但是，如果多次包含头文件，则可能会遇到构建错误。为了解决此问题，可以安装包含保护。
- en: Include Guard
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含保护
- en: Context
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You split your implementation into multiple files. Inside the implementation
    you include header files to get forward declarations of other code that you want
    to call or use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您将实现分割为多个文件。在实现中，包含头文件以获取其他要调用或使用的代码的前向声明。
- en: Problem
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**It’s easy to include a header file multiple times, but including the same
    header file leads to compile errors if types or certain macros are part of it,
    because during compilation they get redefined.**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**很容易多次包含头文件，但如果类型或特定宏是其中的一部分，则包含相同头文件会导致编译错误，因为在编译过程中它们会被重新定义。**'
- en: In C, during compilation, the `#include` directive lets the C preprocessor fully
    copy the included file into your compilation unit. If, for example, a `struct`
    is defined in the header file and that header file is included multiple times,
    then that `struct` definition is copied multiple times and is present multiple
    times in the compilation unit, which then leads to a compile error.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，在编译期间，`#include` 指令允许C预处理器完全复制包含的文件到您的编译单元中。例如，如果在头文件中定义了一个 `struct` 并且该头文件多次包含，则该
    `struct` 定义将被多次复制并且在编译单元中出现多次，这将导致编译错误。
- en: To avoid this, you could try to not include files more than once. However, when
    including a header file, you usually don’t have the overview of whether other
    additional header files are included inside that header file. Thus, it is easy
    to include files multiple times.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，您可以尝试不多次包含文件。但是，在包含头文件时，通常不清楚该头文件内是否包含其他额外的头文件。因此，很容易多次包含文件。
- en: Solution
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Protect the content of your header files against multiple inclusion so that
    the developer using the header files does not have to care whether it is included
    multiple times. Use an interlocked `#ifdef` statement or a `#pragma once` statement
    to achieve this.**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**保护头文件的内容免受多次包含，以便使用头文件的开发人员无需关心其是否被多次包含。使用互锁的 `#ifdef` 语句或 `#pragma once`
    语句可以实现此目的。**'
- en: 'The following code shows how to use the Include Guard:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用包含保护：
- en: '*somecode.h*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*somecode.h*'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*othercode.h*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*othercode.h*'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: During the build procedure, the interlocked `#ifdef` statement or the `#pragma
    once` statement protects the content of the header file against being compiled
    multiple times in a compilation unit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，互锁的 `#ifdef` 语句或 `#pragma once` 语句保护头文件内容，防止在编译单元中多次编译。
- en: The `#pragma once` statement is not defined in the C standard, but it is supported
    by most C preprocessors. Still, you have to keep in mind that you could have a
    problem with this statement when switching to a different toolchain with a different
    C preprocessor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`#pragma once` 语句在C标准中未定义，但大多数C预处理器都支持。但请注意，如果切换到具有不同C预处理器的不同工具链，可能会出现该语句的问题。'
- en: While the interlocked `#ifdef` statement works with all C preprocessors, it
    brings the difficulty that you have to use a unique name for the defined macro.
    Usually, a name scheme that relates to the name of the header file is used but
    that could lead to outdated names if you rename a file and forget to change the
    Include Guard. Also, you could run into problems when using third-party code,
    because the names of your Include Guards might collide. A way to avoid these problems
    is to not use the name of the header file, but instead use some other unique name
    like the current timestamp or a UUID.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然嵌套的`#ifdef`语句适用于所有C预处理器，但它带来了一个难题，即你必须为定义的宏使用一个唯一的名称。通常会使用与头文件名称相关的命名方案，但如果重命名文件并忘记更改包含保护的名称，可能会导致名称过时。此外，在使用第三方代码时可能会遇到问题，因为你的包含保护名称可能会冲突。避免这些问题的方法是不使用头文件的名称，而是使用一些其他唯一的名称，例如当前时间戳或UUID。
- en: Consequences
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: As a developer who includes header files, you now don’t have to care whether
    that file might be included multiple times. This makes life a lot easier, especially
    when you have nested `#include` statements, because it is difficult to know exactly
    which files are already included.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个包含头文件的开发者，你现在无需关心文件是否会被多次包含。这让生活变得更加轻松，特别是在有嵌套`#include`语句的情况下，因为很难准确知道哪些文件已经被包含。
- en: You have to either take the nonstandard `#pragma once` statement, or you have
    to come up with a unique naming scheme for your interlocked `#ifdef` statement.
    While filenames work as unique names most of the time, there could still be problems
    with similar names in third-party code that you use. Also, there could be inconsistent
    names of the `#define` statements when renaming your own files, but some IDEs
    help out here. They already create an Include Guard when creating a new header
    file or adapt the name of the `#define` when renaming the header file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你必须使用非标准的`#pragma once`语句，或者你必须为你的嵌套`#ifdef`语句提出一个独特的命名方案。虽然文件名在大多数情况下作为唯一名称有效，但是在使用第三方代码时仍可能出现类似名称的问题。此外，当重命名自己的文件时，`#define`语句的名称可能不一致，但某些集成开发环境会在此时提供帮助。它们在创建新的头文件时已经创建了一个包含保护，或在重命名头文件时会自动调整`#define`的名称。
- en: The interlocked `#ifdef` statements prevent compilation errors when you have
    a file included multiple times, but they don’t prevent opening and copying the
    included file multiple times into the compilation unit. That is an unnecessary
    part of the compilation time and could be optimized. One approach to optimize
    would be to have an additional Include Guard around each of your `#include` statements,
    but this makes including the files more cumbersome. Also, this is unnecessary
    for most modern compilers because they optimize compilation by themselves (for
    example, by caching the header file content or remembering which files are already
    included).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`#ifdef`语句的嵌套防止了当同一个文件多次包含时的编译错误，但并未阻止多次打开和复制被包含的文件到编译单元中。这是编译时间中不必要的部分，可以进行优化。优化的一种方法是在每个`#include`语句周围添加额外的包含保护，但这样会使得文件的包含更加繁琐。对于大多数现代编译器来说，这是不必要的，因为它们会自行优化编译过程（例如，通过缓存头文件内容或记住已经包含的文件）。'
- en: Known Uses
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知的应用
- en: 'The following examples show applications of this pattern:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了此模式的应用：
- en: Pretty much every C code that consists of more than one file applies this pattern.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎所有由多个文件组成的C代码都应用了这种模式。
- en: The book *Large-Scale C++ Software Design* by John Lakos (Addison-Wesley, 1996)
    describes optimizing the performance of Include Guards by having an additional
    guard around each `#include` statement.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《大规模C++软件设计》（John Lakos著，Addison-Wesley出版，1996年）一书描述了通过在每个`#include`语句周围添加额外的保护来优化包含保护的性能。
- en: The Portland Pattern Repository describes the Include Guard pattern and also
    describes a pattern to optimize compilation time by having an additional guard
    around each `#include` statement.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Portland模式库描述了包含保护模式，并描述了通过在每个`#include`语句周围添加额外的保护来优化编译时间的模式。
- en: Applied to Running Example
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'The Include Guard in the following code ensure that even if a header file is
    included multiple times, no build error occurs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面代码中的包含保护确保即使头文件被多次包含，也不会出现构建错误：
- en: '*hash.h*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash.h*'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*filereader.h*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*filereader.h*'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the next feature of your code, you want to also print the hash value calculated
    by another kind of hash function. Simply adding another *hash.c* file for the
    other hash function is not possible because filenames have to be unique. It would
    be an option to give another name to the new file. However, even if you do that,
    you are still not happy with the situation because more and more files are now
    in one directory, which makes it difficult to get an overview of the files and
    to see which files are related. To improve the situation, you could use Software-Module
    Directories.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为代码的下一个特性，您希望还打印由另一种哈希函数计算的哈希值。仅仅添加另一个*hash.c*文件来实现另一种哈希函数是不可能的，因为文件名必须是唯一的。给新文件取另一个名字是一个选项。然而，即使这样做了，您对情况仍然不满意，因为现在一个目录中有越来越多的文件，这使得难以获得文件的概览并查看哪些文件是相关的。为了改善情况，您可以使用软件模块目录。
- en: Software-Module Directories
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件模块目录
- en: Context
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: You split your source code into different implementation files, and you utilize
    header files to use functionality from other implementation files. More and more
    files are being added to your codebase.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您将源代码分割为不同的实现文件，并利用头文件从其他实现文件中使用功能。越来越多的文件被添加到您的代码库中。
- en: Problem
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**Splitting code into different files increases the number of files in your
    codebase. Having all files in one directory makes it difficult to keep an overview
    of all the files, particularly for large codebases.**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**将代码分割成不同文件会增加代码库中文件的数量。将所有文件放在一个目录中会使得在大型代码库中保持所有文件的概览变得困难。**'
- en: Putting the files into different directories raises the question of which files
    you want to put into which directory. It should be easy to find files that belong
    together, and it should be easy to know where to put files if additional files
    have to be added later.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件放入不同的目录中会引发一个问题，即您想将哪些文件放入哪个目录。应该很容易找到属于一起的文件，并且应该知道如果需要添加更多文件，则应将文件放在哪里。
- en: Solution
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Put header files and implementation files that belong to a tightly coupled
    functionality into one directory. Name that directory after the functionality
    that is provided via the header files.**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**将属于紧密耦合功能的头文件和实现文件放入一个目录中。将该目录命名为通过头文件提供的功能。**'
- en: The directory and its content is furthermore called a *software-module*. Quite
    often, a software-module contains all code that provides operations on an instance
    addressed with Handles. In that case, the software-module is the non-object-oriented
    equivalent to an object-oriented class. Having all files for a software-module
    in one directory is the equivalent to having all files for a class in one directory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录及其内容进一步称为*软件模块*。经常，软件模块包含所有在使用句柄操作实例的代码。在这种情况下，软件模块是面向对象类的非面向对象等效物。将软件模块的所有文件放入一个目录中相当于将类的所有文件放入一个目录中。
- en: The software-module could contain a single header file and a single implementation
    file or multiple such files. The main criteria for putting the files into one
    directory is high cohesion between the files within the directory and low coupling
    to other Software-Module Directories.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 软件模块可以包含一个单独的头文件和一个单独的实现文件或多个这样的文件。将文件放入一个目录的主要标准是目录内文件的高内聚性和与其他软件模块目录的低耦合性。
- en: 'When you have header files used only inside the software-module and header
    files used outside the software-module, name the files in a way that makes clear
    which header files are not to be used outside the software-module (for example,
    by giving them the postfix *internal* as shown in [Figure 8-3](#fig_dir2) and
    the following code):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当您只在软件模块内使用头文件和在软件模块外使用头文件时，通过命名文件可以清楚地表明哪些头文件不应在软件模块外部使用（例如，通过给它们添加后缀*internal*，如[图8-3](#fig_dir2)和以下代码所示）：
- en: '![fluc 0803](assets/fluc_0803.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0803](assets/fluc_0803.png)'
- en: Figure 8-3\. File overview
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-3 文件概览
- en: '*somecode.c*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*somecode.c*'
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*morecode.c*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*morecode.c*'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*othercode.c*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*othercode.c*'
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code excerpt shows how the files are being included, but it does
    not show the implementation. Note that files from the same software-module can
    easily be included. In order to include header files of other software-modules,
    it is necessary to know the path to these software-modules.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码摘录显示了如何包含文件，但未显示实现。请注意，可以轻松地包含来自同一软件模块的头文件。为了包含其他软件模块的头文件，需要知道这些软件模块的路径。
- en: When your files are distributed across different directories, you have to make
    sure that your toolchain is configured in a way to compile all these files. Maybe
    your IDE automatically compiles all files in subdirectories of your codebase,
    but you might have to adapt build settings or manipulate Makefiles to compile
    the files from the new directories.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的文件分布在不同的目录中时，您必须确保您的工具链配置为编译所有这些文件。也许您的集成开发环境自动编译代码库子目录中的所有文件，但您可能需要调整构建设置或操作Makefile来编译新目录中的文件。
- en: Configuring Include Directories and Files to Compile
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置包含目录和编译文件
- en: Modern C programming IDEs usually provide a carefree environment where the C
    programmer can focus on programming and does not necessarily have to get in touch
    with the build procedure. These IDEs provide build settings that allow you to
    easily configure which directories contain the implementation files to be built
    and which directories contain your include files. This allows the C programmer
    to focus on programming and not on writing Makefiles and compiler commands. This
    chapter assumes you have such an IDE and doesn’t focus on Makefiles and their
    syntax.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C编程IDE通常提供了一个无忧的环境，让C程序员可以专注于编程，不一定需要涉及构建过程。这些IDE提供了构建设置，允许您轻松配置包含实现文件和包含文件的目录。这使得C程序员可以专注于编程，而不是编写Makefile和编译器命令。本章假设您有这样的IDE，并且不关注Makefile及其语法。
- en: Consequences
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响
- en: Splitting code files into different directories makes it possible to have the
    same filenames in different directories. This comes in handy when using third-party
    code, because otherwise those filenames might clash with the filenames in your
    own codebase.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码文件分割到不同的目录中，可以让不同目录中具有相同文件名。在使用第三方代码时特别方便，否则这些文件名可能会与您自己代码库中的文件名冲突。
- en: However, having similar filenames, even when they are in different directories,
    is not recommended. For header files in particular, it is advisable to have unique
    filenames to make sure that the file that will be included does not depend on
    the search order of your include paths. To make filenames unique, you can use
    a short and unique prefix for all files of your software-module.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不建议在不同目录中使用类似的文件名。特别是对于头文件，建议使用唯一的文件名，以确保要包含的文件不依赖于包含路径的搜索顺序。为了使文件名唯一，您可以为软件模块的所有文件使用一个短且唯一的前缀。
- en: Putting all files that are related to a software-module into one directory makes
    it easier to find files that are related, because you only have to know the name
    of the software-module. The number of files inside a software-module is usually
    low enough to be able to quickly spot files in that directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有与软件模块相关的文件放入一个目录中，可以更容易地找到相关文件，因为您只需知道软件模块的名称即可。软件模块内的文件数量通常足够少，可以快速定位该目录中的文件。
- en: Most code dependencies are local to each software-module, so you now have the
    highly dependent files within the same directory. This makes it much easier for
    programmers trying to understand some part of the code to see which other files
    are also relevant. Any implementation files outside the software-module directory
    are usually not relevant for understanding the functionality of that software-module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码依赖都局限于每个软件模块，因此现在高度依赖的文件都在同一个目录中。这使得试图理解代码某一部分的程序员更容易看到哪些其他文件也相关。软件模块目录外的任何实现文件通常与理解该软件模块的功能无关。
- en: Known Uses
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了这种模式的应用：
- en: The Git source code structures some of its code in directories, and other code
    then includes these headers by using relative paths. For example, *kwset.c* includes
    *compat/obstack.h*.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git源代码在其目录中结构化了一些代码，然后其他代码使用相对路径包含这些头文件。例如，*kwset.c* 包含 *compat/obstack.h*。
- en: The Netdata real-time performance monitoring and visualization system organizes
    its code files into directories like *database* or *registry*, which contain a
    handful of files each. To include files from another directory, relative include
    paths are used.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netdata实时性能监控和可视化系统将其代码文件组织到诸如 *database* 或 *registry* 等目录中，每个目录包含少量文件。要包含来自另一个目录的文件，使用相对包含路径。
- en: The network mapper Nmap organizes its software-modules into directories like
    *ncat* or *ndiff*. Header files from other software-modules are included using
    relative paths.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络映射工具 Nmap 将其软件模块组织成目录，例如 *ncat* 或 *ndiff*。使用相对路径包含来自其他软件模块的头文件。
- en: Applied to Running Example
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'The code pretty much stayed the same. Only a new header file and a new implementation
    file for the new hash function were added. The location of the files changed,
    as you can see from the include paths. In addition to putting the files into separate
    directories, their names were also changed to make the filenames unique:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基本上保持不变。只是为新哈希函数添加了一个新的头文件和一个新的实现文件。文件的位置已经改变，从包含路径可以看出。除了将文件放入单独的目录中外，它们的名称也更改为使文件名唯一：
- en: '*main.c*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.c*'
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*bernstein/bernsteinhash.h*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*bernstein/bernsteinhash.h*'
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*bernstein/bernsteinhash.c*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*bernstein/bernsteinhash.c*'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Splitting the code files into separate directories is very common. It makes
    it easier to find a file and makes it possible to have files with similar filenames.
    Still, instead of having similar filenames it might even be better to have unique
    filenames, for example, by having a unique filename prefix per software-module.
    Without these prefixes, you’ll end up with the directory structure and filenames
    shown in [Figure 8-4](#fig_dir3).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码文件分割成单独的目录非常常见。这样做可以更容易地找到文件，并且可以拥有具有相似文件名的文件。但是，与其具有相似的文件名，甚至将文件名前缀与软件模块每个文件名唯一化可能更好。如果没有这些前缀，您最终将得到[图 8-4](#fig_dir3)
    中显示的目录结构和文件名。
- en: '![fluc 0804](assets/fluc_0804.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0804](assets/fluc_0804.png)'
- en: Figure 8-4\. File overview
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. 文件概述
- en: All files that belong together are now in the same directory. The files are
    well structured into directories, and the header files from other directories
    can be accessed with relative paths.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属于一起的文件现在都在同一个目录中。这些文件按目录结构良好组织，并且可以使用相对路径访问其他目录中的头文件。
- en: However, relative paths bring the problem that if you want to rename one of
    the directories, you also have to touch other source files to fix their include
    paths. This is a dependency you don’t want, and you can get rid of it by having
    a Global Include Directory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相对路径带来了一个问题，即如果您想要重命名其中一个目录，您还必须修改其他源文件以修复其包含路径。这是您不希望的依赖性，通过拥有全局包含目录可以摆脱这种依赖性。
- en: Global Include Directory
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局包含目录
- en: Context
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You have header files, and you have structured your code into Software-Module
    Directories.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您有头文件，并且将代码结构化为软件模块目录。
- en: Problem
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**To include files from other software-modules, you have to use relative paths
    like *../othersoftwaremodule/file.h*. You have to know the exact location of the
    other header file.**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**要包含来自其他软件模块的文件，您必须使用像 *../othersoftwaremodule/file.h* 这样的相对路径。您必须知道其他头文件的确切位置。**'
- en: If the path to the other header file changes, you have to change your code that
    includes that header file. If, for example, the other software-module is renamed,
    you have to change your code. So you have a dependency on the name and location
    of the other software-module.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他头文件的路径发生变化，您必须更改包含该头文件的代码。例如，如果其他软件模块被重命名，您也必须更改代码。因此，您对其他软件模块的名称和位置有依赖性。
- en: As a developer, you want to clearly see which header files belong to the API
    of a software-module that you are supposed to use and which header files are internal
    header files that nobody outside the software-module should use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，您希望清楚地看到哪些头文件属于您应该使用的软件模块的 API，哪些头文件是内部头文件，外部人员不应该使用。
- en: Solution
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Have one global directory in your codebase that contains all software-module
    APIs. Add this directory to the global include paths in your toolchain.**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**在代码库中有一个全局目录，包含所有软件模块的 API。将此目录添加到您的工具链的全局包含路径中。**'
- en: Leave all implementation files and all header files that are only used by one
    software-module in the directory of that software-module. If a header file is
    used by other code as well, then put it in the global directory, which is commonly
    named */include*, as shown in [Figure 8-5](#fig_dir5) and in the following code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有只由一个软件模块使用的实现文件和所有头文件放在该软件模块的目录中。如果一个头文件也被其他代码使用，那么将其放在通用目录 */include* 中，如[图 8-5](#fig_dir5)
    和下面的代码所示。
- en: '![fluc 0805](assets/fluc_0805.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0805](assets/fluc_0805.png)'
- en: Figure 8-5\. File overview
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-5\. 文件概述
- en: The configured global include path is */include*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的全局包含路径为 */include*。
- en: '*somecode.c*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*somecode.c*'
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*morecode.c*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*morecode.c*'
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*othercode.c*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*othercode.c*'
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code excerpt shows how the files are being included. Note that
    there are no more relative paths. To make it clearer in this code which files
    are included from the global include path, all these files are included with angle
    brackets in the `#include` statement.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码摘录显示了如何包含文件。请注意，不再使用相对路径。为了在这段代码中更清晰地表明从全局包含路径包含哪些文件，所有这些文件在`#include`语句中都使用尖括号包含。
- en: '#include Syntax'
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#include 语法'
- en: For all of the included files, the syntax with the quotation marks could be
    used as well (`#include "stdio.h"`). Most C preprocessors would look up these
    include files by relative path first, not find them there, and then look them
    up in the global directories configured on your system and used by the toolchain.
    In C, you usually use the syntax with the angle brackets (`#include <stdio.h>`),
    which only searches the global directories, when including files from outside
    of your codebase. But that syntax could also be used for files in your own codebase
    if they are not included by a relative path.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有包含的文件，也可以使用带引号的语法（`#include "stdio.h"`）。大多数C预处理器首先通过相对路径查找这些包含文件，如果找不到，则在系统配置的全局目录中查找并被工具链使用。在C中，通常使用尖括号的语法（`#include
    <stdio.h>`），仅在从代码库外部包含文件时搜索全局目录。但如果它们没有通过相对路径包含，则该语法也可以用于您自己的代码库中的文件。
- en: The global include path has to be configured in the build settings of your toolchain,
    or if you manually write Makefiles and compiler commands, you have to add the
    include path there.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 全局包含路径必须在工具链的构建设置中配置，或者如果您手动编写Makefile和编译器命令，则必须在那里添加包含路径。
- en: If the number of header files in this directory grows large, or if there are
    very specific header files that are used by only a few software-modules, you should
    consider splitting your codebase into Self-Contained Components.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此目录中的头文件数量增加，或者有仅被少数软件模块使用的非常特定的头文件，您应考虑将代码库拆分为自包含组件。
- en: Consequences
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: It is very clear which header files are supposed to be used by other software-modules
    and which header files are internal and are supposed to be used within this software-module
    only.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 很明确哪些头文件应由其他软件模块使用，哪些头文件是内部的，仅应在此软件模块内部使用。
- en: Now there is no more need to use relative directories in order to include files
    from other software-modules. But the code from other software-modules is not inside
    a single directory anymore and is instead split over your codebase.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再需要使用相对目录来包含来自其他软件模块的文件。但是其他软件模块的代码不再位于单个目录中，而是分散在您的代码库中。
- en: Putting all APIs into one directory might lead to many files inside this directory,
    which would make it difficult to find files that belong together. You have to
    be careful not to end up with all your header files of the whole codebase in that
    one include directory. That would mitigate the benefits of having Software-Module
    Directories. And what would you do if software-module A is the only one that needs
    the interfaces of software-module B? With the proposed solution, you’d put the
    interfaces of software-module B into the Global Include Directory. However, if
    nobody else needs these interfaces, then you might not want them to be available
    for everyone in your codebase. To avoid that problem, use Self-Contained Components.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有API放入一个目录中可能会导致此目录中有许多文件，这将使查找属于一起的文件变得困难。您必须小心，不要让整个代码库的所有头文件都放在一个包含目录中。这将削弱具有软件模块目录的好处。如果软件模块A是唯一需要软件模块B接口的模块，那该怎么办？使用建议的解决方案，您将把软件模块B的接口放入全局包含目录中。然而，如果没有其他人需要这些接口，则可能不希望它们对代码库中的每个人都可用。为了避免这个问题，请使用自包含组件。
- en: Known Uses
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: The OpenSSL code has an */include* directory that contains all header files
    that are used in multiple software-modules.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL的代码有一个*/include*目录，其中包含多个软件模块中使用的所有头文件。
- en: The code of the game NetHack has all its header files in the directory */include*.
    The implementations are not organized into software-modules, but instead they
    are all in one single */src* directory.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏NetHack的代码将所有的头文件放在目录*/include*中。实现部分未按软件模块组织，而是放在一个单独的*/src*目录中。
- en: The OpenZFS code for Linux has one global directory called */include* that contains
    all header files. This directory is configured as an include path in the Makefiles
    that are in the directories of the implementation files.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 的 OpenZFS 代码有一个名为*/include*的全局目录，其中包含所有头文件。此目录在实现文件所在的目录中的 Makefile 中配置为包含路径。
- en: Applied to Running Example
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'The location of the header files changed in your codebase. You moved them to
    a Global Include Directory that you configured in your toolchain. Now you can
    simply include the files without searching through relative filepaths. Note that
    because of this, angle brackets instead of quotation marks are now used for the
    `#include` statements:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码库中头文件的位置发生了变化。您将它们移动到了配置在工具链中的全局包含目录。现在您可以简单地包含文件，而无需搜索相对文件路径。请注意，由于此原因，现在使用尖括号而不是引号来进行`#include`语句：
- en: '*main.c*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.c*'
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In your code, you now have the file organization and the global include path
    */include* configured in your toolchain as shown in [Figure 8-6](#fig_dir6).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，您现在使用文件组织和全局包含路径*/include*在您的工具链中进行配置，如[图8-6](#fig_dir6)所示。
- en: '![fluc 0806](assets/fluc_0806.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0806](assets/fluc_0806.png)'
- en: Figure 8-6\. File overview
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-6\. 文件概览
- en: Now, even if you rename one of the directories, you do not have to touch the
    implementation files. So you decoupled the implementations a bit more.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使您重命名其中一个目录，也无需触及实现文件。因此，您将实现进一步解耦。
- en: Next, you want to extend the code. You want to use the hash functions not only
    to hash the content of the files but also in another application context, calculating
    a pseudorandom number based on the hash function. You want to make it possible
    to develop the two applications, which both use the hash functions, independently
    from each other, maybe even by independent development teams.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您希望扩展代码。您希望使用哈希函数不仅对文件内容进行哈希处理，而且在另一个应用程序上下文中使用，基于哈希函数计算伪随机数。您希望能够独立开发这两个应用程序，两者都使用哈希函数，甚至可能由独立的开发团队进行开发。
- en: Having to share one global include directory with another development team is
    not an option, as you don’t want to mix the code files between the different teams.
    You want to separate the two applications as far as possible from each other.
    To do that, organize them as Self-Contained Components.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与另一个开发团队共享一个全局包含目录是不可行的选择，因为您不希望在不同团队之间混合代码文件。您希望尽可能地将这两个应用程序分开。为此，请将它们组织为自包含组件。
- en: Self-Contained Component
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自包含组件
- en: Context
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You have Software-Module Directories and maybe a Global Include Directory. The
    number of software-modules keeps growing, and your code becomes larger.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您有软件模块目录，可能还有一个全局包含目录。软件模块的数量不断增加，您的代码变得越来越大。
- en: Problem
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**From the directory structure it is not possible to see the dependencies in
    the code. Any software-module can simply include the header files from any other
    software-module, so it’s impossible to check dependencies in the code via the
    compiler.**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**从目录结构中无法看出代码的依赖关系。任何软件模块都可以简单地包含来自任何其他软件模块的头文件，因此无法通过编译器检查代码的依赖关系。**'
- en: Including header files can be done by using relative paths, which means that
    any software-module can include the header files from any other software-module.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用相对路径可以包含头文件，这意味着任何软件模块都可以包含来自任何其他软件模块的头文件。
- en: Keeping an overview of the software-modules gets difficult as their number grows.
    Just like before you used Software-Module Directories, where you had too many
    files in a single directory, now you have too many Software-Module Directories.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件模块数量的增长，保持对其的概述变得困难。就像之前使用软件模块目录一样，在一个单一目录中有太多文件时，现在您有太多软件模块目录。
- en: As with the dependencies, it is also not possible to see the code responsibility
    from the code structure. If multiple development teams work on the code, you might
    want to define who is responsible for which software-module.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖项类似，无法从代码结构中看出代码的责任。如果多个开发团队共同开发代码，您可能希望定义谁负责哪个软件模块。
- en: Solution
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Identify software-modules that contain similar functionality and that should
    be deployed together. Put these software-modules into a common directory and have
    a designated subdirectory for their header files that are relevant for the caller.**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别包含类似功能的软件模块，并应共同部署。将这些软件模块放入一个共同的目录中，并为调用者相关的头文件指定一个子目录。**'
- en: Furthermore, such a group of software-modules including all their header files
    will be called a *component*. Compared to software-modules, a component is usually
    bigger and could be deployed independently from the rest of the codebase.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这样一个包含所有头文件的软件模块组将被称为*组件*。与软件模块相比，组件通常更大，并且可以独立于代码库的其余部分部署。
- en: When grouping the software-modules, check which part of your code could be independently
    deployed from the rest of the codebase. Check which part of the code is developed
    by separate teams and thus might be developed in a way to only have loose coupling
    to the rest of the codebase. Such software-module groups are candidates for components.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在对软件模块进行分组时，请检查您的代码中哪些部分可以独立于代码库的其余部分部署。查看由单独团队开发的代码的哪些部分，因此这些部分可能以只对代码库的其余部分松散耦合的方式开发。这样的软件模块组是组件的候选者。
- en: If you have one Global Include Directory, move all header files from your component
    from that directory and put them inside the designated directory in your component
    (for example, *myComponent/include*). Developers who use the component can add
    this path to their global include paths in their toolchain or can modify the Makefile
    and compiler command accordingly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个全局包含目录，请将你的组件中所有的头文件从那个目录移动到你的组件指定目录中（例如，*myComponent/include*）。使用该组件的开发人员可以将此路径添加到其工具链中的全局包含路径中，或者可以相应地修改Makefile和编译器命令。
- en: You can use the toolchain to check if the code in one of the components only
    uses functionality that it is allowed to use. For example, if you have a component
    that abstracts the operating system, you might want all other code to use that
    abstraction and to not use operating system–specific functions. You can configure
    your toolchain to set the include paths to the operating system–specific functions
    only for your component that abstracts the operating system. For all other code,
    only the directory with the interface of your operating-system abstraction is
    configured as the include path. Then an unexperienced developer who does not know
    that there is an operating system abstraction and tries to use the operating system–specific
    functions directly would have to use the relative include path to these function
    declarations to get the code compiling (and this will hopefully discourage the
    developer from doing that).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用工具链检查一个组件中的代码是否只使用允许使用的功能。例如，如果您有一个抽象操作系统的组件，您可能希望所有其他代码都使用该抽象，并且不使用特定于操作系统的功能。您可以配置您的工具链，将操作系统特定函数的包含路径仅设置为抽象操作系统接口的目录。然后，一个不熟悉的开发人员，不知道有一个操作系统抽象层，并尝试直接使用操作系统特定功能的开发人员，将不得不使用这些函数声明的相对包含路径来使代码编译通过（这将希望能够阻止开发人员这样做）。
- en: '[Figure 8-7](#fig_dir7) and the following code show the file structure and
    the include filepaths.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-7](#fig_dir7) 和下面的代码展示了文件结构和包含文件路径。'
- en: '![fluc 0807](assets/fluc_0807.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0807](assets/fluc_0807.png)'
- en: Figure 8-7\. File overview
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-7\. 文件概览
- en: 'Configured global include paths:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的全局包含路径：
- en: '*/somecomponent/include*'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/somecomponent/include*'
- en: '*/nextcomponent/include*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/nextcomponent/include*'
- en: '*somecode.c*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*somecode.c*'
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*morecode.c*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*morecode.c*'
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*othercode.c*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*othercode.c*'
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*nextcode.c*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*nextcode.c*'
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Consequences
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The software-modules are well organized, and it is easier to find software-modules
    that belong together. If the components are well split, then it should also be
    clear to which component which kind of new code should be added.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 软件模块组织良好，易于找到彼此相关的软件模块。如果组件分离得当，那么应该清楚每个组件应该添加哪种新代码。
- en: Having everything that belongs together in a single directory makes it easier
    to configure specific things for that component in the toolchain. For example,
    you can have stricter compiler warnings for new components that you create in
    your codebase, and you can automatically check code dependencies between components.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有归属于同一目录的内容放在单个目录中，这样在工具链中配置该组件的特定内容会更加容易。例如，您可以为代码库中创建的新组件设置更严格的编译器警告，并且可以自动检查组件之间的代码依赖关系。
- en: When developing the code in multiple teams, component directories make it easier
    to set the responsibilities between the teams because these components usually
    have very low coupling between each other. Even the functionality for the overall
    product might not depend on these components. It is easier to split responsibilities
    on a component level than on a software-module level.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在多团队开发代码时，组件目录使得在团队之间设置责任更加容易，因为这些组件通常彼此之间的耦合度非常低。即使整体产品的功能可能不依赖于这些组件，也比在软件模块级别上分割责任更容易。
- en: Known Uses
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: The GCC code has separate components with their own directories gathering its
    header files. For example, */libffi/include* or *libcpp/include*.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC代码具有独立的组件，每个组件都有自己的目录，收集其头文件。例如，*/libffi/include*或*libcpp/include*。
- en: The operating system RIOT organizes its drivers into well-separated directories.
    For example, the directories */drivers/xbee* and */drivers/soft_spi* each contain
    an *include* subdirectory that contains all interfaces for that software-module.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统RIOT将其驱动程序组织到良好分离的目录中。例如，目录*/drivers/xbee*和*/drivers/soft_spi*中的每个都包含一个*include*子目录，其中包含该软件模块的所有接口。
- en: The Radare reverse engineering framework has well-separated components, each
    with its own *include* directory that contains all its interfaces.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Radare反向工程框架具有良好分离的组件，每个组件都有自己的*include*目录，其中包含其所有接口。
- en: Applied to Running Example
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'You added the implementation of pseudorandom numbers that uses one of the hash
    functions. Apart from that, you isolated three different parts of your code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您添加了使用其中一个哈希函数的伪随机数实现。除此之外，您还分离了代码的三个不同部分：
- en: The hash functions
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数
- en: The hash calculation of a file content
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件内容的哈希计算
- en: The pseudorandom number calculation
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪随机数计算
- en: 'All three parts of the code are now well separated and could easily be developed
    by different teams or could even be deployed independently from one another:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码的所有三个部分都已经很好地分离开来，可以很容易地由不同的团队开发，甚至可以独立部署：
- en: '*main.c*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.c*'
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*randrandomapplication/include/pseudorandom.h*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*randrandomapplication/include/pseudorandom.h*'
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*randomapplication/pseudorandom/pseudorandom.c*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*randomapplication/pseudorandom/pseudorandom.c*'
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Your code now has the following directory structure. Note how each part of the
    code files is well separated from the other parts. For example, all code related
    to hashes is in one directory. For a developer using these functions, it is easy
    to spot where to find the API to these functions, which are in the *include* directory
    as shown in [Figure 8-8](#fig_dir8).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的代码具有以下目录结构。请注意，代码文件的每个部分都与其他部分很好地分离开来。例如，所有与哈希相关的代码都在一个目录中。对于使用这些函数的开发人员来说，很容易找到这些函数的API，这些API在*include*目录中，如[图 8-8](#fig_dir8)所示。
- en: '![fluc 0808](assets/fluc_0808.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0808](assets/fluc_0808.png)'
- en: Figure 8-8\. File overview
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-8\. 文件概述
- en: 'For this code, the following global include directories are configured in the
    toolchain:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此代码，在工具链中配置了以下全局包含目录：
- en: '*/hashlibrary/include*'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/hashlibrary/include*'
- en: '*/fileapplication/include*'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/fileapplication/include*'
- en: '*/randomapplication/include*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/randomapplication/include*'
- en: Now the code is well separated into different directories, but there are still
    dependencies that you could remove. Have a look at the include paths. You have
    one codebase and all include paths are used for all that code. However, for the
    code of the hash functions, there is no need to have the file handling include
    path.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经很好地分离到不同的目录中，但仍然存在可以移除的依赖关系。查看包含路径。您有一个代码库，所有包含路径都用于所有代码。然而，对于哈希函数的代码，没有必要使用文件处理的包含路径。
- en: Also, you compile all code and simply link all the objects into one executable
    file. However, you might want to split that code and independently deploy it.
    You might want to have one application that prints the hash output and one application
    that prints the pseudorandom number. Those two applications should be independently
    developed, but both should use, for example, the same hash function code, which
    you do not want to duplicate.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您编译所有代码并简单地将所有对象链接到一个可执行文件中。但是，您可能希望将该代码拆分并独立部署。您可能希望有一个打印哈希输出的应用程序，以及一个打印伪随机数的应用程序。这两个应用程序应该独立开发，但两者都应该使用例如相同的哈希函数代码，您不希望重复。
- en: To decouple the applications and have a defined way to access the functionality
    from other parts without having to share private information, like include paths
    to those parts, you should have an API Copy.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解耦应用程序，并以一种定义良好的方式访问来自其他部分的功能，而无需共享私有信息（例如这些部分的包含路径），您应该有一个API复制。
- en: API Copy
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API复制
- en: Context
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You have a large codebase with different teams developing it. In the codebase,
    the functionality is abstracted via header files that are organized in Software-Module
    Directories. Best case is that you have well-organized Self-Contained Components,
    and the interfaces have existed for some time, so you are quite sure they are
    stable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个大型的代码库，由不同团队开发。在代码库中，功能通过组织在软件模块目录中的头文件抽象出来。最好的情况是您有组织良好的自包含组件，并且这些接口已经存在一段时间，因此您相当确信它们是稳定的。
- en: Problem
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**You want to develop, version, and deploy the parts of your codebase independently
    from one another. However, to do that, you need clearly defined interfaces between
    the code parts and the ability to separate that code into different repositories.**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**您希望能够独立开发、版本化和部署代码库中的各个部分。然而，要做到这一点，您需要在代码部分之间具有明确定义的接口，并能够将该代码分隔到不同的存储库中。**'
- en: If you have Self-Contained Components then you are nearly there. The components
    have well-defined interfaces, and all code for those components is already in
    separate directories, so they could easily be checked in to separate repositories.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有自包含的组件，那么您已经接近成功。这些组件具有明确定义的接口，并且所有这些组件的代码已经在单独的目录中，因此它们可以轻松地检入到单独的存储库中。
- en: 'But there is still a directory structure dependency between the components:
    the configured include path. That path still includes the full path to the code
    of the other component and, for example, if the name of that component changes,
    you have to change the configured include path. That is a dependency you do not
    want to have.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但是组件之间仍然存在目录结构依赖：配置的包含路径。该路径仍然包括另一个组件代码的完整路径，例如，如果该组件的名称发生更改，您必须更改配置的包含路径。这是您不希望存在的依赖关系。
- en: Solution
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**To use the functionality of another component, copy its API. Build that other
    component separately and copy the build artifacts and its public header files.
    Put these files into a directory inside your component and configure that directory
    as a global include path.**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了使用另一个组件的功能，请复制其API。单独构建另一个组件并复制生成的文件和其公共头文件。将这些文件放入您组件内的一个目录，并将该目录配置为全局包含路径。**'
- en: 'Copying code may seem like a bad idea. In general it is, but here you only
    copy the interface of another component. You copy the function declarations of
    the header files, so there are no multiple implementations. Think about what you
    do when you install a third-party library: you also have a copy of its interfaces
    to access its functionality.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 复制代码似乎是一个坏主意。通常情况下确实如此，但在这里，您只复制另一个组件的接口。您复制头文件的函数声明，因此没有多个实现。想想当您安装第三方库时会发生什么：您也会复制其接口以访问其功能。
- en: In addition to the copied header files, you have to use other build artifacts
    during the build of your component. You could version and deploy the other component
    as a separate library that you’d have to link to your component. [Figure 8-9](#fig_dir9)
    and the following code show the overview of the involved files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除了复制的头文件外，在构建组件时，您还必须使用其他构建生成物件。您可以将另一个组件版本化并部署为一个单独的库，您需要将其链接到您的组件中。[图 8-9](#fig_dir9)和下面的代码展示了所涉文件的概览。
- en: '![fluc 0809](assets/fluc_0809.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0809](assets/fluc_0809.png)'
- en: Figure 8-9\. File overview
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-9\. 文件概览
- en: 'Configured global include paths for `somecomponent`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`somecomponent`的配置全局包含路径：'
- en: '*/include*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/include*'
- en: '*/include-from-nextcomponent*'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/include-from-nextcomponent*'
- en: '*somecode.c*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*somecode.c*'
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*morecode.c*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*morecode.c*'
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*othercode.c*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*othercode.c*'
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Configured global include path for `nextcomponent`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextcomponent`的配置全局包含路径：'
- en: '*/include*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/include*'
- en: '*nextcode.c*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*nextcode.c*'
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that the preceding code is now split into two different code blocks. It
    is now possible to split the code and put it into separate repositories, or in
    other words: to have separate codebases. There are no more dependencies involving
    the directory structure between the components. However, now you are in the situation
    that different versions of the components have to ensure that their interfaces
    stay compatible even if their implementations change. Depending on your deployment
    strategy, you have to define which kind of interface compatibility (API compatible
    or ABI compatible) you want to provide. To keep your interfaces flexible while
    being compatible, you can use Handles, Dynamic Interfaces, or Function Controls.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码现在分成了两个不同的代码块。现在可以将代码拆分并放入单独的代码库，或者换句话说：拥有单独的代码库。组件之间不再涉及目录结构的依赖关系。然而，现在你面临的情况是，即使实现发生变化，不同版本的组件也必须确保它们的接口保持兼容。根据你的部署策略，你必须定义你想要提供哪种类型的接口兼容性（API兼容或ABI兼容）。为了在保持兼容性的同时保持接口的灵活性，可以使用句柄、动态接口或函数控制。
- en: Interface Compatibility
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口兼容性
- en: The *application programming interface* (API) stays compatible if there is no
    need to change anything in the caller’s code. You break API compatibility if you,
    for example, add another parameter to an existing function, or if you change the
    type of the return value or the parameters.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要在调用方的代码中做任何更改，则*应用程序编程接口*（API）保持兼容。如果例如向现有函数添加另一个参数，或者更改返回值或参数的类型，则会破坏API兼容性。
- en: The *application binary interface* (ABI) stays compatible if there is no need
    to recompile the caller’s code. You break the ABI compatibility if you, for example,
    change the platform for which you compile your code, or if you update your compiler
    to a newer version that has a different function, calling convention compared
    to previous compiler versions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要重新编译调用方的代码，则*应用程序二进制接口*（ABI）保持兼容。如果例如更改编译代码的平台，或者将编译器更新到具有与先前编译器版本不同的函数调用约定的新版本，那么就会破坏ABI兼容性。
- en: Consequences
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Now there are no more dependencies involving the directory structure between
    the components. It is possible to rename one of the components without having
    to change the include directives of the code from other components (or as you
    can call them now, other codebases).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，组件之间不再涉及目录结构的依赖关系。可以重命名其中一个组件，而无需更改其他组件代码的包含指令（或者现在称之为其他代码库）。
- en: Now the code can be checked into different repositories, and there is absolutely
    no need to know the path to other components in order to include their header
    files. To get to the header files of another component, you copy it. So initially
    you have to know from where to get the header files and build artifacts. Maybe
    the other component provides some kind of setup installer, or maybe it just provides
    a versioned list of all required files.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码可以检入不同的代码库，完全不需要知道其他组件的路径以包含它们的头文件。要获取另一个组件的头文件，只需复制它。因此，最初你必须知道从哪里获取头文件和构建产物。也许其他组件提供了某种设置安装程序，或者只是提供了所有所需文件的版本列表。
- en: 'You need an agreement that the interfaces of the components will stay compatible
    in order to use the main benefit of the split codebases: independent development
    and versioning. The requirement for compatible interfaces restricts the development
    of components providing such interfaces, because once a function can be used by
    others, it cannot be freely changed anymore. Even compatible changes, like adding
    a new function to an existing header file, could become more difficult. This is
    because then you’d provide a different set of functionality with different versions
    of that header file, which makes it more difficult for your callers to know which
    version of the header file they should use. It also makes it difficult to write
    code that works with any version of your header file.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用拆分的代码库的主要优势：独立开发和版本控制，你需要达成接口兼容的协议。对于提供这些接口的组件的开发有一定限制，因为一旦一个函数可以被其他人使用，它就不能再自由修改了。即使是兼容性的更改，比如向现有头文件添加新函数，也可能变得更加困难。这是因为你会在不同版本的头文件中提供不同功能集，这使得你的调用方更难知道应该使用哪个版本的头文件。同时，这也使得编写可以与任何版本头文件一起使用的代码变得困难。
- en: You buy the flexibility of separate codebases with the additional complexity
    of having to cope with API compatibility requirements and with more complexity
    in the build procedure (copying header files, keeping them in sync, linking the
    other component, versioning the interfaces).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你购买了分离代码库的灵活性，但必须应对 API 兼容性要求以及构建过程中的更多复杂性（复制头文件、保持同步、链接其他组件、版本化接口）。
- en: Version Numbers
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本号
- en: The way you version your interfaces should specify if a new version brings incompatible
    changes. Commonly, [*semantic versioning*](https://semver.org) is used to indicate
    in the version number whether there are major changes. With semantic versioning
    you have a three-digit version number for your interface (for example, 1.0.7),
    and only a change in the first number means an incompatible change.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 版本接口的方式应指定新版本是否带来不兼容的更改。通常使用 [*语义化版本*](https://semver.org) 来指示版本号中是否存在主要更改。使用语义化版本，您的接口有一个三位数的版本号（例如，1.0.7），只有第一个数字的更改表示有不兼容的更改。
- en: Known Uses
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知应用
- en: 'The following examples show applications of this pattern:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这种模式的应用：
- en: Wireshark copies the APIs of the independently deployed Kazlib to use its exception
    emulation functionality.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark 复制独立部署的 Kazlib 的 API，以使用其异常仿真功能。
- en: The B&R Visual Components software accesses functionality from the underlying
    Automation Runtime operating system. The Visual Components software is independently
    deployed and versioned from Automation Runtime. To access the Automation Runtime
    functionality, its public header files are copied into the Visual Components codebase.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B&R Visual Components 软件从底层的 Automation Runtime 操作系统中访问功能。Visual Components
    软件是独立部署和版本化的，与 Automation Runtime 分开。为了访问 Automation Runtime 的功能，其公共头文件被复制到 Visual
    Components 代码库中。
- en: The Education First company develops digital learning products. In their C code,
    they copy include files into a global include directory when building the software
    in order to decouple the components in their codebase.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Education First 公司开发数字学习产品。在他们的 C 代码中，构建软件时将包含文件复制到全局包含目录，以解耦其代码库中的组件。
- en: Applied to Running Example
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: Now the different parts of the code are well separated. The hash implementation
    has a well-defined interface to the code for printing file hashes and to the code
    for generating pseudorandom numbers. Additionally, these parts of the code are
    well separated into directories. Even the APIs of other components are copied,
    so that all code that has to be accessed by one of the components is in its own
    directory. The code for each of the components could even be stored in its own
    repository and deployed and versioned independently from the other components.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码的不同部分已经很好地分离。哈希实现具有明确定义的接口，用于打印文件哈希和生成伪随机数的代码。此外，这些代码部分已经分离到不同的目录中。甚至其他组件的
    API 也被复制，以便所有需要被一个组件访问的代码都位于自己的目录中。每个组件的代码甚至可以存储在自己的代码库中，并且可以独立部署和版本化，与其他组件分开。
- en: The implementations did not change at all. Only the APIs of other components
    were copied and the include paths for the codebases changed. The hashing code
    is now isolated from even the main application. The hashing code is treated as
    an independently deployed component and is only linked to the rest of the application.
    [Example 8-1](#dir_rex_7_1) shows the code of your main application, which is
    now separated from the hash library.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 实现本身没有改变。只是其他组件的 API 被复制了，代码库的包含路径也改变了。哈希代码现在甚至与主应用程序隔离开来。哈希代码被视为独立部署的组件，只与应用程序的其余部分链接。[示例
    8-1](#dir_rex_7_1) 展示了您的主应用程序的代码，现在已从哈希库中分离出来。
- en: Example 8-1\. Code of the main application
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. 主应用程序的代码
- en: '*main.c*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.c*'
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*randomapplication/include/pseudorandom.h*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*randomapplication/include/pseudorandom.h*'
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*randomapplication/pseudorandom/pseudorandom.c*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*randomapplication/pseudorandom/pseudorandom.c*'
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*fileapplication/include/filereader.h*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*fileapplication/include/filereader.h*'
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code has the directory structure and include path shown in [Figure 8-10](#fig_dir10)
    and the following code example. Note that no source code regarding the hash implementation
    is part of this codebase anymore. The hash functionality is accessed by including
    the copied header files, and then the *.a* file has to be linked to the code in
    the build process.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码具有[图 8-10](#fig_dir10)中显示的目录结构和包含路径以及以下代码示例。请注意，此代码库不再包含关于哈希实现的源代码。通过包含复制的头文件访问哈希功能，然后在构建过程中将
    *.a* 文件链接到代码中。
- en: '![fluc 0810](assets/fluc_0810.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0810](assets/fluc_0810.png)'
- en: Figure 8-10\. File overview
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-10\. 文件概述
- en: 'Configured include paths:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 配置包含路径：
- en: '*/hashlibrary*'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/hashlibrary*'
- en: '*/fileapplication/include*'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/fileapplication/include*'
- en: '*/randomapplication/include*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/randomapplication/include*'
- en: '[Example 8-2](#dir_rex_7_2) for the hash implementation is now managed in its
    own repository. Every time the code changes, a new version of the hash library
    can be shipped. That means that the object file compiled for that library has
    to be copied into the other code, and as long as the API of the hash library does
    not change, there is nothing more to do.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-2](#dir_rex_7_2)中的哈希实现现在由其自己的存储库管理。每当代码更改时，都可以发布哈希库的新版本。这意味着必须将编译为该库的对象文件复制到其他代码中，只要哈希库的API不改变，就不需要做更多事情。'
- en: Example 8-2\. Code of the hash library
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 哈希库的代码
- en: '*inc/adlerhash.h*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc/adlerhash.h*'
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*adler/adlerhash.c*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*adler/adlerhash.c*'
- en: '[PRE38]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*inc/bernsteinhash.h*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc/bernsteinhash.h*'
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*bernstein/bernsteinhash.c*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*bernstein/bernsteinhash.c*'
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code has the directory structure and include path shown in [Figure 8-11](#fig_dir11).
    Note that source code regarding the file handling or the pseudorandom number calculation
    is not part of this codebase anymore. The codebase here is generic and could be
    used in other contexts as well.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码具有图 8-11 所示的目录结构和包含路径。请注意，关于文件处理或伪随机数计算的源代码不再是此代码库的一部分。这里的代码库是通用的，也可以在其他上下文中使用。
- en: '![fluc 0811](assets/fluc_0811.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![fluc 0811](assets/fluc_0811.png)'
- en: Figure 8-11\. File overview
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-11\. 文件概述
- en: 'Configured include paths:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 配置包含路径：
- en: '*/include*'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/include*'
- en: Starting from a simple hash application, we ended up with this code, which lets
    you develop and deploy the hash code separately from its application. Going one
    step further, the two applications could even be split into separate parts, which
    can be separately deployed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单的哈希应用程序开始，我们最终得到了这段代码，可以让您分开开发和部署哈希代码，与其应用程序分开。更进一步，这两个应用程序甚至可以分成独立的部分，可以分别部署。
- en: Organizing the directory structure as proposed in this example is not at all
    the most important issue in making the code modular. There are many more important
    issues that are not explicitly addressed in this chapter and in this running example,
    like code dependencies, which can be addressed by applying the SOLID principles.
    However, once the dependencies are set in a way that makes the code modular, the
    directory structure as shown in this example makes it easier to split the ownership
    of the code and to version and deploy the code independently from other parts
    of the codebase.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本示例建议的目录结构组织并不是使代码模块化的最重要问题。本章和本示例中未明确解决的许多更重要问题，例如代码依赖性，可以通过应用SOLID原则来解决。但是，一旦设置了使代码模块化的依赖关系，如本示例所示的目录结构将使得更容易分割代码的所有权，并使其能够独立于代码库的其他部分进行版本控制和部署。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter presented patterns on how to structure source and header files
    in order to build large modular C programs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何结构化源代码和头文件，以构建大型模块化的C程序的模式。
- en: The Include Guard pattern makes sure header files are not included multiple
    times. Software-Module Directories suggests putting all files for a software-module
    into one directory. Global Include Directory suggests having all header files
    that are used by multiple software-modules in one global directory. For larger
    programs, Self-Contained Component suggests instead having one global header file
    directory per component. In order to decouple these components, API Copy suggests
    copying the header files and build artifacts that are used from other components.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 包含保护模式确保头文件不会被多次包含。软件模块目录建议将一个软件模块的所有文件放入一个目录。全局包含目录建议将所有被多个软件模块使用的头文件放入一个全局目录。对于更大的程序，自包含组件建议为每个组件使用一个全局头文件目录。为了解耦这些组件，API复制建议复制头文件和从其他组件使用的构建工件。
- en: 'The presented patterns to some extent build on one another. The later patterns
    in this chapter can be applied more easily if the former ones were already applied.
    After applying all of the patterns to your codebase, the codebase reaches a high
    level of flexibility for developing and deploying parts of it separately. However,
    that flexibility is not always needed and it does not come for free: with each
    of these patterns, you add complexity to your codebase. For very small codebases
    in particular, it will not be required to deploy parts of the codebase separately,
    so it will likely not be necessary to apply API Copy. It might even be sufficient
    to simply stop after applying Header Files and Include Guard. Do not blindly apply
    all of the patterns. Instead, only apply them if you face the problems described
    in the patterns and if solving these problems is worth the additional complexity.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 所提出的模式在某种程度上是相互构建的。如果先前的模式已经应用，那么本章后面的模式可以更容易地应用。在将所有模式应用到代码库后，代码库达到了一个高度的灵活性，可以分开开发和部署其部分内容。然而，这种灵活性并非总是需要的，并且它并非免费的：每个模式都会向您的代码库增加复杂性。特别是对于非常小的代码库，可能不需要分开部署其部分内容，因此可能不需要应用
    API Copy。甚至只应用 Header Files 和 Include Guard 就可能已经足够了。不要盲目地应用所有模式。相反，只有在面对模式描述的问题并且解决这些问题值得增加复杂性时，才应用它们。
- en: With these patterns as part of the programming vocabulary, a C programmer has
    a toolbox and step-by-step guidance on how to build modular C programs and organize
    their files.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些模式作为编程词汇的一部分，C 程序员拥有一个工具箱，并逐步指导如何构建模块化的 C 程序并组织它们的文件。
- en: Outlook
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望
- en: 'The next chapter covers an aspect of many large-scale programs: handling multiplatform
    code. The chapter presents patterns on how to implement code in a way that makes
    it easier to have a single codebase for multiple processor architectures or multiple
    operating systems.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章涵盖了许多大型程序的一个方面：处理多平台代码。本章介绍了如何实现代码的模式，使得在多处理器架构或多操作系统中有一个单一的代码库更容易。
