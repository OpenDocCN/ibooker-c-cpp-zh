<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 8. The Type Erasure Design Pattern" data-type="chapter" epub:type="chapter"><div class="chapter" id="type_erasure">
<h1><span class="label">Chapter 8. </span>The Type Erasure Design Pattern</h1>
<p>Separation<a data-primary="Type Erasure design pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043085822448"/> of concerns and value semantics are two of the essential takeaways
from this book that I have mentioned a couple of times by now.
In this chapter, these two are beautifully combined into one of the most interesting
modern C++ design patterns: Type Erasure. Since this pattern can be considered
one of the hottest irons in the fire, in this chapter I will give you a very thorough,
in-depth introduction to all aspects of Type Erasure. This, of course, includes all
design-specific aspects and a lot of specifics about implementation details.</p>
<p>In <a data-type="xref" href="#consider_replacing_inheritance_hierarchies_with_type_erasure">“Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure”</a>, I will introduce
you to Type Erasure and give you an idea why this design pattern is such
a great combination of dependency reduction and value semantics. I will also give you a
walkthrough of a basic, owning Type Erasure implementation.</p>
<p><a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>
<span class="keep-together">is an</span> exception:
despite the fact that in this book I primarily focus on dependencies and design aspects,
in this one guideline I will entirely focus on performance-related implementation details.
I will show you how to apply the <em>Small Buffer Optimization (SBO)</em> and how to implement
a manual virtual dispatch to speed up your Type Erasure implementation.</p>
<p>In <a data-type="xref" href="#be_aware_of_the_setup_costs_of_owning_type_erasure_wrappers">“Guideline 34: Be Aware of the Setup Costs of Owning 
<span class="keep-together">Type Erasure Wrappers</span>”</a>, we will investigate
the setup costs of the owning Type Erasure implementation. We will find that there is a
cost associated with value semantics that sometimes we may not be willing to pay. For this
reason, we dare to take a step into the realm of reference semantics and implement a
form of nonowning Type Erasure.</p>
<section data-pdf-bookmark="Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure" data-type="sect1"><div class="sect1" id="consider_replacing_inheritance_hierarchies_with_type_erasure">
<h1>Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure</h1>
<p>There<a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-type="indexterm" id="TEDPinhi08"/><a data-primary="inheritance" data-secondary="replacing with Type Erasure design pattern" data-type="indexterm" id="INreplace08"/> are a couple of<a data-primary="software design" data-secondary="basic guidelines for" data-tertiary="recurring advice" data-type="indexterm" id="idm45043085811776"/> recurring pieces of advice throughout this book:</p>
<ul>
<li>
<p>Minimize dependencies.</p>
</li>
<li>
<p>Separate concerns.</p>
</li>
<li>
<p>Prefer composition to inheritance.</p>
</li>
<li>
<p>Prefer nonintrusive solutions.</p>
</li>
<li>
<p>Prefer value semantics over reference semantics.</p>
</li>
</ul>
<p>Used on their own, all of these have very positive effects on the quality of your code.
In combination, however, these guidelines prove to be so much better. This is what you
have experienced in our discussion about the External Polymorphism design pattern in
<a data-type="xref" href="ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism">“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”</a>.
Extracting the polymorphic behavior turned out to be extremely powerful and unlocked an
unprecedented level of loose coupling. Still, probably disappointingly, the demonstrated
implementation of External Polymorphism did not strike you as a very modern way of solving
things. Instead of following the advice to prefer value semantics, the implementation was
firmly built on reference semantics: many pointers, many manual allocations, and manual
lifetime management.<sup><a data-type="noteref" href="ch08.xhtml#idm45043085804224" id="idm45043085804224-marker">1</a></sup> Hence, the missing detail you’re waiting for is a value semantics–based
implementation of the External Polymorphism design pattern. And I will not keep you
waiting anymore: the resulting solution is commonly called <em>Type Erasure</em>.<sup><a data-type="noteref" href="ch08.xhtml#idm45043085802544" id="idm45043085802544-marker">2</a></sup></p>
<section data-pdf-bookmark="The History of Type Erasure" data-type="sect2"><div class="sect2" id="idm45043085800944">
<h2>The History of Type Erasure</h2>
<p>Before<a data-primary="Type Erasure design pattern" data-secondary="history of" data-type="indexterm" id="TEDPhistory08"/> I give you a detailed introduction, let’s quickly talk about the
history of Type Erasure. “Come on,” you argue. “Is this really necessary? I’m
dying to finally see how this stuff works.” Well, I promise to keep it short. But
yes, I feel this is a necessary detail of this discussion for two reasons. First, to
demonstrate that we as a community, aside from the circle of the most experienced
C++ experts, may have overlooked and ignored this technique for too long.
And second, to give some well-deserved credit to the inventor of the technique.</p>
<p>The Type Erasure design pattern is very often attributed to one of the first and therefore
most famous presentations of this technique. At the GoingNative 2013 conference, Sean Parent
gave a talk called “Inheritance Is the Base Class of Evil.”<sup><a data-type="noteref" href="ch08.xhtml#idm45043085797440" id="idm45043085797440-marker">3</a></sup>
recapped his experiences with the development of Photoshop and talked about the dangers
and disadvantages of inheritance-based implementations. However, he also presented a
solution to the inheritance problem, which later came to be known as Type Erasure.</p>
<p>Despite Sean’s talk being one of the first recorded, and for that reason probably the most
well-known resource about Type Erasure, the technique was used long before that. For
instance, Type Erasure was used in several places in the <a href="https://www.boost.org"><em>Boost</em>
libraries</a>, for example, by Douglas Gregor for
<a href="https://oreil.ly/XslzJ"><code>boost::function</code></a>.
Still, to my best knowledge, the technique was first discussed in a paper by Kevlin
Henney in the July-August 2000 edition of the <em>C++ Report</em>.<sup><a data-type="noteref" href="ch08.xhtml#idm45043085793120" id="idm45043085793120-marker">4</a></sup>
In this paper, Kevlin demonstrated Type Erasure with a code example that later
evolved into what we today know as C++17’s <code>std::any</code>. Most importantly, he
was the first to elegantly combine several design patterns to form a value semantics–based implementation around a collection of unrelated, nonpolymorphic types.</p>
<p>Since then, a lot of common types have acquired the technique to provide value types
for various applications. Some of these types have even found their way into the
Standard Library. For instance, we have already seen <code>std::function</code>, which represents
a value-based abstraction of a callable.<sup><a data-type="noteref" href="ch08.xhtml#idm45043085790080" id="idm45043085790080-marker">5</a></sup>
I’ve already mentioned <code>std::any</code>, which represents an abstract container-like value
for virtually anything (hence the name) but without exposing any functionality:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;any&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp"/>
<code class="k">using</code><code class="w"> </code><code class="k">namespace</code><code class="w"> </code><code class="nn">std</code><code class="o">::</code><code class="nn">string_literals</code><code class="p">;</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">any</code><code class="w"> </code><code class="n">a</code><code class="p">;</code><code class="w">          </code><code class="c1">// Creating an empty 'any'</code>
<code class="w">   </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w">               </code><code class="c1">// Storing an 'int' inside the 'any';</code>
<code class="w">   </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"some string"</code><code class="n">s</code><code class="p">;</code><code class="w">  </code><code class="c1">// Replacing the 'int' with a 'std::string'</code>

<code class="w">   </code><code class="c1">// There is nothing we can do with the 'any' except for getting the value back</code>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">any_cast</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>And then there is <code>std::shared_ptr</code>, which uses Type Erasure to store the assigned
deleter:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// Creating a 'std::shared_ptr' with a custom deleter</code>
<code class="w">      </code><code class="c1">//   Note that the deleter is not part of the type!</code>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">shared_ptr</code><code class="o">&lt;</code><code class="kt">int</code><code class="o">&gt;</code><code class="w"> </code><code class="n">s</code><code class="p">{</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">int</code><code class="p">{</code><code class="mi">42</code><code class="p">},</code><code class="w"> </code><code class="p">[](</code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">ptr</code><code class="p">){</code><code class="w"> </code><code class="k">delete</code><code class="w"> </code><code class="n">ptr</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="c1">// The 'std::shared_ptr' is destroyed at the end of the scope,</code>
<code class="w">   </code><code class="c1">//   deleting the 'int' by means of the custom deleter.</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>“It appears to be simpler to just provide a second template parameter for the deleter as
<code>std::unique_ptr</code> does. Why isn’t <code>std::shared_ptr</code> implemented in the same way?” you
inquire. Well, the designs of <code>std::shared_ptr</code> and <code>std::unique_ptr</code> are different
for very good reasons. The philosophy of <code>std::unique_ptr</code> is to represent nothing but the
simplest possible wrapper around a raw pointer: it should be as fast as a raw pointer, and it
should have the same size as a raw pointer. For that reason, it is not desirable to store the
deleter alongside the managed pointer. Consequently, <code>std::unique_ptr</code> is designed such that
for stateless deleters, any size overhead can be avoided. However, unfortunately, this second
template parameter is easily overlooked and causes artificial restrictions:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">// This function takes only unique_ptrs that use the default deleter,</code>
<code class="c1">//   and thus is artificially restricted</code>
<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">func1</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ptr</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="c1">// This function does not care about the way the resource is cleaned up,</code>
<code class="c1">//   and thus is truly generic</code>
<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">D</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">func2</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">D</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ptr</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>This kind of coupling is avoided in the design of <code>std::shared_ptr</code>. Since <code>std::shared_ptr</code>
has to store many more data items in its so-called control block (that includes the reference
count, the weak count, etc.), it has the opportunity to use Type Erasure to literally erase
the type of the deleter, removing any kind of possible dependency.<a data-primary="" data-startref="TEDPhistory08" data-type="indexterm" id="idm45043085456064"/></p>
</div></section>
<section data-pdf-bookmark="The Type Erasure Design Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043085800352">
<h2>The Type Erasure Design Pattern Explained</h2>
<p>“Wow, that<a data-primary="inheritance" data-secondary="replacing with Type Erasure design pattern" data-tertiary="Type Erasure explained" data-type="indexterm" id="idm45043085453744"/><a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-tertiary="Type Erasure explained" data-type="indexterm" id="idm45043085452496"/> truly sounds intriguing. This makes me even more excited to learn about Type
Erasure.” OK then, here we go. However, please don’t expect any magic or revolutionary
new ideas. Type Erasure is nothing but a compound design pattern, meaning that it is a very
clever and elegant combination of three other design patterns. The three design patterns of
choice are External Polymorphism (the key ingredient for achieving the decoupling
effect and the nonintrusive nature of Type Erasure; see
<a data-type="xref" href="ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism">“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”</a>),
Bridge (the key to creating a value semantics–based implementation; see
<a data-type="xref" href="ch07.xhtml#build_bridges_to_remove_physical_dependencies">“Guideline 28: Build Bridges to Remove 
<span class="keep-together">Physical Dependencies</span>”</a>), and (optionally)
Prototype (required to deal with the copy semantics of the resulting values; see
<a data-type="xref" href="ch07.xhtml#apply_prototype_for_abstract_copy_operations">“Guideline 30: Apply Prototype for Abstract Copy Operations”</a>). These three design patterns
form the core of Type Erasure, but of course, keep in mind that different interpretations
and implementations exist, mainly to adapt to specific contexts. The point of combining
these three design patterns is to create a wrapper type, which represents a loosely
coupled, nonintrusive abstraction.</p>
<div data-type="tip"><h1>The Type Erasure Compound Design Pattern</h1>
<p>Intent: “Provide<a data-primary="Type Erasure design pattern" data-secondary="intent of" data-type="indexterm" id="idm45043085447504"/> a value-based, non-intrusive abstraction for an extendable set of
unrelated, potentially non-polymorphic types with the same semantic behavior.”</p>
</div>
<p>The purpose of this formulation is to be as short as possible, and as precise as necessary.
However, every detail of this intent carries meaning. Thus, it may be helpful to elaborate:</p>
<dl>
<dt>Value-based</dt>
<dd>
<p>The intent of Type Erasure is to create value types that may be copyable, movable, and most importantly, easily reasoned about.
However, such a value type is not of the same quality as a
<a href="https://oreil.ly/aLbCD">regular</a> value type; there are some
limitations. In particular, Type Erasure works best for unary operations but has its
limits for binary operations.</p>
</dd>
<dt>Nonintrusive</dt>
<dd>
<p>The intent of Type Erasure is to create an external, nonintrusive
abstraction based on the example set by the External Polymorphism design pattern. All
types providing the behavior expected by the abstraction are automatically supported,
without the need to apply any modifications to them.</p>
</dd>
</dl>
<dl class="less_space pagebreak-before">
<dt>Extendable, unrelated set of types</dt>
<dd>
<p>Type Erasure<a data-primary="object-oriented programming (OOP)" data-secondary="Type Erasure design pattern" data-type="indexterm" id="idm45043085439952"/> is firmly based on object-oriented
principles, i.e., it enables you to add types easily. These types, though, should not be
connected in any way. They do not have to share common behavior via
some base class. Instead, it should be possible to add any fitting type, without any
intrusive measure, to this set of types.</p>
</dd>
<dt>Potentially nonpolymorphic</dt>
<dd>
<p>As demonstrated with the External Polymorphism design
pattern, types should not have to buy into the set by inheritance. They
should also not have to provide virtual functionality on their own, but they should
be decoupled from their polymorphic behavior. However, types with base
classes or virtual functions are not excluded.</p>
</dd>
<dt>Same semantic behavior</dt>
<dd>
<p>The goal is not to provide an abstraction for all possible
types but to provide a semantic abstraction for a set of types that provide the same
operations (including same syntax) and adhere to some expected behavior, according to
the LSP (see
<a data-type="xref" href="ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>). If possible, for any type that
does not provide the expected functionality, a compile-time error should be created.</p>
</dd>
</dl>
<p>With this formulation of the intent in mind, let’s take a look at the dependency graph
of Type Erasure (see <a data-type="xref" href="#fig_type_erasure_dependency_graph">Figure 8-1</a>). The
graph should look very familiar, as the structure of the pattern is dominated by the
inherent structure of the External Polymorphism design pattern (see
<a data-type="xref" href="ch07.xhtml#fig_external_polymorphism_dependency_graph">Figure 7-8</a>). The most important difference and addition
is the <code>Shape</code> class on the highest level of the architecture. This class serves as a
wrapper around the external hierarchy introduced by External Polymorphism. Primarily,
since this external hierarchy will not be used directly anymore, but also to reflect the
fact that <code>ShapeModel</code> is storing, or “owning,” a concrete type, the name of the
class template has been adapted<a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-tertiary="dependency graph" data-type="indexterm" id="idm45043085431536"/> to <code>OwningShapeModel</code>.</p>
<figure><div class="figure" id="fig_type_erasure_dependency_graph">
<img alt="The dependency graph for the Type Erasure design pattern." height="1261" src="assets/cpsd_0801.png" width="1439"/>
<h6><span class="label">Figure 8-1. </span>Dependency graph for the Type Erasure design pattern</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="An Owning Type Erasure Implementation" data-type="sect2"><div class="sect2" id="idm45043085427536">
<h2>An Owning Type Erasure Implementation</h2>
<p>OK, but<a data-primary="inheritance" data-secondary="replacing with Type Erasure design pattern" data-tertiary="simple implementation" data-type="indexterm" id="idm45043085425584"/><a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-tertiary="simple implementation" data-type="indexterm" id="idm45043085424208"/> now, with the structure of Type Erasure in mind, let’s take a look at its
implementation details. Still, despite the fact that you’ve seen all the
ingredients in action before, the implementation details are not particularly beginner-friendly
and are not for the fainthearted. And that is despite the fact that I have picked the simplest
Type Erasure implementation I’m aware of. Therefore, I will try to keep everything at a
reasonable level and not stray too much into the realm of implementation details.
Among other things, this means that I won’t try to squeeze out every tiny bit of
performance. For instance, I won’t use <em>forwarding references</em> or avoid
dynamic memory allocations. Also, I will favor readability and code clarity. While this
may be a disappointment to you, I believe that will save us a lot of headache. However,
if you want to dig deeper into the implementation details and optimization options,
I recommend taking a look at <a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>.</p>
<p>We again start with the <code>Circle</code> and <code>Square</code> classes:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Circle.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">radius_</code><code class="p">(</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Several more getters and circle-specific utility functions */</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">radius_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Several more data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Square.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">Square</code><code class="p">(</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">side_</code><code class="p">(</code><code class="w"> </code><code class="n">side</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Several more getters and square-specific utility functions */</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">double</code><code class="w"> </code><code class="n">side_</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* Several more data members */</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>These two classes have not changed since we last encountered them in the discussion of
External Polymorphism. But it still pays off to again stress that these two are
completely unrelated, do not know about each other, and—most importantly—are
nonpolymorphic, meaning that they do not inherit from any base class or introduce
virtual function on their own.</p>
<p>We have also seen the <code>ShapeConcept</code> and <code>OwningShapeModel</code> classes before, the latter
under the name <code>ShapeModel</code>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">namespace</code><code class="w"> </code><code class="nn">detail</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConcept</code><code class="w">  </code><a class="co" href="#para_g32_1" id="code_g32_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">ShapeConcept</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_2" id="code_g32_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">ShapeConcept</code><code class="o">&gt;</code><code class="w"> </code><code class="n">clone</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_3" id="code_g32_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">OwningShapeModel</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w">  </code><a class="co" href="#para_g32_4" id="code_g32_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">OwningShapeModel</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g32_5" id="code_g32_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">shape_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="n">shape_</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g32_8" id="code_g32_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">ShapeConcept</code><code class="o">&gt;</code><code class="w"> </code><code class="n">clone</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">OwningShapeModel</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_9" id="code_g32_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_6" id="code_g32_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_7" id="code_g32_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace detail
</code></pre>
<p>Next to the name change, there are a couple of other, important differences. For
instance, both classes have been moved to the <code>detail</code> namespace. The name of the
namespace indicates that these two classes are now becoming implementation details,
i.e., they are not intended for direct use anymore.<sup><a data-type="noteref" href="ch08.xhtml#idm45043084954144" id="idm45043084954144-marker">6</a></sup> The <code>ShapeConcept</code> class
(<a class="co" href="#code_g32_1" id="para_g32_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>)
still introduces the pure virtual function <code>draw()</code> to represent the requirement for
drawing a shape
(<a class="co" href="#code_g32_2" id="para_g32_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
In addition, <code>ShapeConcept</code> now also introduces a pure virtual <code>clone()</code> function
(<a class="co" href="#code_g32_3" id="para_g32_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>).
“I know what this is, this is the Prototype design pattern!” you exclaim. Yes, correct.
The name <code>clone()</code> is very strongly connected to Prototype and
is a strong indication of this design pattern (but not a guarantee). However, although
the choice of the function name is very reasonable and canonical, allow me to point out
explicitly that the choice of the function name for <code>clone()</code>, and also for <code>draw()</code>, is
our own: these names are now implementation details and do <em>not</em> have any relationship
to the names that we require from our <code>ShapeT</code> types. We could as well name them
<code>do_draw()</code> and <code>do_clone()</code>, and it would not have any consequence on the <code>ShapeT</code>
types. The real requirement on the <code>ShapeT</code> types is defined by the <em>implementation</em>
of the <code>draw()</code> and <code>clone()</code> functions.</p>
<p>As <code>ShapeConcept</code> is again the base class for the external hierarchy, the <code>draw()</code>
function, the <code>clone()</code> function, and the destructor represent the set of
requirements for all kinds of shapes. This means that all shapes must provide some
drawing 
<span class="keep-together">behavior—they</span> must be copyable and destructible. Note that these three
functions are only requirement choices for this example. In particular,
copyability is not a general requirement for all implementations of Type Erasure.</p>
<p>The <code>OwningShapeModel</code> class
(<a class="co" href="#code_g32_4" id="para_g32_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>)
again represents the one and only implementation of the <code>ShapeConcept</code> class. As before,
<code>OwningShapeModel</code> takes a concrete shape type and a drawing Strategy in its constructor
(<a class="co" href="#code_g32_5" id="para_g32_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>)
and uses these to initialize its two data members
(<a class="co" href="#code_g32_6" id="para_g32_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a> and
<a class="co" href="#code_g32_7" id="para_g32_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).
Since <code>OwningShapeModel</code> inherits from <code>ShapeConcept</code>, it must implement the two pure
virtual functions. The <code>draw()</code> function is implemented by applying the given drawing Strategy
(<a class="co" href="#code_g32_8" id="para_g32_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>),
while the <code>clone()</code> function is implemented to return an exact copy of the corresponding
<code>OwningShapeModel</code>
(<a class="co" href="#code_g32_9" id="para_g32_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re right now thinking, “Oh no, <code>std::make_unique()</code>. That means dynamic memory.
Then I can’t use that in my code!”—don’t worry. <code>std::make_unique()</code> is merely an
implementation detail, a choice to keep the example simple. In
<a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>, you will 
<span class="keep-together">see how</span> to avoid
dynamic memory with the SBO.</p>
</div>
<p>“I’m pretty unimpressed so far. We’ve barely moved beyond the implementation of the
External Polymorphism design pattern.” I completely understand the criticism. However,
we are just one step away from turning External Polymorphism into Type Erasure, just one
step away from switching from reference semantics to value semantics. All we need is a value
type, a wrapper around the external hierarchy introduced by <code>ShapeConcept</code> and <code>OwningShapeModel</code>,
that handles all the details that we don’t want to perform manually: the instantiation of
the <code>OwningShapeModel</code> class template, managing pointers, performing allocations, and dealing
with lifetime. This wrapper is given in the form of the <code>Shape</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">           </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g32_10" id="code_g32_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">detail</code><code class="o">:</code><code class="o">:</code><code class="n">OwningShapeModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_11" id="code_g32_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="n">pimpl_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g32_12" id="code_g32_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">                                      </code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">detail</code><code class="o">:</code><code class="o">:</code><code class="n">ShapeConcept</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_13" id="code_g32_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The first, and perhaps most important, detail about the <code>Shape</code> class is the templated
constructor
(<a class="co" href="#code_g32_10" id="para_g32_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).
As the first argument, this constructor takes any kind of shape (called <code>ShapeT</code>), and
as the second argument, the desired <code>DrawStrategy</code>. To simplify the instantiation
of the corresponding <code>detail::OwningShapeModel</code> class template, it proves to be helpful to use
a convenient type alias
(<a class="co" href="#code_g32_11" id="para_g32_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>).
This alias is used to instantiate the required model by <code>std::make_unique()</code>
(<a class="co" href="#code_g32_12" id="para_g32_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>).
Both the shape and the drawing Strategy are passed to the new model.</p>
<p>The newly created model is used to initialize the one data member of the <code>Shape</code> class:
the <code>pimpl_</code>
(<a class="co" href="#code_g32_13" id="para_g32_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).
“I recognize this one, too; this is a Bridge!” you happily announce. Yes, correct again.
This is an application of the Bridge design pattern. In the construction, we create a
concrete <code>OwningShapeModel</code> based on the actual given types <code>ShapeT</code> and <code>DrawStrategy</code>,
but we store it as a pointer to <code>ShapeConcept</code>. By doing this you create a Bridge to the
implementation details, a Bridge to the real shape type. However, after the initialization
of <code>pimpl_</code>, after the constructor is finished, <code>Shape</code> doesn’t remember the actual type.
<code>Shape</code> does not have a template parameter or any member function that would reveal the
concrete type it stores, and there is no data member that remembers the given type. All
it holds is a pointer to the <code>ShapeConcept</code> base class. Thus, its memory of the real shape
type has been erased. Hence the name of the design pattern: Type Erasure.</p>
<p>The only thing missing in our <code>Shape</code> class is the functionality required for a true 
<span class="keep-together">value type:</span> the copy and move operations. Luckily, due to the application of <code>std::unique_ptr</code>,
our effort is pretty limited. Since the compiler-generated destructor and the two move
operations will work, we only need to deal with the two copy operations:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g32_14" id="code_g32_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">(</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">clone</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g32_15" id="code_g32_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="c1">// Copy-and-Swap Idiom
</code><code class="w">      </code><code class="n">Shape</code><code class="w"> </code><code class="nf">copy</code><code class="p">(</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">pimpl_</code><code class="p">.</code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">copy</code><code class="p">.</code><code class="n">pimpl_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="o">~</code><code class="n">Shape</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g32_16" id="code_g32_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">shape</code><code class="p">.</code><code class="n">pimpl_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The copy constructor
(<a class="co" href="#code_g32_14" id="para_g32_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>)
could be a very difficult function to implement, since we do not know the concrete type of
shape stored in the <code>other</code> <code>Shape</code>. However, by providing the <code>clone()</code> function in
the <code>ShapeConcept</code> base class, we can ask for an exact copy without needing to know
anything about the concrete type. The shortest, most painless, and most convenient way
to implement the copy assignment operator
(<a class="co" href="#code_g32_15" id="para_g32_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>)
is to build on the
<a href="https://oreil.ly/Pm1uW"><em>Copy-and-Swap idiom</em></a>.</p>
<p>In addition, the <code>Shape</code> class provides a so-called
<a href="https://oreil.ly/ylXGZ">hidden <code>friend</code></a>
called <code>draw()</code>
(<a class="co" href="#code_g32_16" id="para_g32_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>).
This <code>friend</code> function is called a <em>hidden friend</em>, since although it’s a free function,
it is defined within the body of the <code>Shape</code> class. As a <code>friend</code>, it’s granted full
access to the 
<span class="keep-together"><code>private</code></span> data member and will be injected into the surrounding namespace.</p>
<p>“Didn’t you say that <code>friend</code>s are bad?” you ask. I admit, that’s what I said in
<a data-type="xref" href="ch01.xhtml#design_for_testability">“Guideline 4: Design for Testability”</a>. However, I also explicitly stated that hidden <code>friend</code>s
are OK. In this case, the <code>draw()</code> function is an integral part of the <code>Shape</code> class and
definitely a real <code>friend</code> (almost part of the family). “But then it should be a member
function, right?” you argue. Indeed, that would be a valid alternative. If you like this
better, go for it. In this case, my preference is to use a free function, since one of our
goals was to reduce dependencies by extracting the <code>draw()</code> operation. This goal should
also be reflected in the <code>Shape</code> implementation. However, since the function requires access
to the <code>pimpl_</code> data member, and in order to not increase the overload set of <code>draw()</code>
functions, I implement it as a hidden <code>friend</code>.</p>
<p>This is it. All of it. Let’s take a look at how beautifully the new functionality works:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Main.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Square.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a circle as one representative of a concrete shape type
</code><code class="w">   </code><code class="n">Circle</code><code class="w"> </code><code class="n">circle</code><code class="p">{</code><code class="w"> </code><code class="mf">3.14</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a drawing strategy in the form of a lambda
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="p">)</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Combine the shape and the drawing strategy in a 'Shape' abstraction
</code><code class="w">   </code><code class="c1">// This constructor call will instantiate a 'detail::OwningShapeModel' for
</code><code class="w">   </code><code class="c1">// the given 'Circle' and lambda types
</code><code class="w">   </code><code class="n">Shape</code><code class="w"> </code><code class="n">shape1</code><code class="p">(</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Draw the shape
</code><code class="w">   </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">shape1</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_17" id="code_g32_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a copy of the shape by means of the copy constructor
</code><code class="w">   </code><code class="n">Shape</code><code class="w"> </code><code class="n">shape2</code><code class="p">(</code><code class="w"> </code><code class="n">shape1</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Drawing the copy will result in the same output
</code><code class="w">   </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">shape2</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_18" id="code_g32_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>We first create <code>shape1</code> as an abstraction for a <code>Circle</code> and an associated drawing
Strategy. This feels easy, right? There’s no need to manually allocate and no need to
deal with pointers. With the <code>draw()</code> function, we’re able to draw this <code>Shape</code>
(<a class="co" href="#code_g32_17" id="para_g32_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>).
Directly afterward, we create a copy of the shape. A real copy—a “deep copy,” not just
the copy of a pointer. Drawing the copy with the <code>draw()</code> function will result in the
same output
(<a class="co" href="#code_g32_18" id="para_g32_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>).
Again, this feels good: you can rely on the copy operations of the value type (in this case,
the copy constructor), and you do not have to <code>clone()</code> manually.</p>
<p>Pretty amazing, right? And definitely much better than using External Polymorphism
manually. I admit that after all these implementation details, it may be a little hard to see
it right away, but if you step through the jungle of implementation details, I hope you
realize the beauty of this approach: you no longer have to deal with pointers, there are no
manual allocations, and you don’t have to deal with inheritance hierarchies anymore. All of
these details are there, yes, but all evidence is nicely encapsulated within the
<code>Shape</code> class. Still, you didn’t lose any of the decoupling benefits: you are still able
to easily add new types, and the concrete shape types are still oblivious about the drawing
behavior. They are only connected to the desired functionality via the <code>Shape</code> constructor.</p>
<p>“I’m wondering,” you begin to ask, “Couldn’t we make this much easier? I envision a
<code>main()</code> function that looks like this”:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;YourMain.cpp&gt; ----------------</code>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// Create a circle as one representative of a concrete shape type</code>
<code class="w">   </code><code class="n">Circle</code><code class="w"> </code><code class="n">circle</code><code class="p">{</code><code class="w"> </code><code class="mf">3.14</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="c1">// Bind the circle to some drawing functionality</code>
<code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">drawingCircle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="o">=</code><code class="p">]()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">myCircleDrawer</code><code class="p">(</code><code class="n">circle</code><code class="p">);</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="c1">// Type-erase the circle equipped with drawing behavior</code>
<code class="w">   </code><code class="n">Shape</code><code class="w"> </code><code class="n">shape</code><code class="p">(</code><code class="w"> </code><code class="n">drawingCircle</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Drawing the shape</code>
<code class="w">   </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>That is a great idea. Remember, you are in charge of all the implementation details of
the Type Erasure wrapper and how to bring together types and their operation implementation. If you like this form better, go for it! However, please do not forget
that in our <code>Shape</code> example, for the sake of simplicity and code brevity, I have
deliberately used only a single functionality with external dependencies (drawing).
There could be more functions that introduce dependencies, such as the serialization
of shapes. In that case, the lambda approach would not work, as you would need multiple,
named functions (e.g., <code>draw()</code> and <code>serialize()</code>). So, ultimately, it depends. It depends
on what kind of abstraction your Type Erasure wrapper represents. But whatever
implementation you prefer, just make sure that you do not introduce artificial 
<span class="keep-together">dependencies</span>
between the different pieces of functionality and/or code duplication. In other words,
remember <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>! That is the reason I favored the solution based
on the Strategy design pattern, which you, however, shouldn’t consider the true and
only solution. On the contrary, you should strive to fully exploit the potential of the
loose coupling of Type Erasure.</p>
</div></section>
<section data-pdf-bookmark="Analyzing the Shortcomings of the Type Erasure Design Pattern" data-type="sect2"><div class="sect2" id="idm45043085426624">
<h2>Analyzing the Shortcomings of the Type Erasure Design Pattern</h2>
<p>Despite<a data-primary="inheritance" data-secondary="replacing with Type Erasure design pattern" data-tertiary="Type Erasure shortcomings" data-type="indexterm" id="idm45043084089840"/><a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-tertiary="Type Erasure shortcomings" data-type="indexterm" id="idm45043084088752"/> the beauty of Type Erasure and the large number of benefits that you acquire,
especially from a design perspective, I don’t pretend that there are no downsides to this
design pattern. No, it wouldn’t be fair to keep potential disadvantages from you.</p>
<p>The first, and probably most obvious, drawback for you might be the implementation complexity
of this pattern. As stated before, I have explicitly kept the implementation details
at a reasonable level, which hopefully helped you to get the idea. I hope I have also given
you the impression that it is not <em>so</em> difficult after all: a basic implementation of Type
Erasure can be realized within approximately 30 lines of code. Still, you might feel that it is too
complex. Also, as soon as you start to go beyond the basic implementation and
consider performance, exception safety, etc., the implementation details indeed become
quite tricky very quickly. In these cases, your safest and most convenient option is to
use a third-party library instead of dealing with all of these details yourself. Possible
libraries include the
<a href="https://oreil.ly/PvVFI"><em>dyno</em> library</a> from Louis Dionne, the
<a href="https://oreil.ly/rB8uj"><em>zoo</em> library</a> from Eduardo Madrid, the
<a href="https://oreil.ly/zKwXF"><em>erasure</em> library</a> from Gašper Ažman, and the
<a href="https://oreil.ly/IGNoq"><em>Boost Type Erasure</em></a>
library from Steven Watanabe.</p>
<p>In the explanation of the intent of Type Erasure, I mentioned the second
disadvantage, which is much more important and limiting: although we are now dealing with
values that can be copied and moved, using Type Erasure for
binary operations is not straightforward. For instance, it is not easily possible to do an equality comparison on these values,
as you would expect from regular values:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">shape1</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">shape2</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><code class="c1">// Does not compile!</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The reason is that, after all, <code>Shape</code> is only an abstraction from a concrete shape type and
only stores a pointer-to-base. As you would deal with exactly the same problem if you
used External Polymorphism directly, this is definitely not a new problem in Type Erasure,
and you might not even count this as a real disadvantage. Still, while equality comparison
is not an expected operation when you’re dealing with pointers-to-base, it usually is an
expected operation on values.</p>
</div></section>
<section data-pdf-bookmark="Comparing Two Type Erasure Wrappers" data-type="sect2"><div class="sect2" id="idm45043084067056">
<h2>Comparing Two Type Erasure Wrappers</h2>
<p>“Isn’t<a data-primary="inheritance" data-secondary="replacing with Type Erasure design pattern" data-tertiary="comparing two type erasure wrappers" data-type="indexterm" id="idm45043084065648"/><a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-tertiary="comparing two types of erasure wrappers" data-type="indexterm" id="idm45043084064432"/> this just a question of exposing the necessary functionality in the interface of
<code>Shape</code>s?” you wonder. “For instance, we could simply add an <code>area()</code> function
to the <code>public</code> interface of shapes and use it to compare two items”:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">bool</code><code class="w"> </code><code class="k">operator</code><code class="o">==</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">lhs</code><code class="p">.</code><code class="n">area</code><code class="p">()</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">area</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>“This is easy to do. So what am I missing?” I agree that this might be all you need: if
two objects are equal if some public properties are equal, then this operator will work
for you. In general, the answer would have to be “it depends.” In this particular case, it
depends on the semantics of the abstraction that the <code>Shape</code> class represents. The question
is: when are two <code>Shape</code>s equal? Consider the following example with a 
<span class="keep-together"><code>Circle</code></span> and a
<code>Square</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Square.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">Shape</code><code class="w"> </code><code class="n">shape1</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="p">{</code><code class="mf">3.14</code><code class="p">}</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">Shape</code><code class="w"> </code><code class="n">shape2</code><code class="p">(</code><code class="w"> </code><code class="n">Square</code><code class="p">{</code><code class="mf">2.71</code><code class="p">}</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">shape1</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">shape2</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>When are these two <code>Shape</code>s equal? Are they equal if their areas are equal, or are they
equal if the instances behind the abstraction are equal, meaning that both <code>Shape</code>s are
of the same type and have the same properties? It depends. In the same spirit, I could ask
the question, when are two <code>Person</code>s equal? Are they equal if their first names are equal?
Or are they equal if all of their characteristics are equal? It depends on the desired
semantics. And while the first comparison is easily done, the second one is not. In a general case, I assume that the second situation is far more likely to be the
desired semantics, and therefore I argue that using Type Erasure
for equality comparison and more generally for binary operations is not straightforward.</p>
<p>Note, however, that I did not say that equality comparison is impossible. Technically, you
can make it work, although it turns out to be a rather ugly solution. Therefore, you have
to promise not to tell anyone that you got this idea from me. “You just made me even
more curious,” you smile whimsically. OK, so here it is:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">namespace</code><code class="w"> </code><code class="nn">detail</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConcept</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="n">isEqual</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">OwningShapeModel</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="n">isEqual</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">OwningShapeModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">dynamic_cast</code><code class="o">&lt;</code><code class="n">Model</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g32_19" id="code_g32_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="n">model</code><code class="w"> </code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape_</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="n">model</code><code class="o">-</code><code class="o">&gt;</code><code class="n">shape_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace detail
</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">lhs</code><code class="p">.</code><code class="n">pimpl_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">isEqual</code><code class="p">(</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">pimpl_</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="k">operator</code><code class="o">!</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="o">!</code><code class="p">(</code><code class="w"> </code><code class="n">lhs</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Circle.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="kt">bool</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">lhs</code><code class="p">.</code><code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">
</code><code class="c1">//---- &lt;Square.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="kt">bool</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">lhs</code><code class="p">.</code><code class="n">side</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">side</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>To make equality comparison work, you could use a <code>dynamic_cast</code>
(<a class="co" href="#code_g32_19" id="para_g32_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a>).
However, this implementation of equality comparison holds two severe disadvantages. First,
as you saw in <a data-type="xref" href="ch04.xhtml#beware_the_performance_of_acyclic_visitors">“Guideline 18: Beware the Performance of Acyclic Visitor”</a>, a <code>dynamic_cast</code> does
most certainly not count as a fast operation. Hence, you would have to pay a considerable
runtime cost for every comparison. Second, in this implementation, you can only successfully
compare two <code>Shape</code>s if they are equipped with the same <code>DrawStrategy</code>. While this might
be reasonable in one context, it might also be considered an unfortunate limitation in
another context. The only solution I am aware of is to return to <code>std::function</code> to store
the drawing Strategy, which, however, would result in another performance penalty.<sup><a data-type="noteref" href="ch08.xhtml#idm45043083389632" id="idm45043083389632-marker">7</a></sup> In summary, depending on the context,
equality comparison may be possible, but it’s usually neither easy nor cheap to accomplish.
This is evidence to my earlier statement that Type Erasure doesn’t support binary
operations.</p>
</div></section>
<section data-pdf-bookmark="Interface Segregation of Type Erasure Wrappers" data-type="sect2"><div class="sect2" id="idm45043083394288">
<h2>Interface Segregation of Type Erasure Wrappers</h2>
<p>“What about<a data-primary="inheritance" data-secondary="replacing with Type Erasure design pattern" data-tertiary="interface segregation of Type Erasure wrappers" data-type="indexterm" id="idm45043083358144"/><a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-tertiary="replacing inheritance hierarchies" data-type="indexterm" id="idm45043083356928"/><a data-primary="interfaces, separating" data-secondary="interface segregation of Type Erasure wrappers" data-type="indexterm" id="idm45043083355808"/> the Interface Segregation Principle (ISP)?” you ask. “While using
External Polymorphism, it was easy to separate concerns in the base class. It appears
we’ve lost this ability, right?” Excellent question. So you remember my example with
the <code>JSONExportable</code> and <code>Serializable</code> base classes in
<a data-type="xref" href="ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism">“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”</a>.
Indeed, with Type Erasure we are no longer able to use the hidden base class,
only the abstracting value type. Therefore, it may appear as if the ISP is out
of reach:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Document</code><code class="w">  </code><code class="c1">// Type-erased 'Document'</code>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="w"> </code><code class="n">bs</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="c1">// Artificial coupling to 'ByteStream', although only the JSON export is needed</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">exportDocument</code><code class="p">(</code><code class="w"> </code><code class="n">Document</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">doc</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">doc</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
<p>However, fortunately, this impression is incorrect. You can easily adhere to the ISP
by providing several type-erased abstractions:<sup><a data-type="noteref" href="ch08.xhtml#idm45043083443376" id="idm45043083443376-marker">8</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="n">Document</code><code class="w"> </code><code class="n">doc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="cm">/*...*/</code><code class="p">;</code><code class="w">  </code><code class="c1">// Type-erased 'Document'</code>
<code class="n">doc</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="n">doc</code><code class="p">.</code><code class="n">serialize</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="n">JSONExportable</code><code class="w"> </code><code class="n">jdoc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">doc</code><code class="p">;</code><code class="w">  </code><code class="c1">// Type-erased 'JSONExportable'</code>
<code class="n">jdoc</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="n">Serializable</code><code class="w"> </code><code class="n">sdoc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">doc</code><code class="p">;</code><code class="w">  </code><code class="c1">// Type-erased 'Serializable'</code>
<code class="n">sdoc</code><code class="p">.</code><code class="n">serialize</code><code class="p">(</code><code class="w"> </code><code class="cm">/* pass necessary arguments */</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>Before considering this, take a look at
<a data-type="xref" href="#be_aware_of_the_setup_costs_of_owning_type_erasure_wrappers">“Guideline 34: Be Aware of the Setup Costs of Owning 
<span class="keep-together">Type Erasure Wrappers</span>”</a>.</p>
<p>“Apart from the implementation complexity and the restriction to unary operations, there
seem to be no disadvantages. Well, then, I have to say this is amazing stuff indeed!
The benefits clearly outweigh the drawbacks.” Well, of course it always
depends, meaning that in a specific context some of these issues might cause some pain.
But I agree that, altogether, Type Erasure proves to be a very valuable design pattern.
From a design perspective, you’ve gained a formidable level of decoupling, which
will definitely lead to less pain when changing or extending your software. However,
although this is already fascinating, there’s more. I’ve mentioned 
<span class="keep-together">performance</span> a
couple of times but haven’t yet shown any performance numbers. So let’s take a look at
the performance results.</p>
</div></section>
<section data-pdf-bookmark="Performance Benchmarks" data-type="sect2"><div class="sect2" id="idm45043083129536">
<h2>Performance Benchmarks</h2>
<p>Before<a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-tertiary="performance benchmarks" data-type="indexterm" id="idm45043083127776"/><a data-primary="inheritance" data-secondary="replacing with Type Erasure design pattern" data-tertiary="performance benchmarks" data-type="indexterm" id="idm45043083126512"/> showing you the performance results for Type Erasure, let me remind you about the
benchmark scenario that we also used to benchmark the Visitor and Strategy solutions
(see <a data-type="xref" href="ch04.xhtml#table_cyclic_visitor_benchmark_results">Table 4-2</a> in
<a data-type="xref" href="ch04.xhtml#use_visitors_to_extend_operations">“Guideline 16: Use Visitor to Extend Operations”</a> and <a data-type="xref" href="ch05.xhtml#table_strategy_benchmark_results">Table 5-1</a> in
<a data-type="xref" href="ch05.xhtml#prefer_a_value_based_implementation_of_strategy_and_command">“Guideline 23: Prefer a Value-Based Implementation of Strategy and Command”</a>).
This time I have extended the benchmark with a Type Erasure solution based on the
<code>OwningShapeModel</code> implementation. For the benchmark, we are still using four different kinds
of shapes (circles, squares, ellipses, and rectangles). And again, I’m running 25,000 translate
operations on 10,000 randomly created shapes. I use both GCC 11.1 and Clang 11.1, and for both
compilers, I’m adding only the <code>-O3</code> and <code>-DNDEBUG</code> compilation flags. The platform I’m using
is macOS Big Sur (version 11.4) on an 8-Core Intel Core i7 with 3.8 GHz, 64 GB of main memory.</p>
<p><a data-type="xref" href="#table_type_erasure_benchmark_results">Table 8-1</a> shows the performance numbers. For your
convenience, I reproduced the performance results from the Strategy benchmarks. After all,
the Strategy design pattern is the solution that is aiming at the same design space. The
most interesting line, though, is the last line. It shows the<a data-primary="object-oriented programming (OOP)" data-secondary="Type Erasure design pattern" data-type="indexterm" id="idm45043083651248"/> performance result for the
Type Erasure design pattern.</p>
<table id="table_type_erasure_benchmark_results">
<caption><span class="label">Table 8-1. </span>Performance results for the Type Erasure implementations</caption>
<thead>
<tr>
<th>Type Erasure implementation</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Object-oriented solution</p></td>
<td><p>1.5205 s</p></td>
<td><p>1.1480 s</p></td>
</tr>
<tr>
<td><p><code>std::function</code></p></td>
<td><p>2.1782 s</p></td>
<td><p>1.4884 s</p></td>
</tr>
<tr>
<td><p>Manual implementation of <code>std::function</code></p></td>
<td><p>1.6354 s</p></td>
<td><p>1.4465 s</p></td>
</tr>
<tr>
<td><p>Classic Strategy</p></td>
<td><p>1.6372 s</p></td>
<td><p>1.4046 s</p></td>
</tr>
<tr>
<td><p>Type Erasure</p></td>
<td><p>1.5298 s</p></td>
<td><p>1.1561 s</p></td>
</tr>
</tbody>
</table>
<p>“Looks very interesting. Type Erasure seems to be pretty fast. Apparently only the
object-oriented solution is faster.” Yes. For Clang, the performance of the
object-oriented solution is a little better. But only a little. However, please remember
that the object-oriented solution does not decouple anything: the
<code>draw()</code> function is implemented as a virtual member function in the <code>Shape</code> hierarchy,
and thus you experience heavy coupling to the drawing functionality. While this may come
with little 
<span class="keep-together">performance</span> overhead, from a design perspective, this is a worst-case scenario.
Taking this into account, the performance numbers of Type Erasure are truly marvelous: it
performs between 6% and 20% better than any Strategy implementation. Thus, Type Erasure
not only provides the strongest decoupling but also performs better than all the other
attempts to reduce coupling.<sup><a data-type="noteref" href="ch08.xhtml#idm45043083097792" id="idm45043083097792-marker">9</a></sup></p>
</div></section>
<section data-pdf-bookmark="A Word About Terminology" data-type="sect2"><div class="sect2" id="idm45043083096432">
<h2>A Word About Terminology</h2>
<p>In<a data-primary="Type Erasure design pattern" data-secondary="replacing inheritance hierarchies" data-tertiary="alternate forms of Type Erasure" data-type="indexterm" id="idm45043083095056"/><a data-primary="inheritance" data-secondary="replacing with Type Erasure design pattern" data-tertiary="alternate forms of Type Erasure" data-type="indexterm" id="idm45043083093968"/> summary, Type Erasure is an amazing approach to achieve both efficient and
loosely coupled code. While it may have a few limitations and disadvantages, the one
thing you probably cannot ignore easily is the complex implementation details.
For that reason, many people, including me and Eric Niebler, feel that Type
Erasure should become a language feature:<sup><a data-type="noteref" href="ch08.xhtml#idm45043083092752" id="idm45043083092752-marker">10</a></sup></p>
<blockquote>
<p>If I could go back in time and had the power to change C++, rather than adding
virtual functions, I would add language support for type erasure and concepts. Define a
single-type concept, automatically generate a type-erasing wrapper for it.</p></blockquote>
<p>There is more to be done, though, to establish Type Erasure as a real design pattern.
I have introduced Type Erasure as a compound design pattern built
from External Polymorphism, Bridge, and Prototype. I’ve introduced it as a
value-based technique for providing strong decoupling of a set of types from their
associated operations. However, unfortunately, you might see other “forms” of Type
Erasure: over time, the term <em>Type Erasure</em> has been misused and abused for all kinds
of techniques and concepts. For instance, sometimes people refer to a <code>void*</code> as
Type Erasure. Rarely, you also hear about Type Erasure in the context of inheritance
hierarchies, or more specifically a pointer-to-base. And finally, you also might hear
about Type Erasure in the context of <code>std::variant</code>.<sup><a data-type="noteref" href="ch08.xhtml#idm45043083089328" id="idm45043083089328-marker">11</a></sup></p>
<p>The <code>std::variant</code> example especially demonstrates how deeply flawed this overuse of
the term <em>Type Erasure</em> really is. While External Polymorphism, the main design pattern
behind Type Erasure, is about enabling you to add new types, the Visitor design
pattern and its modern implementation as <code>std::variant</code> are about adding new
operations (see <a data-type="xref" href="ch04.xhtml#design_for_the_addition_of_types_or_operations">“Guideline 15: Design for the Addition of 
<span class="keep-together">Types or Operations</span>”</a>). From a
software design perspective, these two solutions are completely orthogonal to each
other: while Type Erasure truly decouples from concrete types and erases type
information, the template arguments of <code>std::variant</code> reveal all possible alternatives
and therefore make you depend on these types. Using the same term for both of them
results in exactly zero information conveyed when using the term <em>Type Erasure</em> and generates these types of comments: “I
would suggest we use Type Erasure to solve this problem.” “Could you please be more
specific? Do you want to add types or operations?” As such, the term would not fulfill
the qualities of a design pattern; it wouldn’t carry any intent. Therefore, it would
be useless.</p>
<p>To give Type Erasure its well-earned place in the hall of design patterns and to give it any meaning, consider using the term only for the intent discussed
in this guideline.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043083084064">
<h5>Guideline 32: Consider Replacing Inheritance Hierarchies with 
<span class="keep-together">Type Erasure</span></h5>
<ul>
<li>
<p>Apply the Type Erasure design pattern with the intent to provide a value-based, nonintrusive abstraction for an extendable set of unrelated, potentially nonpolymorphic types with the same semantic behavior.</p>
</li>
<li>
<p>Consider Type Erasure as a compound design pattern, built from the External Polymorphism, Bridge, and Prototype design patterns.</p>
</li>
<li>
<p>Understand the advantages of Type Erasure, but also keep in mind its 
<span class="keep-together">limitations.</span></p>
</li>
<li>
<p>Use the term Type Erasure only to communicate its intent as a design pattern that allows the easy addition of types supporting a fixed set of operations.<a data-primary="" data-startref="TEDPinhi08" data-type="indexterm" id="idm45043083079120"/><a data-primary="" data-startref="INreplace08" data-type="indexterm" id="idm45043083078272"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 33: Be Aware of the Optimization Potential of Type Erasure" data-type="sect1"><div class="sect1" id="know_about_the_optimization_potential_of_type_erasure">
<h1>Guideline 33: Be Aware of the Optimization Potential of Type Erasure</h1>
<p>The<a data-primary="Type Erasure design pattern" data-secondary="optimization potential of" data-type="indexterm" id="TEDPoptimiz08"/><a data-primary="optimization" data-see="Type Erasure design pattern" data-type="indexterm" id="idm45043083073952"/> primary focus of this book is software design. Therefore, all this talk about structuring software, about design principles, about tools for managing dependencies and
abstractions, and, of course, all the information on design patterns is at the center of
interest. Still, I’ve mentioned a few times that performance is important. <em>Very</em> important!
After all, C++ is a performance-centric programming language. Therefore, I now make
an exception: this guideline is devoted to performance. Yes, I’m serious: no talk about
dependencies, (almost) no examples for separation of concerns, no value semantics. Just
performance. “Finally, some performance stuff—great!” you cheer. However, be aware of the
consequences: this guideline is pretty heavy on implementation details. And as it is in
C++, mentioning one detail requires you to also deal with two more details, and
so you are pretty quickly sucked into the realm of implementation details. To avoid
that (and to keep my publisher happy), I will not elaborate on every implementation detail
or demonstrate all the alternatives. I will, however, give additional references
that should help you to dig deeper.<sup><a data-type="noteref" href="ch08.xhtml#idm45043083072592" id="idm45043083072592-marker">12</a></sup></p>
<p>In <a data-type="xref" href="#consider_replacing_inheritance_hierarchies_with_type_erasure">“Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure”</a>, you saw great
performance numbers for our basic, unoptimized Type Erasure implementation. However, since
we are now in possession of a value type and a wrapper class, not just a pointer, we have
gained a multitude of opportunities to speed up performance. This is why we will take a look
at two options to improve performance: the SBO and manual
virtual dispatch.</p>
<section data-pdf-bookmark="Small Buffer Optimization" data-type="sect2"><div class="sect2" id="idm45043083070848">
<h2>Small Buffer Optimization</h2>
<p>Let’s<a data-primary="Type Erasure design pattern" data-secondary="optimization potential of" data-tertiary="Small Buffer Optimization (SBO)" data-type="indexterm" id="idm45043083068896"/><a data-primary="Small Buffer Optimization (SBO)" data-type="indexterm" id="smbufpt08"/><a data-primary="SBO (small buffer optimization)" data-type="indexterm" id="SBO08"/> start our quest to speed up the performance of our Type Erasure implementation.
One of the first things that usually comes to mind when talking about performance is
optimizing memory allocations. This is because acquiring and freeing dynamic memory can be
very <em>slooowww</em> and nondeterministic. And for real: optimizing memory allocations can
make all the difference between slow and lightning fast.</p>
<p>However, there is a second reason to look into memory. In
<a data-type="xref" href="#consider_replacing_inheritance_hierarchies_with_type_erasure">“Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure”</a>,
I might have accidentally given you the impression that we need dynamic memory to pull off
Type Erasure. Indeed, one of the initial implementation details in our first <code>Shape</code> class
was the unconditional dynamic memory allocation in the constructor and <code>clone()</code> function,
independent of the size of the given object, so for both small and large objects, we would
always perform a dynamic memory allocation with <code>std::make_unique()</code>. This choice
is limiting, not just because of performance, in particular for small objects, but also
because in certain environments dynamic memory is not available.
Therefore, I should demonstrate to you that there’s a lot you can do with respect
to memory. In fact, you are in full control of memory management! Since you are using a
value type, a wrapper, you can deal with memory in any way you see fit. One of the many
options is to completely rely on in-class memory and emit a compile-time error if objects
are too large. Alternatively, you might switch between in-class and dynamic memory, depending
on the size of the stored object. Both of these are made possible by the SBO.</p>
<p>To give you an idea of how SBO works, let’s take a look at a <code>Shape</code> implementation
that never allocates dynamically but uses only in-class memory:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;array&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Capacity</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">32U</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Alignment</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">alignof</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><a class="co" href="#para_g33_2" id="code_g33_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="n">Concept</code><code class="o">*</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g33_3" id="code_g33_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="k">reinterpret_cast</code><code class="o">&lt;</code><code class="n">Concept</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">buffer_</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Concept</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w">  </code><a class="co" href="#para_g33_4" id="code_g33_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="k">reinterpret_cast</code><code class="o">&lt;</code><code class="n">Concept</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">buffer_</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">alignas</code><code class="p">(</code><code class="n">Alignment</code><code class="p">)</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">array</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">byte</code><code class="p">,</code><code class="n">Capacity</code><code class="o">&gt;</code><code class="w"> </code><code class="n">buffer_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_1" id="code_g33_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>This <code>Shape</code> class does not store <code>std::unique_ptr</code> anymore, but instead owns an array of
properly aligned bytes
(<a class="co" href="#code_g33_1" id="para_g33_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).<sup><a data-type="noteref" href="ch08.xhtml#idm45043082896256" id="idm45043082896256-marker">13</a></sup> To give users of <code>Shape</code> the flexibility to adjust both the capacity
and the alignment of the array, you can provide the two nontype template parameters, <code>Capacity</code>
and <code>Alignment</code>, to the <code>Shape</code> class
(<a class="co" href="#code_g33_2" id="para_g33_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).<sup><a data-type="noteref" href="ch08.xhtml#idm45043082912976" id="idm45043082912976-marker">14</a></sup>
While this improves the flexibility to adjust to different circumstances, the disadvantage
of that approach is that this turns the <code>Shape</code> class into a class template. As a consequence,
all functions that use this abstraction will likely turn into function templates. This may
be undesirable, for instance, because you might have to move code from source files into
header files. However, be aware that this is just one of many possibilities. As stated before,
you are in full control.</p>
<p>To conveniently work with the <code>std::byte</code> array, we add a pair of <code>pimpl()</code>
functions (named based on the fact that this still realizes the Bridge design pattern,
just using in-class memory)
(<a class="co" href="#code_g33_3" id="para_g33_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a> and
<a class="co" href="#code_g33_4" id="para_g33_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>).
“Oh no, a <code>reinterpret_cast</code>!” you say. “Isn’t this super dangerous?” You are
correct; in general, a <code>reinterpret_cast</code> should be considered potentially dangerous.
However, in this particular case, we are backed up by the
<a href="https://oreil.ly/HKWCv">C++ standard</a>, which explains that what
we are doing here is perfectly safe.</p>
<p>As you probably expect by now, we also need to introduce an external inheritance hierarchy
based on the External Polymorphism design pattern. This time we realize this hierarchy
in the <code>private</code> section of the <code>Shape</code> class. Not because this is better or more suited
for this <code>Shape</code> implementation, but for the sole reason to show you another alternative:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Capacity</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">32U</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Alignment</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">alignof</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">Concept</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Concept</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">draw</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">clone</code><code class="p">(</code><code class="w"> </code><code class="n">Concept</code><code class="o">*</code><code class="w"> </code><code class="n">memory</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_5" id="code_g33_5_2"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">move</code><code class="p">(</code><code class="w"> </code><code class="n">Concept</code><code class="o">*</code><code class="w"> </code><code class="n">memory</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_6" id="code_g33_6_2"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">OwningModel</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Concept</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">OwningModel</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">         </code><code class="o">:</code><code class="w"> </code><code class="n">shape_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">         </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">
</code><code class="w">      </code><code class="p">{</code><code class="w">
</code><code class="w">         </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">shape_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="kt">void</code><code class="w"> </code><code class="n">clone</code><code class="p">(</code><code class="w"> </code><code class="n">Concept</code><code class="o">*</code><code class="w"> </code><code class="n">memory</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g33_5" id="code_g33_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="p">{</code><code class="w">
</code><code class="w">         </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">construct_at</code><code class="p">(</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">OwningModel</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">memory</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">         </code><code class="c1">// or:
</code><code class="w">         </code><code class="c1">// auto* ptr =
</code><code class="w">         </code><code class="c1">//    const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(memory));
</code><code class="w">         </code><code class="c1">// ::new (ptr) OwningModel( *this );
</code><code class="w">      </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="kt">void</code><code class="w"> </code><code class="n">move</code><code class="p">(</code><code class="w"> </code><code class="n">Concept</code><code class="o">*</code><code class="w"> </code><code class="n">memory</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g33_6" id="code_g33_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="p">{</code><code class="w">
</code><code class="w">         </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">construct_at</code><code class="p">(</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">OwningModel</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">memory</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="o">*</code><code class="k">this</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">         </code><code class="c1">// or:
</code><code class="w">         </code><code class="c1">// auto* ptr =
</code><code class="w">         </code><code class="c1">//    const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(memory));
</code><code class="w">         </code><code class="c1">// ::new (ptr) OwningModel( std::move(*this) );
</code><code class="w">      </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape_</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="k">alignas</code><code class="p">(</code><code class="n">Alignment</code><code class="p">)</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">array</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">byte</code><code class="p">,</code><code class="n">Capacity</code><code class="o">&gt;</code><code class="w"> </code><code class="n">buffer_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The first interesting detail in this context is the <code>clone()</code> function
(<a class="co" href="#code_g33_5" id="para_g33_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
As <code>clone()</code> carries the responsibility of creating a copy, it needs to be adapted to the
in-class memory. So instead of creating a new <code>Model</code> via <code>std::make_unique()</code>, it creates
a new <code>Model</code> in place via <code>std::construct_at()</code>. Alternatively, you could use a
<a href="https://oreil.ly/6G3bn">placement <code>new</code></a>
to create the copy at the given memory location.<sup><a data-type="noteref" href="ch08.xhtml#idm45043082806592" id="idm45043082806592-marker">15</a></sup></p>
<p>“Wow, wait a second! That’s a pretty tough piece of code to swallow. What’s with all these
casts? Are they really necessary?” I admit, these lines are a little challenging. Therefore,
I should explain them in detail. The good old approach to creating an instance in place is via
placement <code>new</code>. However, using <code>new</code> always carries the danger of someone (inadvertently
or maliciously) providing a replacement for the class-specific <code>new</code> operator. To
avoid any kind of problem and reliably construct an object in place, the given address
is first converted to <code>void const volatile*</code> via a <code>static_cast</code> and then to <code>void*</code>
via a <code>const_cast</code>. The resulting address is passed to the global placement <code>new</code> operator.
Indeed, not the most obvious piece of code. Therefore, it is advisable to use the
C++20 algorithm <code>std::construct_at()</code>: it provides you with exactly the same
functionality but with a significantly nicer syntax.</p>
<p>However, we need one more function: <code>clone()</code> is concerned only with copy operations. It doesn’t apply to move operations. For that reason, we extend the <code>Concept</code> with a pure
virtual <code>move()</code> function and consequently implement it in the 
<span class="keep-together"><code>OwningModel</code></span> class template
(<a class="co" href="#code_g33_6" id="para_g33_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).</p>
<p>“Is this really necessary? We’re using in-class memory, which cannot be <em>moved</em> to another
instance of <code>Shape</code>. What’s the point of that <code>move()</code>?” Well, you are correct that we can’t
move the memory itself from one object to another, but we can still move the shape stored
inside. Thus, the <code>move()</code> function moves an <code>OwningModel</code> from one buffer to another instead
of copying it.</p>
<p>The <code>clone()</code> and <code>move()</code> functions are used in the copy constructor
(<a class="co" href="#code_g33_7" id="para_g33_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>),
the copy assignment operator
(<a class="co" href="#code_g33_8" id="para_g33_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>),
the move constructor
(<a class="co" href="#code_g33_9" id="para_g33_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>),
and the move assignment operator of <code>Shape</code>
(<a class="co" href="#code_g33_10" id="para_g33_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Capacity</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">32U</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Alignment</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">alignof</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="o">-</code><code class="o">&gt;</code><code class="n">clone</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_7" id="code_g33_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="c1">// Copy-and-Swap Idiom
</code><code class="w">      </code><code class="n">Shape</code><code class="w"> </code><code class="nf">copy</code><code class="p">(</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_8" id="code_g33_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="n">buffer_</code><code class="p">.</code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">copy</code><code class="p">.</code><code class="n">buffer_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">noexcept</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="o">-</code><code class="o">&gt;</code><code class="n">move</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_9" id="code_g33_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">noexcept</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="c1">// Copy-and-Swap Idiom
</code><code class="w">      </code><code class="n">Shape</code><code class="w"> </code><code class="nf">copy</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">other</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_10" id="code_g33_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="n">buffer_</code><code class="p">.</code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">copy</code><code class="p">.</code><code class="n">buffer_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="o">~</code><code class="n">Shape</code><code class="p">(</code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g33_11" id="code_g33_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">destroy_at</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="c1">// or: pimpl()-&gt;~Concept();
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="k">alignas</code><code class="p">(</code><code class="n">Alignment</code><code class="p">)</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">array</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">byte</code><code class="p">,</code><code class="n">Capacity</code><code class="o">&gt;</code><code class="w"> </code><code class="n">buffer_</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p class="less_space pagebreak-before">Definitely noteworthy to mention is the destructor of <code>Shape</code>
(<a class="co" href="#code_g33_11" id="para_g33_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>).
Since we manually create an <code>OwningModel</code> within the byte buffer by
<code>std::construct_at()</code> or a placement <code>new</code>, we are also responsible for explicitly calling a
destructor. The easiest and most elegant way of doing that is to use the C++17
algorithm <a href="https://oreil.ly/2FNtm"><code>std::destroy_at()</code></a>.
Alternatively, you can explicitly call the <code>Concept</code> destructor.</p>
<p>The last, but essential, detail of <code>Shape</code> is the templated constructor:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Capacity</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">32U</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Alignment</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">alignof</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">OwningModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="w">      </code><code class="k">static_assert</code><code class="p">(</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">Model</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">Capacity</code><code class="p">,</code><code class="w"> </code><code class="s">"Given type is too large"</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="k">static_assert</code><code class="p">(</code><code class="w"> </code><code class="k">alignof</code><code class="p">(</code><code class="n">Model</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">Alignment</code><code class="p">,</code><code class="w"> </code><code class="s">"Given type is misaligned"</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">construct_at</code><code class="p">(</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">*&gt;</code><code class="p">(</code><code class="n">pimpl</code><code class="p">())</code><code class="w"/>
<code class="w">                       </code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">shape</code><code class="p">),</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// or:</code>
<code class="w">      </code><code class="c1">// auto* ptr =</code>
<code class="w">      </code><code class="c1">//    const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(pimpl()));</code>
<code class="w">      </code><code class="c1">// ::new (ptr) Model( std::move(shape), std::move(drawer) );</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>After a pair of compile-time checks that the required <code>OwningModel</code> fits into the in-class
buffer and adheres to the alignment restrictions, an <code>OwningModel</code> is instantiated into the
in-class buffer by <code>std::construct_at()</code>.</p>
<p>With this implementation in hand, we now adapt and rerun the performance benchmark from
<a data-type="xref" href="#consider_replacing_inheritance_hierarchies_with_type_erasure">“Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure”</a>. We run exactly the same
benchmark, this time without allocating dynamic memory inside <code>Shape</code> and without
fragmenting the memory with many, tiny allocations. As expected, the performance results
are impressive<a data-primary="object-oriented programming (OOP)" data-secondary="Type Erasure design pattern" data-type="indexterm" id="idm45043081806256"/> (see <a data-type="xref" href="#table_type_erasure_sbo_benchmark_results">Table 8-2</a>).</p>
<table class="less_space pagebreak-before" id="table_type_erasure_sbo_benchmark_results">
<caption><span class="label">Table 8-2. </span>Performance results for the Type Erasure implementations with SBO</caption>
<thead>
<tr>
<th>Type Erasure implementation</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Object-oriented solution</p></td>
<td><p>1.5205 s</p></td>
<td><p>1.1480 s</p></td>
</tr>
<tr>
<td><p><code>std::function</code></p></td>
<td><p>2.1782 s</p></td>
<td><p>1.4884 s</p></td>
</tr>
<tr>
<td><p>Manual implementation of <code>std::function</code></p></td>
<td><p>1.6354 s</p></td>
<td><p>1.4465 s</p></td>
</tr>
<tr>
<td><p>Classic Strategy</p></td>
<td><p>1.6372 s</p></td>
<td><p>1.4046 s</p></td>
</tr>
<tr>
<td><p>Type Erasure</p></td>
<td><p>1.5298 s</p></td>
<td><p>1.1561 s</p></td>
</tr>
<tr>
<td><p>Type Erasure (SBO)</p></td>
<td><p>1.3591 s</p></td>
<td><p>1.0348 s</p></td>
</tr>
</tbody>
</table>
<p>“Wow, this is fast. This is…well, let me do the math…amazing, roughly 20% faster
than the fastest Strategy implementation, and even faster than the object-oriented solution.”
It is, indeed. Very impressive, right? Still, you should remember that these are the numbers
that I got on my system. Your numbers will be different, almost certainly. But even though
your numbers might not be the same, the general takeaway is that there is a lot of potential
to optimize performance by dealing with memory 
<span class="keep-together">allocations.</span></p>
<p>However, while the performance is extraordinary, we’ve lost a lot of flexibility: only
<code>OwningModel</code> instantiations that are smaller or equal to the specified <code>Capacity</code> can be
stored inside <code>Shape</code>. Bigger models are excluded. This brings me back to the idea that we
could switch between in-class and dynamic memory depending on the size of the given shape:
small shapes are stored inside an in-class buffer, while large shapes are allocated dynamically.
You could now go ahead and update the implementation of <code>Shape</code> to use both kinds of
memory. However, at this point it’s probably a good idea to point out one of our most
important design principles again: separation of concerns. Instead of squeezing all logic
and functionality into the <code>Shape</code> class, it would be easier and (much) more flexible to
separate the implementation details and implement <code>Shape</code> with policy-based design
(see <a data-type="xref" href="ch05.xhtml#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a>):</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">StoragePolicy</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="p">;</code><code class="w"/></pre>
<p>The <code>Shape</code> class template is rewritten to accept a <code>StoragePolicy</code>. Via this policy, you
would be able to specify from outside how the class should acquire memory. And of course,
you would perfectly adhere to SRP and OCP. One such storage policy could be the
<code>DynamicStorage</code> policy class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">DynamicStorage</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="p">...</code><code class="w"> </code><code class="n">Args</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="w">   </code><code class="n">T</code><code class="o">*</code><code class="w"> </code><code class="n">create</code><code class="p">(</code><code class="w"> </code><code class="n">Args</code><code class="o">&amp;&amp;</code><code class="p">...</code><code class="w"> </code><code class="n">args</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">T</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">forward</code><code class="o">&lt;</code><code class="n">Args</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">args</code><code class="w"> </code><code class="p">)...</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">destroy</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="o">*</code><code class="w"> </code><code class="n">ptr</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">noexcept</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">delete</code><code class="w"> </code><code class="n">ptr</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>As the name suggests, <code>DynamicPolicy</code> would acquire memory dynamically, for instance via
<code>new</code>. Alternatively, if you have stronger requirements, you could build on
<a href="https://oreil.ly/oIP3K"><code>std::aligned_alloc()</code></a> or
similar functionality to provide dynamic memory with a specified alignment. Similarly to
<code>DynamicStorage</code>, you could provide an <code>InClass​Stor⁠age</code> policy:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;array&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstddef&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Capacity</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">Alignment</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">InClassStorage</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="p">...</code><code class="w"> </code><code class="n">Args</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="w">   </code><code class="n">T</code><code class="o">*</code><code class="w"> </code><code class="n">create</code><code class="p">(</code><code class="w"> </code><code class="n">Args</code><code class="o">&amp;&amp;</code><code class="p">...</code><code class="w"> </code><code class="n">args</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">static_assert</code><code class="p">(</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">T</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">Capacity</code><code class="p">,</code><code class="w"> </code><code class="s">"The given type is too large"</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="k">static_assert</code><code class="p">(</code><code class="w"> </code><code class="k">alignof</code><code class="p">(</code><code class="n">T</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">Alignment</code><code class="p">,</code><code class="w"> </code><code class="s">"The given type is misaligned"</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">      </code><code class="n">T</code><code class="o">*</code><code class="w"> </code><code class="n">memory</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">const_cast</code><code class="o">&lt;</code><code class="n">T</code><code class="o">*&gt;</code><code class="p">(</code><code class="k">reinterpret_cast</code><code class="o">&lt;</code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">*&gt;</code><code class="p">(</code><code class="n">buffer_</code><code class="p">.</code><code class="n">data</code><code class="p">()));</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">construct_at</code><code class="p">(</code><code class="w"> </code><code class="n">memory</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">forward</code><code class="o">&lt;</code><code class="n">Args</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">args</code><code class="w"> </code><code class="p">)...</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">      </code><code class="c1">// or:</code>
<code class="w">      </code><code class="c1">// void* const memory = static_cast&lt;void*&gt;(buffer_.data());</code>
<code class="w">      </code><code class="c1">// return ::new (memory) T( std::forward&lt;Args&gt;( args )... );</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">destroy</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="o">*</code><code class="w"> </code><code class="n">ptr</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">noexcept</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">destroy_at</code><code class="p">(</code><code class="n">ptr</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// or: ptr-&gt;~T();</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">alignas</code><code class="p">(</code><code class="n">Alignment</code><code class="p">)</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">array</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">byte</code><code class="p">,</code><code class="n">Capacity</code><code class="o">&gt;</code><code class="w"> </code><code class="n">buffer_</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>All of these policy classes provide the same interface: a <code>create()</code> function to instantiate
an object of type <code>T</code> and a <code>destroy()</code> function to do whatever is necessary to clean up.
This interface is used by the <code>Shape</code> class to trigger construction and destruction, for
instance, in its templated constructor
(<a class="co" href="#code_g33_12" id="para_g33_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>)<sup><a data-type="noteref" href="ch08.xhtml#idm45043081309312" id="idm45043081309312-marker">16</a></sup> and in the destructor
(<a class="co" href="#code_g33_13" id="para_g33_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">StoragePolicy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">OwningModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">pimpl_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">policy_</code><code class="p">.</code><code class="k">template</code><code class="w"> </code><code class="n">create</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g33_12" id="code_g33_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="o">~</code><code class="n">Shape</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">policy_</code><code class="p">.</code><code class="n">destroy</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g33_13" id="code_g33_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... All other member functions, in particular the
</code><code class="w">   </code><code class="c1">//     special members functions, are not shown
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="p">[</code><code class="p">[</code><code class="n">no_unique_address</code><code class="p">]</code><code class="p">]</code><code class="w"> </code><code class="n">StoragePolicy</code><code class="w"> </code><code class="n">policy_</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_14" id="code_g33_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">Concept</code><code class="o">*</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The last detail that should not be left unnoticed is the data members
(<a class="co" href="#code_g33_14" id="para_g33_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>):
the <code>Shape</code> class now stores an instance of the given <code>StoragePolicy</code> and, do not be alarmed,
a <em>raw</em> pointer to its <code>Concept</code>. Indeed, there is no need to store <code>std::unique_ptr</code> anymore,
since we are manually destroying the object in our own destructor again. You might also notice
the <a href="https://oreil.ly/5gF5n"><code>[[no_unique_address]]</code> attribute</a> on the storage policy. This 
<span class="keep-together">C++20</span> feature gives you the opportunity to save
the memory for the storage policy. If the policy is empty, the compiler is now allowed to
not reserve any memory for the data member. Without this attribute, it would be necessary to
reserve at least a single byte for <code>policy_</code>, but likely more bytes due to alignment restrictions.</p>
<p>In summary, SBO is an effective and one of the most interesting optimizations for
a Type Erasure implementation. For that reason, many standard types, such as <code>std::function</code>
and <code>std::any</code>, use some form of SBO. Unfortunately, the C++ Standard Library
specification doesn’t <em>require</em> the use of SBO. This is why you can only hope that
SBO is used; you can’t count on it. However, because performance is so important and
because SBO plays such a decisive role, there are already proposals out there that
also suggest standardizing the types <code>inplace_function</code> and <code>inplace_any</code>. Time will
tell if these find their way into the Standard Library.<a data-primary="" data-startref="smbufpt08" data-type="indexterm" id="idm45043081107936"/><a data-primary="" data-startref="SBO08" data-type="indexterm" id="idm45043081106960"/></p>
</div></section>
<section data-pdf-bookmark="Manual Implementation of Function Dispatch" data-type="sect2"><div class="sect2" id="idm45043081105760">
<h2>Manual Implementation of Function Dispatch</h2>
<p>“Wow, this<a data-primary="Type Erasure design pattern" data-secondary="optimization potential of" data-tertiary="manual implementation of function dispatch" data-type="indexterm" id="idm45043081042688"/><a data-primary="function dispatch, manual implementation of" data-type="indexterm" id="fundisman08"/> will prove useful. Is there anything else I can do to improve the performance
of my Type Erasure implementation?” you ask. Oh yes, you can do more. There is a
second potential performance optimization. This time we try to improve the performance of
the virtual functions. And yes, I’m talking about the virtual functions that are
introduced by the external inheritance hierarchy, i.e., by the External
Polymorphism design pattern.</p>
<p>“How should we be able to optimize the performance of virtual functions? Isn’t this
something that is completely up to the compiler?” Absolutely, you’re correct. However,
I am not talking about fiddling with backend, compiler-specific implementation details,
but about replacing the virtual functions with something more efficient. And that is
indeed possible. Remember that a virtual function is nothing but a function pointer
that is stored inside a virtual function table. Every type with at least one virtual
function has such a virtual function table. However, there is only one virtual function
table for each type. In other words, this table is not stored inside every instance. So
in order to connect the virtual function table with every instance of that type, the class
stores an additional, hidden data member, which we commonly call the <code>vptr</code> and which is
a raw pointer to the virtual function table.</p>
<p>When you call a virtual function, you first go through the <code>vptr</code> to fetch the virtual
function table. Once you’re there, you can grab the corresponding function pointer from the
virtual function table and call it. Therefore, in total, a virtual function call entails
two indirections: the <code>vptr</code> and the pointer to the actual function. For
that 
<span class="keep-together">reason,</span> roughly speaking, a virtual function call is twice as expensive as a regular,

<span class="keep-together">noninline</span> function call.</p>
<p>These two indirections provide us with the opportunity for optimization: we can in fact
reduce the number of indirections to just one. To achieve that, we will employ an
optimization strategy that works fairly often: we’ll trade space for speed. What we will do
is implement the virtual dispatch manually by storing the virtual function pointers
inside the <code>Shape</code> class. The following code snippet already gives you a pretty good idea
of the details:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstddef&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">           </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">OwningModel</code><code class="w">  </code><a class="co" href="#para_g33_15" id="code_g33_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">OwningModel</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">value</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">         </code><code class="o">:</code><code class="w"> </code><code class="n">shape_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">         </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape_</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer_</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">DestroyOperation</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">void</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="p">;</code><code class="w">   </code><a class="co" href="#para_g33_16" id="code_g33_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">DrawOperation</code><code class="w">    </code><code class="o">=</code><code class="w"> </code><code class="kt">void</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="p">;</code><code class="w">   </code><a class="co" href="#para_g33_17" id="code_g33_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">CloneOperation</code><code class="w">   </code><code class="o">=</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_18" id="code_g33_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="kt">void</code><code class="p">,</code><code class="n">DestroyOperation</code><code class="o">*</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_19" id="code_g33_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">DrawOperation</code><code class="o">*</code><code class="w">  </code><code class="n">draw_</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">nullptr</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">               </code><a class="co" href="#para_g33_20" id="code_g33_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">CloneOperation</code><code class="o">*</code><code class="w"> </code><code class="n">clone_</code><code class="p">{</code><code class="w"> </code><code class="k">nullptr</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">               </code><a class="co" href="#para_g33_21" id="code_g33_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Since we are replacing <em>all</em> virtual functions, even the virtual destructor, there’s no need
for a <code>Concept</code> base class anymore. Consequently, the external hierarchy is reduced to just
the <code>OwningModel</code> class template
(<a class="co" href="#code_g33_15" id="para_g33_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>),
which still acts as storage for a specific kind of shape (<code>ShapeT</code>) and <code>DrawStrategy</code>.
Still, it meets the same fate: all virtual functions are removed. The only remaining details
are the constructor and the data members.</p>
<p>The virtual functions are replaced by manual function pointers. Since the syntax for function
pointers is not the most pleasant to use, we add a couple of
function type aliases for our convenience:<sup><a data-type="noteref" href="ch08.xhtml#idm45043080813136" id="idm45043080813136-marker">17</a></sup>
<code>DestroyOperation</code> represents the former virtual destructor
(<a class="co" href="#code_g33_16" id="para_g33_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>),
<code>DrawOperation</code> represents the former virtual <code>draw()</code> function
(<a class="co" href="#code_g33_17" id="para_g33_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>), and
<code>CloneOperation</code> represents the former virtual <code>clone()</code> function
(<a class="co" href="#code_g33_18" id="para_g33_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>).
<code>Destroy​Operation</code> is used to configure the <code>Deleter</code> of the <code>pimpl_</code> data member
(<a class="co" href="#code_g33_19" id="para_g33_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a>)
(and yes, as such it acts as a Strategy). The latter two, <code>DrawOperation</code> and
<code>CloneOperation</code>, are used for the two additional function pointer data members, <code>draw_</code>
and <code>clone_</code>
(<a class="co" href="#code_g33_20" id="para_g33_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a> and
<a class="co" href="#code_g33_21" id="para_g33_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a>).</p>
<p>“Oh no, <code>void*</code>s! Isn’t that an archaic and super dangerous way of doing things?” you
gasp. OK, I admit that without explanation it looks <em>very</em> suspicious. However, stay with me,
I promise that everything will be perfectly fine and type safe. The key to making this work
now lies in the initialization of these function pointers. They are initialized in the
templated constructor of the <code>Shape</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">           </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">(</code><code class="w">   </code><a class="co" href="#para_g33_22" id="code_g33_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a><code class="w">
</code><code class="w">            </code><code class="k">new</code><code class="w"> </code><code class="n">OwningModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w">
</code><code class="w">                                                </code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">move</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">          </code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">shapeBytes</code><code class="w"> </code><code class="p">)</code><code class="p">{</code><code class="w">  </code><a class="co" href="#para_g33_23" id="code_g33_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a><code class="w">
</code><code class="w">               </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">OwningModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">               </code><code class="k">auto</code><code class="o">*</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">shapeBytes</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_24" id="code_g33_24"><img alt="24" height="12" src="assets/24.png" width="12"/></a><code class="w">
</code><code class="w">               </code><code class="k">delete</code><code class="w"> </code><code class="n">model</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g33_25" id="code_g33_25"><img alt="25" height="12" src="assets/25.png" width="12"/></a><code class="w">
</code><code class="w">            </code><code class="p">}</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">draw_</code><code class="p">(</code><code class="w">  </code><a class="co" href="#para_g33_26" id="code_g33_26"><img alt="26" height="12" src="assets/26.png" width="12"/></a><code class="w">
</code><code class="w">            </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">shapeBytes</code><code class="w"> </code><code class="p">)</code><code class="p">{</code><code class="w">
</code><code class="w">               </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">OwningModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">               </code><code class="k">auto</code><code class="o">*</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">shapeBytes</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">               </code><code class="p">(</code><code class="o">*</code><code class="n">model</code><code class="o">-</code><code class="o">&gt;</code><code class="n">drawer_</code><code class="p">)</code><code class="p">(</code><code class="w"> </code><code class="n">model</code><code class="o">-</code><code class="o">&gt;</code><code class="n">shape_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">            </code><code class="p">}</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">clone_</code><code class="p">(</code><code class="w">  </code><a class="co" href="#para_g33_27" id="code_g33_27"><img alt="1" height="12" src="assets/27.png" width="12"/></a><code class="w">
</code><code class="w">            </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">shapeBytes</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">-</code><code class="o">&gt;</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">               </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">OwningModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">               </code><code class="k">auto</code><code class="o">*</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">shapeBytes</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">               </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Model</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="n">model</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">            </code><code class="p">}</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Let’s focus on the <code>pimpl_</code> data member. It is initialized both by a pointer
to the newly instantiated <code>OwningModel</code>
(<a class="co" href="#code_g33_22" id="para_g33_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a>)
and by a stateless lambda expression
(<a class="co" href="#code_g33_23" id="para_g33_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a>).
You may remember that a stateless lambda is implicitly convertible to a function pointer.
This language guarantee is what we use to our advantage: we directly pass the lambda as the
deleter to the constructor of <code>unique_ptr</code>, force the compiler to apply the implicit conversion
to a <code>DestroyOperation*</code>, and thus bind the lambda function to the <code>std::unique_ptr</code>.</p>
<p>“OK, I get the point: the lambda can be used to initialize the function pointer. But how does
it work? What does it do?” Well, also remember that we are creating this lambda inside the
templated constructor. That means that at this point we are fully aware of the actual type
of the passed <code>ShapeT</code> and <code>DrawStrategy</code>. Thus, the lambda is generated with the
knowledge of which type of <code>OwningModel</code> is instantiated and stored inside the <code>pimpl_</code>.
Eventually it will be called with a <code>void*</code>, i.e., by the address of some <code>OwningModel</code>.
However, based on its knowledge about the actual type of 
<span class="keep-together"><code>OwningModel</code></span>, it can first of all
perform a <code>static_cast</code> from <code>void*</code> to 
<span class="keep-together"><code>OwningModel&lt;ShapeT,DrawStrategy&gt;*</code></span>
(<a class="co" href="#code_g33_24" id="para_g33_24"><img alt="24" height="12" src="assets/24.png" width="12"/></a>).
While in most other contexts this kind of cast would be suspicious and would likely be a wild
guess, in this context it is perfectly type safe: we can be certain about the correct type
of <code>OwningModel</code>. Therefore, we can use the resulting pointer to trigger the correct
cleanup behavior
(<a class="co" href="#code_g33_25" id="para_g33_25"><img alt="25" height="12" src="assets/25.png" width="12"/></a>).</p>
<p>The initialization of the <code>draw_</code> and <code>clone_</code> data members is very similar
(<a class="co" href="#code_g33_26" id="para_g33_26"><img alt="26" height="12" src="assets/26.png" width="12"/></a> and
<a class="co" href="#code_g33_27" id="para_g33_27"><img alt="27" height="12" src="assets/27.png" width="12"/></a>).
The only difference is, of course, the action performed by the lambdas: they perform the
correct actions to draw the shape and to create a copy of the model, respectively.</p>
<p>I know, this may take some time to digest. But we are almost done; the only missing detail
is the special member functions. For the destructor and the two move operations, we can again
ask for the compiler-generated default. However, we have to deal with the copy constructor
and copy assignment operator ourselves:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Shape.h&gt; ----------------</code>

<code class="c1">// ...</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">(</code><code class="w"> </code><code class="n">clone_</code><code class="p">(</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="p">.</code><code class="n">get</code><code class="p">()</code><code class="w"> </code><code class="p">),</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="p">.</code><code class="n">get_deleter</code><code class="p">()</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">draw_</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">draw_</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">clone_</code><code class="p">(</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">clone_</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// Copy-and-Swap Idiom</code>
<code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">swap</code><code class="p">;</code><code class="w"/>
<code class="w">      </code><code class="n">Shape</code><code class="w"> </code><code class="nf">copy</code><code class="p">(</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">,</code><code class="w"> </code><code class="n">copy</code><code class="p">.</code><code class="n">pimpl_</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">draw_</code><code class="p">,</code><code class="w"> </code><code class="n">copy</code><code class="p">.</code><code class="n">draw_</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">clone_</code><code class="p">,</code><code class="w"> </code><code class="n">copy</code><code class="p">.</code><code class="n">clone_</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="o">~</code><code class="n">Shape</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>This is all we need to do, and we’re ready to try this out. So let’s put this implementation
to the test. Once again we update the benchmark from
<a data-type="xref" href="#consider_replacing_inheritance_hierarchies_with_type_erasure">“Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure”</a> and run it with our manual
implementation of virtual functions. I have even combined the manual virtual dispatch with
the previously discussed SBO.
<a data-type="xref" href="#table_type_erasure_vd_benchmark_results">Table 8-3</a> shows the<a data-primary="object-oriented programming (OOP)" data-secondary="Type Erasure design pattern" data-type="indexterm" id="idm45043080040384"/> performance results.</p>
<table id="table_type_erasure_vd_benchmark_results">
<caption><span class="label">Table 8-3. </span>Performance results for the Type Erasure implementations with manual virtual dispatch</caption>
<thead>
<tr>
<th>Type Erasure implementation</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Object-oriented solution</p></td>
<td><p>1.5205 s</p></td>
<td><p>1.1480 s</p></td>
</tr>
<tr>
<td><p><code>std::function</code></p></td>
<td><p>2.1782 s</p></td>
<td><p>1.4884 s</p></td>
</tr>
<tr>
<td><p>Manual implementation of <code>std::function</code></p></td>
<td><p>1.6354 s</p></td>
<td><p>1.4465 s</p></td>
</tr>
<tr>
<td><p>Classic Strategy</p></td>
<td><p>1.6372 s</p></td>
<td><p>1.4046 s</p></td>
</tr>
<tr>
<td><p>Type Erasure</p></td>
<td><p>1.5298 s</p></td>
<td><p>1.1561 s</p></td>
</tr>
<tr>
<td><p>Type Erasure (SBO)</p></td>
<td><p>1.3591 s</p></td>
<td><p>1.0348 s</p></td>
</tr>
<tr>
<td><p>Type Erasure (manual virtual dispatch)</p></td>
<td><p>1.1476 s</p></td>
<td><p>1.1599 s</p></td>
</tr>
<tr>
<td><p>Type Erasure (SBO + manual virtual dispatch)</p></td>
<td><p>1.2538 s</p></td>
<td><p>1.2212 s</p></td>
</tr>
</tbody>
</table>
<p>The performance improvement for the manual virtual dispatch is extraordinary for GCC. On
my system, I get down to 1.1476 seconds, which is an improvement of 25% in comparison to
the based, unoptimized implementation of Type Erasure. Clang, on the other hand, does
not show any improvement in comparison to the basic, unoptimized implementation. Although
this may be a little disappointing, the runtime is, of course, still remarkable.</p>
<p>Unfortunately the combination of SBO and manual virtual dispatch does not lead to an even
better performance. While GCC shows a small improvement in comparison to the pure SBO
approach (which might be interesting for environments without dynamic memory), on Clang
this combination does not work as well as you might have hoped for.</p>
<p>In summary, there is a lot of potential for optimizing the performance for Type Erasure
implementations. If you’ve been skeptical before about Type Erasure, this gain in
performance should give you a strong incentive to investigate for yourself. While this
is amazing and without doubt is pretty exciting, it is important to remember
where this is coming from: only due to separating the concerns of virtual behavior and encapsulating the behavior into a value type have we gained these optimization
opportunities. We wouldn’t have been able to achieve this if all we had was a
pointer-to-base.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043080023616">
<h5>Guideline 33: Be Aware of the Optimization Potential of Type Erasure</h5>
<ul>
<li>
<p>Use SBO to avoid expensive copy operations for small objects.</p>
</li>
<li>
<p>Reduce the number of indirections by implementing virtual dispatch manually.<a data-primary="" data-startref="fundisman08" data-type="indexterm" id="idm45043080021168"/><a data-primary="" data-startref="TEDPoptimiz08" data-type="indexterm" id="idm45043080020192"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 34: Be Aware of the Setup Costs of Owning &#10;Type Erasure Wrappers" data-type="sect1"><div class="sect1" id="be_aware_of_the_setup_costs_of_owning_type_erasure_wrappers">
<h1>Guideline 34: Be Aware of the Setup Costs of Owning 
<span class="keep-together">Type Erasure Wrappers</span></h1>
<p>In<a data-primary="Type Erasure design pattern" data-secondary="setup costs" data-type="indexterm" id="TEDPsetup08"/> <a data-type="xref" href="#consider_replacing_inheritance_hierarchies_with_type_erasure">“Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure”</a> and
<a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>, I guided you through the
thicket of implementation details for a basic Type Erasure implementation. Yes, that
was tough, but definitely worth the effort: you have emerged stronger, wiser, and with a new,
efficient, and strongly decoupling design pattern in your toolbox. Great!</p>
<p>However, we have to go back into the thicket. I see you are rolling your eyes, but
there is more. And I have to admit: I lied. At least a little. Not by telling you
something incorrect, but by omission. There is one more disadvantage of Type Erasure
that you should know of. A big one. One that you might not like at all. <em>Sigh</em>.</p>
<section data-pdf-bookmark="The Setup Costs of an Owning Type Erasure Wrapper" data-type="sect2"><div class="sect2" id="idm45043080013104">
<h2>The Setup Costs of an Owning Type Erasure Wrapper</h2>
<p>Assume<a data-primary="Type Erasure design pattern" data-secondary="setup costs" data-tertiary="of owning Type Erasure wrappers" data-tertiary-sortas="owning Type Erasure wrappers" data-type="indexterm" id="idm45043080010880"/> for a second that <code>Shape</code> is a base class again, and <code>Circle</code> one of many deriving
classes. Then passing a <code>Circle</code> to a function expecting a <code>Shape const&amp;</code> would be easy and
cheap (<a class="co" href="#code_g34_1" id="para_g34_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><code class="c1">// Classic base class
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><code class="c1">// Deriving class
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">useShape</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">shape</code><code class="p">.</code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">Circle</code><code class="w"> </code><code class="n">circle</code><code class="p">{</code><code class="w"> </code><code class="mf">3.14</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Automatic and cheap conversion from 'Circle const&amp;' to 'Shape const&amp;'
</code><code class="w">   </code><code class="n">useShape</code><code class="p">(</code><code class="w"> </code><code class="n">circle</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_1" id="code_g34_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>Although the Type Erasure <code>Shape</code> abstraction is a little different (for instance,
it always requires a drawing Strategy), this kind of conversion is still possible:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><code class="c1">// Nonpolymorphic geometric primitive
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><code class="c1">// Type erasure wrapper class as shown before
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">useShape</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">draw</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">Circle</code><code class="w"> </code><code class="n">circle</code><code class="p">{</code><code class="w"> </code><code class="mf">3.14</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">drawStrategy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="p">)</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Creates a temporary 'Shape' object, involving
</code><code class="w">   </code><code class="c1">//   a copy operation and a memory allocation
</code><code class="w">   </code><code class="n">useShape</code><code class="p">(</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="n">drawStrategy</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_2" id="code_g34_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>Unfortunately, it is no longer cheap. On the contrary, based on our previous implementations,
which include both the basic one and optimized ones, the call to the <code>useShape()</code>
function would involve a couple of potentially expensive operations
(<a class="co" href="#code_g34_2" id="para_g34_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>):</p>
<ul>
<li>
<p>To convert a <code>Circle</code> into a <code>Shape</code>, the compiler creates a temporary <code>Shape</code>
using the non-<code>explicit</code>, templated <code>Shape</code> constructor.</p>
</li>
<li>
<p>The call of the constructor results in a copy operation of the given shape
(not expensive for <code>Circle</code>, but potentially expensive for other shapes) and the
given draw Strategy (essentially free if the Strategy is stateless, but
potentially expensive, depending on what is stored inside the object).</p>
</li>
<li>
<p>Inside the <code>Shape</code> constructor, a <code>new</code> shape model is created, involving a
memory allocation (hidden in the call to <code>std::make_unique()</code> in the <code>Shape</code>
constructor and definitely expensive).</p>
</li>
<li>
<p>The temporary (rvalue) <code>Shape</code> is passed by reference-to-<code>const</code> to the
<code>useShape()</code> function.</p>
</li>
</ul>
<p>It is important to point out that this is not a specific problem of our <code>Shape</code>
implementation. The same problem will hit you if, for instance, you use <code>std::function</code>
as a function argument:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;functional&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">compute</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">j</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">function</code><code class="o">&lt;</code><code class="kt">int</code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="kt">int</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="n">op</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">op</code><code class="p">(</code><code class="w"> </code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="n">j</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">17</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">j</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">compute</code><code class="p">(</code><code class="w"> </code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="n">j</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="n">offset</code><code class="o">=</code><code class="mi">15</code><code class="p">](</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">offset</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In this example, the given lambda is converted into the <code>std::function</code> instance. This
conversion will involve a copy operation and might involve a memory allocation. It entirely
depends on the size of the given callable and on the implementation of <code>std::function</code>.
For that reason, <code>std::function</code> is a different kind of abstraction than, for instance,
<code>std::string_view</code> and <code>std::span</code>. <code>std::string_view</code> and <code>std::span</code> are nonowning
abstractions that are cheap to copy because they consist of only a pointer to the
first element and a size. Because these two types perform a shallow copy, they are
perfectly suited as function parameters. <code>std::function</code>, on the other hand, is an
owning abstraction that performs a deep copy. Therefore, it is not the perfect type
to be used as a function parameter. Unfortunately, the same is true for our <code>Shape</code>
implementation.<sup><a data-type="noteref" href="ch08.xhtml#idm45043079519664" id="idm45043079519664-marker">18</a></sup></p>
<p>“Oh my, I don’t like this. Not at all. That is terrible! I want my money back!” you
exclaim. I have to agree that this may be a severe issue in your codebase. However, you
understand that the underlying problem is the owning semantics of the <code>Shape</code> class: on
the basis of its value semantics background, our current <code>Shape</code>
<span class="keep-together">implementation</span> will always
create a copy of the given shape and will always own the copy. While this is perfectly in
line with all the benefits discussed in <a data-type="xref" href="ch05.xhtml#prefer_value_semantics_to_reference_semantics">“Guideline 22: Prefer Value Semantics over 
<span class="keep-together">Reference Semantics</span>”</a>,
in this context it results in a pretty unfortunate performance penalty. However, stay calm—there is something we can do: for such a context, we can provide a nonowning Type Erasure
implementation.</p>
</div></section>
<section data-pdf-bookmark="A Simple Nonowning Type Erasure Implementation" data-type="sect2"><div class="sect2" id="idm45043080012448">
<h2>A Simple Nonowning Type Erasure Implementation</h2>
<p>Generally<a data-primary="Type Erasure design pattern" data-secondary="setup costs" data-tertiary="simple nonowning  Type Erasure implementation" data-type="indexterm" id="idm45043079513328"/> speaking, the value semantics–based Type Erasure implementation is beautiful
and perfectly adheres to the spirit of modern C++. However, performance is
important. It might be so important that sometimes you might not care about the value
semantics part, but only about the abstraction provided by Type Erasure. In that case,
you might want to reach for a nonowning implementation of Type Erasure, despite the
disadvantage that this pulls you back into the realm of reference 
<span class="keep-together">semantics</span>.</p>
<p>The good news is that if you desire only a simple Type Erasure wrapper, a wrapper
that represents a reference-to-base, that is nonowning and trivially copyable, then the
required code is fairly simple. That is particularly true because you have already
seen how to manually implement the virtual dispatch in
<a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>. With this technique, a simple,
nonowning Type Erasure implementation is just a matter of a few lines of code:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConstRef</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeConstRef</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="o">&amp;</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g34_6" id="code_g34_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">shape_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">addressof</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">addressof</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">draw_</code><code class="p">{</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">shapeBytes</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">drawerBytes</code><code class="w"> </code><code class="p">)</code><code class="p">{</code><code class="w">
</code><code class="w">           </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">shapeBytes</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">           </code><code class="k">auto</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">DrawStrategy</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">drawerBytes</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">           </code><code class="p">(</code><code class="o">*</code><code class="n">drawer</code><code class="p">)</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConstRef</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">shape</code><code class="p">.</code><code class="n">draw_</code><code class="p">(</code><code class="w"> </code><code class="n">shape</code><code class="p">.</code><code class="n">shape_</code><code class="p">,</code><code class="w"> </code><code class="n">shape</code><code class="p">.</code><code class="n">drawer_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">DrawOperation</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">void</code><code class="p">(</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="p">,</code><code class="kt">void</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">shape_</code><code class="p">{</code><code class="w"> </code><code class="k">nullptr</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">    </code><a class="co" href="#para_g34_3" id="code_g34_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">drawer_</code><code class="p">{</code><code class="w"> </code><code class="k">nullptr</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">   </code><a class="co" href="#para_g34_4" id="code_g34_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">DrawOperation</code><code class="o">*</code><code class="w"> </code><code class="n">draw_</code><code class="p">{</code><code class="w"> </code><code class="k">nullptr</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_5" id="code_g34_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>As the name suggests, the <code>ShapeConstRef</code> class represents a reference to a <code>const</code>
shape type. Instead of storing a copy of the given shape, it only holds a pointer to it
in the form of a <code>void*</code>
(<a class="co" href="#code_g34_3" id="para_g34_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>).
In addition, it holds a <code>void*</code> to the associated <code>DrawStrategy</code>
(<a class="co" href="#code_g34_4" id="para_g34_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>),
and as the third data member, a function pointer to the manually implemented virtual
<code>draw()</code> function
(<a class="co" href="#code_g34_5" id="para_g34_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>)
(see <a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>).</p>
<p><code>ShapeConstRef</code> takes its two arguments, the shape and the drawing Strategy, both
possibly cv qualified, by reference-to-non-<code>const</code>
(<a class="co" href="#code_g34_6" id="para_g34_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).<sup><a data-type="noteref" href="ch08.xhtml#idm45043079442800" id="idm45043079442800-marker">19</a></sup> In this form, it is not possible to pass rvalues to the constructor,
which prevents any kind of lifetime issue with temporary values. This unfortunately does
not protect you from all possible lifetime issues with lvalues but still provides a very
reasonable protection.<sup><a data-type="noteref" href="ch08.xhtml#idm45043079319984" id="idm45043079319984-marker">20</a></sup> If you want to allow rvalues, you
should reconsider. And if you’re really, <em>really</em> willing to risk lifetime issues
with temporaries, then you can simply take the argument(s) by reference-to-<code>const</code>.
Just remember that you did not get this advice from me!</p>
<p>This is it. This is the complete nonowning implementation. It is efficient, short,
simple, and can be even shorter and simpler if you do not need to store any kind of
associated data or Strategy object.
With this functionality in place, you are now able to create cheap shape abstractions.
This is demonstrated in the following code example by the <code>useShapeConstRef()</code>
function. This function enables you to draw any kind of shape (<code>Circle</code>s, <code>Square</code>s, etc.)
with any possible drawing implementation by simply using a <code>ShapeConstRef</code> as the function argument.
In the <code>main()</code> function, we call <code>useShapeConstRef()</code> by a concrete shape and a
concrete drawing Strategy (in this case, a lambda)
(<a class="co" href="#code_g34_7" id="para_g34_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Main.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Circle.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">useShapeConstRef</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConstRef</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a circle as one representative of a concrete shape type
</code><code class="w">   </code><code class="n">Circle</code><code class="w"> </code><code class="n">circle</code><code class="p">{</code><code class="w"> </code><code class="mf">3.14</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a drawing strategy in the form of a lambda
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="p">)</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Draw the circle directly via the 'ShapeConstRef' abstraction
</code><code class="w">   </code><code class="n">useShapeConstRef</code><code class="p">(</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_7" id="code_g34_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>This call triggers the desired effect, notably without any memory allocation or expensive
copy operation, but only by wrapping polymorphic behavior around a set of pointers to the
given shape and drawing Strategy.</p>
</div></section>
<section data-pdf-bookmark="A More Powerful Nonowning Type Erasure Implementation" data-type="sect2"><div class="sect2" id="idm45043078984208">
<h2>A More Powerful Nonowning Type Erasure Implementation</h2>
<p>Most<a data-primary="Type Erasure design pattern" data-secondary="setup costs" data-tertiary="powerful nonowning Type Erasure implementation" data-type="indexterm" id="idm45043078982384"/> of the time, this simple nonowning Type Erasure implementation should prove to be
enough and fulfill all your needs. Sometimes, however, and only sometimes, it might not be
enough. Sometimes, you might be interested in a slightly different form of <code>Shape</code> reference:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Cirlce.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Shape.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a circle as one representative of a concrete shape type
</code><code class="w">   </code><code class="n">Circle</code><code class="w"> </code><code class="n">circle</code><code class="p">{</code><code class="w"> </code><code class="mf">3.14</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a drawing strategy in the form of a lambda
</code><code class="w">   </code><code class="k">auto</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="p">)</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Combine the shape and the drawing strategy in a 'Shape' abstraction
</code><code class="w">   </code><code class="n">Shape</code><code class="w"> </code><code class="n">shape1</code><code class="p">(</code><code class="w"> </code><code class="n">circle</code><code class="p">,</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Draw the shape
</code><code class="w">   </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">shape1</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a reference to the shape
</code><code class="w">   </code><code class="c1">// Works already, but the shape reference will store a pointer
</code><code class="w">   </code><code class="c1">// to the 'shape1' instance instead of a pointer to the 'circle'.
</code><code class="w">   </code><code class="n">ShapeConstRef</code><code class="w"> </code><code class="n">shaperef</code><code class="p">(</code><code class="w"> </code><code class="n">shape1</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_8" id="code_g34_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Draw via the shape reference, resulting in the same output
</code><code class="w">   </code><code class="c1">// This works, but only by means of two indirections!
</code><code class="w">   </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">shaperef</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_9" id="code_g34_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Create a deep copy of the shape via the shape reference
</code><code class="w">   </code><code class="c1">// This is _not_ possible with the simple nonowning implementation!
</code><code class="w">   </code><code class="c1">// With the simple implementation, this creates a copy of the 'shaperef'
</code><code class="w">   </code><code class="c1">// instance. 'shape2' itself would act as a reference and there would be
</code><code class="w">   </code><code class="c1">// three indirections... sigh.
</code><code class="w">   </code><code class="n">Shape</code><code class="w"> </code><code class="n">shape2</code><code class="p">(</code><code class="w"> </code><code class="n">shaperef</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_10" id="code_g34_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Drawing the copy will again result in the same output
</code><code class="w">   </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">shape2</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>Assuming that you have a type-erased <code>circle</code> called <code>shape1</code>, you might want to
convert this <code>Shape</code> instance to a <code>ShapeConstRef</code>
(<a class="co" href="#code_g34_8" id="para_g34_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).
With the current implementation, this works, but the <code>shaperef</code> instance would hold
a pointer to the <code>shape1</code> instance, instead of a pointer to the <code>circle</code>. As a
consequence, any use of the <code>shaperef</code> would result in two indirections (one via the
<code>ShapeConstRef</code>, and one via the <code>Shape</code> abstraction)
(<a class="co" href="#code_g34_9" id="para_g34_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).
Furthermore, you might also be interested in converting a <code>ShapeConstRef</code> instance to a
<code>Shape</code> instance
(<a class="co" href="#code_g34_10" id="para_g34_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).
In that case, you might expect that a full copy of the underlying <code>Circle</code> is created
and that the resulting <code>Shape</code> abstraction contains and represents this copy.
Unfortunately, with the current implementation, the <code>Shape</code> would create a copy of
the <code>ShapeConstRef</code> instance, and thus introduce a third indirection. <em>Sigh</em>.</p>
<p>If you need a more efficient interaction between owning and nonowning Type
Erasure wrappers, and if you need a real copy when copying a nonowning wrapper into
an owning wrapper, then I can offer you a working solution. Unfortunately, it is more
involved than the previous implementation(s), but fortunately it isn’t not overly complex. The
solution builds on the basic Type Erasure implementation from
<a data-type="xref" href="#consider_replacing_inheritance_hierarchies_with_type_erasure">“Guideline 32: Consider Replacing Inheritance Hierarchies with Type Erasure”</a>, which includes the
<code>ShapeConcept</code> and <code>OnwingShapeModel</code> classes in the <code>detail</code> namespace, and the
<code>Shape</code> Type Erasure wrapper. You will see that it just requires a few additions,
all of which you have already seen before.</p>
<p>The first addition happens in the <code>ShapeConcept</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">namespace</code><code class="w"> </code><code class="nn">detail</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConcept</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">clone</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="o">*</code><code class="w"> </code><code class="n">memory</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_11" id="code_g34_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace detail
</code></pre>
<p>The <code>ShapeConcept</code> class is extended with a second <code>clone()</code> function
(<a class="co" href="#code_g34_11" id="para_g34_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>).
Instead of returning a newly instantiated copy of the corresponding model, this function is
passed the address of the memory location where the new model needs to be created.</p>
<p>The second addition is a new model class, the <code>NonOwningShapeModel</code>:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">namespace</code><code class="w"> </code><code class="nn">detail</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">NonOwningShapeModel</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">NonOwningShapeModel</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="o">&amp;</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">shape_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">addressof</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">      </code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="p">{</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">addressof</code><code class="p">(</code><code class="n">drawer</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">drawer_</code><code class="p">)</code><code class="p">(</code><code class="o">*</code><code class="n">shape_</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g34_14" id="code_g34_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">unique_ptr</code><code class="o">&lt;</code><code class="n">ShapeConcept</code><code class="o">&gt;</code><code class="w"> </code><code class="n">clone</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g34_15" id="code_g34_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">OwningShapeModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">make_unique</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="o">*</code><code class="n">shape_</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">drawer_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">clone</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="o">*</code><code class="w"> </code><code class="n">memory</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w">  </code><a class="co" href="#para_g34_16" id="code_g34_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">construct_at</code><code class="p">(</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">NonOwningShapeModel</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">memory</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="c1">// or:
</code><code class="w">      </code><code class="c1">// auto* ptr =
</code><code class="w">      </code><code class="c1">//    const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(memory));
</code><code class="w">      </code><code class="c1">// ::new (ptr) NonOwningShapeModel( *this );
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeT</code><code class="o">*</code><code class="w"> </code><code class="n">shape_</code><code class="p">{</code><code class="w"> </code><code class="k">nullptr</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_12" id="code_g34_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">DrawStrategy</code><code class="o">*</code><code class="w"> </code><code class="n">drawer_</code><code class="p">{</code><code class="w"> </code><code class="k">nullptr</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_13" id="code_g34_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace detail
</code></pre>
<p>The <code>NonOwningShapeModel</code> is very similar to the <code>OwningShapeModel</code> implementation, but, as the
name suggests, it does not store copies of the given shape and strategy. Instead, it stores only
pointers (<a class="co" href="#code_g34_12" id="para_g34_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>
and <a class="co" href="#code_g34_13" id="para_g34_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).
Thus, this class represents the reference semantics version of the <code>OwningShapeModel</code> class.
Also, <code>NonOwningShapeModel</code> needs to override the pure virtual functions of the <code>ShapeConcept</code>
class: <code>draw()</code> again forwards the drawing request to the given drawing Strategy
(<a class="co" href="#code_g34_14" id="para_g34_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>),
while the <code>clone()</code> functions perform a copy. The first <code>clone()</code> function is implemented
by creating a new <code>OwningShapeModel</code> and copying both the stored shape and drawing Strategy
(<a class="co" href="#code_g34_15" id="para_g34_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>).
The second <code>clone()</code> function is implemented by creating a new <code>NonOwningShapeModel</code> at
the specified address by <code>std::construct_at()</code>
(<a class="co" href="#code_g34_16" id="para_g34_16"><img alt="16" height="12" src="assets/16.png" width="12"/></a>).</p>
<p>In addition, the <code>OwningShapeModel</code> class needs to provide an implementation of the new
<code>clone()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">namespace</code><code class="w"> </code><code class="nn">detail</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">
</code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">        </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">OwningShapeModel</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">clone</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConcept</code><code class="o">*</code><code class="w"> </code><code class="n">memory</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w">  </code><a class="co" href="#para_g34_17" id="code_g34_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">NonOwningShapeModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="w"> </code><code class="k">const</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="w"> </code><code class="k">const</code><code class="o">&gt;</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">construct_at</code><code class="p">(</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">memory</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">shape_</code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="c1">// or:
</code><code class="w">      </code><code class="c1">// auto* ptr =
</code><code class="w">      </code><code class="c1">//    const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(memory));
</code><code class="w">      </code><code class="c1">// ::new (ptr) Model( shape_, drawer_ );
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="p">}</code><code class="w"> </code><code class="c1">// namespace detail
</code></pre>
<p>The <code>clone()</code> function in <code>OwningShapeModel</code> is implemented similarly to the implementation
in the <code>NonOwningShapeModel</code> class by creating a new instance of a 
<span class="keep-together"><code>NonOwningShapeModel</code></span> by <code>std::construct_at()</code>
(<a class="co" href="#code_g34_17" id="para_g34_17"><img alt="17" height="12" src="assets/17.png" width="12"/></a>).</p>
<p>The next addition is the corresponding wrapper class that acts as a wrapper around the
external hierarchy <code>ShapeConcept</code> and <code>NonOwningShapeModel</code>. This wrapper should take
on the same responsibilities as the <code>Shape</code> class (i.e., the instantiation of
the <code>NonOwningShapeModel</code> class template and the encapsulation of all pointer handling)
but should merely represent a reference to a <code>const</code> concrete shape, not a copy. This
wrapper is again given in the form of the <code>ShapeConstRef</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;array&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstddef&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory&gt;</code><code class="cp">
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConstRef</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Expected size of a model instantiation:
</code><code class="w">   </code><code class="c1">//     sizeof(ShapeT*) + sizeof(DrawStrategy*) + sizeof(vptr)
</code><code class="w">   </code><code class="k">static</code><code class="w"> </code><code class="k">constexpr</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">MODEL_SIZE</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">3U</code><code class="o">*</code><code class="k">sizeof</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_19" id="code_g34_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">alignas</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">array</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">byte</code><code class="p">,</code><code class="n">MODEL_SIZE</code><code class="o">&gt;</code><code class="w"> </code><code class="n">raw_</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_18" id="code_g34_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>As you will see, the <code>ShapeConstRef</code> class is very similar to the <code>Shape</code> class, but there
are a few important differences. The first noteworthy detail is the use of a <code>raw_</code> storage
in the form of a properly aligned <code>std::byte</code> array
(<a class="co" href="#code_g34_18" id="para_g34_18"><img alt="18" height="12" src="assets/18.png" width="12"/></a>).
That indicates that 
<span class="keep-together"><code>ShapeConstRef</code></span> does not allocate dynamically, but firmly builds on in-class
memory. In this case, however, this is easily possible, because we can predict the size
of the required <code>NonOwningShapeModel</code> to be equal to the size of three pointers (assuming
that the pointer to the virtual function table, the <code>vptr</code>, has the same size as any
other pointer)
(<a class="co" href="#code_g34_19" id="para_g34_19"><img alt="19" height="12" src="assets/19.png" width="12"/></a>).</p>
<p>The <code>private</code> section of <code>ShapeConstRef</code> also contains a couple of member functions:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConstRef</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">friend</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">draw</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConstRef</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">shape</code><code class="p">.</code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="o">-</code><code class="o">&gt;</code><code class="n">draw</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeConcept</code><code class="o">*</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g34_20" id="code_g34_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="k">reinterpret_cast</code><code class="o">&lt;</code><code class="n">ShapeConcept</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">raw_</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeConcept</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w">  </code><a class="co" href="#para_g34_21" id="code_g34_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="k">reinterpret_cast</code><code class="o">&lt;</code><code class="n">ShapeConcept</code><code class="w"> </code><code class="k">const</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="w"> </code><code class="n">raw_</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>We also add a <code>draw()</code> function as a hidden <code>friend</code> and, just as in the SBO implementation in
<a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>, we add a pair of <code>pimpl()</code>
functions
(<a class="co" href="#code_g34_20" id="para_g34_20"><img alt="20" height="12" src="assets/20.png" width="12"/></a> and
<a class="co" href="#code_g34_21" id="para_g34_21"><img alt="21" height="12" src="assets/21.png" width="12"/></a>).
This will enable us to work conveniently with the in-class <code>std::byte</code> array.</p>
<p>The second noteworthy detail is the signature function of every Type Erasure implementation,
the templated constructor:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConstRef</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// Type 'ShapeT' and 'DrawStrategy' are possibly cv qualified;
</code><code class="w">   </code><code class="c1">// lvalue references prevent references to rvalues
</code><code class="w">   </code><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">ShapeT</code><code class="w">
</code><code class="w">           </code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">DrawStrategy</code><code class="w"> </code><code class="o">&gt;</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeConstRef</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeT</code><code class="o">&amp;</code><code class="w"> </code><code class="n">shape</code><code class="w">
</code><code class="w">                </code><code class="p">,</code><code class="w"> </code><code class="n">DrawStrategy</code><code class="o">&amp;</code><code class="w"> </code><code class="n">drawer</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g34_22" id="code_g34_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">using</code><code class="w"> </code><code class="n">Model</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">         </code><code class="n">detail</code><code class="o">:</code><code class="o">:</code><code class="n">NonOwningShapeModel</code><code class="o">&lt;</code><code class="n">ShapeT</code><code class="w"> </code><code class="k">const</code><code class="p">,</code><code class="n">DrawStrategy</code><code class="w"> </code><code class="k">const</code><code class="o">&gt;</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_23" id="code_g34_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="k">static_assert</code><code class="p">(</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">Model</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="n">MODEL_SIZE</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">Invalid size detected</code><code class="s">"</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_24" id="code_g34_24"><img alt="24" height="12" src="assets/24.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="k">static_assert</code><code class="p">(</code><code class="w"> </code><code class="k">alignof</code><code class="p">(</code><code class="n">Model</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="k">alignof</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">Misaligned detected</code><code class="s">"</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">construct_at</code><code class="p">(</code><code class="w"> </code><code class="k">static_cast</code><code class="o">&lt;</code><code class="n">Model</code><code class="o">*</code><code class="o">&gt;</code><code class="p">(</code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">shape_</code><code class="p">,</code><code class="w"> </code><code class="n">drawer_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g34_25" id="code_g34_25"><img alt="1" height="12" src="assets/25.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">      </code><code class="c1">// or:
</code><code class="w">      </code><code class="c1">// auto* ptr =
</code><code class="w">      </code><code class="c1">//    const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(pimpl()));
</code><code class="w">      </code><code class="c1">// ::new (ptr) Model( shape_, drawer_ );
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>Again, you have the choice to accept the arguments by reference-to-non-<code>const</code> to prevent lifetime issues with temporaries (very much recommended!)
(<a class="co" href="#code_g34_22" id="para_g34_22"><img alt="22" height="12" src="assets/22.png" width="12"/></a>).
Alternatively, you accept the arguments by reference-to-<code>const</code>, which would allow you to
pass rvalues but puts you at risk of experiencing lifetime issues with temporaries. Inside
the constructor, we again first use a convenient type alias for the required type of model
(<a class="co" href="#code_g34_23" id="para_g34_23"><img alt="23" height="12" src="assets/23.png" width="12"/></a>),
before checking the actual size and alignment of the model
(<a class="co" href="#code_g34_24" id="para_g34_24"><img alt="24" height="12" src="assets/24.png" width="12"/></a>).
If it does not adhere to the expected <code>MODEL_SIZE</code> or pointer alignment, we create a compile-time error. Then we construct the new model inside the in-class memory by <code>std::construct_at()</code>
(<a class="co" href="#code_g34_25" id="para_g34_25"><img alt="25" height="12" src="assets/25.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Shape.h&gt; ----------------
</code><code class="w">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">ShapeConstRef</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeConstRef</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">       </code><code class="p">{</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">clone</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g34_26" id="code_g34_26"><img alt="26" height="12" src="assets/26.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">ShapeConstRef</code><code class="p">(</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl_</code><code class="o">-</code><code class="o">&gt;</code><code class="n">clone</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeConstRef</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConstRef</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="o">-</code><code class="o">&gt;</code><code class="n">clone</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">ShapeConstRef</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConstRef</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="c1">// Copy-and-swap idiom
</code><code class="w">      </code><code class="n">ShapeConstRef</code><code class="w"> </code><code class="nf">copy</code><code class="p">(</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">raw_</code><code class="p">.</code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">copy</code><code class="p">.</code><code class="n">raw_</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="o">*</code><code class="k">this</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="o">~</code><code class="n">ShapeConstRef</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">destroy_at</code><code class="p">(</code><code class="w"> </code><code class="n">pimpl</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="c1">// or: pimpl()-&gt;~ShapeConcept();
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// Move operations explicitly not declared  </code><a class="co" href="#para_g34_27" id="code_g34_27"><img alt="27" height="12" src="assets/27.png" width="12"/></a><code class="c1">
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>In addition to the templated <code>ShapeConstRef</code> constructor, <code>ShapeConstRef</code> offers two
constructors to enable a conversion from <code>Shape</code> instances
(<a class="co" href="#code_g34_26" id="para_g34_26"><img alt="26" height="12" src="assets/26.png" width="12"/></a>).
While these are not strictly required, as we could also create an instance of a
<code>NonOwningShapeModel</code> for a <code>Shape</code>, these constructors directly create a
<code>NonOwningShapeModel</code> for the corresponding, underlying shape type, and thus shave off one
indirection, which contributes to better performance. Note that to make these
constructors work, <code>ShapeConstRef</code> needs to become a <code>friend</code> of the <code>Shape</code> class. Don’t worry, though, as this is a good example for <code>friend</code>ship: <code>Shape</code> and <code>ShapeConstRef</code>
truly belong together, work hand in hand, and are even provided in the same header
file.</p>
<p>The last noteworthy detail is the fact that the two move operations are neither explicitly
declared nor deleted
(<a class="co" href="#code_g34_27" id="para_g34_27"><img alt="27" height="12" src="assets/27.png" width="12"/></a>).
Since we have explicitly defined the two copy operations, the compiler neither creates
nor deletes the two move operations, thus they are gone. Completely gone in the sense that
these two functions never participate in overload resolution. And yes, this is different
from explicitly deleting them: if they were deleted, they would participate in overload
resolution, and if selected, they would result in a compilation error. But with these two functions
gone, when you try to move a <code>ShapeConstRef</code>, the copy operations would be used instead,
which are cheap and efficient, since <code>ShapeConstRef</code> only represents a reference.
Thus, this class deliberately implements the
<a href="https://oreil.ly/hYYiq">Rule of 3</a>.</p>
<p>We are almost finished. The last detail is one more addition, one more constructor in the
<code>Shape</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Shape.h&gt; ----------------</code>

<code class="c1">// ...</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Shape</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="n">Shape</code><code class="p">(</code><code class="w"> </code><code class="n">ShapeConstRef</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">pimpl_</code><code class="p">{</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">pimpl</code><code class="p">()</code><code class="o">-&gt;</code><code class="n">clone</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="p">{}</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
<p>Via this constructor, an instance of <code>Shape</code> creates a deep copy of the shape stored in
the passed <code>ShapeConstRef</code> instance. Without this constructor, <code>Shape</code> stores a
copy of the <code>ShapeConstRef</code> instance and thus acts as a reference itself.</p>
<p>In summary, both nonowning implementations, the simple and the more complex one, give you all
the design advantages of the Type Erasure design pattern but at the same time pull you back
into the realm of reference semantics, with all its deficiencies. Hence, utilize the strengths
of this nonowning form of Type Erasure, but also be aware of the usual lifetime issues. Consider
it on the same level as <code>std::string_view</code> and <code>std::span</code>. All of these serve as very useful
tools for function arguments, but do not use them to store anything for a longer period, for
instance in the form of a data member. The danger of lifetime-related issues is just too high.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043077198976">
<h5>Guideline 34: Be Aware of the Setup Costs of Owning 
<span class="keep-together">Type Erasure Wrappers</span></h5>
<ul>
<li>
<p>Keep in mind that the setup of owning Type Erasure wrappers may involve copy operations and allocations.</p>
</li>
<li>
<p>Be aware of nonowning Type Erasure, but also understand its reference semantics deficiencies.</p>
</li>
<li>
<p>Prefer simple Type Erasure implementations, but know their limits.</p>
</li>
<li>
<p>Prefer to use nonowning Type Erasure for function arguments but not for data members or return types.<a data-primary="" data-startref="TEDPsetup08" data-type="indexterm" id="idm45043077193536"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45043085804224"><sup><a href="ch08.xhtml#idm45043085804224-marker">1</a></sup> Yes, I consider the manual use of <code>std::unique_ptr</code> manual lifetime management. But of course it could be much worse if we would not reach for the power of RAII.</p><p data-type="footnote" id="idm45043085802544"><sup><a href="ch08.xhtml#idm45043085802544-marker">2</a></sup> The term Type Erasure is heavily overloaded, as it is used in different programming languages and for many different things. Even within the C++ community, you hear the term being used for various purposes: you might have heard it being used to denote <code>void*</code>, pointers-to-base, and <code>std::variant</code>. In the context of software design, I consider this a very unfortunate issue. I will address this issue at the end of this guideline.</p><p data-type="footnote" id="idm45043085797440"><sup><a href="ch08.xhtml#idm45043085797440-marker">3</a></sup> Sean Parent, “Inheritance Is the Base Class of Evil,” GoingNative 2013, <a href="https://oreil.ly/COYs2">YouTube</a>.</p><p data-type="footnote" id="idm45043085793120"><sup><a href="ch08.xhtml#idm45043085793120-marker">4</a></sup> Kevlin Henney, “Valued Conversions,” <em>C++ Report</em>, July-August 2000, <a href="https://oreil.ly/BPCjV">CiteSeer</a>.</p><p data-type="footnote" id="idm45043085790080"><sup><a href="ch08.xhtml#idm45043085790080-marker">5</a></sup> For an introduction to <code>std::function</code>, see <a data-type="xref" href="ch05.xhtml#prefer_a_value_based_implementation_of_strategy_and_command">“Guideline 23: Prefer a Value-Based Implementation of Strategy and Command”</a>.</p><p data-type="footnote" id="idm45043084954144"><sup><a href="ch08.xhtml#idm45043084954144-marker">6</a></sup> The placement of <code>ShapeConcept</code> and <code>OwningShapeModel</code> in a namespace is purely an implementation detail of this example implementation. Still, as you will see in <a data-type="xref" href="#be_aware_of_the_setup_costs_of_owning_type_erasure_wrappers">“Guideline 34: Be Aware of the Setup Costs of Owning 
<span class="keep-together">Type Erasure Wrappers</span>”</a>, this choice will come in pretty handy. Alternatively, these two classes  <span class="keep-together">can be</span> implemented as nested classes. You will see examples of this in <a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>.</p><p data-type="footnote" id="idm45043083389632"><sup><a href="ch08.xhtml#idm45043083389632-marker">7</a></sup> Refer to <a data-type="xref" href="ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism">“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”</a> for the implementation based on <code>std::function</code>.</p><p data-type="footnote" id="idm45043083443376"><sup><a href="ch08.xhtml#idm45043083443376-marker">8</a></sup> Many thanks to Arthur O’Dwyer for providing this example.</p><p data-type="footnote" id="idm45043083097792"><sup><a href="ch08.xhtml#idm45043083097792-marker">9</a></sup> Again, please don’t consider these performance numbers the perfect truth. These are the performance results on my machine and my implementation. Your results will differ for sure. However, the takeaway is that Type Erasure performs really well and might perform even better if we take the many optimization options into account (see <a data-type="xref" href="#know_about_the_optimization_potential_of_type_erasure">“Guideline 33: Be Aware of the Optimization Potential of Type Erasure”</a>).</p><p data-type="footnote" id="idm45043083092752"><sup><a href="ch08.xhtml#idm45043083092752-marker">10</a></sup> Eric Niebler on <a href="https://oreil.ly/SXeni">Twitter</a>, June 19, 2020.</p><p data-type="footnote" id="idm45043083089328"><sup><a href="ch08.xhtml#idm45043083089328-marker">11</a></sup> For an introduction of <code>std::variant</code>, see <a data-type="xref" href="ch04.xhtml#consider_std_variant_for_implementing_visitors">“Guideline 17: Consider std::variant for 
<span class="keep-together">Implementing Visitor</span>”</a>.</p><p data-type="footnote" id="idm45043083072592"><sup><a href="ch08.xhtml#idm45043083072592-marker">12</a></sup> You should avoid going too deep, though, as you probably remember what happened to the dwarves of Moria who dug too deep…</p><p data-type="footnote" id="idm45043082896256"><sup><a href="ch08.xhtml#idm45043082896256-marker">13</a></sup> Alternatively, you could use an array of bytes, e.g., <code>std::byte[Capacity]</code> or <a href="https://oreil.ly/nE5SK"><code>std::aligned_storage</code></a>. The advantage of <code>std::array</code> is that it enables you to copy the buffer (if that is applicable!).</p><p data-type="footnote" id="idm45043082912976"><sup><a href="ch08.xhtml#idm45043082912976-marker">14</a></sup> Note that the choice for the default arguments for <code>Capacity</code> and <code>Alignment</code> are reasonable but still arbitrary. You can, of course, use different defaults that best fit the properties of the expected actual types.</p><p data-type="footnote" id="idm45043082806592"><sup><a href="ch08.xhtml#idm45043082806592-marker">15</a></sup> You might not have seen a placement <code>new</code> before. If that’s the case, rest assured that this form of <code>new</code> doesn’t perform any memory allocation, but only calls a constructor to create an object at the specified address. The only syntactic difference is that you provide an additional pointer argument to <code>new</code>.</p><p data-type="footnote" id="idm45043081309312"><sup><a href="ch08.xhtml#idm45043081309312-marker">16</a></sup> As a reminder, since you might not see this syntax often: the <code>template</code> keyword in the constructor is necessary because we are trying to call a function template on a dependent name (a name whose meaning depends on a template parameter). Therefore, you have to make it clear to the compiler that the following is the beginning of a template argument list and not a less-than comparison.</p><p data-type="footnote" id="idm45043080813136"><sup><a href="ch08.xhtml#idm45043080813136-marker">17</a></sup> Some people consider function pointers to be the best feature of C++. In his lightning talk, <a href="https://oreil.ly/hq15H">“The Very Best Feature of C++”</a>, James McNellis demonstrates their syntactic beauty and enormous flexibility. Please do not take this too seriously, though, but rather as a humorous demonstration of a C++ imperfection.</p><p data-type="footnote" id="idm45043079519664"><sup><a href="ch08.xhtml#idm45043079519664-marker">18</a></sup> At the time of writing, there is an active <a href="https://oreil.ly/p3cFD">proposal</a> for the <code>std::function_ref</code> type, a nonowning version of <code>std::function</code>.</p><p data-type="footnote" id="idm45043079442800"><sup><a href="ch08.xhtml#idm45043079442800-marker">19</a></sup> The term <a href="https://oreil.ly/TGlBO"><em>cv qualified</em></a> refers to the <code>const</code> and <code>volatile</code> qualifiers.</p><p data-type="footnote" id="idm45043079319984"><sup><a href="ch08.xhtml#idm45043079319984-marker">20</a></sup> For a reminder about lvalues and rvalues, refer to Nicolai Josuttis’s book on move semantics: <em>C++ Move Semantics - The Complete Guide</em>.</p></div></div></section></div></body></html>