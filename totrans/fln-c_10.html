<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 9. Escaping #ifdef Hell" data-type="chapter" epub:type="chapter"><div class="chapter" id="ifdef_hell">
<h1><span class="label">Chapter 9. </span>Escaping #ifdef Hell</h1>
<p>C is widespread, in particular with systems where high-performance or hardware-near programming is required. With hardware-near programming comes the necessity of dealing with hardware variants. Aside from hardware variants, some systems support multiple operating systems or cope with multiple product variants in the code. A commonly used approach to addressing these issues is to use <code>#ifdef</code> statements of the C preprocessor to distinguish variants in the code. The C preprocessor comes with this power, but with this power also comes the responsibility to use it in a well-structured way.</p>
<p>However, that is where the weakness<a data-primary="#ifdef statements" data-secondary="weaknesses of" data-type="indexterm" id="idm45587914017200"/> of the C preprocessor with its <code>#ifdef</code> statements shows up. The C preprocessor does not support any methods to enforce rules regarding its usage.  That is a pity, because it can very easily be abused. It is very easy to add another hardware variant or another optional feature in the code by adding yet another <code>#ifdef</code>. Also, <code>#ifdef</code> statements can easily be abused to add quick bug fixes that only affect a single variant. That makes the code for different variants more diverse and leads to code that increasingly has to be fixed for each of the variants 
<span class="keep-together">separately</span>.</p>
<p>Using <code>#ifdef</code> statements in such an unstructured and ad-hoc way is the certain path to hell. The code becomes unreadable and unmaintainable, which all developers should avoid. This chapter presents approaches to escape from such a situation or avoid it altogether.</p>
<p>This chapter gives detailed guidance on how to implement variants, like operating system variants or hardware variants, in C code. It discusses five patterns on how to cope with code variants as well as how to organize or even get rid of <code>#ifdef</code> statements. The patterns can be viewed as an introduction to organizing such code or as a guide on how to refactor unstructured <code>#ifdef</code> code.</p>
<p><a data-type="xref" href="#fig_ifdef">Figure 9-1</a> shows the way out of the <code>#ifdef</code> nightmare, and <a data-type="xref" href="#tab_ifdef">Table 9-1</a> provides a short summary of the patterns discussed in this chapter.</p>
<figure><div class="figure" id="fig_ifdef">
<img alt="The way out of the #ifdef nightmare" height="1044" src="assets/fluc_0901.png" width="1150"/>
<h6><span class="label">Figure 9-1. </span>The way out of <code>#ifdef</code> hell</h6>
</div></figure>
<table id="tab_ifdef">
<caption><span class="label">Table 9-1. </span>Patterns on how to escape <code>#ifdef</code> hell</caption>
<thead>
<tr>
<th/>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td/>
<td><p>Avoid Variants</p></td>
<td><p>Using<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="overview of patterns for" data-type="indexterm" id="idm45587914001392"/> different functions for each platform makes the code harder to read and write. The programmer is required to initially understand, correctly use, and test these multiple functions in order to achieve a single functionality across multiple platforms. Therefore, use standardized functions that are available on all platforms. If there are no standardized functions, consider not implementing the functionality.</p></td>
</tr>
<tr>
<td/>
<td><p>Isolated Primitives</p></td>
<td><p>Having code variants organized with <code>#ifdef</code> statements makes the code unreadable. It is very difficult to follow the program flow, because it is implemented multiple times for multiple platforms. Therefore, isolate your code variants. In your implementation file, put the code handling the variants into separate functions and call these functions from your main program logic, which then contains only platform-independent code.</p></td>
</tr>
<tr>
<td/>
<td><p>Atomic Primitives</p></td>
<td><p>The function that contains the variants and is called by the main program is still hard to comprehend because all the complex <code>#ifdef</code> code was only put into this function in order to get rid of it in the main program. Therefore, make your primitives atomic. Only handle exactly one kind of variant per function. If you handle multiple kinds of variants—for example, operating system variants and hardware variants—then have separate functions for each.</p></td>
</tr>
<tr>
<td/>
<td><p>Abstraction Layer</p></td>
<td><p>You want to use the functionality that handles platform variants at several places in your codebase, but you do not want to duplicate the code of that functionality. Therefore, provide an API for each functionality that requires platform-specific code. Define only platform-independent functions in the header file and put all platform-specific <code>#ifdef</code> code into the implementation file. The caller of your functions includes only your header file and does not have to include any platform-specific files.</p></td>
</tr>
<tr>
<td/>
<td><p>Split Variant Implementations</p></td>
<td><p>The platform-specific implementations still contain <code>#ifdef</code> statements to distinguish between code variants. That makes it difficult to see and select which part of the code should be built for which platform. Therefore, put each variant implementation into a separate implementation file and select per file what you want to compile for which platform.</p></td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Running Example" data-type="sect1"><div class="sect1" id="idm45587913990480">
<h1>Running Example</h1>
<p>Let’s<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="running example" data-type="indexterm" id="idm45587913989008"/> say you want to implement the functionality to write some text into a file to be stored in a newly created directory that, depending on a configuration flag, is either created in the current or in the home-directory. To make things more complicated, your code should run on Windows systems as well as on Linux systems.</p>
<p>Your first attempt is to have one implementation file that contains all the code for all configurations and operating systems. To do that, the file contains many <code>#ifdef</code> statements to distinguish between the code variants:</p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdio.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdlib.h&gt;</code><code class="cp"/>
<code class="cp">#ifdef __unix__</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;sys/stat.h&gt;</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;fcntl.h&gt;</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;unistd.h&gt;</code><code class="cp"/>
<code class="cp">#elif defined _WIN32</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;windows.h&gt;</code><code class="cp"/>
<code class="cp">#endif</code>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">dirname</code><code class="p">[</code><code class="mi">50</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">filename</code><code class="p">[</code><code class="mi">60</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">my_data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Write this data to the file"</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef __unix__</code>
<code class="w">    </code><code class="cp">#ifdef STORE_IN_HOME_DIR</code>
<code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOME"</code><code class="p">),</code><code class="w"> </code><code class="s">"/newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newfile"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="cp">#elif defined STORE_IN_CWD</code>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir"</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir/newfile"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="cp">#endif</code>
<code class="w">    </code><code class="n">mkdir</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="n">S_IRWXU</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">open</code><code class="w"> </code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="n">O_RDWR</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="n">O_CREAT</code><code class="p">,</code><code class="w"> </code><code class="mo">0666</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">write</code><code class="p">(</code><code class="n">fd</code><code class="p">,</code><code class="w"> </code><code class="n">my_data</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">my_data</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="n">close</code><code class="p">(</code><code class="n">fd</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined _WIN32</code>
<code class="w">    </code><code class="cp">#ifdef STORE_IN_HOME_DIR</code>
<code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEDRIVE"</code><code class="p">),</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEPATH"</code><code class="p">),</code><code class="w"/>
<code class="w">              </code><code class="s">"</code><code class="se">\\</code><code class="s">newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newfile"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="cp">#elif defined STORE_IN_CWD</code>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir"</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir</code><code class="se">\\</code><code class="s">newfile"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="cp">#endif</code>
<code class="w">    </code><code class="n">CreateDirectory</code><code class="w"> </code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">HANDLE</code><code class="w"> </code><code class="n">hFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CreateFile</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="n">GENERIC_WRITE</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">,</code><code class="w"/>
<code class="w">                              </code><code class="n">CREATE_NEW</code><code class="p">,</code><code class="w"> </code><code class="n">FILE_ATTRIBUTE_NORMAL</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">WriteFile</code><code class="p">(</code><code class="n">hFile</code><code class="p">,</code><code class="w"> </code><code class="n">my_data</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">my_data</code><code class="p">),</code><code class="w"> </code><code class="nb">NULL</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">CloseHandle</code><code class="p">(</code><code class="n">hFile</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This code is chaos. The program logic is completely duplicated. This is not operating system-independent code; instead, it is only two different operating system–specific implementations put into one file. In particular, the orthogonal code variants of different operating systems and different places for creating the directory make the code ugly because they lead to nested <code>#ifdef</code> statements, which are very hard to understand. When reading the code, you have to constantly jump between the lines. You have to skip the code from other <code>#ifdef</code> branches in order to follow the program logic. Such duplicated program logic invites programmers to fix errors or to add new features only in the code variant that they currently work on. That causes the code pieces and the behavior for the variants to drift apart, which makes the code hard to maintain.</p>
<p>Where to start? How to clean this mess up? As a first step, if possible, you can use standardized functions in order to Avoid Variants.</p>
</div></section>
<section data-pdf-bookmark="Avoid Variants" data-type="sect1"><div class="sect1" id="pattern_avoid_variants">
<h1>Avoid Variants</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587913879040">
<h2>Context</h2>
<p>You<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Avoid Variants pattern" data-type="indexterm" id="IDSavvar09"/><a data-primary="Avoid Variants pattern" data-type="indexterm" id="avovarpat"/> write portable code that should be used on multiple operating system platforms or on multiple hardware platforms. Some of the functions you call in your code are available on one platform, but are not available in exactly the same syntax and semantics on another platform. Because of this, you implement code variants—one for each platform. Now you have different pieces of code for your different platforms, and you distinguish between the variants with <code>#ifdef</code> statements in your code.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587913649552">
<h2>Problem</h2>
<p><strong>Using different functions for each platform makes the code harder to read and write. The programmer is required to initially understand, correctly use, and test these multiple functions in order to achieve a single functionality across multiple platforms.</strong></p>
<p>Quite often it is the aim to implement functionality that should behave exactly the same on all platforms, but when using platform-dependent functions, that aim is more difficult to achieve and might require writing additional code. This is because not only the syntax but also the semantics of the functions might differ slightly between the platforms.</p>
<p>Using multiple functions for multiple platforms makes the code more difficult to write, read, and understand. Distinguishing between the different functions with <code>#ifdef</code> statements makes the code longer and requires the reader to jump across lines to find out what the code does for a single <code>#ifdef</code> branch.</p>
<p>With any piece of code that you have to write, you can ask yourself if it is worth the effort. If the required functionality is not an important one, and if platform-specific functions make it very difficult to implement and support that functionality, then it is an option to not provide that functionality at all.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587913645216">
<h2>Solution</h2>
<p><strong>Use<a data-primary="functions" data-secondary="using standardized" data-type="indexterm" id="idm45587913642784"/> standardized functions that are available on all platforms. If there are no standardized functions, consider not implementing the functionality.</strong></p>
<p>Good examples of standardized functions that you can use are the C standard library functions and the POSIX functions. Consider which platforms you want to support and check  that these standardized functions are available on all your platforms. If possible, such standardized functions should be used instead of more specific platform-dependent functions as shown in the following code:</p>
<p><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;standardizedApi.h&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* just a single function is called instead of multiple via</code>
<code class="cm">     ifdef distinguished functions */</code><code class="w"/>
<code class="w">  </code><code class="n">somePosixFunction</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><br/></p>
<p class="pagebreak-before"><em>Standardized API</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="w">  </code><code class="cm">/* this function is available on all operating systems</code>
<code class="cm">     that adhere to the POSIX standard */</code><code class="w"/>
<code class="w">  </code><code class="n">somePosixFunction</code><code class="p">();</code><code class="w"/></pre>
<p>Again, if no standardized functions exist for what you want, you probably shouldn’t implement the requested functionality. If there are only platform-dependent functions available for the functionality you want to implement, then it might not be worth the implementation, testing, and maintenance effort.</p>
<p>However, in some cases you do have to provide functionality in your product even if there are no standardized functions available. That means you have to use different functions across different platforms or maybe even implement features on one platform that are already available on another. To do that in a structured way, have Isolated Primitives for your code variants and hide them behind an Abstraction Layer.</p>
<p>To avoid variants you can, for example, use C standard library file access functions like <code>fopen</code> instead of using operating system–specific functions like Linux’s <code>open</code> or Windows’ <code>CreateFile</code> functions. As another example, you can use the C standard library time functions. Avoid using operating system–specific time functions like Windows’ <code>GetLocalTime</code> and Linux’s <code>localtime_r</code>; use the standardized <code>localtime</code> function from <em>time.h</em> instead.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587913497216">
<h2>Consequences</h2>
<p>The code is  simple to write and read because a single piece of code can be used for multiple platforms. The programmer does not have to understand different functions for different platforms when writing the code, and they don’t have to jump between <code>#ifdef</code> branches when reading the code.</p>
<p>Since the same piece of code is being used across all platforms, functionality doesn’t differ. But the standardized function might not be the most efficient or high-performance way to achieve the required functionality on each of the platforms. Some platforms might provide other platform-specific functions that, for example, use specialized hardware on that platform to achieve higher performance. These advantages may not be used by the standardized functions.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587913494496">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>The code of the VIM text editor uses the operating system–independent functions <code>fopen</code>, <code>fwrite</code>, <code>fread</code>, and <code>fclose</code> to access files.</p>
</li>
<li>
<p>The OpenSSL code writes the current local time to its log messages. To do that, it converts the current UTC time to local time using the operating 
<span class="keep-together">system–independent</span> function <code>localtime</code>.</p>
</li>
<li>
<p>The OpenSSL function <code>BIO_lookup_ex</code> looks up the node and service to connect to. This function is compiled on Windows and Linux and uses the operating system–independent function <code>htons</code> to convert a value to network byte order.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587913483184">
<h2>Applied to Running Example</h2>
<p>For<a data-primary="Avoid Variants pattern" data-startref="avovarpat" data-type="indexterm" id="idm45587913481376"/> your functionality to access files, you are in a lucky position because there are operating system–independent functions available. You now have the following code:</p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;string.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;stdio.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;stdlib.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">ifdef __unix__</code><code class="cp">
</code><code class="w">  </code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;sys/stat.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">elif defined _WIN32</code><code class="cp">
</code><code class="w">  </code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;windows.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">endif</code><code class="cp">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">dirname</code><code class="p">[</code><code class="mi">50</code><code class="p">]</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">filename</code><code class="p">[</code><code class="mi">60</code><code class="p">]</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">my_data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"</code><code class="s">Write this data to the file</code><code class="s">"</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="cp">#</code><code class="cp">ifdef __unix__</code><code class="cp">
</code><code class="w">    </code><code class="cp">#</code><code class="cp">ifdef STORE_IN_HOME_DIR</code><code class="cp">
</code><code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">%s%s</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"</code><code class="s">HOME</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">/newdir/</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">%s%s</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">newfile</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="cp">#</code><code class="cp">elif defined STORE_IN_CWD</code><code class="cp">
</code><code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">newdir</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">newdir/newfile</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="cp">#</code><code class="cp">endif</code><code class="cp">
</code><code class="w">    </code><code class="n">mkdir</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="n">S_IRWXU</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="cp">#</code><code class="cp">elif defined _WIN32</code><code class="cp">
</code><code class="w">    </code><code class="cp">#</code><code class="cp">ifdef STORE_IN_HOME_DIR</code><code class="cp">
</code><code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">%s%s%s</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"</code><code class="s">HOMEDRIVE</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"</code><code class="s">HOMEPATH</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">              </code><code class="s">"</code><code class="se">\\</code><code class="s">newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">%s%s</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">newfile</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="cp">#</code><code class="cp">elif defined STORE_IN_CWD</code><code class="cp">
</code><code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">newdir</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">newdir</code><code class="se">\\</code><code class="s">newfile</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="cp">#</code><code class="cp">endif</code><code class="cp">
</code><code class="w">    </code><code class="n">CreateDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="cp">#</code><code class="cp">endif</code><code class="cp">
</code><code class="w">  </code><code class="kt">FILE</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fopen</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">w+</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_escaping__ifdef_hell_CO1-1" id="co_escaping__ifdef_hell_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="n">fwrite</code><code class="p">(</code><code class="n">my_data</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">my_data</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">f</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="n">fclose</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_escaping__ifdef_hell_CO1-1" id="callout_escaping__ifdef_hell_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The functions <code>fopen</code>, <code>fwrite</code>, and <code>fclose</code> are part of the C standard library and are available on Windows as well as on Linux.</p></dd>
</dl>
<p>The standardized file-related function calls in that code made things a lot simpler already. Instead of having the separate file access calls for Windows and for Linux, you now have one common code. The common code ensures that the calls perform the same functionality for both operating systems, and there is no danger that two different implementations run apart after bug fixes or added features.</p>
<p>However, because your code is still dominated by <code>#ifdefs</code>, it is very difficult to read. Therefore, make sure that your main program logic does not get obfuscated by code variants. Have Isolated Primitives separating the code variants from the main program logic.<a data-primary="" data-startref="IDSavvar09" data-type="indexterm" id="idm45587913320640"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Isolated Primitives" data-type="sect1"><div class="sect1" id="pattern_isolate_primitives">
<h1>Isolated Primitives</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587913318192">
<h2>Context</h2>
<p>Your<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Isolated Primitives pattern" data-type="indexterm" id="IDSavisolp09"/><a data-primary="Isolated Primitives pattern" data-type="indexterm" id="isopripat"/> code calls platform-specific functions. You have different pieces of code for different platforms, and you distinguish between the code variants with <code>#ifdef</code> statements. You cannot simply Avoid Variants because there are no standardized functions available that provide the feature you need in a uniform way on all your platforms.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587913313232">
<h2>Problem</h2>
<p><strong>Having code variants organized with <code>#ifdef</code> statements makes the code unreadable. It is very difficult to follow the program flow, because it is implemented multiple times for multiple platforms.</strong></p>
<p>When trying to understand the code, you usually focus on only one platform, but the <code>#ifdefs</code> force you to jump between the lines in the code to find the code variant you are interested in.</p>
<p>The <code>#ifdef</code> statements also make the code difficult to maintain. Such statements invite programmers to only fix the code for the one platform they are interested in and to not touch any other code because of the danger of breaking it. But only fixing a bug or introducing a new feature for one platform means that the behavior of the code on the other platforms drifts apart. The alternative—to fix such a bug on all platforms in different ways—requires testing the code on all platforms.</p>
<p>Testing code with many code variants is difficult. Each new kind of <code>#ifdef</code> statement doubles the testing effort because all possible combinations have to be tested. Even worse, each such statement doubles the number of binaries that can be built and have to be tested. That brings in a logistic problem because build times increase and the number of binaries provided to the test department and to the customer increases.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587913307952">
<h2>Solution</h2>
<p><strong>Isolate<a data-primary="code variants" data-type="indexterm" id="idm45587913305952"/> your code variants. In your implementation file, put the code handling the variants into separate functions and call these functions from your main program logic, which then only contains platform-independent code.</strong></p>
<p>Each of your functions should either only contain program logic or only cope with handling variants. None of your functions should do both. So either there is no <code>#ifdef</code> statement at all in a function, or there are <code>#ifdef</code> statements with a single variant-dependent function call per <code>#ifdef</code> branch. Such a variant could be a software feature that is turned on or off by a build configuration, or it could be a platform variant as shown in the following code:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">handlePlatformVariants</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="cp">#</code><code class="cp">ifdef PLATFORM_A</code><code class="cp">
</code><code class="w">    </code><code class="cm">/* call function of platform A */</code><code class="w">
</code><code class="w">  </code><code class="cp">#</code><code class="cp">elif defined PLATFORM_B </code><a class="co" href="#callout_escaping__ifdef_hell_CO2-1" id="co_escaping__ifdef_hell_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="cp">
</code><code class="w">    </code><code class="cm">/* call function of platform B */</code><code class="w">
</code><code class="w">  </code><code class="cp">#</code><code class="cp">endif</code><code class="cp">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="cm">/* program logic goes here */</code><code class="w">
</code><code class="w">  </code><code class="n">handlePlatformVariants</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="cm">/* program logic continues */</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_escaping__ifdef_hell_CO2-1" id="callout_escaping__ifdef_hell_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Similar to <code>else if</code> statements, mutually exclusive variants can be expressed nicely using <code>#elif</code>.</p></dd>
</dl>
<p>Utilizing a single function call per <code>#ifdef</code> branch should make it possible to find a good abstraction granularity for the functions handling the variants. Usually the granularity is exactly at the level of the available platform-specific or feature-specific functions to be wrapped.</p>
<p>If the functions that handle the variants are still complicated and contain <code>#ifdef</code> cascades (nested <code>#ifdef</code> statements), it helps to make sure you only have Atomic 
<span class="keep-together">Variants.</span></p>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587913099008">
<h2>Consequences</h2>
<p>The main program logic is now easy to follow, because the code variants are separated from it. When reading the main code, it is no longer necessary to jump between the lines to find out what the code does on one specific platform.</p>
<p>To determine what the code does on one specific platform, you have to look at the called function that implements this variant. Having that code in a separately called function has the advantage that it can be called from other places in the file, and thus code duplications can be avoided. If the functionality is also required in other implementation files, then an Abstraction Layer has to be implemented.</p>
<p>No program logic should be introduced in the functions handling the variants, so it is easier to pinpoint bugs that do not occur on all platforms, because it is easy to identify the places in the code where the behavior of the platforms differs.</p>
<p>Code duplication becomes less of an issue since the main program logic is well separated from the variant implementations. There is no temptation to duplicate the program logic anymore, so there is no threat of then accidentally only making bug fixes in one of these duplications.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587913095952">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>The code of the VIM text editor isolates the function <code>htonl2</code> that converts data to network byte order. The program logic of VIM defines <code>htonl2</code> as a macro in the implementation file. The macro is compiled differently depending on the platform endianness.</p>
</li>
<li>
<p>The OpenSSL function <code>BIO_ADDR_make</code> copies socket information into an internal <code>struct</code>. The function uses <code>#ifdef</code> statements to handle operating system–specific and feature-specific variants distinguishing between Linux/Windows and IPv4/IPv6. The function isolates these variants from the main program logic.</p>
</li>
<li>
<p>The function <code>load_rcfile</code> of GNUplot reads data from an initialization file and isolates operating system–specific file access operations from the rest of the code.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587913215168">
<h2>Applied to Running Example</h2>
<p>Now<a data-primary="Isolated Primitives pattern" data-startref="isopripat" data-type="indexterm" id="idm45587913213424"/> that you have Isolated Primitives, your main program logic is a lot easier to read and doesn’t require the reader to jump between the lines to keep the variants apart:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">getDirectoryName</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef __unix__</code>
<code class="w">    </code><code class="cp">#ifdef STORE_IN_HOME_DIR</code>
<code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOME"</code><code class="p">),</code><code class="w"> </code><code class="s">"/newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="cp">#elif defined STORE_IN_CWD</code>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="cp">#endif</code>
<code class="w">  </code><code class="cp">#elif defined _WIN32</code>
<code class="w">    </code><code class="cp">#ifdef STORE_IN_HOME_DIR</code>
<code class="w">      </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEDRIVE"</code><code class="p">),</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEPATH"</code><code class="p">),</code><code class="w"/>
<code class="w">              </code><code class="s">"</code><code class="se">\\</code><code class="s">newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="cp">#elif defined STORE_IN_CWD</code>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="cp">#endif</code>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">createNewDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef __unix__</code>
<code class="w">    </code><code class="n">mkdir</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="n">S_IRWXU</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined _WIN32</code>
<code class="w">    </code><code class="n">CreateDirectory</code><code class="w"> </code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">dirname</code><code class="p">[</code><code class="mi">50</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">filename</code><code class="p">[</code><code class="mi">60</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">my_data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Write this data to the file"</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">getDirectoryName</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">createNewDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">sprintf</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newfile"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">FILE</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fopen</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"w+"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">fwrite</code><code class="p">(</code><code class="n">my_data</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">my_data</code><code class="p">),</code><code class="w"> </code><code class="n">f</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">fclose</code><code class="p">(</code><code class="n">f</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The code variants are now well isolated. The program logic of the <code>main</code> function is very easy to read and understand without the variants. However, the new function <code>getDirectoryName</code> is still dominated by <code>#ifdefs</code> and is not easy to comprehend. It may help to only have Atomic Primitives.<a data-primary="" data-startref="IDSavisolp09" data-type="indexterm" id="idm45587913205776"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Atomic Primitives" data-type="sect1"><div class="sect1" id="pattern_atomic_primitives">
<h1>Atomic Primitives</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587913373248">
<h2>Context</h2>
<p>You<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Atomic Primitives pattern" data-type="indexterm" id="IDSavatprim09"/><a data-primary="Atomic Primitives pattern" data-type="indexterm" id="atopripat"/> implemented variants in your code with <code>#ifdef</code> statements, and you put these variants into separate functions in order to have Isolated Primitives that handle these variants. The primitives separate the variants from the main program flow, which makes the main program well structured and easy to comprehend.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587913368448">
<h2>Problem</h2>
<p><strong>The function that contains the variants and is called by the main program is still hard to comprehend because all the complex <code>#ifdef</code> code was only put into this function in order to get rid of it in the main program.</strong></p>
<p>Handling all kinds of variants in one function becomes difficult as soon as there are many different variants to handle. If, for example, a single function uses <code>#ifdef</code> statements to distinguish between different hardware types and operating systems, then adding an additional operating system variant becomes difficult because it has to be added for all hardware variants. Each variant cannot be handled in one place anymore; instead, the effort multiplies with the number of different variants. That is a problem. It should be easy to add new variants at one place in the code.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587913364784">
<h2>Solution</h2>
<p><strong>Make your primitives atomic. Only<a data-primary="functions" data-secondary="handling one kind of variant only" data-type="indexterm" id="idm45587913362672"/> handle exactly one kind of variant per function. If you handle multiple kinds of variants—for example, operating system variants and hardware variants—then have separate functions for each.</strong></p>
<p>Let one of these functions call another that already abstracts one kind of variant. If you abstract a platform-dependence and a feature-dependence, then let the feature-dependent function be the one calling the platform-dependent function, because you usually provide features across all platforms. Therefore, platform-dependent functions should be the most atomic functions, as shown in the following code:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">handleHardwareOfFeatureX</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef HARDWARE_A</code>
<code class="w">   </code><code class="cm">/* call function for feature X on hardware A */</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined HARDWARE_B || defined HARDWARE_C</code>
<code class="w">   </code><code class="cm">/* call function for feature X on hardware B and C */</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">handleHardwareOfFeatureY</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef HARDWARE_A</code>
<code class="w">   </code><code class="cm">/* call function for feature Y on hardware A */</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined HARDWARE_B</code>
<code class="w">   </code><code class="cm">/* call function for feature Y on hardware B */</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined HARDWARE_C</code>
<code class="w">   </code><code class="cm">/* call function for feature Y on hardware C */</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">callFeature</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef FEATURE_X</code>
<code class="w">    </code><code class="n">handleHardwareOfFeatureX</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined FEATURE_Y</code>
<code class="w">    </code><code class="n">handleHardwareOfFeatureY</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/></pre>
<p>If there is a function that clearly has to provide a functionality across multiple kinds of variants as well as handle all these kinds of variants, then the function scope might be wrong. Perhaps the function is too general or does more than one thing. Split the function as suggested by the Function Split pattern.</p>
<p>Call Atomic Primitives in your main code containing the program logic. If you want to use the Atomic Primitives in other implementation files with a well-defined interface, then use an Abstraction Layer.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587912635664">
<h2>Consequences</h2>
<p>Each function now only handles one kind of variant. That makes each of the functions easy to understand because there are no more cascades of <code>#ifdef</code> statements. Each of the functions now only abstracts one kind of variant and does no more than exactly that one thing. So the functions follow the single-responsibility principle.</p>
<p>Having no <code>#ifdef</code> cascades makes it less tempting for programmers to simply handle one additional kind of variant in one function, because starting an <code>#ifdef</code> cascade is less likely than extending an existing cascade.</p>
<p>With separate functions, each kind of variant can easily be extended for an additional variant. To achieve this, only one <code>#ifdef</code> branch has to be added in one function, and the functions which handle other kinds of variants do not have to be touched.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587912618000">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>The OpenSSL implementation file <em>threads_pthread.c</em> contains functions for thread handling. There are separate functions to abstract operating systems and separate functions to abstract whether pthreads are available at all.</p>
</li>
<li>
<p>The code of SQLite contains functions to abstract operating system–specific file access (for example, the <code>fileStat</code> function). The code abstracts file access–related compile-time features with other separate functions.</p>
</li>
<li>
<p>The Linux function <code>boot_jump_linux</code> calls another function that performs different boot actions depending on the CPU architecture that is handled via <code>#ifdef</code> statements in that function. Then the function <code>boot_jump_linux</code> calls another function that uses <code>#ifdef</code> statements to select which configured resources (USB, network, etc.) have to be cleaned up.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587912524656">
<h2>Applied to Running Example</h2>
<p>With<a data-primary="Atomic Primitives pattern" data-startref="atopripat" data-type="indexterm" id="idm45587912523008"/> Atomic Primitives you now have the following code for your functions to determine the directory path:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">getHomeDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef __unix__</code>
<code class="w">    </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOME"</code><code class="p">),</code><code class="w"> </code><code class="s">"/newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined _WIN32</code>
<code class="w">    </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEDRIVE"</code><code class="p">),</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEPATH"</code><code class="p">),</code><code class="w"/>
<code class="w">            </code><code class="s">"</code><code class="se">\\</code><code class="s">newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">getWorkingDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef __unix__</code>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined _WIN32</code>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">getDirectoryName</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef STORE_IN_HOME_DIR</code>
<code class="w">    </code><code class="n">getHomeDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined STORE_IN_CWD</code>
<code class="w">    </code><code class="n">getWorkingDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/></pre>
<p>The code variants are now very well isolated. To obtain the directory name, instead of having one complicated function with many <code>#ifdefs</code>, you now have several functions that only have one <code>#ifdef</code> each. That makes it a lot easier to understand the code because now each of these functions only performs one thing instead of distinguishing between several kinds of variants with <code>#ifdef</code> cascades.</p>
<p>The functions are now very simple and easy to read, but your implementation file is still very long. In addition, one implementation file contains the main program logic as well as code to distinguish between variants. This makes parallel development or separate testing of the variant code next to impossible.</p>
<p>To improve things, split the implementation file up into variant-dependent and variant-independent files. To do that, create an Abstraction Layer.<a data-primary="" data-startref="IDSavatprim09" data-type="indexterm" id="idm45587912452160"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Abstraction Layer" data-type="sect1"><div class="sect1" id="pattern_abstraction_layer">
<h1>Abstraction Layer</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587912449600">
<h2>Context</h2>
<p>You<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Abstraction Layer pattern" data-type="indexterm" id="IDSabst09"/><a data-primary="Abstraction Layer pattern" data-type="indexterm" id="abslaypat"/> have platform variants that are distinguished with <code>#ifdef</code> statements in your code. You may have Isolated Primitives to separate the variants from the program logic and made sure that you have Atomic Primitives.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587912444800">
<h2>Problem</h2>
<p><strong>You want to use the functionality which handles platform variants at several places in your codebase, but you do not want to duplicate the code of that functionality.</strong></p>
<p>Your callers might be used to work directly with platform-specific functions, but you don’t want that anymore because each of the callers has to implement platform variants on their own. Generally, callers should not have to cope with platform variants. In the callers’ code, it should not be necessary to know anything about implementation details for the different platforms, and the callers should not have to use any <code>#ifdef</code> statements or include any platform-specific header files.</p>
<p>You are even considering working with different programmers (not the ones responsible for the platform-independent code) to separately develop and test the platform-dependent code.</p>
<p>You want to be able to change the platform-specific code later on without requiring the caller of this code to care about this change. If programmers of the platform-dependent code perform a bug fix for one platform or if they add an additional platform, then this must not require changes to the caller’s code.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587912440608">
<h2>Solution</h2>
<p><strong>Provide an API for each functionality that requires platform-specific code. Define only platform-independent functions in the<a data-primary="header files" data-secondary="placing only platform-independent functions in" data-type="indexterm" id="idm45587912438176"/><a data-primary="functions" data-secondary="placing only platform-independent in header files" data-type="indexterm" id="idm45587912437232"/> header file and put all platform-specific <code>#ifdef</code> code into the implementation file. The caller of your functions only includes your header file and does not have to include any platform-specific files.</strong></p>
<p>Try to design a stable API for the abstraction layer, because changing the API later on requires changes in your caller’s code and sometimes that is not possible. However, it is very difficult to design a stable API. For platform abstractions, try looking around at different platforms, even ones you don’t yet support. After you have a sense of how they work and what the differences are, you can create an API to abstract features for these platforms. That way, you won’t need to change the API later, even when you’re adding support for different platforms.</p>
<p>Make sure to document the API thoroughly. Add comments to each function describing what the function does. Also, describe on which platforms the functions are supported if that is not clearly defined elsewhere for your whole codebase.</p>
<p>The following code shows a simple Abstraction Layer:</p>
<p><em>caller.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">"someFeature.h"</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">someFeature</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><br/><em>someFeature.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Provides generic access to someFeature.</code>
<code class="cm">   Supported on platform A and platform B. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">someFeature</code><code class="p">();</code><code class="w"/></pre>
<p><br/><em>someFeature.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">someFeature</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef PLATFORM_A</code>
<code class="w">    </code><code class="n">performFeaturePlatformA</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined PLATFORM_B</code>
<code class="w">    </code><code class="n">performFeaturePlatformB</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/></pre>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587912217152">
<h2>Consequences</h2>
<p>The abstracted features can be used from anywhere in the code and not only from one single implementation file. In other words, now you have distinct roles of caller and callee. The callee has to cope with platform variants, and the caller can be platform independent.</p>
<p>The benefit to this setup is the caller does not have to cope with platform-specific code. The caller simply includes the provided header file and does not have to include any platform-specific header files. The downside is the caller cannot directly use all platform-specific functions anymore. If the caller is accustomed to these functions, then the caller might not be satisfied with using the abstracted functionality and may find it difficult to use or suboptimal in functionality.</p>
<p>The platform-specific code can now be developed and even tested separately from the other code. Now the testing effort is manageable, even with many platforms, because you can mock the hardware-specific code in order to write simple tests for the platform-independent code.</p>
<p>When building up such APIs for all platform-specific functions, the sum of these functions and APIs is the platform abstraction layer for the codebase. With a platform abstraction layer, it is very clear which code is platform dependent and which is platform independent. A platform abstraction layer also makes it clear which parts of the code have to be touched in order to support an additional platform.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587912194016">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>Most larger-scale code that runs on multiple platforms has a hardware Abstraction Layer. For example, Nokia’s Maemo platform has such an Abstraction Layer to abstract which actual device drivers are loaded.</p>
</li>
<li>
<p>The function <code>sock_addr_inet_pton</code> of the lighttpd web server converts an IP address from text to binary form. The implementation uses <code>#ifdef</code> statements to distinguish between code variants for IPv4 and IPv6. Callers of the API do not see this distinction.</p>
</li>
<li>
<p>The function <code>getprogname</code> of the gzip data compression program returns the name of the invoking program. The way to obtain this name depends on the operating system and is distinguished via <code>#ifdef</code> statements in the implementation. The caller does not have to care on which operating system the function is called.</p>
</li>
<li>
<p>A hardware abstraction is used for the Time-Triggered Ethernet protocol described in the bachelor’s thesis <a href="https://oreil.ly/hs0Jh">“Hardware-Abstraction of an Open Source Real-Time Ethernet Stack—Design, Realisation and Evaluation”</a> by Flemming Bunzel. The hardware abstraction layer contains functions for accessing interrupts and timers. The functions are marked as <code>inline</code> to not lose performance.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587912185024">
<h2>Applied to Running Example</h2>
<p>Now you have a much more streamlined piece of code. Each of the functions only performs one action, and you hide implementation details about the variants behind APIs:</p>
<p><em>directoryNames.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Copies the path to a new directory with name "newdir"</code>
<code class="cm">   located in the user's home directory into "dirname".</code>
<code class="cm">   Works on Linux and Windows. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">getHomeDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">);</code><code class="w"/>


<code class="cm">/* Copies the path to a new directory with name "newdir"</code>
<code class="cm">   located in the current working directory into "dirname".</code>
<code class="cm">   Works on Linux and Windows. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">getWorkingDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>directoryNames.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryNames.h"</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdio.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdlib.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string.h&gt;</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">getHomeDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef __unix__</code>
<code class="w">    </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOME"</code><code class="p">),</code><code class="w"> </code><code class="s">"/newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined _WIN32</code>
<code class="w">    </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEDRIVE"</code><code class="p">),</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEPATH"</code><code class="p">),</code><code class="w"/>
<code class="w">            </code><code class="s">"</code><code class="se">\\</code><code class="s">newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">getWorkingDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef __unix__</code>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined _WIN32</code>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/></pre>
<p><br/><em>directorySelection.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Copies the path to a new directory with name "newdir" into "dirname".</code>
<code class="cm">   The directory is located in the user's home directory, if STORE_IN_HOME_DIR</code>
<code class="cm">   is set or it is located in the current working directory, if STORE_IN_CWD</code>
<code class="cm">   is set. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">getDirectoryName</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>directorySelection.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directorySelection.h"</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryNames.h"</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">getDirectoryName</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef STORE_IN_HOME_DIR</code>
<code class="w">    </code><code class="n">getHomeDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined STORE_IN_CWD</code>
<code class="w">    </code><code class="n">getWorkingDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/></pre>
<p><br/><em>directoryHandling.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Creates a new directory of the provided name ("dirname").</code>
<code class="cm">   Works on Linux and Windows. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">createNewDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>directoryHandling.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryHandling.h"</code><code class="cp"/>
<code class="cp">#ifdef __unix__</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;sys/stat.h&gt;</code><code class="cp"/>
<code class="cp">#elif defined _WIN32</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;windows.h&gt;</code><code class="cp"/>
<code class="cp">#endif</code>

<code class="kt">void</code><code class="w"> </code><code class="nf">createNewDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cp">#ifdef __unix__</code>
<code class="w">    </code><code class="n">mkdir</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="n">S_IRWXU</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#elif defined _WIN32</code>
<code class="w">    </code><code class="n">CreateDirectory</code><code class="w"> </code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="cp">#endif</code>
<code class="p">}</code><code class="w"/></pre>
<p><br/><em>main.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdio.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">"directorySelection.h"</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryHandling.h"</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">dirname</code><code class="p">[</code><code class="mi">50</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">filename</code><code class="p">[</code><code class="mi">60</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">my_data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Write this data to the file"</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">getDirectoryName</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">createNewDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">sprintf</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newfile"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">FILE</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fopen</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"w+"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">fwrite</code><code class="p">(</code><code class="n">my_data</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">my_data</code><code class="p">),</code><code class="w"> </code><code class="n">f</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">fclose</code><code class="p">(</code><code class="n">f</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Your file with the main program logic is finally completely independent from the operating system; operating system–specific header files are not even included here. Separating the implementation files with an Abstraction Layer makes the files easier to comprehend and makes it possible to reuse the functions in other parts of the code. Also, development, maintenance, and testing can be split for the platform-dependent and platform-independent code.</p>
<p>If you have Isolated Primitives behind an Abstraction Layer and you’ve organized them according to the kind of variant that they abstract, then you’ll end up with a hardware abstraction layer or operating system abstraction layer. Now that you have a lot more code files than before—particularly those handling different variants—you may want to consider structuring them into Software-Module Directories.</p>
<p>The code that uses the API of the Abstraction Layer is very clean now, but the implementations below that API still contain <code>#ifdef</code> code for different variants. This has the disadvantage that these implementations have to be touched and will grow if, for example, additional operating systems have to be supported. To avoid touching existing implementation files when adding another variant, you could Split Variant 
<span class="keep-together">Implementations</span>.<a data-primary="" data-startref="IDSabst09" data-type="indexterm" id="idm45587911596560"/><a data-primary="Abstraction Layer pattern" data-startref="abslaypat" data-type="indexterm" id="idm45587911595552"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Split Variant Implementations" data-type="sect1"><div class="sect1" id="pattern_split_implementation_variants">
<h1>Split Variant Implementations</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587911593536">
<h2>Context</h2>
<p>You<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Split Variant Implementations" data-type="indexterm" id="IDSavspvariant09"/><a data-primary="Split Variant Implementations pattern" data-type="indexterm" id="spvaimpat"/> have platform variants hidden behind an Abstraction Layer. In the platform-specific implementation, you distinguish between the code variants with <code>#ifdef</code> statements.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587911588768">
<h2>Problem</h2>
<p><strong>The platform-specific implementations still contain <code>#ifdef</code> statements to distinguish between code variants. That makes it difficult to see and select which part of the code should be built for which platform.</strong></p>
<p>Because code for different platforms is put into a single file, it is not possible to select the platform-specific code on a file-basis. However, that is the approach taken by tools such as Make, which are usually responsible for selecting via Makefiles which files should be compiled in order to come up with variants for different platforms.</p>
<p>When looking at the code from a high-level view, it is not possible to see which parts are platform-specific and which are not, but that would be very desirable when porting the code to another platform, in order to quickly see which code has to be touched.</p>
<p class="fix-tracking">The open-closed principle says that to bring in new features (or to port to a new platform), it should not be necessary to touch existing code. The code should be open for such modifications. However, having platform variants separated with <code>#ifdef</code>
<span class="keep-together">statements</span> requires that existing implementations have to be touched when introducing a new platform, because another <code>#ifdef</code> branch has to be placed into an existing 
<span class="keep-together">function</span>.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587911555008">
<h2>Solution</h2>
<p><strong>Put each variant implementation into a separate implementation file and select per file what you want to compile for which platform.</strong></p>
<p>Related functions of the same platform can still be put into the same file. For example, there could be a file gathering all socket handling functions on Windows and one such file doing the same for Linux.</p>
<p>With separate files for each platform, it is OK to use <code>#ifdef</code> statements to determine which code is compiled on a specific platform. For example, a <em>someFeatureWindows.c</em> file could have an <code>#ifdef _WIN32</code> statement across the whole file similar to Include Guards:</p>
<p><em>someFeature.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Provides generic access to someFeature.</code>
<code class="cm">   Supported on platform A and platform B. */</code><code class="w"/>
<code class="w">  </code><code class="n">someFeature</code><code class="p">();</code><code class="w"/></pre>
<p><br/><em>someFeatureWindows.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef _WIN32</code>
<code class="w">  </code><code class="n">someFeature</code><code class="p">()</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">performWindowsFeature</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p><br/><em>someFeatureLinux.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef __unix__</code>
<code class="w">  </code><code class="n">someFeature</code><code class="p">()</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">performLinuxFeature</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p>Alternatively to using <code>#ifdef</code> statements across the whole file, other platform-independent mechanisms such as Make can be used to decide on a file-basis which code to compile on a specific platform. If your IDE helps with generating Makefiles, that alternative might be more comfortable for you, but be aware that when changing the IDE, you might have to reconfigure which files to compile on which platform in the new IDE.</p>
<p>With separate files for the platforms comes the question of where to put these files and how to name them:</p>
<ul>
<li>
<p>One option is to put platform-specific files per software-module next to each other and name them in a way that makes it clear which platform they cover (for example <em>fileHandlingWindows.c</em>). Such Software-Module Directories provide the advantage that the implementations of the software-modules are in the same place.</p>
</li>
<li>
<p>Another option is to put all platform-specific files from the codebase into one directory and to have one subdirectory for each platform. The advantage of this is that all files for one platform are in the same place and it becomes easier to configure in your IDE which files to compile on which platform.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587911554416">
<h2>Consequences</h2>
<p>Now it is possible to not have any <code>#ifdef</code> statements at all in the code but to instead distinguish between the variants on a file-basis with tools such as Make.</p>
<p>In each implementation file there is now just one code variant, so there is no need to jump between the lines when reading the code in order to only read the <code>#ifdef</code> branch you are looking for. It is much easier to read and understand the code.</p>
<p>When fixing a bug on one platform, no files for other platforms have to be touched. When porting to a new platform, only new files have to be added, and no existing file or existing code has to be modified.</p>
<p>It is easy to spot which part of the code is platform-dependent and which code has to be added in order to port to a new platform. Either all platform-specific files are in one directory, or the files are named in a way that makes it clear they are platform-dependent.</p>
<p>However, putting each variant into a separate file creates many new files. The more files you have, the more complex your build procedure gets and the longer the compile time for your code gets. You will need to think about structuring the files, for example, with Software-Module Directories.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587911450704">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>The Simple Audio Library presented in the book <em>Write Portable Code: An Introduction to Developing Software for Multiple Platforms</em> by Brian Hook (No Starch Press, 2005) uses separate implementation files to provide access to threads and Mutexes for Linux and OS X. The implementation files use <code>#ifdef</code> statements to ensure that only the correct code for the platform is compiled.</p>
</li>
<li>
<p>The Multi-Processing-Module of the Apache web server, which is responsible for handling accesses to the web server, is implemented in separate implementation files for Windows and Linux. The implementation files use <code>#ifdef</code> statements to ensure that only the correct code for the platform is compiled.</p>
</li>
<li>
<p>The code of the U-Boot bootloader puts the source code for each hardware platform it supports into a separate directory. Each of these directories contains, among others, the file <em>cpu.c</em>, which contains a function to reset the CPU. A Makefile decides which directory (and which <em>cpu.c</em> file) has to be compiled—there are no <code>#ifdef</code> statements in these files. The main program logic of U-Boot calls the function to reset the CPU and does not have to care about hardware platform details at that point.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587911442752">
<h2>Applied to Running Example</h2>
<p>After Splitting Variant Implementations, you’ll end up with the following final code for your functionality to create a directory and write data to a file:</p>
<p><em>directoryNames.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Copies the path to a new directory with name "newdir"</code>
<code class="cm">   located in the user's home directory into "dirname".</code>
<code class="cm">   Works on Linux and Windows. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">getHomeDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">);</code><code class="w"/>

<code class="cm">/* Copies the path to a new directory with name "newdir"</code>
<code class="cm">   located in the current working directory into "dirname".</code>
<code class="cm">   Works on Linux and Windows. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">getWorkingDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>directoryNamesLinux.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef __unix__</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryNames.h"</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string.h&gt;</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdio.h&gt;</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdlib.h&gt;</code><code class="cp"/>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">getHomeDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOME"</code><code class="p">),</code><code class="w"> </code><code class="s">"/newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">getWorkingDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir/"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p><br/><em>directoryNamesWindows.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef _WIN32</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryNames.h"</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string.h&gt;</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdio.h&gt;</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;windows.h&gt;</code><code class="cp"/>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">getHomeDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">sprintf</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEDRIVE"</code><code class="p">),</code><code class="w"> </code><code class="n">getenv</code><code class="p">(</code><code class="s">"HOMEPATH"</code><code class="p">),</code><code class="w"/>
<code class="w">            </code><code class="s">"</code><code class="se">\\</code><code class="s">newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">getWorkingDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newdir</code><code class="se">\\</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p class="extra-space-above"><em>directorySelection.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Copies the path to a new directory with name "newdir" into "dirname".</code>
<code class="cm">   The directory is located in the user's home directory, if STORE_IN_HOME_DIR</code>
<code class="cm">   is set or it is located in the current working directory, if STORE_IN_CWD</code>
<code class="cm">   is set. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">getDirectoryName</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">);</code><code class="w"/></pre>
<p class="extra-space-above"><em>directorySelectionHomeDir.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef STORE_IN_HOME_DIR</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directorySelection.h"</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryNames.h"</code><code class="cp"/>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">getDirectoryName</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">getHomeDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p class="extra-space-above"><em>directorySelectionWorkingDir.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef STORE_IN_CWD</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directorySelection.h"</code><code class="cp"/>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryNames.h"</code><code class="cp"/>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">getDirectoryName</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">getWorkingDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p><br/><em>directoryHandling.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Creates a new directory of the provided name ("dirname").</code>
<code class="cm">   Works on Linux and Windows. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">createNewDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>directoryHandlingLinux.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef __unix__</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;sys/stat.h&gt;</code><code class="cp"/>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">createNewDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">mkdir</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="n">S_IRWXU</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p><br/><em>directoryHandlingWindows.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifdef _WIN32</code>
<code class="w">  </code><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;windows.h&gt;</code><code class="cp"/>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">createNewDirectory</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dirname</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">CreateDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="cp">#endif</code></pre>
<p><br/><em>main.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">"directorySelection.h"</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">"directoryHandling.h"</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdio.h&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">dirname</code><code class="p">[</code><code class="mi">50</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">filename</code><code class="p">[</code><code class="mi">60</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">my_data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Write this data to the file"</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">getDirectoryName</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">createNewDirectory</code><code class="p">(</code><code class="n">dirname</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">sprintf</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"%s%s"</code><code class="p">,</code><code class="w"> </code><code class="n">dirname</code><code class="p">,</code><code class="w"> </code><code class="s">"newfile"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">FILE</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fopen</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="s">"w+"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">fwrite</code><code class="p">(</code><code class="n">my_data</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">my_data</code><code class="p">),</code><code class="w"> </code><code class="n">f</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">fclose</code><code class="p">(</code><code class="n">f</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>There are still <code>#ifdef</code> statements present in this code. Each of the implementation files has one huge <code>#ifdef</code> in order to make sure that the correct code is compiled for each platform and variant. Alternatively, the decision regarding which files should be compiled could be put into a Makefile. That would get rid of the <code>#ifdefs</code>, but you’d simply use another mechanism to chose between variants. Deciding which mechanism to use is not so important. It is much more important, as described throughout this chapter, to isolate and abstract the variants.</p>
<p>While the code files would look cleaner when using other mechanisms to handle the variants, the complexity would still be there. Putting the complexity into Makefiles can be a good idea because the purpose of Makefiles is to decide which files to build.
In other situations, it’s better to use <code>#ifdef</code> statements. For example, if you’re building operating system–specific code, maybe a proprietary IDE for Windows and another IDE for Linux is used to decide which files to build. In that circumstance, using the solution with <code>#ifdef</code> statements in the code is much cleaner; configuring which files should be built for which operating system is only done once by the <code>#ifdef</code> statements, and there is no need to touch that when changing to another IDE.</p>
<p>The final code of the running example showed very clearly how code with operating system–specific variants or other variants can be improved step by step. Compared to the first code example, this final piece of code is readable and can easily be extended with additional features or ported to additional operating systems without touching any of the existing code.<a data-primary="" data-startref="IDSavspvariant09" data-type="indexterm" id="idm45587910675088"/><a data-primary="Split Variant Implementations pattern" data-startref="spvaimpat" data-type="indexterm" id="idm45587910674112"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45587911441808">
<h1>Summary</h1>
<p>This<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="overview of patterns for" data-type="indexterm" id="idm45587910672016"/> chapter presented patterns on how to handle variants, like hardware or operating system variants, in C code and how to organize and get rid of <code>#ifdef</code> statements.</p>
<p>The Avoid Variants pattern suggests using standardized functions instead of self-implemented variants. This pattern should be applied anytime it is applicable, because it resolves issues with code variants in one blow. However, there is not always a standardized function available, and in such cases, programmers have to implement their own function to abstract the variant. As a start, Isolated Primitives suggests putting variants into separate functions, and Atomic Primitives suggests only handling one kind of variant in such functions. Abstraction Layer takes the additional step to hide the implementations of the primitives behind an API. Split Variant Implementations suggests putting each variant into a separate implementation file.</p>
<p>With these patterns as part of the programming vocabulary, a C programmer has a toolbox and step-by-step guidance on how to tackle C code variants in order to structure code and escape from <code>#ifdef</code> hell.</p>
<p>For experienced programmers, some of the patterns might look like obvious solutions and that is a good thing. One of the tasks of patterns is to educate people on how to do the right thing; once they know how to do the right thing, the patterns are not necessary anymore because people then intuitively do as suggested by the 
<span class="keep-together">patterns</span>.</p>
</div></section>
<section data-pdf-bookmark="Further Reading" data-type="sect1"><div class="sect1" id="idm45587911441440">
<h1>Further Reading</h1>
<p>If<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="further reading on" data-type="indexterm" id="idm45587910639248"/> you’re ready for more, here are some resources that can help you further your knowledge of platform and variant abstractions.</p>
<ul>
<li>
<p>The book <em>Write Portable Code: An Introduction to Developing Software for Multiple Platforms</em> by Brian Hook (No Starch Press, 2005) describes how to write portable code in C. The book covers operating system variants and hardware variants by giving advice for specific situations, like coping with byte ordering, data type sizes, or line-separator tokens.</p>
</li>
<li>
<p>The article <a href="https://oreil.ly/eZ2CW">“#ifdef Considered Harmful”</a> by Henry Spencer and Geoff Collyer is one of the first that skeptically discusses the use of <code>#ifdef</code> statements. The article elaborates on problems that arise when using them in an unstructured way and provides alternatives.</p>
</li>
<li>
<p>The article <a href="https://oreil.ly/XkTbj">“Writing Portable Code”</a> by Didier Malenfant describes how to structure portable code and which functionality should be put below an abstraction layer.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Outlook" data-type="sect1"><div class="sect1" id="idm45587910632112">
<h1>Outlook</h1>
<p>You are now equipped with more patterns. Next, you’ll learn how to apply these patterns as well as the patterns from the previous chapters. The next chapters cover larger code examples that show the application of all these patterns.</p>
</div></section>
</div></section></div></body></html>