["```cpp\n#define LEFT_BTN  12\n#define RIGHT_BTN  9\n#define FWD_BTN   10\n#define BKWD_BTN  11\n```", "```cpp\n#define GOOD_STATUS  \"OK\"\n#define BAD_STATUS   \"ERROR\"\n#define NO_STATUS    \"UNKNOWN\"\n```", "```cpp\n#define MIN (x,y) x < y ? x : y\n\nint main() {\n  int smaller1 = MIN(9, 5);\n  float smaller2 = MIN(1.414, 3.1415);\n  // ...\n}\n```", "```cpp\nint main() {\n  int smaller1 = 9 < 5 ? 9 : 5;\n  float smaller2 = 1.414 < 3.1415 ? 1.414 : 3.1415;\n}\n```", "```cpp\n#define MIN (x,y) (x) < (y) ? (x) : (y)\n```", "```cpp\ntypedef unsigned char byte;\ntypedef unsigned char uint8_t;\ntypedef unsigned long int uint32_t;\n```", "```cpp\ntypedef struct transaction {\n  double amount;\n  int day, month, year;\n} transaction_t;\n\n// Transaction variables can now be declared like this:\ntransaction_t bill;\ntransaction_t deposit;\n```", "```cpp\ntypedef signed char direction_t;\n```", "```cpp\nconst direction_t STOP     = 0;\nconst direction_t LEFT     = 1;\nconst direction_t RIGHT    = 2;\nconst direction_t FORWARD  = 3;\nconst direction_t BACKWARD = 4;\n```", "```cpp\n// Define the pins we're using for the joystick and the motor\n#define LEFT_BTN  12\n#define RIGHT_BTN  9\n#define FWD_BTN   10\n#define BKWD_BTN  11\n\n#define AIN1 4\n#define AIN2 5\n#define BIN1 6\n#define BIN2 7\n\n// Define our direction type\ntypedef char direction_t;\n\n// Define our direction constants\nconst direction_t STOP     = 0;\nconst direction_t LEFT     = 1;\nconst direction_t RIGHT    = 2;\nconst direction_t FORWARD  = 3;\nconst direction_t BACKWARD = 4;\n\nvoid setup() {\n  // Tell our board we want to write to the built-in LED\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Accept input from the joystick pins\n  pinMode(LEFT_BTN, INPUT_PULLUP);\n  pinMode(RIGHT_BTN, INPUT_PULLUP);\n  pinMode(FWD_BTN, INPUT_PULLUP);\n  pinMode(BKWD_BTN, INPUT_PULLUP);\n\n  // Send output to the motor pins\n  pinMode(AIN1, OUTPUT);\n  pinMode(AIN2, OUTPUT);\n  pinMode(BIN1, OUTPUT);\n  pinMode(BIN2, OUTPUT);\n\n  // And make sure our LED is off\n  digitalWrite(LED_BUILTIN, LOW);\n}\n\nvoid allstop() {\n  digitalWrite(AIN1, LOW);\n  digitalWrite(AIN2, LOW);\n  digitalWrite(BIN1, LOW);\n  digitalWrite(BIN2, LOW);\n}\n\nvoid forward() {\n  digitalWrite(AIN1, LOW);\n  digitalWrite(AIN2, HIGH);\n  digitalWrite(BIN1, HIGH);\n  digitalWrite(BIN2, LOW);\n}\n\nvoid backward() {\n  digitalWrite(AIN1, HIGH);\n  digitalWrite(AIN2, LOW);\n  digitalWrite(BIN1, LOW);\n  digitalWrite(BIN2, HIGH);\n}\n\nvoid left() {\n  digitalWrite(AIN1, HIGH);\n  digitalWrite(AIN2, LOW);\n  digitalWrite(BIN1, LOW);\n  digitalWrite(BIN2, LOW);\n}\n\nvoid right() {\n  digitalWrite(AIN1, LOW);\n  digitalWrite(AIN2, LOW);\n  digitalWrite(BIN1, LOW);\n  digitalWrite(BIN2, HIGH);\n}\n\ndirection_t readDirection() {\n  if (digitalRead(FWD_BTN) == LOW) {\n    return FORWARD;\n  }\n  if (digitalRead(BKWD_BTN) == LOW) {\n    return BACKWARD;\n  }\n  if (digitalRead(LEFT_BTN) == LOW) {\n    return LEFT;\n  }\n  if (digitalRead(RIGHT_BTN) == LOW) {\n    return RIGHT;\n  }\n  // No buttons were pressed, so return STOP\n  return STOP;\n}\n\nvoid loop() {\n  direction_t dir = readDirection();\n  if (dir > 0) { // Driving!\n    digitalWrite(LED_BUILTIN, HIGH);\n    switch (dir) {\n      case FORWARD:\n        forward();\n        break;\n      case BACKWARD:\n        backward();\n        break;\n      case LEFT:\n        left();\n        break;\n      case RIGHT:\n        right();\n        break;\n    }\n  } else {\n    // Stopping, or eventually we could handle errors, too\n    digitalWrite(LED_BUILTIN, LOW);\n    allstop();\n  }\n}\n```", "```cpp\nvoid allstop() {\n  digitalWrite(AIN1, LOW);\n  digitalWrite(AIN2, LOW);\n  digitalWrite(BIN1, LOW);\n  digitalWrite(BIN2, LOW);\n}\n\nvoid forward() {\n  digitalWrite(AIN1, LOW);\n  digitalWrite(AIN2, HIGH);\n  digitalWrite(BIN1, HIGH);\n  digitalWrite(BIN2, LOW);\n}\n\nvoid backward() {\n  digitalWrite(AIN1, HIGH);\n  digitalWrite(AIN2, LOW);\n  digitalWrite(BIN1, LOW);\n  digitalWrite(BIN2, HIGH);\n}\n\nvoid left() {\n  digitalWrite(AIN1, LOW);\n  digitalWrite(AIN2, HIGH);\n  digitalWrite(BIN1, LOW);\n  digitalWrite(BIN2, LOW);\n}\n\nvoid right() {\n  digitalWrite(AIN1, LOW);\n  digitalWrite(AIN2, LOW);\n  digitalWrite(BIN1, HIGH);\n  digitalWrite(BIN2, LOW);\n}\n```", "```cpp\n// Define the pins we're using for the joystick and the motor\n\n#ifndef PINS_H\n#define PINS_H\n\n#define LEFT_BTN  12\n#define RIGHT_BTN  9\n#define FWD_BTN   10\n#define BKWD_BTN  11\n\n#define AIN1 4\n#define AIN2 5\n#define BIN1 6\n#define BIN2 7\n\n#endif /* PINS_H */\n```", "```cpp\n#include \"pins.h\"\n```", "```cpp\n#ifndef SMALLERC_H ![1](Images/1.png)\n#define SMALLERC_H\n\n#include \"Arduino.h\" ![2](Images/2.png)\n#include <SPI.h> ![3](Images/3.png)\n#include <RH_RF69.h> ![4](Images/4.png)\n\n#define RF69_FREQ 915.0 ![5](Images/5.png)\n#define RFM69_CS      4\n#define RFM69_INT     3\n#define RFM69_RST     2\n#define LED          13\n\n#define rc_INIT_SUCCESS  1 ![6](Images/6.png)\n#define rc_INIT_FAILED  -1\n#define rc_FREQ_FAILED  -2\n\n// Define our direction type typedef signed char direction_t;      ![7](Images/7.png)\n\n// Define our directions const direction_t rc_STOP     = 0;\nconst direction_t rc_LEFT     = 1;\nconst direction_t rc_RIGHT    = 2;\nconst direction_t rc_FORWARD  = 3;\nconst direction_t rc_BACKWARD = 4;\n\nchar rc_start();                      ![8](Images/8.png)\nvoid rc_send(int d);\nint  rc_receive();\n\n#endif /* SMALLERC_H */\n```", "```cpp\n#include \"SmalleRC.h\" ![1](Images/1.png)\n\nRH_RF69 rf69(RFM69_CS, RFM69_INT);                    ![2](Images/2.png)\n\nchar rc_start() {                                     ![3](Images/3.png)\n  pinMode(LED, OUTPUT);\n  pinMode(RFM69_RST, OUTPUT);\n  digitalWrite(RFM69_RST, LOW);\n\n  // manual reset\n  digitalWrite(RFM69_RST, HIGH);\n  delay(10);\n  digitalWrite(RFM69_RST, LOW);\n  delay(10);\n\n  if (!rf69.init()) {\n    return rc_INIT_FAILED;\n  }\n\n  if (!rf69.setFrequency(RF69_FREQ)) {\n    return rc_FREQ_FAILED;\n  }\n\n  // range from 14-20 for power\n  // 2nd arg must be true for 69HCW\n  rf69.setTxPower(17, true);\n\n  // The encryption key is up to you, but must be\n  // the same for both the car and the controller\n  uint8_t key[] = {                                   ![4](Images/4.png)\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08\n  };\n  rf69.setEncryptionKey(key);\n\n  pinMode(LED, OUTPUT);\n  return rc_INIT_SUCCESS;\n}\n\nvoid rc_send(direction_t d) {                         ![5](Images/5.png)\n  uint8_t packet[1] = { d };\n  rf69.send(packet, 1);\n  rf69.waitPacketSent();\n}\n\ndirection_t rc_receive() {                            ![6](Images/6.png)\n  uint8_t buf[RH_RF69_MAX_MESSAGE_LEN];\n  uint8_t len = sizeof(buf);\n  if (rf69.recv(buf, &len)) {\n    if (len == 0) {\n      return -1;\n    }\n    buf[len] = 0;\n    return (direction_t)buf[0];\n  }\n  return STOP;\n}\n```", "```cpp\n#ifndef PINS_H\n#define PINS_H\n\n#define AIN1 9\n#define AIN2 8\n#define BIN1 6\n#define BIN2 7\n\n#endif /* PINS_H */\n```", "```cpp\n#include \"pins.h\"\n#include \"SmalleRC.h\"\n\nvoid setup() {\n  Serial.begin(115200);\n  // Send output to the motor pins\n  pinMode(AIN1, OUTPUT);\n  pinMode(AIN2, OUTPUT);\n  pinMode(BIN1, OUTPUT);\n  pinMode(BIN2, OUTPUT);\n\n  if (rc_start() != rc_INIT_SUCCESS) {\n    Serial.println(\"Failed to initialize radio.\");\n  }\n}\n\nvoid loop() {\n  direction_t dir = rc_receive();\n  if (dir > 0) { // Driving!\n    switch (dir) {\n      case rc_FORWARD:\n        forward();\n        break;\n      case rc_BACKWARD:\n        backward();\n        break;\n      case rc_LEFT:\n        left();\n        break;\n      case rc_RIGHT:\n        right();\n        break;\n    }\n    delay(20);\n  } else {\n    // Stopping, or eventually we could handle errors, too\n    allstop();\n  }\n}\n```", "```cpp\n#include \"SmalleRC.h\"\n\n#define LEFT_BTN  9\n#define RIGHT_BTN 7\n#define FWD_BTN   8\n#define BKWD_BTN  6\n\nvoid setup() {\n  Serial.begin(115200);\n  // Accept input from the joystick pins\n  pinMode(LEFT_BTN, INPUT_PULLUP);\n  pinMode(RIGHT_BTN, INPUT_PULLUP);\n  pinMode(FWD_BTN, INPUT_PULLUP);\n  pinMode(BKWD_BTN, INPUT_PULLUP);\n\n  if (rc_start() != rc_INIT_SUCCESS) {\n    Serial.println(\"Failed to initialize radio.\");\n  }\n}\n\ndirection_t readDirection() {\n  if (digitalRead(FWD_BTN) == LOW) {\n    return rc_FORWARD;\n  }\n  if (digitalRead(BKWD_BTN) == LOW) {\n    return rc_BACKWARD;\n  }\n  if (digitalRead(LEFT_BTN) == LOW) {\n    return rc_LEFT;\n  }\n  if (digitalRead(RIGHT_BTN) == LOW) {\n    return rc_RIGHT;\n  }\n  // No buttons were pressed, so return STOP\n  return rc_STOP;\n}\n\nvoid loop() {\n  direction_t dir = readDirection();\n  rc_send(dir);\n  delay(10);\n}\n```", "```cpp\nrc_INIT_SUCCESS LITERAL1\nrc_INIT_FAILED  LITERAL1\nrc_FREQ_FAILED  LITERAL1\n\ndirection_t KEYWORD1\n\nrc_STOP LITERAL1\nrc_LEFT LITERAL1\nrc_RIGHT    LITERAL1\nrc_FORWARD  LITERAL1\nrc_BACKWARD LITERAL1\n\nrc_start    KEYWORD2\nrc_send KEYWORD2\nrc_receive  KEYWORD2\n```"]