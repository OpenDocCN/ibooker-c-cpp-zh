["```cpp\n//---- <Database.h> ---------------- \nclass Database final\n{\n public:\n   static Database& instance()  ![1](assets/1.png)\n   {\n      static Database db;  // The one, unique instance\n      return db;\n   }\n\n   bool write( /*some arguments*/ );\n   bool read( /*some arguments*/ ) const;\n   // ... More database-specific functionality \n   // ... Potentially access to data members \n private:\n   Database() {}  ![2](assets/2.png)\n   Database( Database const& ) = delete;\n   Database& operator=( Database const& ) = delete;\n   Database( Database&& ) = delete;\n   Database& operator=( Database&& ) = delete;\n\n   // ... Potentially some data members };\n\n```", "```cpp\n#include <Database.h>\n#include <cstdlib>\n\nint main()\n{\n   // First access, database object is created\n   Database& db1 = Database::instance();\n   // ...\n\n   // Second access, returns a reference to the same object\n   Database& db2 = Database::instance();\n   assert( &db1 == &db2 );\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n#include <cstdlib>\n\nclass Database\n{\n public:\n   // ... As before\n\n private:\n   Database() = default;  // Compiler generated default constructor\n\n   // ... As before\n};\n\nint main()\n{\n   Database db;    // Does not compile: Default initialization\n   Database db{};  // Works, since value initialization results in aggregate\n                   //   initialization, because Database is an aggregate type\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <Widget.h> ----------------\n\n#include <Database.h>\n\nclass Widget\n{\n public:\n   void doSomething( /*some arguments*/ )\n   {\n      // ...\n      Database::instance().read( /*some arguments*/ );\n      // ...\n   }\n};\n\n//---- <Gadget.h> ----------------\n\n#include <Database.h>\n\nclass Gadget\n{\n public:\n   void doSomething( /*some arguments*/ )\n   {\n      // ...\n      Database::instance().write( /*some arguments*/ );\n      // ...\n   }\n};\n```", "```cpp\n#include <array>\n#include <cstddef>\n#include <cstdlib>\n#include <memory_resource>\n#include <string>\n#include <vector>\n// ... \nint main()\n{\n   std::array<std::byte,1000> raw;  // Note: not initialized! \n   std::pmr::monotonic_buffer_resource\n      buffer{ raw.data(), raw.size(), std::pmr::null_memory_resource() };  ![1](assets/1.png)\n\n   std::pmr::vector<std::pmr::string> strings{ &buffer };\n\n   // ... \n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\n#include <memory_resource>\n// ... \nint main()\n{\n   // ... \n   std::pmr::monotonic_buffer_resource\n      buffer{ raw.data(), raw.size(), std::pmr::get_default_resource() };  ![2](assets/2.png)\n\n   // ... \n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nnamespace std::pmr {\n\nmemory_resource* set_default_resource(memory_resource* r) noexcept;\n\n} // namespace std::pmr\n```", "```cpp\n// ... \nint main()\n{\n   // ... \n   std::pmr::set_default_resource( std::pmr::null_memory_resource() );  ![3](assets/3.png)\n\n   std::pmr::monotonic_buffer_resource\n      buffer{ raw.data(), raw.size(), std::pmr::get_default_resource() };\n\n   // ... \n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\n//---- <CustomAllocator.h> ----------------\n\n#include <memory_resource>\n\nclass CustomAllocator : public std::pmr::memory_resource\n{\n public:\n   // There is no need to enforce a single instance\n   CustomAllocator( /*...*/ );\n   // No explicitly declared copy or move operations\n\n private:\n   void* do_allocate( size_t bytes, size_t alignment ) override;\n\n   void do_deallocate( void* ptr, size_t bytes,\n                       size_t alignment ) override;\n\n   bool do_is_equal(\n      std::pmr::memory_resource const& other ) const noexcept override;\n\n   // ...\n};\n```", "```cpp\n#include <CustomAllocator.h>\n\nint main()\n{\n   // ...\n   CustomAllocator custom_allocator{ /*...*/ };\n\n   std::pmr::set_default_resource( &custom_allocator );  ![4](assets/4.png)\n   // ... }\n\n```", "```cpp\nint main()\n{\n   // The one and only system-wide clock has no lifetime dependencies.\n   // Thus it is created first\n   SystemClock clock{ /*...*/ };\n\n   // The one and only system-wide configuration depends on the clock.\n   SystemConfiguration config{ &clock, /*...*/ };\n\n   // ...\n}\n```", "```cpp\n//---- <PersistenceInterface.h> ---------------- \nclass PersistenceInterface  ![5](assets/5.png)\n{\n public:\n   virtual ~PersistenceInterface() = default;\n\n   bool read( /*some arguments*/ ) const  ![6](assets/6.png)\n   {\n      return do_read( /*...*/ );\n   }\n   bool write( /*some arguments*/ )  ![7](assets/7.png)\n   {\n      return do_write( /*...*/ );\n   }\n\n   // ... More database specific functionality \n private:\n   virtual bool do_read( /*some arguments*/ ) const = 0;  ![6](assets/6.png)\n   virtual bool do_write( /*some arguments*/ ) = 0;  ![7](assets/7.png)\n};\n\nPersistenceInterface* get_persistence_interface();  ![8](assets/8.png)\nvoid set_persistence_interface( PersistenceInterface* persistence );  ![9](assets/9.png)\n\n// Declaration of the one 'instance' variable extern PersistenceInterface* instance;  ![10](assets/10.png)\n\n```", "```cpp\n//---- <Database.h> ----------------\n\nclass Database : public PersistenceInterface\n{\n public:\n   // ... Potentially access to data members\n\n   // Make the class immobile by deleting the copy and move operations\n   Database( Database const& ) = delete;\n   Database& operator=( Database const& ) = delete;\n   Database( Database&& ) = delete;\n   Database& operator=( Database&& ) = delete;\n\n private:\n   bool do_read( /*some arguments*/ ) const override;\n   bool do_write( /*some arguments*/ ) override;\n   // ... More database-specific functionality\n\n   // ... Potentially some data members\n};\n```", "```cpp\n//---- <PersistenceInterface.cpp> ---------------- \n#include <Database.h>\n\n// Definition of the one 'instance' variable PersistenceInterface* instance = nullptr;\n\nPersistenceInterface* get_persistence_interface()\n{\n   // Local object, initialized by an\n   //   'Immediately Invoked Lambda Expression (IILE)'\n   static bool init = [](){  ![11](assets/11.png)\n      if( !instance ) {\n         static Database db;\n         instance = &db;\n      }\n      return true;  // or false, as the actual value does not matter.\n   }();  // Note the '()' after the lambda expression. This invokes the lambda. \n   return instance;\n}\n\nvoid set_persistence_interface( PersistenceInterface* persistence )\n{\n   instance = persistence;\n}\n\n```", "```cpp\n#include <PersistenceInterface.h>\n#include <cstdlib>\n\nint main()\n{\n   // First access, database object is created\n   PersistenceInterface* persistence = get_persistence_interface();\n\n   // ...\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\ntemplate< typename T >\nvoid f( T& value )\n{\n   // ...\n   T other = std::move(value);  // Very bad move (literally)!\n   // ...\n}\n```", "```cpp\n//---- <Widget.h> ----------------\n\n#include <PersistenceInterface.h>\n\nclass Widget\n{\n public:\n   Widget( PersistenceInterface* persistence )  // Dependency injection\n      : persistence_(persistence)\n   {}\n\n   void doSomething( /*some arguments*/ )\n   {\n      // ...\n      persistence_->read( /*some arguments*/ );\n      // ...\n   }\n\n private:\n   PersistenceInterface* persistence_{};\n};\n```", "```cpp\n//---- <Widget.h> ----------------\n\n#include <PersistenceInterface.h>\n\nclass Widget\n{\n public:\n   void doSomething( PersistenceInterface* persistence, /*some arguments*/ )\n   {\n      // ...\n      persistence->read( /*some arguments*/ );\n      // ...\n   }\n};\n```", "```cpp\n//---- <Widget.h> ---------------- \n#include <PersistenceInterface.h>\n\nclass Widget\n{\n public:\n   void doSomething( /*some arguments*/ )  ![12](assets/12.png)\n   {\n      doSomething( get_persistence_interface(), /*some arguments*/ );\n   }\n\n   void doSomething( PersistenceInterface* persistence, /*some arguments*/ )  ![13](assets/13.png)\n   {\n      // ...\n      persistence->read( /*some arguments*/ );\n      // ...\n   }\n};\n\n```"]