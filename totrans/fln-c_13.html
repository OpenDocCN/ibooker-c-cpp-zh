<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 11. Building a User Management System" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_story_rbac">
<h1><span class="label">Chapter 11. </span>Building a User Management System</h1>
<p>This chapter tells the story of applying the patterns from <a data-type="xref" href="part01.xhtml#part_1">Part I</a> of this book to a running example. With that example, it illustrates how design choices made with the aid of patterns provide benefits and support for programmers. This chapter’s running example is abstracted from an industrial-strength implementation of a user management system.</p>
<section data-pdf-bookmark="The Pattern Story" data-type="sect1"><div class="sect1" id="idm45587908596208">
<h1>The Pattern Story</h1>
<p>Imagine<a data-primary="user management system example" data-secondary="context" data-type="indexterm" id="idm45587908594576"/> you are fresh from university and start working for a software development company. Your boss hands you a product specification for a piece of software that stores usernames and passwords and tells you to implement it. The software should provide functionality to check whether a provided password for a user is correct and functionality to create, delete, and view existing users.</p>
<p>You are eager to show your boss that you are a good programmer, but before you even start, your mind fills with questions. Should you write all code into a single file? You know from your studies that this is bad practice, but what’s a good number of files? Which parts of the code will you put into the same files?  Should you check the input parameters for each function? Should your functions return detailed error information? At university you learned how to build a software program that works, but you did not learn how to write good code that is maintainable. So what should you do? How do you start?</p>
<section data-pdf-bookmark="Data Organization" data-type="sect2"><div class="sect2" id="idm45587908592960">
<h2>Data Organization</h2>
<p>To<a data-primary="design patterns" data-secondary="selecting" data-type="indexterm" id="idm45587908591456"/><a data-primary="user management system example" data-secondary="data organization" data-type="indexterm" id="idm45587908590448"/><a data-primary="data storage" data-secondary="selecting patterns for" data-type="indexterm" id="idm45587908589536"/> answer your questions, start by reviewing the patterns in this book to get guidance on how to build good C programs. Begin with the part of your system that stores the usernames and passwords. Your questions should now focus on how to store the data in your program. Should you store it in global variables? Should you hold the data in local variables inside a function? Should you allocate dynamic memory?</p>
<p>First, consider the exact problem that you want to solve in your application: you are not sure how to store the username data. Currently, there is no need to make this data persistent; you simply want to be able to build up and access this data at runtime. Also, you don’t want the caller of your functions to have to cope with explicit allocation and initialization of the data.</p>
<p>Next, look for patterns that address your specific problem. Review the C patterns on data lifetime and ownership from <a data-type="xref" href="ch05.xhtml#chapter_lifetime">Chapter 5</a>, which addresses the issue of who is responsible of holding which data. Read through all the problem sections of these patterns and find one pattern that matches your problem very well and describes consequences which are acceptable to you. That pattern is the<a data-primary="data lifetime and ownership" data-secondary="Software-Module with Global State pattern" data-type="indexterm" id="idm45587908586704"/><a data-primary="Software-Module with Global State pattern" data-type="indexterm" id="idm45587908585824"/> Software-Module with Global State pattern, which suggests having<a data-primary="memory management" data-secondary="Eternal Memory pattern" data-type="indexterm" id="idm45587908585056"/><a data-primary="Eternal Memory pattern" data-type="indexterm" id="idm45587908584112"/> Eternal Memory in the form of global variables with scope limited to the file in order for that data to be accessed from within that file.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Software-Module with Global State</p></td>
<td><p>Have one global instance to let your related functions share common resources. Put all functions that operate on this instance into one header file and provide the caller this interface to your software-module.</p></td>
</tr>
<tr>
<td><p>Eternal Memory</p></td>
<td><p>Put your data into memory that is available throughout the whole lifetime of your program.</p></td>
</tr>
</tbody>
</table>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#</code><code class="cp">define MAX_SIZE 50</code><code class="cp">
</code><code class="cp">#</code><code class="cp">define MAX_USERS 50</code><code class="cp">
</code><code class="w">
</code><code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">name</code><code class="p">[</code><code class="n">MAX_SIZE</code><code class="p">]</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">pwd</code><code class="p">[</code><code class="n">MAX_SIZE</code><code class="p">]</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="n">USER</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">static</code><code class="w"> </code><code class="n">USER</code><code class="w"> </code><code class="n">userList</code><code class="p">[</code><code class="n">MAX_USERS</code><code class="p">]</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_building_a_user_management_system_CO1-1" id="co_building_a_user_management_system_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_building_a_user_management_system_CO1-1" id="callout_building_a_user_management_system_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The <code>userList</code> contains the data for your users. It is accessible within the implementation file. Because it is kept in the static memory, there is no need to manually allocate it (which would make the code more flexible, but also more complicated).</p></dd>
</dl>
<div data-type="warning" epub:type="warning"><h1>Storing Passwords</h1>
<p>In<a data-primary="salted hash values" data-type="indexterm" id="idm45587908534656"/><a data-primary="passwords" data-type="indexterm" id="idm45587908533920"/> this simplified example, we keep the password in plain text. Never, ever do this in real-life applications. When storing passwords, you should instead store a <a href="https://oreil.ly/5y7yO">salted hash value</a> of the plain text password.</p>
</div>
</div></section>
<section data-pdf-bookmark="File Organization" data-type="sect2"><div class="sect2" id="idm45587908532080">
<h2>File Organization</h2>
<p>Next, define<a data-primary="user management system example" data-secondary="file organization" data-type="indexterm" id="idm45587908530352"/> an interface for your caller. Make sure that it is easy for you to change your implementation later on without requiring the caller to change any code. Now you have to decide which part of your program should be defined in the interface and which part should be defined in your implementation file.</p>
<p>Solve this problem by using<a data-primary="APIs, flexible" data-secondary="Header Files pattern" data-type="indexterm" id="idm45587908494848"/><a data-primary="Header Files pattern" data-type="indexterm" id="idm45587908493968"/> Header Files. Put as few things as possible (only those things that are relevant to the caller) into the interface (<em>.h</em> file). All the rest goes into your implementation files (<em>.c</em> files). To protect against multiple inclusion of header files, implement an<a data-primary="files, organizing in modular programs" data-secondary="Include Guard pattern" data-type="indexterm" id="idm45587908492240"/><a data-primary="Include Guard pattern" data-type="indexterm" id="idm45587908491296"/> Include Guard.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Header Files</p></td>
<td><p>Provide function declarations in your API for any functionality you want to provide to your user. Hide any internal functions, internal data, and your function definitions (the implementations) in your implementation file and don’t provide this implementation file to the user.</p></td>
</tr>
<tr>
<td><p>Include Guard</p></td>
<td><p>Protect the content of your header files against multiple inclusion so that the developer using the header files does not have to care whether it is included multiple times. Use an interlocked <code>#ifdef</code> statement or a <code>#pragma once</code> statement to achieve this.</p></td>
</tr>
</tbody>
</table>
<p><em>user.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#ifndef USER_H</code>
<code class="cp">#define USER_H</code>

<code class="cp">#define MAX_SIZE 50</code>

<code class="cp">#endif</code></pre>
<p><br/><em>user.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">"user.h"</code><code class="cp"/>

<code class="cp">#define MAX_USERS 50</code>

<code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">name</code><code class="p">[</code><code class="n">MAX_SIZE</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">pwd</code><code class="p">[</code><code class="n">MAX_SIZE</code><code class="p">];</code><code class="w"/>
<code class="p">}</code><code class="n">USER</code><code class="p">;</code><code class="w"/>

<code class="k">static</code><code class="w"> </code><code class="n">USER</code><code class="w"> </code><code class="n">userList</code><code class="p">[</code><code class="n">MAX_USERS</code><code class="p">];</code><code class="w"/></pre>
<p>Now the caller can use the defined <code>MAX_SIZE</code> to know how long the strings provided to the software-module can be. By convention, the caller knows that everything in the <em>.h</em> file can be used but that nothing in the <em>.c</em> file should be used.</p>
<p>Next, make sure that your code files are well separated from your caller’s code to avoid name clashes. Should you put all your files into one directory, or should you, for example, have all <em>.h</em> files in the whole codebase in one directory to make it easier to include them?</p>
<p>Create<a data-primary="Software-Module Directories pattern" data-type="indexterm" id="idm45587908387376"/><a data-primary="files, organizing in modular programs" data-secondary="Software-Module Directories pattern" data-type="indexterm" id="idm45587908386672"/> a Software-Module Directory and put all your files for your software-module, the interfaces and the implementations, into one directory.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Software-Module Directories</p></td>
<td><p>Put header files and implementation files that belong to a tightly coupled functionality into one directory. Name that directory after the functionality that is provided via the header files.</p></td>
</tr>
</tbody>
</table>
<p>With the directory structure shown in <a data-type="xref" href="#fig_story2">Figure 11-1</a>, it is now possible to easily spot all files that are related to your code. Now you don’t have to worry that the names of your implementation files will clash with other filenames.</p>
<figure><div class="figure" id="fig_story2">
<img alt="fluc 1101" src="assets/fluc_1101.png" width="150"/>
<h6><span class="label">Figure 11-1. </span>File structure</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Authentication: Error Handling" data-type="sect2"><div class="sect2" id="idm45587908531456">
<h2>Authentication: Error Handling</h2>
<p>Now<a data-primary="authentication" data-secondary="error handling" data-type="indexterm" id="idm45587908376384"/><a data-primary="user management system example" data-secondary="authentication" data-tertiary="error handling" data-type="indexterm" id="idm45587908375376"/> it is time to implement the first functionality to access the data. Start by implementing a function that checks whether a provided password matches the previously saved password for a provided user. Define the behavior of the function by declaring the function in the header file and documenting that behavior with code comments next to the function declaration.</p>
<p>The function should let the caller know whether the provided password is correct for a provided user. Tell the caller by using the<a data-primary="C functions, returning data from" data-secondary="Return Value pattern" data-type="indexterm" id="idm45587908373632"/><a data-primary="Return Value pattern" data-type="indexterm" id="idm45587908372640"/> Return Value of the function. But which information should you return? Should you provide the caller with any error information that occurs?</p>
<p class="fix-tracking">Only<a data-primary="error information, returning" data-secondary="Return Relevant Errors pattern" data-type="indexterm" id="idm45587908371024"/><a data-primary="Return Relevant Errors pattern" data-type="indexterm" id="idm45587908369984"/> Return Relevant Errors because for any security-related functionality, it is common to provide only the information that you must provide and no more. Don’t let the caller know whether the provided user does not exist or whether the provided password is wrong. Instead, simply tell the caller whether authentication 
<span class="keep-together">worked or not</span>.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Return Value</p></td>
<td><p>Simply use the one C mechanism intended to retrieve information about the result of a function call: the Return Value. The mechanism to return data in C copies the function result and provides the caller access to this copy.</p></td>
</tr>
<tr>
<td><p>Return Relevant Errors</p></td>
<td><p>Only return error information to the caller if that information is relevant to the caller. Error information is only relevant to the caller if the caller can react to that information.</p></td>
</tr>
</tbody>
</table>
<p><em>user.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Returns true if the provided username exists and</code>
<code class="cm">   if the provided password is correct for that user. */</code><code class="w"/>
<code class="kt">bool</code><code class="w"> </code><code class="nf">authenticateUser</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">username</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">pwd</code><code class="p">);</code><code class="w"/></pre>
<p>This code defines which value is returned by the function very well, but it does not specify the behavior in case of invalid input. How should you cope with invalid input like <code>NULL</code> pointers? Should you check against <code>NULL</code> pointers, or should you simply ignore invalid input?</p>
<p>Require your user to provide valid input, because invalid input would be a programming error of that user, and such errors should not go unnoticed. According to the<a data-primary="Samurai Principle pattern" data-type="indexterm" id="idm45587908340800"/><a data-primary="error handling" data-secondary="Samurai Principle pattern" data-type="indexterm" id="idm45587908340192"/> Samurai Principle, you abort the program in case of invalid input and document that behavior in the header file.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Samurai Principle</p></td>
<td><p>Return from a function victorious or not at all. If there is a situation for which you know that an error cannot be handled, then abort the program.</p></td>
</tr>
</tbody>
</table>
<p><em>user.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Returns true if the provided username exists and</code>
<code class="cm">   if the provided password is correct for that user,</code>
<code class="cm">   returns false otherwise. Asserts in case of invalid</code>
<code class="cm">   input (NULL string) */</code><code class="w"/>
<code class="kt">bool</code><code class="w"> </code><code class="nf">authenticateUser</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">username</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">pwd</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>user.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">bool</code><code class="w"> </code><code class="nf">authenticateUser</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">username</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">pwd</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">assert</code><code class="p">(</code><code class="n">username</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">assert</code><code class="p">(</code><code class="n">pwd</code><code class="p">);</code><code class="w"/>

<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">MAX_USERS</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">strcmp</code><code class="p">(</code><code class="n">username</code><code class="p">,</code><code class="w"> </code><code class="n">userList</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">name</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"/>
<code class="w">       </code><code class="n">strcmp</code><code class="p">(</code><code class="n">pwd</code><code class="p">,</code><code class="w"> </code><code class="n">userList</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">pwd</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>With the Samurai Principle, you take the burden from your caller of checking for specific return values indicating invalid input. Instead, for invalid input the program crashes. You chose to use explicit <code>assert</code> statements instead of letting the program crash in an uncontrolled way (e.g., by passing invalid input to the <code>strcmp</code> function), In the context of security-critical applications, you want your program to have a defined behavior even in error situations.</p>
<p>At first glance, letting the program crash looks like a brutal solution, but with that behavior, calls with invalid parameters do not go unnoticed. Over the long term, this strategy makes the code more reliable. It does not let subtle bugs, like invalid parameters, manifest and show up somewhere else in the caller’s code.</p>
</div></section>
<section data-pdf-bookmark="Authentication: Error Logging" data-type="sect2"><div class="sect2" id="idm45587908186000">
<h2>Authentication: Error Logging</h2>
<p>Next, keep<a data-primary="authentication" data-secondary="error logging" data-type="indexterm" id="idm45587908184112"/><a data-primary="user management system example" data-secondary="authentication" data-tertiary="error logging" data-type="indexterm" id="idm45587908183104"/> track of callers who provide you with the wrong password. Log Errors<a data-primary="error information, returning" data-secondary="Log Errors pattern" data-type="indexterm" id="idm45587908181792"/><a data-primary="Log Errors pattern" data-type="indexterm" id="idm45587908180880"/> if your <code>authenticateUser</code> function fails so this information is available for security audits later on. For logging, either take the code from <a data-type="xref" href="ch10.xhtml#chapter_story_logging">Chapter 10</a> or implement a simpler version for logging as shown in the following.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Log Errors</p></td>
<td><p>Use different channels to provide error information that is relevant for the calling code and error information that is relevant for the developer. For example, write debug error information into a log file and don’t return the detailed debug error information to the caller.</p></td>
</tr>
</tbody>
</table>
<p>It is difficult to provide this logging mechanism on different platforms—for example on Linux as well as on Windows—because the different operating systems provide different functions for accessing files. Also, multiplatform code is hard to implement and maintain. So how can you implement your logging functionality as simply as possible? Make sure to<a data-primary="#ifdef statements" data-secondary="avoiding poorly implemented" data-tertiary="Avoid Variants pattern" data-type="indexterm" id="idm45587908098800"/><a data-primary="Avoid Variants pattern" data-type="indexterm" id="idm45587908097712"/> Avoid Variants and to use standardized functions, which are available on all platforms.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Avoid Variants</p></td>
<td><p>Use standardized functions that are available on all platforms. If there are no standardized functions, consider not implementing the functionality.</p></td>
</tr>
</tbody>
</table>
<p>Luckily, the C standard defines functions for accessing files, and these can be used on Windows and Linux systems. While there are operating system–specific functions for accessing files which might be more performant or might provide you with operating system–specific features, these are not necessary here. Simply use the file access functions defined by the C standard.</p>
<p>To implement your logging functionality, call the following function if the wrong password was provided:</p>
<p class="pagebreak-before"><em>user.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">logError</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">username</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">logString</code><code class="p">[</code><code class="mi">200</code><code class="p">]</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="n">sprintf</code><code class="p">(</code><code class="n">logString</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">Failed login. User:%s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">username</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="kt">FILE</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fopen</code><code class="p">(</code><code class="s">"</code><code class="s">logfile</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">a+</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_building_a_user_management_system_CO2-1" id="co_building_a_user_management_system_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="n">fwrite</code><code class="p">(</code><code class="n">logString</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">strlen</code><code class="p">(</code><code class="n">logString</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">f</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="n">fclose</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_building_a_user_management_system_CO2-1" id="callout_building_a_user_management_system_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Use the platform-independent functions <code>fopen</code>, <code>fwrite</code>, and <code>fclose</code>. This code works on Windows and Linux platforms, and there are no nasty <code>#ifdef</code> statements to handle the platform variants.</p></dd>
</dl>
<p>For storing the log information, the code uses<a data-primary="memory management" data-secondary="Stack First pattern" data-type="indexterm" id="idm45587908014288"/><a data-primary="Stack First pattern" data-type="indexterm" id="idm45587908013312"/><a data-primary="data storage" data-secondary="stack first approach" data-type="indexterm" id="idm45587908012640"/> Stack First, because the log message is small enough to fit on the stack. This is also easiest for you because you don’t have to deal with memory cleanup.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Stack First</p></td>
<td><p>Simply put your variables on the stack by default to profit from automatic cleanup of stack variables.</p></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Adding Users: Error Handling" data-type="sect2"><div class="sect2" id="idm45587908185408">
<h2>Adding Users: Error Handling</h2>
<p>Looking<a data-primary="user management system example" data-secondary="adding users" data-type="indexterm" id="idm45587907961200"/> at the whole code, you now have a function to check whether a password is correct for a username stored in your list, but your list of users is still empty. To fill your list of users, implement a function that allows the caller to add new users.</p>
<p>Make sure that the usernames are unique, and let the caller know whether adding the new user worked or not, either because the username already exists or because there is no more space in your user list.</p>
<p>Now you have to decide how you want to inform the caller about these error situations. Should you use the Return Value to return this information, or should you set the <code>errno</code> variable? Additionally, what kind of information will you provide the caller, and what data type will you use to return that information?</p>
<p>In this instance, Return Status Codes<a data-primary="error information, returning" data-secondary="Return Status Codes pattern" data-type="indexterm" id="idm45587907958080"/><a data-primary="Return Status Codes pattern" data-type="indexterm" id="idm45587907957168"/> because you have different error situations and you want to inform your caller about these different situations. In addition, in case of invalid parameters, abort the program (Samurai Principle). Define the error codes in your interface to allow you and your caller to have a mutual understanding of how the error codes map to different error situations so the caller can react accordingly.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Return Status Codes</p></td>
<td><p>Use the Return Value of a function to return status information. Return a value that represents a specific status. Both of you as the callee and the caller must have a mutual understanding of what the value means.</p></td>
</tr>
</tbody>
</table>
<p class="pagebreak-before"><em>user.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">typedef</code><code class="w"> </code><code class="k">enum</code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">USER_SUCCESSFULLY_ADDED</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="n">USER_ALREADY_EXISTS</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="n">USER_ADMINISTRATION_FULL</code><code class="w"/>
<code class="p">}</code><code class="n">USER_ERROR_CODE</code><code class="p">;</code><code class="w"/>

<code class="cm">/* Adds a new user with the provided `username' and the provided password</code>
<code class="cm">   `pwd' (asserts on NULL). Returns USER_SUCCESSFULLY_ADDED on success,</code>
<code class="cm">   USER_ALREADY_EXISTS if a user with the provided username already exists</code>
<code class="cm">   and USER_ADMINISTRATION_FULL if no more users can be added. */</code><code class="w"/>
<code class="n">USER_ERROR_CODE</code><code class="w"> </code><code class="nf">addUser</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">username</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">pwd</code><code class="p">);</code><code class="w"/></pre>
<p>Next, implement the <code>addUser</code> function. Check whether such a user already exists and then add the user. To separate these tasks, perform<a data-primary="error handling" data-secondary="Function Split pattern" data-type="indexterm" id="idm45587907884272"/><a data-primary="Function Split pattern" data-type="indexterm" id="idm45587907883392"/> a Function Split to split the different tasks and responsibilities into different functions. First, implement a function to check whether the user already exists.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Function Split</p></td>
<td><p>Split up the function. Take a part of a function that seems useful on its own, create a new function with that, and call that function.</p></td>
</tr>
</tbody>
</table>
<p><em>user.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">static</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="nf">userExists</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">username</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">MAX_USERS</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">strcmp</code><code class="p">(</code><code class="n">username</code><code class="p">,</code><code class="w"> </code><code class="n">userList</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">name</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This function can now be called inside the function that adds new users in order to add new users only if they don’t yet exist. Should you check for existing users at the beginning of the function or right before you add the user to the list? Which of these alternatives would make your function easier to read and maintain?</p>
<p>Implement a<a data-primary="error handling" data-secondary="Guard Clause pattern" data-type="indexterm" id="idm45587907756992"/><a data-primary="Guard Clause pattern" data-type="indexterm" id="idm45587907788720"/> Guard Clause at the beginning of the function that will return immediately if the action cannot be performed because the user already exists. A check right at the beginning of the function makes it easier to follow the program flow.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Guard Clause</p></td>
<td><p>Check whether you have pre-conditions and immediately return from the function if these pre-conditions are not met.</p></td>
</tr>
</tbody>
</table>
<p class="pagebreak-before"><em>user.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="n">USER_ERROR_CODE</code><code class="w"> </code><code class="nf">addUser</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">username</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">pwd</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">assert</code><code class="p">(</code><code class="n">username</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">assert</code><code class="p">(</code><code class="n">pwd</code><code class="p">);</code><code class="w"/>

<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">userExists</code><code class="p">(</code><code class="n">username</code><code class="p">))</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">USER_ALREADY_EXISTS</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">MAX_USERS</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">strcmp</code><code class="p">(</code><code class="n">userList</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="s">""</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">userList</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">username</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">strcpy</code><code class="p">(</code><code class="n">userList</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">pwd</code><code class="p">,</code><code class="w"> </code><code class="n">pwd</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">USER_SUCCESSFULLY_ADDED</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">USER_ADMINISTRATION_FULL</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>With the implemented code fragments so far, you can fill your user administration with users and to check whether a provided password is correct for these users.</p>
</div></section>
<section data-pdf-bookmark="Iterating" data-type="sect2"><div class="sect2" id="idm45587907962176">
<h2>Iterating</h2>
<p>Next, provide<a data-primary="user management system example" data-secondary="iterating" data-type="indexterm" id="idm45587907569632"/> some functionality to read out all usernames by implementing an iterator. While you may want to simply provide an interface that lets the caller access the <code>userList</code> array by index, you’d be in trouble if the underlying data structure changes (for example, to a linked list), or if the caller wants to access the array while another caller modifies the array.</p>
<p>To provide an iterator interface to the caller that solves the mentioned issues, implement a<a data-primary="iterator interfaces" data-secondary="Cursor Iterator pattern" data-type="indexterm" id="idm45587907567712"/><a data-primary="Cursor Iterator pattern" data-type="indexterm" id="idm45587907566736"/> Cursor Iterator, which uses a<a data-primary="APIs, flexible" data-secondary="Handle pattern" data-type="indexterm" id="idm45587907565936"/><a data-primary="Handle pattern" data-type="indexterm" id="idm45587907564992"/> Handle to hide the underlying data structure from the caller.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Cursor Iterator</p></td>
<td><p>Create an iterator instance that points to an element in the underlying data structure. An iteration function takes this iterator instance as argument, retrieves the element the iterator currently points to, and modifies the iteration instance to point to the next element. The user then iteratively calls this function to retrieve one element at a time.</p></td>
</tr>
<tr>
<td><p>Handle</p></td>
<td><p>Have a function to create the context on which the caller operates and return an abstract pointer to internal data for that context. Require the caller to pass that pointer to all your functions, which can then use the internal data to store state information and resources.</p></td>
</tr>
</tbody>
</table>
<p><em>user.h</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">ITERATOR</code><code class="p">;</code><code class="w"/>

<code class="cm">/* Create an iterator instance. Returns NULL on error. */</code><code class="w"/>
<code class="n">ITERATOR</code><code class="w"> </code><code class="nf">createIterator</code><code class="p">();</code><code class="w"/>

<code class="cm">/* Retrieves the next element from an iterator instance. */</code><code class="w"/>
<code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="nf">getNextElement</code><code class="p">(</code><code class="n">ITERATOR</code><code class="w"> </code><code class="n">iterator</code><code class="p">);</code><code class="w"/>

<code class="cm">/* Destroys an iterator instance. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">destroyIterator</code><code class="p">(</code><code class="n">ITERATOR</code><code class="w"> </code><code class="n">iterator</code><code class="p">);</code><code class="w"/></pre>
<p>The caller has full control of when to create and destroy the iterator. Thus, you have<a data-primary="memory management" data-secondary="Dedicated Ownership pattern" data-type="indexterm" id="idm45587907503136"/><a data-primary="Dedicated Ownership pattern" data-type="indexterm" id="idm45587907528896"/> Dedicated Ownership with a<a data-primary="data lifetime and ownership" data-secondary="Caller-Owned Instance pattern" data-type="indexterm" id="idm45587907528160"/><a data-primary="Caller-Owned Instance pattern" data-type="indexterm" id="idm45587907527312"/> Caller-Owned Instance. The caller can simply create the iterator Handle and use it to access the list of usernames. If creation fails, then<a data-primary="error information, returning" data-secondary="Special Return Values pattern" data-type="indexterm" id="idm45587907526384"/><a data-primary="Special Return Values pattern" data-type="indexterm" id="idm45587907525024"/> the Special Return Value <code>NULL</code> indicates this. Having this Special Return Value instead of explicit error codes makes using the function easier because no additional function parameters are needed to return error information. When the caller is done with iterating, the caller can destroy the Handle.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Dedicated Ownership</p></td>
<td><p>Right at the time when you implement memory allocation, clearly define where it’s going to be cleaned up and who is going to do that.</p></td>
</tr>
<tr>
<td><p>Caller-Owned Instance</p></td>
<td><p>Require the caller to pass an instance, which is used to store resource and state information, along to your functions. Provide explicit functions to create and destroy these instances, so that the caller can determine their lifetime.</p></td>
</tr>
<tr>
<td><p>Special Return Values</p></td>
<td><p>Use the Return Value of your function to return the data computed by the function. Reserve one or more special values to be returned if an error occurs.</p></td>
</tr>
</tbody>
</table>
<p>Because the interface provides the caller with explicit functions to create and destroy the iterator, this naturally leads to separate functions for initializing and cleaning up the resources for your iterator in the implementation. This<a data-primary="error handling" data-secondary="Object-Based Error Handling pattern" data-type="indexterm" id="idm45587907515904"/><a data-primary="Object-Based Error Handling pattern" data-type="indexterm" id="idm45587907514912"/> Object-based Error Handling brings the advantage of nicely separated responsibilities in your functions, which makes them easier to extend if necessary later on. You can see this separation in the following code where all initialization code is in one function, and all cleanup code is in another function.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Object-Based Error Handling</p></td>
<td><p>Put initialization and cleanup into separate functions, similar to the concept of constructors and destructors in object-oriented programming.</p></td>
</tr>
</tbody>
</table>
<p class="pagebreak-before"><em>user.c</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">currentPosition</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">currentElement</code><code class="p">[</code><code class="n">MAX_SIZE</code><code class="p">];</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">ITERATOR</code><code class="w"> </code><code class="nf">createIterator</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">ITERATOR</code><code class="w"> </code><code class="n">iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">ITERATOR</code><code class="p">)</code><code class="w"> </code><code class="n">calloc</code><code class="p">(</code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="p">),</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">iterator</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="nf">getNextElement</code><code class="p">(</code><code class="n">ITERATOR</code><code class="w"> </code><code class="n">iterator</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">currentPosition</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">MAX_USERS</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">currentElement</code><code class="p">,</code><code class="n">userList</code><code class="p">[</code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">currentPosition</code><code class="p">].</code><code class="n">name</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">currentPosition</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">else</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">currentElement</code><code class="p">,</code><code class="w"> </code><code class="s">""</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">currentElement</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">destroyIterator</code><code class="p">(</code><code class="n">ITERATOR</code><code class="w"> </code><code class="n">iterator</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">free</code><code class="p">(</code><code class="n">iterator</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>When implementing the preceding code, how should you provide the username data to the caller? Should you simply provide the caller with a pointer to that data? If you copy that data into a buffer, who should allocate it?</p>
<p>In this situation, the<a data-primary="C functions, returning data from" data-secondary="Callee Allocates pattern" data-type="indexterm" id="idm45587907352464"/><a data-primary="Callee Allocates pattern" data-type="indexterm" id="idm45587907351616"/> Callee Allocates the string buffer. This makes it possible for the caller to have full access to that string without having the possibility of changing the data in the <code>userList</code>. Additionally, the caller avoids accessing data that might be changed by other callers at the same time.</p>
<table>
<thead>
<tr>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Callee Allocates</p></td>
<td><p>Allocate a buffer with the required size inside the function that provides the large, complex data. Copy the required data into the buffer and return a pointer to that buffer.</p></td>
</tr>
</tbody>
</table>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Using the User Management System" data-type="sect2"><div class="sect2" id="idm45587907570608">
<h2>Using the User Management System</h2>
<p>You<a data-primary="user management system example" data-secondary="using the system" data-type="indexterm" id="idm45587907283792"/> have now completed your user management code. The following code shows how to use that user management system:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">element</code><code class="p">;</code><code class="w"/>
<code class="n">addUser</code><code class="p">(</code><code class="s">"A"</code><code class="p">,</code><code class="w"> </code><code class="s">"pass"</code><code class="p">);</code><code class="w"/>
<code class="n">addUser</code><code class="p">(</code><code class="s">"B"</code><code class="p">,</code><code class="w"> </code><code class="s">"pass"</code><code class="p">);</code><code class="w"/>
<code class="n">addUser</code><code class="p">(</code><code class="s">"C"</code><code class="p">,</code><code class="w"> </code><code class="s">"pass"</code><code class="p">);</code><code class="w"/>

<code class="n">ITERATOR</code><code class="w"> </code><code class="n">it</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">createIterator</code><code class="p">();</code><code class="w"/>

<code class="k">while</code><code class="p">(</code><code class="nb">true</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getNextElement</code><code class="p">(</code><code class="n">it</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">strcmp</code><code class="p">(</code><code class="n">element</code><code class="p">,</code><code class="w"> </code><code class="s">""</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">break</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="n">printf</code><code class="p">(</code><code class="s">"User: %s "</code><code class="p">,</code><code class="w"> </code><code class="n">element</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">printf</code><code class="p">(</code><code class="s">"Authentication success? %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">authenticateUser</code><code class="p">(</code><code class="n">element</code><code class="p">,</code><code class="w"> </code><code class="s">"pass"</code><code class="p">));</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">destroyIterator</code><code class="p">(</code><code class="n">it</code><code class="p">);</code><code class="w"/></pre>
<p>Throughout this chapter, the patterns helped you to design this final piece of code. Now you can tell your boss you completed the task of implementing the requested system for storing usernames and passwords. By utilizing pattern-based design for that system, you rely on documented solutions that are proven in use.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45587907202352">
<h1>Summary</h1>
<p>You constructed the code in this chapter step by step by applying the patterns presented in <a data-type="xref" href="part01.xhtml#part_1">Part I</a> in order to solve one problem after another. At the start you had many questions on how to organize the files and how to cope with error handling. The patterns showed you the way. They gave you guidance and made it easier to construct this piece of code. They also provide understanding as to why the code looks and behaves the way it does. Throughout this chapter, you applied the<a data-primary="user management system example" data-secondary="overview of patterns used" data-type="indexterm" id="idm45587907097760"/> patterns shown in <a data-type="xref" href="#fig_story2_patterns">Figure 11-2</a>. In the figure, you can see how many decisions you had to make and how many decisions were guided by the patterns.</p>
<p class="fix-tracking">The constructed user administration system contains basic functionalities to add, find, and authenticate users. Again, there are many other functionalities that could be added to that system, like the functionality to change passwords, to not store them in plain text, or to check that the passwords meet some security criteria. The advanced functionality is not addressed in this chapter to make the pattern application easier to grasp.</p>
<figure><div class="figure" id="fig_story2_patterns">
<img alt="fluc 1102" height="2094" src="assets/fluc_1102.png" width="1436"/>
<h6><span class="label">Figure 11-2. </span>The patterns applied throughout this story</h6>
</div></figure>
</div></section>
</div></section></div></body></html>