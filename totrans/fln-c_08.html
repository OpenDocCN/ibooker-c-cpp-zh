<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 7. Flexible Iterator Interfaces" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_iterator">
<h1><span class="label">Chapter 7. </span>Flexible Iterator Interfaces</h1>
<p>Iterating<a data-primary="iterator interfaces" data-secondary="designing flexible" data-type="indexterm" id="idm45587918943824"/> over a set of elements is a common operation in any program. Some programming languages provide native constructs to iterate over elements, and object-oriented programming languages have guidance in the form of design patterns on how to implement generic iteration functionality. However, there is very little guidance of this kind for procedural programming languages like C.</p>
<p>The verb “iterate” means to do the same thing multiple times. In programming, it usually means to run the same program code on multiple data elements. Such an operation is often required, which is why it is natively supported in C for arrays, as shown in the following code:</p>
<pre data-code-language="c" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">MAX_ARRAY_SIZE</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">doSomethingWith</code><code class="p">(</code><code class="n">my_array</code><code class="p">[</code><code class="n">i</code><code class="p">]);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If you want to iterate over a different data structure, like a red-black tree, for example, then you have to implement your own iteration function. You might equip this function with data structure–specific iteration options, like whether to traverse the tree depth-first or breadth-first. There is literature available on how to implement such specific data structures and how the iteration interfaces for these data structures look. If you use such a data structure-specific interface for iteration and your underlying data structure changes, you’d have to adapt your iteration function and all your code that calls this function. In some cases this is just fine, and even required, because you want to perform some special kind of iteration specific to the underlying data structure—perhaps to optimize the performance of your code.</p>
<p>In other cases, if you have to provide an iteration interface across component boundaries, having such an abstraction that leaks implementation details isn’t an option because it might require interface changes in the future. For example, if you sell your customers a component providing iteration functions, and your customers write code using these functions, then they likely expect their code to work without any modification if you provide them with a newer version of your component that maybe uses a different data structure. In that case, you’d even put some extra effort into your implementation to make sure that the interface to the customers stays compatible so that they do not have to change (or maybe not even recompile) their code.</p>
<p>That is where we start in this chapter. I’ll show you three patterns on how you, the iterator implementer, can provide stable iterator interfaces to the user (the customer). The patterns do not describe the specific kinds of iterators for specific kinds of data structures. Instead, the patterns assume that within your implementation you already have functions to retrieve the elements from your underlying data structure. The patterns show the options you have to abstract these functions in order to provide a stable iteration interface.</p>
<p><a data-type="xref" href="#fig_iterator">Figure 7-1</a> shows an overview of the patterns covered in this chapter and their relationships, and <a data-type="xref" href="#tab_iterator">Table 7-1</a> provides a summary of the patterns.</p>
<figure><div class="figure" id="fig_iterator">
<img alt="Overview of the Iterator Patterns" height="464" src="assets/fluc_0701.png" width="1231"/>
<h6><span class="label">Figure 7-1. </span>Overview of patterns for iterator interfaces</h6>
</div></figure>
<table id="tab_iterator">
<caption><span class="label">Table 7-1. </span>Patterns for iterator interfaces</caption>
<thead>
<tr>
<th/>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td/>
<td><p>Index Access</p></td>
<td><p>You<a data-primary="iterator interfaces" data-secondary="overview of patterns for" data-type="indexterm" id="idm45587918908368"/> want to make it possible for the user to iterate elements in your data structure in a convenient way, and it should be possible to change internals of the data structure without resulting in changes to the user’s code. Therefore, provide a function that takes an index to address the element in your underlying data structure and return the content of this element. The user calls this function in a loop to iterate over all elements.</p></td>
</tr>
<tr>
<td/>
<td><p>Cursor Iterator</p></td>
<td><p>You want to provide an iteration interface to your user that is robust in case the elements change during the iteration and that enables you to change the underlying data structure at a later point without requiring any changes to the user’s code. Therefore, create an iterator instance that points to an element in the underlying data structure. An iteration function takes this iterator instance as argument, retrieves the element the iterator currently points to, and modifies the iteration instance to point to the next element. The user then iteratively calls this function to retrieve one element at a time.</p></td>
</tr>
<tr>
<td/>
<td><p>Callback Iterator</p></td>
<td><p>You want to provide a robust iteration interface that does not require the user to implement a loop in the code for iterating over all elements and and that enables you to change the underlying data structure at a later point without requiring any changes to the user’s code. Therefore, use your existing data structure–specific operations to iterate over all your elements within your implementation and call some provided user-function on each element during this iteration. This user-function gets the element content as a parameter and can then perform its operations on this element. The user calls just one function to trigger the iteration, and the whole iteration takes place inside your implementation.</p></td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Running Example" data-type="sect1"><div class="sect1" id="idm45587918903072">
<h1>Running Example</h1>
<p>You<a data-primary="iterator interfaces" data-secondary="running example" data-type="indexterm" id="idm45587918901536"/> implemented an access control component for your application with an underlying data structure in which you have a function to randomly access any of the elements. More specifically, in the following code you have a <code>struct</code> array that holds account information like login names and passwords:</p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">loginname</code><code class="p">[</code><code class="n">MAX_NAME_LENGTH</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">password</code><code class="p">[</code><code class="n">MAX_PWD_LENGTH</code><code class="p">];</code><code class="w"/>
<code class="p">};</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT</code><code class="w"> </code><code class="n">accountData</code><code class="p">[</code><code class="n">MAX_USERS</code><code class="p">];</code><code class="w"/></pre>
<p>The next code shows how users can access this struct to read specific information like the login names:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">accessData</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">loginname</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="n">loginname</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">accountData</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">loginname</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="cm">/* do something with loginname */</code><code class="w"/>

<code class="w">  </code><code class="n">loginname</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">accountData</code><code class="p">[</code><code class="mi">1</code><code class="p">].</code><code class="n">loginname</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="cm">/* do something with loginname */</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Of course, you could simply not worry about abstracting access to your data structure and let other programmers directly retrieve a pointer to this <code>struct</code> to loop over the <code>struct</code> elements and access any information in the <code>struct</code>. But that would be a bad idea because there might be information in your data structure that you do not want to provide to the client. If you have to keep your interface to the client stable over time, you won’t be able to remove information you once revealed to the client, because your client might use that information and you don’t want to break the 
<span class="keep-together">client’s code.</span></p>
<p>To avoid this problem, a much better idea is to let the user only access the required information. A simple solution is to provide Index Access.</p>
</div></section>
<section data-pdf-bookmark="Index Access" data-type="sect1"><div class="sect1" id="pattern_index_access">
<h1>Index Access</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587918765584">
<h2>Context</h2>
<p>You<a data-primary="iterator interfaces" data-secondary="Index Access pattern" data-type="indexterm" id="iindacpat"/><a data-primary="Index Access pattern" data-type="indexterm" id="indaccpat"/> have a set of elements stored in a data structure that can be randomly accessed. For example, you have an array or a database with functions to randomly retrieve single elements. A user wants to iterate these elements.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587918761344">
<h2>Problem</h2>
<p><strong>You want to make it possible for the user to iterate elements in your data structure in a convenient way, and it should be possible to change internals of the data structure without resulting in changes to the user’s code.</strong></p>
<p>The user might be somebody who writes code that is not versioned and released with your codebase, so you have to make sure that future versions of your implementation also work with the user code written against the current version of your code. Thus, the user should not be able to access any internal implementation details, such as the underlying data structure you use to hold your elements, because you might want to change that at a later point.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587918728336">
<h2>Solution</h2>
<p><strong>Provide<a data-primary="functions" data-secondary="iterating over elements" data-type="indexterm" id="idm45587918726432"/> a function that takes an index to address the element in your underlying data structure and return the content of this element. The user calls this function in a loop to iterate over all elements as shown in <a data-type="xref" href="#fig_index_access">Figure 7-2</a>.</strong></p>
<figure><div class="figure" id="fig_index_access">
<img alt="sketches/index-access-sketch.png" height="698" src="assets/fluc_0702.png" width="1031"/>
<h6><span class="label">Figure 7-2. </span>Index-accessed iteration</h6>
</div></figure>
<p>The equivalent to this approach would be that in an array, the user would simply use an index to retrieve the value of one array element or to iterate over all elements. But when you have a function that takes such an index, more complex underlying data structures are also possible to iterate without requiring the user’s knowledge.</p>
<p>In order to achieve this, provide the users only the data they are interested in and do not reveal all elements of your underlying data structure. For example, do not return a pointer to the whole <code>struct</code> element, return a pointer only to the <code>struct</code> member the user is interested in:</p>
<p><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">element</code><code class="p">;</code><code class="w"/>

<code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getElement</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="cm">/* operate on element 1 */</code><code class="w"/>

<code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getElement</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="cm">/* operate on element 2 */</code><code class="w"/></pre>
<p><br/><em>Iterator API</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#define MAX_ELEMENTS 42</code>

<code class="cm">/* Retrieve one single element identified by the provided 'index' */</code><code class="w"/>
<code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="nf">getElement</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">index</code><code class="p">);</code><code class="w"/></pre>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587918728032">
<h2>Consequences</h2>
<p>Users can retrieve the elements by using the index to conveniently loop over the elements in their code. They do not have to deal with the internal data structure from which this data was gathered. If something in the implementation changes (for example, the retrieved <code>struct</code> member is renamed), users need not recompile their code.</p>
<p>Other changes to the underlying data structure might turn out to be more difficult. If, for example, the underlying data structure changes from an array (randomly accessible) to a linked list (sequentially accessible), then you’d have to iterate the list each time until you get to the requested index. That would not be efficient at all, and to make sure to also allow such changes in the underlying data structure, it would be better to use a Cursor Iterator or Callback Iterator instead.</p>
<p>If the user retrieves only basic data types that can be returned as Return Value of a C function, then the user implicitly retrieves a copy of this element. If the corresponding element in the underlying data structure changes in the meantime, then this would not affect the user. But if the user retrieves a more complex data type (like a string), then compared to simply providing direct access to the underlying data structure, you have with Index Access the advantage that you can copy the current data element in a thread-safe way and provide it to the user, for example with a Caller-Owned Buffer. If you are not operating in a multithreaded environment, you could simply return a pointer for complex data types.</p>
<p>When accessing a set of elements, the user often wants to iterate over all elements. If somebody else adds or removes an element in the underlying data in the meantime, then the user’s understanding of the index to access the elements might become invalid, and they might unintentionally retrieve an element twice during the iteration. A straightforward solution to this would be to simply copy all elements the user is interested in into an array and provide this exclusive array to the user, who can then conveniently loop over this array. The user would have Dedicated Ownership of that copy and could even modify the elements. But if that is not explicitly required, copying all the elements might not be worth it. A much more convenient solution, where the user does not have to worry about changes to the underlying data order during iteration, is to provide a Callback Iterator instead.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587918644672">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>James Noble describes the External Iterator pattern in his article <a href="https://oreil.ly/fganK">“Iterators and Encapsulation”</a>. This is an object-oriented version of the concept described in this pattern.</p>
</li>
<li>
<p>The book <em>Data Structures and Problem Solving Using Java</em> by Mark Allen Weiss (Addison-Wesley, 2006) describes this approach and calls it access with an array-like interface.</p>
</li>
<li>
<p>The function <code>service_response_time_get_column_name</code> of the Wireshark code returns the name of columns for a statistics table. The name to be returned is addressed with an index parameter provided by the user. The column names cannot change at runtime, and therefore even in multithreaded environments this way of accessing the data or iterating over column names is safe.</p>
</li>
<li>
<p>The Subversion project contains code that is used to build up a table of strings. These strings can be accessed with the function <code>svn_fs_x__string_table_get</code>. This function takes an index as parameter that is used to address the string to be retrieved. The retrieved string is copied into a provided buffer.</p>
</li>
<li>
<p>The OpenSSL function <code>TXT_DB_get_by_index</code> retrieves a string selected with an index from a text database and stores it in a provided buffer.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587918635392">
<h2>Applied to Running Example</h2>
<p>Now<a data-primary="iterator interfaces" data-secondary="Index Access pattern" data-startref="iindacpat" data-type="indexterm" id="idm45587918633152"/><a data-primary="Index Access pattern" data-startref="indaccpat" data-type="indexterm" id="idm45587918631872"/> you have a clean abstraction for reading the login names, and you don’t reveal internal implementation details to the user:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="nf">getLoginName</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">index</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">accountData</code><code class="p">[</code><code class="n">index</code><code class="p">].</code><code class="n">loginname</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Users do not have to deal with accessing the underlying <code>struct</code> array. This has the advantage that access to the required data is easier for them and that they cannot use any information that is not intended for them. For example, they cannot access sub-elements of your <code>struct</code> that you might want to change in the future and that can only be changed if nobody accesses this data because you do not want to break the users’ code.</p>
<p>Someone using this interface, such as someone who wants to write a function that checks if there is any login name starting with the letter “X,” writes the following code:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">bool</code><code class="w"> </code><code class="nf">anyoneWithX</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">MAX_USERS</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">loginName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getLoginName</code><code class="p">(</code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">loginName</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">'X'</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You are happy with your implementation until the data structure that you use to store the login names changes, because you need a more convenient way to insert and delete account data, which is quite difficult when storing the data in a plain array. Now the login names are no longer stored in a single plain array but in an underlying data structure that offers you an operation to get from one element to the next without offering an operation to randomly access elements. More specifically, you have a linked list that can be accessed, as shown in the following code:</p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">loginname</code><code class="p">[</code><code class="n">MAX_NAME_LENGTH</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">password</code><code class="p">[</code><code class="n">MAX_PWD_LENGTH</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="o">*</code><code class="w"> </code><code class="n">next</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="o">*</code><code class="w"> </code><code class="n">accountList</code><code class="p">;</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="o">*</code><code class="w"> </code><code class="n">getFirst</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">accountList</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="o">*</code><code class="w"> </code><code class="n">getNext</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="o">*</code><code class="w"> </code><code class="n">current</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">current</code><code class="o">-&gt;</code><code class="n">next</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">accessData</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="o">*</code><code class="w"> </code><code class="n">account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getFirst</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">loginname</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">account</code><code class="o">-&gt;</code><code class="n">loginname</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getNext</code><code class="p">(</code><code class="n">account</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">loginname</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">account</code><code class="o">-&gt;</code><code class="n">loginname</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>That makes the situation difficult with your current interface, which provides one randomly index-accessed login name at a time. To further support this, you’d have to emulate the index by calling the <code>getNext</code> function and counting until you reach the indexed element. That is quite inefficient. All that hassle is only necessary because you designed the interface in a way that turned out to be not flexible enough.</p>
<p>To make things easier, provide a Cursor Iterator to access the login names.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Cursor Iterator" data-type="sect1"><div class="sect1" id="pattern_cursor_iterator">
<h1>Cursor Iterator</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587918362480">
<h2>Context</h2>
<p>You<a data-primary="iterator interfaces" data-secondary="Cursor Iterator pattern" data-type="indexterm" id="icuritpat"/><a data-primary="Cursor Iterator pattern" data-type="indexterm" id="curitepat"/> have a set of elements stored in a data structure that can be accessed randomly or sequentially. For example, you have an array, a linked list, a hash map, or a tree data structure. A user wants to iterate these elements.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587918252560">
<h2>Problem</h2>
<p><strong>You want to provide an iteration interface to your user that is robust in case the elements change during the iteration and that enables you to change the underlying data structure at a later point without requiring any changes to the user’s code.</strong></p>
<p>The user might be somebody who writes code that is not versioned and released with your codebase, so you have to make sure that future versions of your implementation also work with the user code written against the current version of your code. Thus, the user should not be able to access any internal implementation details, such as the underlying data structure you use to hold your elements, because you might want to change that at a later point.</p>
<p>Aside from that, when operating in multithreaded environments, you want to provide the user a robust and clearly defined behavior if the  element’s content changes while the user iterates over it. Even for complex data like strings, the user should not have to worry about other threads changing that data while the user wants to read it.</p>
<p>You don’t care if you have to make an extra implementation effort to achieve all this, because many users will use your code, and if you can take implementation effort away from the user by implementing it in your code, then the overall effort will be decreased.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587918248640">
<h2>Solution</h2>
<p><strong>Create an iterator instance that points to an element in the underlying data structure. An iteration function takes this iterator instance as argument, retrieves the element the iterator currently points to, and modifies the iteration instance to point to the next element. The<a data-primary="functions" data-secondary="retrieving one element at a time" data-type="indexterm" id="idm45587918246256"/> user then iteratively calls this function to retrieve one element at a time as shown in <a data-type="xref" href="#fig_cursor">Figure 7-3</a>.</strong></p>
<figure><div class="figure" id="fig_cursor">
<img alt="sketches/cursor-iterator-sketch.png" height="698" src="assets/fluc_0703.png" width="1128"/>
<h6><span class="label">Figure 7-3. </span>Iteration with a Cursor Iterator</h6>
</div></figure>
<p>The iterator interface requires two functions to create and destroy the iterator instance and one function to perform the actual iteration and to retrieve the current element. Having explicit create/destroy functions makes it possible to have an instance in which you store your internal iteration data (position, data of the current element). The user then has to pass this instance to all your iteration function calls as shown in the following code:</p>
<p><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">element</code><code class="p">;</code><code class="w"/>
<code class="n">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">it</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">createIterator</code><code class="p">();</code><code class="w"/>

<code class="k">while</code><code class="p">(</code><code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getNext</code><code class="p">(</code><code class="n">it</code><code class="p">))</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* operate on element */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">destroyIterator</code><code class="p">(</code><code class="n">it</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Iterator API</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Creates an iterator and moves it to the first element */</code><code class="w"/>
<code class="n">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="nf">createIterator</code><code class="p">();</code><code class="w"/>

<code class="cm">/* Returns the element currently pointed to and sets the iterator to the</code>
<code class="cm">   next element. Returns NULL if the element does not exist. */</code><code class="w"/>
<code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="nf">getNext</code><code class="p">(</code><code class="n">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">iterator</code><code class="p">);</code><code class="w"/>

<code class="cm">/* Cleans up an iterator created with the function createIterator() */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">destroyIterator</code><code class="p">(</code><code class="n">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">iterator</code><code class="p">),</code><code class="w"/></pre>
<p>If you do not want the user to be able to access this internal data, then you can hide it and provide the user with a Handle instead. That makes it possible that even changes to this internal data of the iteration instance do not affect the user.</p>
<p>When retrieving the current element, basic data types can be provided direcetly as the Return Value. Complex data types can either be returned as a reference or copied into the iterator instance. Copying them into the iterator instance gives you the advantage that the data is consistent, even if the data in the underlying data structure changes in the meantime (for example, because it is being modified by someone else in a multithreaded environment).</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587918248048">
<h2>Consequences</h2>
<p>The user can iterate the data simply by calling the <code>getNext</code> method as long as valid elements are retrieved. They do not have to deal with the internal data structure from which this data was gathered, nor do they have to worry about an element index or about the maximum number of elements. But not being able to index the elements also means that the user cannot randomly access the elements (which could be done with Index Access).</p>
<p>Even if the underlying data structure changes, for example, from a linked list to a randomly accessible data structure like an array, then that change can be hidden in the iterator implementation and the user need not change or recompile code.</p>
<p>No matter which kind of data the user retrieves—simple or complex data types—they need not be afraid that the retrieved element will become invalid if the underlying element is changed or removed in the meantime. To make this possible, the user now has to explicitly call functions to create and destroy the iterator instance. Compared to Index Access, more function calls are necessary.</p>
<p>When accessing a set of elements, the user often wants to iterate over all elements. If somebody else adds an element to the underlying data in the meantime, then the user might miss this element during the iteration. If this is a problem for you and you want to make sure that the elements do not change at all during the iteration, then it is easier to use a Callback Iterator.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587918115616">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>James Noble describes an object-oriented version of this iterator as the Magic Cookie pattern in his article <a href="https://oreil.ly/NVnbw">“Iterators and Encapsulation.”</a></p>
</li>
<li>
<p>The article <a href="https://oreil.ly/BzFJJ">“Interruptible Iterators”</a> by Jed Liu et al. describes the presented concept as <em>cursor object</em>.</p>
</li>
<li>
<p>This kind of iteration is used for file access. For example, the <code>getline</code> C function iterates over the lines in a file, and the iterator position is stored in the <code>FILE</code> pointer.</p>
</li>
<li>
<p>The OpenSSL code provides the functions <code>ENGINE_get_first</code> and <code>ENGINE_​get_next</code> to iterate a list of encryption engines. Each of these calls takes the pointer to an <code>ENGINE struct</code> as a parameter. This <code>struct</code> stores the current position in the iteration.</p>
</li>
<li>
<p>The Wireshark code contains the functions <code>proto_get_first_protocol</code> and <code>proto_get_next_protocol</code>. These functions make it possible for a user to iterate over a list of network protocols. The functions take a <code>void</code> pointer as out-parameter to store and pass along state information.</p>
</li>
<li>
<p>The code of the Subversion project for generating diffs between files contains the function <code>datasource_get_next_token</code>. This function is to be called in a loop in order to get the next diff token from a provided datasource object that stores the iteration position.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587918096896">
<h2>Applied to Running Example</h2>
<p>You now have the following function to retrieve the login names:</p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">buffer</code><code class="p">[</code><code class="n">MAX_NAME_LENGTH</code><code class="p">];</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="o">*</code><code class="w"> </code><code class="n">element</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">createIterator</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">malloc</code><code class="p">(</code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="p">));</code><code class="w"/>
<code class="w">  </code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getFirst</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">iterator</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">getNextLoginName</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">iterator</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">element</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nb">NULL</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">strcpy</code><code class="p">(</code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">buffer</code><code class="p">,</code><code class="w"> </code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">element</code><code class="o">-&gt;</code><code class="n">loginname</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getNext</code><code class="p">(</code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">element</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">iterator</code><code class="o">-&gt;</code><code class="n">buffer</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">else</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nb">NULL</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">destroyIterator</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">iterator</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">free</code><code class="p">(</code><code class="n">iterator</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The following code shows how this interface is used:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">bool</code><code class="w"> </code><code class="nf">anyoneWithX</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">loginName</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">ITERATOR</code><code class="o">*</code><code class="w"> </code><code class="n">iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">createIterator</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="k">while</code><code class="p">(</code><code class="n">loginName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getNextLoginName</code><code class="p">(</code><code class="n">iterator</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_flexible_iterator_interfaces_CO1-1" id="co_flexible_iterator_interfaces_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">loginName</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="sc">'</code><code class="sc">X</code><code class="sc">'</code><code class="p">)</code><code class="w">
</code><code class="w">    </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">destroyIterator</code><code class="p">(</code><code class="n">iterator</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_flexible_iterator_interfaces_CO1-2" id="co_flexible_iterator_interfaces_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w">
</code><code class="w">  </code><code class="p">}</code><code class="w">
</code><code class="w">  </code><code class="n">destroyIterator</code><code class="p">(</code><code class="n">iterator</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_flexible_iterator_interfaces_CO1-2" id="co_flexible_iterator_interfaces_CO1-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_flexible_iterator_interfaces_CO1-1" id="callout_flexible_iterator_interfaces_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The application does not have to deal with the index and the maximum number of elements anymore</p></dd>
<dt><a class="co" href="#co_flexible_iterator_interfaces_CO1-2" id="callout_flexible_iterator_interfaces_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>In this case, the required cleanup code for destroying the iterator leads to code duplication.</p></dd>
</dl>
<p>Next, <a data-primary="iterator interfaces" data-secondary="Cursor Iterator pattern" data-startref="icuritpat" data-type="indexterm" id="idm45587917773232"/><a data-primary="Cursor Iterator pattern" data-startref="curitepat" data-type="indexterm" id="idm45587917771952"/>you don’t just want to implement the <code>anyoneWithX</code> function, but you also want to implement an additional function that, for example, tells you how many login names start with the letter “Y.” You could simply copy the code, modify the body of the <code>while</code> loop, and count the occurrences of “Y” but with this approach you’ll end up with duplicated code because both of your functions will contain the same code for creating and destroying the iterator and for performing the loop operation. To avoid this code duplication, you can use a Callback Iterator instead.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Callback Iterator" data-type="sect1"><div class="sect1" id="pattern_callback_iterator">
<h1>Callback Iterator</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587917768464">
<h2>Context</h2>
<p>You<a data-primary="iterator interfaces" data-secondary="Callback Iterator pattern" data-type="indexterm" id="icalitpat"/><a data-primary="Callback Iterator pattern" data-type="indexterm" id="calitepat"/> have a set of elements stored in a data structure that can be accessed randomly or sequentially. For example, you have an array, a linked list, a hash map, or a tree data structure. A user wants to iterate these elements.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587917713040">
<h2>Problem</h2>
<p><strong>You want to provide a robust iteration interface that does not require the user to implement a loop in the code for iterating over all elements and that enables you to change the underlying data structure at a later point without requiring any changes to the user’s code.</strong></p>
<p>The user might be somebody who writes code that is not versioned and released with your codebase, so you have to make sure that future versions of your implementation also work with the user code written against the current version of your code. Thus, the user should not be able to access any internal implementation details, such as the underlying data structure you use to hold your elements, because you might want to change that at a later point.</p>
<p>Aside from that, when operating in<a data-primary="multithreaded environments" data-type="indexterm" id="idm45587917710528"/> multithreaded environments, you want to provide the user a robust and clearly defined behavior if the element’s content changes while the user iterates over it. Even for complex data like strings, the user should not have to worry about other threads changing that data while the user wants to read it. Also, you want to make sure that the user iterates over each element exactly once. That should hold even if other threads try to create new elements or delete existing elements during the iteration.</p>
<p>You don’t care if you have to make an extra implementation effort to achieve all this, because many users will use your code, and if you can take implementation effort away from the user by implementing it in your code, then the overall effort will be decreased.</p>
<p>You want to make access to your elements as easy as possible. In particular, the user shouldn’t have to cope with iteration details like mappings between index and element or the number of available elements. Also, they shouldn’t have to implement loops in their code because that would lead to duplications in the user code, so Index Access or a Cursor Iterator isn’t  an option for you.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587917708608">
<h2>Solution</h2>
<p><strong>Use your existing data structure-specific operations to iterate over all your elements within your implementation, and call some provided user-function on each element during this iteration. This user-function gets the element content as a parameter and can then perform its operations on this element. The user calls just one function to trigger the iteration, and the whole iteration takes place inside your implementation as shown in <a data-type="xref" href="#fig_callback">Figure 7-4</a>.</strong></p>
<figure><div class="figure" id="fig_callback">
<img alt="sketches/callback-iterator-sktech.png" height="694" src="assets/fluc_0704.png" width="1390"/>
<h6><span class="label">Figure 7-4. </span>Iteration with a Callback Iterator</h6>
</div></figure>
<p>To realize this, you have to declare a function pointer in your interface. The declared function takes an element that should be iterated over as parameter. The user implements such a function and passes it to your iteration function. Within your implementation you iterate over all elements, and you’ll call the user’s function for each element with the current element as parameter.</p>
<p>You can add an additional <code>void*</code> parameter to your iteration function and to the function pointer declaration. In the implementation of your iteration function, you simply pass that parameter to the user’s function. That makes it possible for the user to pass some context information to the function:</p>
<p><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">myCallback</code><code class="p">(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">element</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">arg</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* operate on element */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">doIteration</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">iterate</code><code class="p">(</code><code class="n">myCallback</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><br/><em>Iterator API</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Callback for the iteration to be implemented by the caller. */</code><code class="w"/>
<code class="k">typedef</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">FP_CALLBACK</code><code class="p">)(</code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">element</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">arg</code><code class="p">);</code><code class="w"/>

<code class="cm">/* Iterates over all elements and calls callback(element, arg)</code>
<code class="cm">   on each element. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">iterate</code><code class="p">(</code><code class="n">FP_CALLBACK</code><code class="w"> </code><code class="n">callback</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">arg</code><code class="p">);</code><code class="w"/></pre>
<p>Sometimes the user does not want to iterate over all elements but wants to find one specific element. To make that use case more efficient, you can add a break condition to your iteration function. For example, you can declare the function pointer for the user function that operates on the elements of return type <code>bool</code>, and if the user function returns the Return Value <code>true</code>, you stop the iteration. Then the user can signal as soon as the desired element is found and save the time it would take for iterating all the rest of the elements.</p>
<p>When implementing the iteration function for multithreaded environments, make sure to cover the situation when during the iteration, the current element is changed, new elements are added, or elements are deleted by other threads. In case of such changes, you could Return Status Codes to the user who currently iterates, or you could prevent such changes during an iteration by locking write access to the elements in the meantime.</p>
<p>Because the implementation can ensure that the data is not changed during the iteration, it is not necessary to copy the elements on which the user operates. The user simply retrieves a pointer to this data and works with the original data.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587917567216">
<h2>Consequences</h2>
<p>The user code for iterating over all elements is now just a single line of code. All the implementation details, like an element index and the maximum number of elements, are hidden inside the iterator implementation. The user does not even have to implement a loop to iterate over the elements. They also do not have to create or destroy an iterator instance, nor do they have to cope with the internal data structure from which the elements are gathered. Even if you change the type of underlying data structure in your implementation, they need not even recompile the code.</p>
<p>If the underlying elements change during an iteration, then the iterator implementation can react accordingly, which ensures that the user iterates over a consistent set of data while not having to cope with locking functionality in the user code. All this is possible because the control flow does not jump between the user code and the iterator-code. The control flow stays inside the iterator implementation, and thus the iterator implementation can detect if elements are changed during the iteration and react accordingly.</p>
<p>The user can iterate over all elements, but the iteration loop is implemented inside the iterator implementation, so the user cannot randomly access elements as with Index Access.</p>
<p>In the callback, your implementation runs user code on each element. To some extent this means that you have to trust that the user’s code does the right thing. For example, if your iterator implementation locks all elements during the iteration, then you expect the user code to quickly do something with the retrieved element and to not perform any time-consuming operations, because during this iteration, all other calls accessing this data will be locked.</p>
<p>Using callbacks implies that you have a platform- and programming language–specific interface, because you call the code implemented by your caller, and you can only do that if that code uses the same calling conventions (i.e., the same way of providing function parameters and returning data). That means, for implementing an iterator in C, you can only use this pattern if the user code is also written in C. You cannot provide a C Callback Iterator, for example, to a user writing code with Java (which could with some effort be done with any of the other iterator patterns).</p>
<p>When reading the code, the program flow with callbacks is more difficult to follow. For example, compared to having a simple <code>while</code> loop directly in the code, it might be more difficult to find out that the program iterates over elements when seeing only one line of user code with a callback parameter. Thus, it is critical to give the iteration function a name that makes it clear that this function performs an iteration.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587917594736">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>James Noble describes an object-oriented version of this iterator as the Internal Iterator pattern in his article <a href="https://oreil.ly/u8B7I">“Iterators and Encapsulation”</a>.</p>
</li>
<li>
<p>The function <code>svn_iter_apr_hash</code> of the Subversion project iterates over all elements in a hash table that is provided to the function as a parameter. For each element of the hash table, a function pointer, which has to be provided by the caller, is called, and if that call returns <code>SVN_ERR_ITER_BREAK</code>, the iteration is 
<span class="keep-together">stopped.</span></p>
</li>
<li>
<p>The OpenSSL function <code>ossl_provider_forall_loaded</code> iterates over a set of OpenSSL provider objects. The function takes a function pointer as a parameter, and that function pointer is called for each provider object. A <code>void*</code> parameter can be provided to the iteration call, and this parameter is then provided for each call in the iteration so that users can pass their own context.</p>
</li>
<li>
<p>The Wireshark function <code>conversation_table_iterate_tables</code> iterates through a list of “conversation” objects. Each such object stores information about sniffed network data. The function takes a function pointer and a <code>void*</code> as parameters.
For each conversation object, the function pointer is called with the <code>void*</code> as context.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587917584352">
<h2>Applied to Running Example</h2>
<p>You<a data-primary="iterator interfaces" data-secondary="Callback Iterator pattern" data-startref="icalitpat" data-type="indexterm" id="idm45587917582400"/><a data-primary="Callback Iterator pattern" data-startref="calitepat" data-type="indexterm" id="idm45587917581152"/> now provide the following function for accessing the login names:</p>
<pre data-code-language="c" data-type="programlisting"><code class="k">typedef</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="n">FP_CALLBACK</code><code class="p">)(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">loginName</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">arg</code><code class="p">);</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">iterateLoginNames</code><code class="p">(</code><code class="n">FP_CALLBACK</code><code class="w"> </code><code class="n">callback</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">arg</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">ACCOUNT_NODE</code><code class="o">*</code><code class="w"> </code><code class="n">account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getFirst</code><code class="p">(</code><code class="n">accountList</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">while</code><code class="p">(</code><code class="n">account</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nb">NULL</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">callback</code><code class="p">(</code><code class="n">account</code><code class="o">-&gt;</code><code class="n">loginname</code><code class="p">,</code><code class="w"> </code><code class="n">arg</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getNext</code><code class="p">(</code><code class="n">account</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The following code shows how to use this interface:</p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">findX</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">loginName</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">arg</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="kt">bool</code><code class="o">*</code><code class="w"> </code><code class="n">found</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">bool</code><code class="o">*</code><code class="p">)</code><code class="w"> </code><code class="n">arg</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">loginName</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="sc">'</code><code class="sc">X</code><code class="sc">'</code><code class="p">)</code><code class="w">
</code><code class="w">  </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="o">*</code><code class="n">found</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="p">}</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">countY</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">loginName</code><code class="p">,</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">arg</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="kt">int</code><code class="o">*</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="o">*</code><code class="p">)</code><code class="w"> </code><code class="n">arg</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">loginName</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="sc">'</code><code class="sc">Y</code><code class="sc">'</code><code class="p">)</code><code class="w">
</code><code class="w">  </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="p">(</code><code class="o">*</code><code class="n">count</code><code class="p">)</code><code class="o">+</code><code class="o">+</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="p">}</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">bool</code><code class="w"> </code><code class="nf">anyoneWithX</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="kt">bool</code><code class="w"> </code><code class="n">found</code><code class="o">=</code><code class="nb">false</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="n">iterateLoginNames</code><code class="p">(</code><code class="n">findX</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">found</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_flexible_iterator_interfaces_CO2-1" id="co_flexible_iterator_interfaces_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">found</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">numberOfUsersWithY</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">count</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w">
</code><code class="w">  </code><code class="n">iterateLoginNames</code><code class="p">(</code><code class="n">countY</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">count</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_flexible_iterator_interfaces_CO2-1" id="co_flexible_iterator_interfaces_CO2-2"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">count</code><code class="p">;</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_flexible_iterator_interfaces_CO2-1" id="callout_flexible_iterator_interfaces_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The application no longer contains an explicit loop statement.</p></dd>
</dl>
<p>As a possible enhancement, the callback function could have a return value that determines whether the iteration is continued or stopped. With such a return value, the iteration could, for example, be stopped once the <code>findX</code> function iterates over the first user starting with “X.”</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45587917389680">
<h1>Summary</h1>
<p>This chapter showed you three different ways to implement interfaces that provide iteration functionality. <a data-type="xref" href="#iterator_comparison">Table 7-2</a> gives an<a data-primary="iterator interfaces" data-secondary="overview of patterns for" data-type="indexterm" id="idm45587917387392"/> overview of the three patterns and compares their consequences.</p>
<table id="iterator_comparison">
<caption><span class="label">Table 7-2. </span>Comparison of the iterator patterns</caption>
<thead>
<tr>
<th/>
<th>Index Access</th>
<th>Cursor Iterator</th>
<th>Callback Iterator</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Element access</p></td>
<td><p>Allows random access</p></td>
<td><p>Only sequential access</p></td>
<td><p>Only sequential access</p></td>
</tr>
<tr>
<td><p>Data structure changes</p></td>
<td><p>Underlying data structure can only easily be changed to another random-access data structure</p></td>
<td><p>Underlying data structure can easily be changed</p></td>
<td><p>Underlying data structure can easily be changed</p></td>
</tr>
<tr>
<td><p>Info leaked through interface</p></td>
<td><p>Amount of elements; usage of a random-access data structure</p></td>
<td><p>Iterator position (user can stop and continue the iteration at a later point)</p></td>
<td><p>-</p></td>
</tr>
<tr>
<td><p>Code duplication</p></td>
<td><p>Loop in user code; index increment in user code</p></td>
<td><p>Loop in user code</p></td>
<td><p>-</p></td>
</tr>
<tr>
<td><p>Robustness</p></td>
<td><p>Difficult to implement robust iteration behavior</p></td>
<td><p>Difficult to implement robust iteration behavior</p></td>
<td><p>easy to implement robust iteration behavior because control flow stays within the iteration code, and insert/delete/modify operations can simply be locked during the iteration (but would block other iterations during that time)</p></td>
</tr>
<tr>
<td><p>Platforms</p></td>
<td><p>Interface can be used across different languages and platforms</p></td>
<td><p>Interface can be used across different languages and platforms</p></td>
<td><p>Can only be used with the same language and platform (with the same calling convention) as the implementation</p></td>
</tr>
</tbody>
</table>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Further Reading" data-type="sect1"><div class="sect1" id="idm45587917152064">
<h1>Further Reading</h1>
<p>If<a data-primary="iterator interfaces" data-secondary="further reading on" data-type="indexterm" id="idm45587917150496"/> you’re ready for more, here are some resources that can help you further your knowledge of iterator interface design.</p>
<ul>
<li>
<p>The most closely related work regarding iterators in C is an online version of <a href="https://oreil.ly/2fuPK">university class notes</a> by James Aspnes. The class notes describe different C iterator designs, discuss their advantages and disadvantages, and provide source code examples.</p>
</li>
<li>
<p>There is more guidance on iterators for other programming languages, but many of the concepts can also be applied to C. For example, the article <a href="https://oreil.ly/GWR0F">“Iterators and Encapsulation”</a> by James Noble describes eight patterns on how to design object-oriented iterators, the book <em>Data Structures and Problem Solving Using Java</em> by Mark Allen Weiss (Addison-Wesley, 2006) describes different iterator designs for Java, and the book <em>Higher-Order Perl</em> by Mark Jason Dominus (Morgan Kaufmann, 2005) describes different iterator designs for Perl.</p>
</li>
<li>
<p>The article <a href="https://oreil.ly/JsEKb">“Loop Patterns”</a> by Owen Astrachan and Eugene Wallingford contains patterns that describe best practices for implementing loops and that include C++ and Java code snippets. Most of the ideas are also relevant for C.</p>
</li>
<li>
<p>The book <em>C Interfaces and Implementations</em> by David R. Hanson (Addison-Wesley, 1996) describes C implementations and their interfaces for several common data structures like linked lists or hash tables. These interfaces of course also contain functions that traverse these data structures.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Outlook" data-type="sect1"><div class="sect1" id="idm45587917129520">
<h1>Outlook</h1>
<p>The next chapter focuses on how to organize the code files in large programs. Once you apply the patterns from the previous chapters to define your interfaces and to program their implementations, you end up with many files. Their file organization has to be tackled to implement modular, large scale programs.</p>
</div></section>
</div></section></div></body></html>