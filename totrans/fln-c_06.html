<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 5. Data Lifetime and Ownership" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_lifetime">
<h1><span class="label">Chapter 5. </span>Data Lifetime and Ownership</h1>
<p>If we have a look at procedural programming languages like C, there are no native object-oriented mechanisms. This makes life harder to some extent, because most design guidance is tailored for object-oriented software (like the Gang of Four design patterns).</p>
<p>This<a data-primary="data lifetime and ownership" data-secondary="structuring programs with object-like elements" data-type="indexterm" id="idm45587922845696"/><a data-primary="resources" data-secondary="lifetime and ownership of" data-type="indexterm" id="idm45587922844752"/> chapter discusses patterns for how to structure your C program with object-like elements. For these object-like elements, the patterns put special focus on who is responsible for creating and destroying them—in other words, they put special focus on lifetime and ownership. This topic is especially important for C because C has no automatic destructor and<a data-primary="garbage collection" data-secondary="dealing with lack of" data-type="indexterm" id="idm45587922843712"/> no garbage collection mechanism, and thus special attention has to be paid to cleanup of resources.</p>
<p>However, what<a data-primary="object-like elements" data-type="indexterm" id="idm45587922842144"/> is an “object-like element” and what is the meaning of it for C? The term <em>object</em> is well defined for object-oriented programming languages, but for non-object-oriented programming languages it is not clear what the term object means. For C, a simple definition for object is the following:</p>
<blockquote>
<p>“An object is a named region of storage.”</p>
<p data-type="attribution">Kernighan and Ritchie</p>
</blockquote>
<p>Usually such an object describes a related set of data that has an identity and properties and that is used to store representations of things found in the real world. In object-oriented programming, an object additionally has the capability of polymorphism and inheritance. The object-like elements described throughout this book do not address polymorphism or inheritance, and therefore we’ll not use the term object anymore. Instead, we’ll consider such an object-like element simply as an instance of a data structure and will furthermore call it<a data-primary="instances" data-secondary="definition of term" data-type="indexterm" id="idm45587922838896"/> <em>instance</em>.</p>
<p>Such<a data-primary="instances" data-secondary="software-modules and" data-type="indexterm" id="idm45587922836928"/> instances do not stand by themselves, but instead they usually come with related pieces of code that make it possible to operate on the instances. This code is usually put together into a set of header files for its interface and a set of implementation files for its implementation. Throughout this chapter, the sum of all this related code that, similar to object-oriented classes, often defines the operations that can be performed on an instance, will be called<a data-primary="software-modules" data-type="indexterm" id="idm45587922835312"/> <em>software-module</em>.</p>
<p>When programming C, the described instances of data are usually implemented<a data-primary="abstract data types" data-type="indexterm" id="idm45587922833424"/><a data-primary="data, abstract types of" data-type="indexterm" id="idm45587922832720"/> as abstract data types (for example, by having an instance of a <code>struct</code> with functions accessing the <code>struct</code> members). An example of such an instance is the C stdlib <code>FILE</code> <code>struct</code> that stores information like the file pointer or the position in the file. The corresponding software-module is the <em>stdio.h</em> API and its implementation of functions like <code>fopen</code> and <code>fclose</code>, which provide access to the <code>FILE</code> instances.</p>
<p><a data-type="xref" href="#fig_lifetime">Figure 5-1</a> shows an overview of the patterns discussed in this chapter and their relationships, and <a data-type="xref" href="#tab_lifetime">Table 5-1</a> provides a summary of the patterns.</p>
<figure><div class="figure" id="fig_lifetime">
<img alt="pattern-maps/lifetime-ownership.png" height="631" src="assets/fluc_0501.png" width="1443"/>
<h6><span class="label">Figure 5-1. </span>Overview of patterns for lifetime and ownership</h6>
</div></figure>
<table id="tab_lifetime">
<caption><span class="label">Table 5-1. </span>Patterns for lifetime and ownership</caption>
<thead>
<tr>
<th/>
<th>Pattern name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td/>
<td><p>Stateless Software-Module</p></td>
<td><p>You<a data-primary="data lifetime and ownership" data-secondary="overview of patterns for" data-type="indexterm" id="idm45587922779504"/> want to provide logically related functionality to your caller and make that functionality as easy as possible for the caller to use. Therefore, keep your functions simple and don’t build up state information in your implementation. Put all related functions into one header file and provide the caller this interface to your software-module.</p></td>
</tr>
<tr>
<td/>
<td><p>Software-Module with Global State</p></td>
<td><p>You want to structure your logically related code that requires common state information and make that functionality as easy as possible for the caller to use. Therefore, have one global instance to let your related functions share common resources. Put all functions that operate on the instance into one header file and provide the caller this interface to your software-module.</p></td>
</tr>
<tr>
<td/>
<td><p>Caller-Owned Instance</p></td>
<td><p>You want to provide multiple callers or threads access to functionality with functions that depend on one another, and the interaction of the caller with your functions builds up state information. Therefore, require the caller to pass an instance, which is used to store resource and state information, along to your functions. Provide explicit functions to create and destroy these instances, so that the caller can determine their lifetime.</p></td>
</tr>
<tr>
<td/>
<td><p>Shared Instance</p></td>
<td><p>You want to provide multiple callers or threads access to functionality with functions that depend on one another, and the interaction of the caller with your functions builds up state information, which your callers want to share. Therefore, require the caller to pass an instance, which is used to store resource and state information, along to your functions. Use the same instance for multiple callers and keep the ownership of that instance in your software-module.</p></td>
</tr>
</tbody>
</table>
<p>As<a data-primary="data lifetime and ownership" data-secondary="running example" data-type="indexterm" id="idm45587922771136"/> a running example, in this chapter you want to implement a device driver for your Ethernet network interface card. The Ethernet network interface card is installed on the operating system your software runs on, so you can use the POSIX socket functions to send and receive network data. You want to build some abstraction for your user because you want to provide an easier way to send and receive data compared to socket functions, and because you want to add some additional features to your Ethernet driver. Thus you want to implement something that encapsulates all the socket details. To achieve this, start with a simple Stateless Software-Module.</p>
<section data-pdf-bookmark="Stateless Software-Module" data-type="sect1"><div class="sect1" id="pattern_stateless_software_module">
<h1>Stateless Software-Module</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587922768368">
<h2>Context</h2>
<p>You<a data-primary="data lifetime and ownership" data-secondary="Stateless Software-Module pattern" data-type="indexterm" id="dssomopat"/><a data-primary="Stateless Software-Module pattern" data-type="indexterm" id="stsomopat"/> want to provide functions with related functionality to a caller. The functions don’t operate on common data shared between the functions, and they don’t require preparation of resources like memory that has to be initialized prior to the function call.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587922763792">
<h2>Problem</h2>
<p><strong>You want to provide logically related functionality to your caller and make that functionality as easy as possible for the caller to use.</strong></p>
<p>You want to make it simple for the caller to access your functionality. The caller should not have to deal with initialization and cleanup aspects of the provided functions, and the caller should not be confronted with implementation details.</p>
<p>You don’t necessarily need the functions to be very flexible regarding future changes while maintaining backwards compatibility—instead the functions should provide  an easy-to-use abstraction for accessing the implemented functionality.</p>
<p>You have many options for organizing the header and implementation files, and going through and evaluating each of these options becomes a lot of effort if you have to do it for each and every functionality that you implement.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587922760384">
<h2>Solution</h2>
<p><strong>Keep your functions simple and don’t build up state information in your implementation. Put all related functions into one header file and provide the caller this interface to your software-module.</strong></p>
<p>No communication or sharing of internal or external state information takes place between the functions, and state information is not stored between function calls. This means the functions calculate a result or perform an action that does not depend on other function calls in the API (the header file) or previous function calls. The only communication that takes place is between the caller and the called function (for example, in the form of Return Values).</p>
<p>If a function requires any resources, such as heap memory, then the resources have to be handled transparently for the caller. They have to be acquired, implicitly initialized before they are used, and released within the function call. This makes it possible to call the functions completely independent from one another.</p>
<p>Still, the functions are related and because of this they are put together into one API. Being related means that the functions are usually applied together by a caller (interface segregation principle) and that if they change, they change for the same reason (common closure principle). These principles are described in the book <em>Clean Architecture</em> by Robert C. Martin (Prentice Hall, 2018).</p>
<p>Put the declarations of the related functions into one Header File, and put the implementations of the functions into one or more implementation files, but into the same Software-Module Directory. The functions are related because they logically belong together, but they do not share a common state or influence one another’s state, so there is no need to share information between the functions via global variables or to encapsulate this information by passing instances between the functions. That’s why each single function implementation could be put into a separate implementation file.</p>
<p>The following code shows an example for a simple Stateless Software-Module:</p>
<p><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">sum</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>API (header file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Returns the sum of the two parameters */</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="nf">sum</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">summand1</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">summand2</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">sum</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">summand1</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">summand2</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* calculate result only depending on parameters and</code>
<code class="cm">     not requiring any state information */</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">summand1</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">summand2</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The caller calls <code>sum</code> and retrieves a copy of the function result. If you call the function twice with the same input parameters, the function would deliver the exact same result because no state information is maintained in the Stateless Software-Module. As in this special case, no other function that holds state information is called either.</p>
<p><a data-type="xref" href="#fig_stateless">Figure 5-2</a> shows an overview of the Stateless Software-Module.</p>
<figure><div class="figure" id="fig_stateless">
<img alt="Stateless Software-Module Lifetime" height="585" src="assets/fluc_0502.png" width="940"/>
<h6><span class="label">Figure 5-2. </span>Stateless Software-Module</h6>
</div></figure>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587922618384">
<h2>Consequences</h2>
<p>You have a very simple interface, and the caller does not have to cope with initializing or cleaning up anything for your software-module. The caller can simply call one of the functions independently of previous function calls and other parts of the program, for example, other threads that concurrently access the software-module. Having no state information makes it much easier to understand what a function does.</p>
<p>The caller does not have to cope with questions about ownership because there is nothing to own—the functions have no state. The resources required by the function are allocated and cleaned up within the function call and are thus transparent to the caller.</p>
<p>But not all functionality can be provided with such a simple interface. If the functions within an API share state information or data (for example, one has to allocate resources required by another), then a different approach, like a Software-Module with Global State or a Caller-Owned Instance, has to be taken in order to share this information.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587922615648">
<h2>Known Uses</h2>
<p>These types of related functions gathered into one API are found each time that the function within the API does not require shared information or state information. The following examples show applications of this pattern:</p>
<ul>
<li>
<p>The <code>sin</code> and <code>cos</code> functions from <em>math.h</em> are provided in the same header file and calculate their results solely based on the function input. They do not maintain state information, and each call with the same input produces the same output.</p>
</li>
<li>
<p>The <em>string.h</em> functions <code>strcpy</code> or <code>strcat</code> do not depend on each other. They don’t share information, but they belong together and are thus part of a single API.</p>
</li>
<li>
<p>The Windows header file <em>VersionHelpers.h</em> provides information about which Microsoft Windows version is currently running. Functions like <code>IsWind⁠ows​7OrGreater</code> or <code>IsWindowsServer</code> provide related information, but the functions still don’t share information and are independent from one another.</p>
</li>
<li>
<p>The Linux header file <em>parser.h</em> comes with functions like <code>match_int</code> or <code>match_hex</code>. These functions try to parse an integer or a hexadecimal value from a substring. The functions are independent from one another, but they still belong together in the same API.</p>
</li>
<li>
<p>The source code of the NetHack game also has many applications of this pattern. For example, the <em>vision.h</em> header file includes functions to calculate if the player is able to see specific items on the game map. The functions <code>couldsee(x,y)</code> and <code>cansee(x,y)</code> calculate if the player has a clear line of sight to the item and if the player also faces that item. Both functions are independent from each other and don’t share state information.</p>
</li>
<li>
<p>The pattern Header Files present a variant of this pattern with more focus on API flexibility.</p>
</li>
<li>
<p>The pattern called Per-Request Instance from the book <em>Remoting Patterns</em> by Markus Voelter et al. (Wiley, 2007) explains that a server in a distributed object middleware should activate a new servant for each invocation, and that it should, after the servant handles the request, return the result and deactivate the servant. Such a call to a server maintains no state information and is similar to calls in Stateless Software-Modules, but with the difference that Stateless Software-Modules don’t deal with remote entities.</p>
</li>
</ul>
</div></section>
<section class="notoc pagebreak-before" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587922599248">
<h2>Applied to Running Example</h2>
<p>Your<a data-primary="Stateless Software-Module pattern" data-startref="stsomopat" data-type="indexterm" id="idm45587922597344"/><a data-primary="data lifetime and ownership" data-secondary="Stateless Software-Module pattern" data-startref="dssomopat" data-type="indexterm" id="idm45587922596368"/> first device driver has the following code:</p>
<p><em>API (header file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="kt">char</code><code class="w"> </code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">);</code><code class="w"/>
<code class="kt">char</code><code class="w"> </code><code class="nf">receiveByte</code><code class="p">();</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="kt">char</code><code class="w"> </code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* open socket to destination_ip, send data via this socket and close</code>
<code class="cm">     the socket */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">char</code><code class="w"> </code><code class="nf">receiveByte</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* open socket for receiving data, wait some time and return</code>
<code class="cm">     the received data */</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The user of your Ethernet driver does not have to cope with implementation details like how to access sockets and can simply use the provided API. Both of the functions in this API can be called at any time independently from each other and the caller can obtain data provided by the functions without having to cope with ownership and freeing resources. Using this API is simple but also very limited.</p>
<p>Next, you want to provide additional functionality for your driver. You want to make it possible for the user to see whether the Ethernet communication works, and thus you want to provide statistics showing the number of sent or received bytes. With a simple Stateless Software-Module, you cannot achieve this, because you have no retained memory for storing state information from one function call to another.</p>
<p>To achieve this, you need a Software-Module with Global State.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Software-Module with Global State" data-type="sect1"><div class="sect1" id="pattern_software_module_with_global_state">
<h1>Software-Module with Global State</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587922497200">
<h2>Context</h2>
<p>You<a data-primary="data lifetime and ownership" data-secondary="Software-Module with Global State pattern" data-type="indexterm" id="dsmwgspat"/><a data-primary="Software-Module with Global State pattern" data-type="indexterm" id="swmwgspat"/> want to provide functions with related functionality to a caller. The functions operate on common data shared between them, and they might require preparation of resources like memory that has to be initialized prior to using your functionality, but the functions do not require any caller-dependent state information.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587922493088">
<h2>Problem</h2>
<p><strong>You want to structure your logically related code that requires common state information and make that functionality as easy as possible to use for the caller.</strong></p>
<p>You want to make it simple for the caller to access your functionality. The caller should not have to deal with initialization and cleanup aspects of the functions, and the caller should not be confronted with implementation details. The caller should not necessarily realize that the functions access common data.</p>
<p>You don’t necessarily need the functions to be very flexible regarding future changes while maintaining backwards compatibility—instead the functions should provide an easy-to-use abstraction for accessing the implemented functionality.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587922490128">
<h2>Solution</h2>
<p><strong>Have<a data-primary="functions" data-secondary="global instances and" data-type="indexterm" id="idm45587922474080"/><a data-primary="global variables" data-type="indexterm" id="idm45587922473072"/> one global instance to let your related function implementations share common resources. Put all functions that operate on this instance into one header file and provide the caller this interface to your software-module.</strong></p>
<p>Put the function declaration in one Header File, and put all the implementations for your software-module into one implementation file in a Software-Module Directory.
In this implementation file, have a global instance (a file-global static <code>struct</code> or several file-global static variables—see Eternal Memory) that holds the common shared resources that should be available for your function implementations. Your function implementations can then access these shared resources similar to how private variables work in object-oriented programming languages.</p>
<p>The initialization and lifetime of the resources are transparently managed in the software-module and are independent from the lifetime of its callers. If the resources have to be initialized, then you can initialize them at startup time, or you can use lazy acquisition to initialize the resources right before they are needed.</p>
<p>The caller does not realize from the function call syntax that the functions operate on common resources, so you should document this for the caller. Within your software-module, the access to these file-global resources might have to be protected by synchronization primitives such as a Mutex to make it possible to have multiple callers from different threads. Make this synchronization within your function implementation, so that the caller does not have to deal with synchronization aspects.</p>
<p>The following code shows an example of a simple Software-Module with Global State:</p>
<p><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="n">result</code><code class="p">;</code><code class="w"/>
<code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">addNext</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code><code class="w"/>
<code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">addNext</code><code class="p">(</code><code class="mi">20</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>API (header file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* Adds the parameter 'value' to the values accumulated</code>
<code class="cm">   with previous calls of this function. */</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="nf">addNext</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">value</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">addNext</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* calculation of the result depending on the parameter</code>
<code class="cm">     and on state information from previous function calls */</code><code class="w"/>
<code class="w">  </code><code class="n">sum</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">sum</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The caller calls <code>addNext</code> and retrieves a copy of the result. When calling the function twice with same the input parameters, the function might deliver different results because the function maintains state information.</p>
<p><a data-type="xref" href="#fig_global">Figure 5-3</a> shows an overview of the Software-Module with Global State.</p>
<figure><div class="figure" id="fig_global">
<img alt="sketches/alt=Software-Module with Global State Lifetime" height="586" src="assets/fluc_0503.png" width="1149"/>
<h6><span class="label">Figure 5-3. </span>Software-Module with Global State</h6>
</div></figure>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587922489504">
<h2>Consequences</h2>
<p>Now your functions can share information or resources, even though the caller is not required to pass parameters containing this shared information, and the caller is not responsible for allocating and cleaning up resources. To achieve this sharing of information in your software-module, you implemented the C version of a<a data-primary="Singleton pattern/anti-pattern" data-type="indexterm" id="idm45587922348400"/> Singleton. Beware of the Singleton—many have commented on the disadvantages of this pattern, and often it is instead called an antipattern.</p>
<p>Still, in C such Software-Modules with Global State are widespread, because it is quite easy to write the keyword <code>static</code> before a variable, and as soon as you do that, you have your Singleton. In some cases that is OK. If your implementation files are short, having file-global variables is quite similar to having private variables in object-oriented programming. If your functions do not require state information or do not operate in multithreaded environments, then you might be just fine. However if multithreading and state information become an issue and your implementation file becomes longer and longer, then you are in trouble and the Software-Module with Global State is not a good solution anymore.</p>
<p>If your Software-Module with Global State requires initialization, then you either have to initialize it during an initialization phase like at system startup, or you have to use lazy acquisition to initialize short before the first use of resources. However, this has the drawback that the duration for your function calls varies, because additional initialization code is implicitly called at the very first call. In any case, the resource acquisition is performed transparently to the caller. The resources are owned by your software-module, and thus the caller is not burdened with ownership of resources and does not have to explicitly acquire or release the resources.</p>
<p>However, not all functionality can be provided with such a simple interface. If the functions within an API share caller-specific state information, then a different approach, like a Caller-Owned Instance, has to be taken.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587922345712">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>The <em>string.h</em> function <code>strtok</code> splits a string into tokens. Each time the function is called, the next token for the string is delivered. In order to have the state information about which token to deliver next, the function uses static variables.</p>
</li>
<li>
<p>With a Trusted Platform Module (TPM) one can accumulate hash values of loaded software. The corresponding function in the TPM-Emulator v0.7 code uses static variables to store this accumulated hash value.</p>
</li>
<li>
<p>The <code>math</code> library uses a state for its random number generation. Each call of <code>rand</code> calculates a new pseudorandom number based on the number calculated with the previous <code>rand</code> call. <code>srand</code> has to be called first in order to set the seed (the initial static information) for the pseudorandom number generator called with <code>rand</code>.</p>
</li>
<li>
<p>An Immutable Instance can be seen as part of a Software-Module with Global State with the special case that the instance is not modified at runtime.</p>
</li>
<li>
<p>The source code of the NetHack game stores information about items (swords, shields) in a static list defined at compile time and provides functions to access this shared information.</p>
</li>
<li>
<p>The pattern called Static Instance from the book <em>Remoting Patterns</em> by Markus Voelter et al. (Wiley, 2007) suggests providing remote objects with lifetime decoupled from the lifetime of the caller. The remote objects can, for example, be initialized at startup time and then be provided to a caller when requested. Software-Module with Global State presents the same idea of having static data, but it is not meant to have multiple instances for different callers.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587922296288">
<h2>Applied to Running Example</h2>
<p>Now<a data-primary="Software-Module with Global State pattern" data-startref="swmwgspat" data-type="indexterm" id="idm45587922294048"/><a data-primary="data lifetime and ownership" data-secondary="Software-Module with Global State pattern" data-startref="dsmwgspat" data-type="indexterm" id="idm45587922292944"/> you have the following code for your Ethernet driver:</p>
<p><em>API (header file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="kt">char</code><code class="w"> </code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">);</code><code class="w"/>
<code class="kt">char</code><code class="w"> </code><code class="nf">receiveByte</code><code class="p">();</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="nf">getNumberOfSentBytes</code><code class="p">();</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="nf">getNumberOfReceivedBytes</code><code class="p">();</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">number_of_sent_bytes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="k">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">number_of_received_bytes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="kt">char</code><code class="w"> </code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">number_of_sent_bytes</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="cm">/* socket stuff */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">char</code><code class="w"> </code><code class="nf">receiveByte</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">number_of_received_bytes</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="cm">/* socket stuff */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">getNumberOfSentBytes</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">number_of_sent_bytes</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">getNumberOfReceivedBytes</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">number_of_received_bytes</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p class="fix-tracking">The API looks very similar to an API of a Stateless Software-Module, but behind this API now lies functionality to retain information between the function calls, which is needed for the counters for sent and received bytes. As long as there is only one user (one thread) who uses this API, everything is just fine. However, if there are multiple threads, then with static variables you always run into the problem that race 
<span class="keep-together">conditions</span> occur if you don’t implement mutual exclusion for the access to the static variables.</p>
<p>All right—now you want the Ethernet driver to be more efficient, and you want to send more data. You could simply call your <code>sendByte</code> function frequently to do this, but in your Ethernet driver implementation that means that for each <code>sendByte</code> call, you establish a socket connection, send the data, and close the socket connection again. Establishing and closing the socket connection takes most of the communication time.</p>
<p>This is quite inefficient and you’d prefer to open your socket connection once, then send all the data by calling your <code>sendByte</code> function several times, and then close the socket connection. But now your <code>sendByte</code> function requires a preparation and a teardown phase. This state cannot be stored in a Software-Module with Global State because as soon as you have more than one caller (that is, more than one thread), you’d run into the problem or multiple callers wanting to simultaneously send data—maybe even to different destinations.</p>
<p>To achieve that, provide each of these callers with a Caller-Owned Instance.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Caller-Owned Instance" data-type="sect1"><div class="sect1" id="pattern_caller_owned_instance">
<h1>Caller-Owned Instance</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587922122016">
<h2>Context</h2>
<p>You<a data-primary="data lifetime and ownership" data-secondary="Caller-Owned Instance pattern" data-type="indexterm" id="dcaowipat"/><a data-primary="Caller-Owned Instance pattern" data-type="indexterm" id="caowinpat"/> want to provide functions with related functionality to a caller. The functions operate on common data shared between them, they might require preparation of resources like memory that has to be initialized prior to using your functionality, and they share caller-specific state information among one another.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587922117552">
<h2>Problem</h2>
<p><strong>You<a data-primary="functions" data-secondary="providing access to multiple threads" data-type="indexterm" id="idm45587922115648"/><a data-primary="multithreaded environments" data-type="indexterm" id="idm45587922086800"/> want to provide multiple callers or threads access to functionality with functions that depend on one another, and the interaction of the caller with your functions builds up state information.</strong></p>
<p>Maybe one function has to be called before another because it influences a state stored in your software-module that is then needed by the other function. This can be achieved with a Software-Module with Global State, but it only works as long as there is only one caller. In a multithreaded environment with multiple callers, you cannot have one central software-module holding all caller-dependent state information.</p>
<p class="pagebreak-before">Still, you want to hide implementation details from the caller, and you want to make it as simple as possible for the caller to access your functionality. It has to be clearly defined if the caller is responsible for allocating and cleaning up resources.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587922084656">
<h2>Solution</h2>
<p><strong>Require the caller to pass an instance, which is used to store resource and state information, along to your functions. Provide explicit functions to create and destroy these instances, so that the caller can determine their lifetime.</strong></p>
<p class="fix-tracking">To implement such an instance that can be accessed from multiple functions, pass a <code>struct</code> pointer along with all functions that require sharing resources or state information. The functions can now use the <code>struct</code> members, which are similar to private variables in object-oriented languages, to store and read resource and state 
<span class="keep-together">information.</span></p>
<p>The <code>struct</code> can be declared in the API to let the caller conveniently access its members directly. Alternatively, the <code>struct</code> can be declared in the implementation, and only a pointer to the <code>struct</code> can be declared in the API (as suggested by Handle). The caller does not know the <code>struct</code> members (they are like private variables) and can only operate with functions on the <code>struct</code>.</p>
<p>Because the instance has to be manipulated by multiple functions and you do not know when the caller finished calling functions, the lifetime of the instance has to be determined by the caller. Therefore, Dedicate Ownership to the caller and provide explicit functions for creating and destroying the instance. The caller has an aggregate relationship to the instance.</p>
<div data-type="note" epub:type="note"><h1>Aggregation Versus Association</h1>
<p>If<a data-primary="aggregation, versus association" data-type="indexterm" id="idm45587922075888"/><a data-primary="association, versus aggregation" data-type="indexterm" id="idm45587922075184"/> an instance is semantically related to another instance, then those instances are associated. A stronger type of association is an aggregation, in which one instance has ownership of the other.</p>
</div>
<p>The following code shows an example of a simple Caller-Owned Instance:</p>
<p><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">;</code><code class="w"/>
<code class="n">inst</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">createInstance</code><code class="p">();</code><code class="w"/>
<code class="n">operateOnInstance</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/>
<code class="cm">/* access inst-&gt;x or inst-&gt;y */</code><code class="w"/>
<code class="n">destroyInstance</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/></pre>
<p class="pagebreak-before"><em>API (header file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="cm">/* Creates an instance which is required for working</code>
<code class="cm">   with the function 'operateOnInstance' */</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">createInstance</code><code class="p">();</code><code class="w"/>

<code class="cm">/* Operates on the data stored in the instance */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">operateOnInstance</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">);</code><code class="w"/>

<code class="cm">/* Cleans up an instance created with 'createInstance' */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">destroyInstance</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">createInstance</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">inst</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">malloc</code><code class="p">(</code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="p">));</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">inst</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">operateOnInstance</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* work with inst-&gt;x and inst-&gt;y */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">destroyInstance</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">free</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The function <code>operateOnInstance</code> works on resources created with the previous function call <code>createInstance</code>. The resource or state information between the two function calls is transported by the caller, who has to provide the <code>INSTANCE</code> for each function call and who also has to clean up all the resources by calling <code>destroy​In⁠stance</code>.</p>
<p><a data-type="xref" href="#fig_caller">Figure 5-4</a> shows an overview of the Caller-Owned Instance.</p>
<figure><div class="figure" id="fig_caller">
<img alt="Caller-Owned Instance Lifetime" height="668" src="assets/fluc_0504.png" width="700"/>
<h6><span class="label">Figure 5-4. </span>Caller-Owned Instance</h6>
</div></figure>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587922084064">
<h2>Consequences</h2>
<p>The functions in your API are more powerful now because they can share state information and operate on shared data while still being available for multiple callers (that is, multiple threads). Each created Caller-Owned Instance has its own private variables, and even if more than one such Caller-Owned Instance is created (for example, by multiple callers in a multithreaded environment), it is not a problem.</p>
<p>However, to achieve this, your API becomes more complicated. You have to make explicit <code>create()</code> and <code>destroy()</code> calls for managing the instance’s lifetime, because C does not support constructors and destructors. This makes handling with instances much more difficult because the caller obtains ownership and is responsible for cleaning up the instance. As this has to be done manually with the <code>destroy()</code> call, and not via an automatic destructor like in object-oriented programing languages, this is a common pitfall for memory leaks. This issue is addressed by Object-Based Error Handling, which suggests that the caller should also have a dedicated cleanup function to make this task more explicit.</p>
<p>Also, compared to a Stateless Software-Module, calling each of the functions becomes a bit more complicated. Each function takes an additional parameter referencing the instance, and the functions cannot be called in arbitrary order—the caller has to know which one has to be called first. This is made explicit through the function 
<span class="keep-together">signatures.</span></p>
</div></section>
<section class="notoc pagebreak-before" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587921801520">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>An example of the use of a Caller-Owned Instance is the doubly linked list provided with the <code>glibc</code> library. The caller creates a list with <code>g_list_alloc</code> and can then insert items into this list with <code>g_list_insert</code>. When finished working with the list, the caller is responsible for cleaning it up with <code>g_list_free</code>.</p>
</li>
<li>
<p>This pattern is described by Robert Strandh in the article <a href="https://oreil.ly/UVodl">“Modular C”</a>. It describes how to write modular C programs. The article states the importance of identifying abstract data types—which can be manipulated or accessed with functions—in the application.</p>
</li>
<li>
<p>The Windows API to create menus in the menu bar has a function to create a menu instance (<code>CreateMenu</code>), functions to operate on menus (like <code>InsertMenu​Item</code>), and a function to destroy the menu instance (<code>DestroyMenu</code>). All these functions have one parameter to pass the Handle to the menu instance.</p>
</li>
<li>
<p>Apache’s software-module to handle HTTP requests provides functions to create all required request information (<code>ap_sub_req_lookup_uri</code>), to process it (<code>ap_run_sub_req</code>), and to destroy it (<code>ap_destroy_sub_req</code>). These functions take a <code>struct</code> pointer to the request instance in order to share request information.</p>
</li>
<li>
<p>The source code of the NetHack game uses a <code>struct</code> instance to represent monsters and provides functions to create and destroy a monster. The NetHack code also provides functions to obtian information from monsters (<code>is_starting_pet</code>, <code>is_vampshifter</code>).</p>
</li>
<li>
<p>The pattern called Client-Dependent Instance, from the book <em>Remoting Patterns</em> by Markus Voelter et al. (Wiley, 2007), suggests for distributed object middlewares, providing remote objects whose lifetime is controlled by the clients. The server creates new instances for clients and the client can then work with these instances, pass them along, or destroy them.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587921786064">
<h2>Applied to Running Example</h2>
<p>Now<a data-primary="Caller-Owned Instance pattern" data-startref="caowinpat" data-type="indexterm" id="idm45587921784160"/><a data-primary="data lifetime and ownership" data-secondary="Caller-Owned Instance pattern" data-startref="dcaowipat" data-type="indexterm" id="idm45587921783184"/> you have the following code for your Ethernet driver:</p>
<p><em>API (header file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">char</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">[</code><code class="mi">16</code><code class="p">];</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">socket</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">};</code><code class="w"/>

<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">createSender</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">data</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">destroySender</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">createSender</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">malloc</code><code class="p">(</code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="p">));</code><code class="w"/>
<code class="w">  </code><code class="cm">/* create socket to destination_ip and store it in Sender s*/</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">s</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">sendByte</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">data</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">number_of_sent_bytes</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="cm">/* send data via socket stored in Sender s */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">destroySender</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* close socket stored in Sender s */</code><code class="w"/>
<code class="w">  </code><code class="n">free</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>A caller can first create a sender, then send all the data, and then destroy the sender. Thus, the caller can make sure that the socket connection does not have to be established again for each <code>sendByte()</code> call. The caller has ownership of the created sender, has full control over how long the sender lives, and is responsible for cleaning it up:</p>
<p><em>Caller’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">createSender</code><code class="p">(</code><code class="s">"192.168.0.1"</code><code class="p">);</code><code class="w"/>
<code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">dataToSend</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Hello World!"</code><code class="p">;</code><code class="w"/>
<code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">pointer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dataToSend</code><code class="p">;</code><code class="w"/>
<code class="k">while</code><code class="p">(</code><code class="o">*</code><code class="n">pointer</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="sc">'\0'</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">sendByte</code><code class="p">(</code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">pointer</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">pointer</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">destroySender</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"/></pre>
<p>Next, let’s assume that you are not the only user of this API. There might be multiple threads using your API. As long as one thread creates a sender for sending to IP address X and another thread creates a sender for sending to Y, we are just fine, and the Ethernet driver creates independent sockets for both threads.</p>
<p>However, let’s say the two threads want to send data to the same recipient. Now the Ethernet driver is in trouble because on one specific port, it can only open one socket per destination IP. A solution to this problem would be to not allow two different threads to send to the same destination—the second thread creating the sender could simply receive an error. But it is also possible to allow both threads to send data using the same sender.</p>
<p>To achieve this, simply construct a Shared Instance.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Shared Instance" data-type="sect1"><div class="sect1" id="pattern_shared_instance">
<h1>Shared Instance</h1>
<section class="notoc" data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm45587921443392">
<h2>Context</h2>
<p>You<a data-primary="data lifetime and ownership" data-secondary="Shared Instance pattern" data-type="indexterm" id="dshainpat"/><a data-primary="Shared Instance pattern" data-type="indexterm" id="shainspat"/><a data-primary="instances" data-secondary="sharing" data-type="indexterm" id="idm45587921439568"/> want to provide functions with related functionality to a caller. The functions operate on shared common data, and they might require preparation of resources like memory that has to be initialized prior to using your functionality. There are multiple contexts in which the functionality can be called, and these contexts are shared between the callers.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45587921438240">
<h2>Problem</h2>
<p><strong>You want to provide multiple callers or threads access to functionality with functions that depend on one another, and the interaction of the caller with your 
<span class="keep-together">functions</span> builds up state information, which your callers want to share.</strong></p>
<p>Storing the state information in a Software-Module with Global State is not an option because there are multiple callers who want to build up different state information. Storing the state information per caller in a Caller-Owned Instance is not an option because either some of your callers want to access and operate on the same instance, or because you don’t want to create new instances for every caller in order to keep resource costs low.</p>
<p>Still, you want to hide implementation details from the caller, and you want to make it as simple as possible for the caller to access your functionality. It has to be clearly defined if the caller is responsible for allocating and cleaning up resources.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45587921434592">
<h2>Solution</h2>
<p><strong>Require<a data-primary="functions" data-secondary="passing instances to" data-type="indexterm" id="idm45587921432496"/> the caller to pass an instance, which is used to store resource and state information, along to your functions. Use the same instance for multiple callers and keep the ownership of that instance in your software-module.</strong></p>
<p class="fix-tracking">Just like with the Caller-Owned Instance, provide a <code>struct</code> pointer or a Handle that the caller then passes along the function calls. When creating the instance, the caller now also has to provide an identifier (for example, a unique name) to specify the kind of instance to create. With this identifier you can know if such an instance already exists. If it exists, you don’t create a new instance, but instead return the <code>struct</code> pointer or Handle to the instance that you already created and returned to other 
<span class="keep-together">callers.</span></p>
<p>To know if an instance already exists, you have to hold a list of already created instances in your software-module. This can be done by implementing a Software-Module with Global State to hold the list. In addition to whether an instance was already created or not, you can store the information of who currently accesses which instances or at least how many callers currently access an instance. This additional information is required because when everybody is finished accessing an instance, it is your duty to clean it up because you are the one who has Dedicated Ownership of it.</p>
<p>You also have to check whether your functions can be called simultaneously by different callers on the same instance. In some easier cases, there might be no data whose access has to be mutually excluded by different callers because it is only read. In such cases an Immutable Instance, which does not allow the caller to change the instance, could be implemented. But in other cases, you have to implement mutual exclusion in your functions for resources shared through the instance.</p>
<p>The following code shows an example of a simple Shared Instance:</p>
<p><em>Caller1’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">openInstance</code><code class="p">(</code><code class="n">INSTANCE_TYPE_B</code><code class="p">);</code><code class="w"/>
<code class="cm">/* operate on the same instance as caller2 */</code><code class="w"/>
<code class="n">operateOnInstance</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/>
<code class="n">closeInstance</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Caller2’s code</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">openInstance</code><code class="p">(</code><code class="n">INSTANCE_TYPE_B</code><code class="p">);</code><code class="w"/>
<code class="cm">/* operate on the same instance as caller1 */</code><code class="w"/>
<code class="n">operateOnInstance</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/>
<code class="n">closeInstance</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>API (header file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="cm">/* to be used as IDs for the function openInstance */</code><code class="w"/>
<code class="cp">#define INSTANCE_TYPE_A 1</code>
<code class="cp">#define INSTANCE_TYPE_B 2</code>
<code class="cp">#define INSTANCE_TYPE_C 3</code>

<code class="cm">/* Retrieve an instance identified by the parameter 'id'. That instance is</code>
<code class="cm">   created if no instance of that 'id' was yet retrieved from any</code>
<code class="cm">   other caller. */</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">openInstance</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">id</code><code class="p">);</code><code class="w"/>

<code class="cm">/* Operates on the data stored in the instance. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">operateOnInstance</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">);</code><code class="w"/>

<code class="cm">/* Releases an instance which was retrieved with 'openInstance'.</code>
<code class="cm">   If all callers release an instance, it gets destroyed. */</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">closeInstance</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="cp">#define MAX_INSTANCES 4</code>

<code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCELIST</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">count</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">static</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCELIST</code><code class="w"> </code><code class="n">list</code><code class="p">[</code><code class="n">MAX_INSTANCES</code><code class="p">];</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">openInstance</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">id</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">list</code><code class="p">[</code><code class="n">id</code><code class="p">].</code><code class="n">count</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">list</code><code class="p">[</code><code class="n">id</code><code class="p">].</code><code class="n">inst</code><code class="w"> </code><code class="o">=</code><code class="w">  </code><code class="n">malloc</code><code class="p">(</code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="p">));</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="n">list</code><code class="p">[</code><code class="n">id</code><code class="p">].</code><code class="n">count</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">list</code><code class="p">[</code><code class="n">id</code><code class="p">].</code><code class="n">inst</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">operateOnInstance</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="cm">/* work with inst-&gt;x and inst-&gt;y */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">getInstanceId</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">MAX_INSTANCES</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="p">(</code><code class="n">inst</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">list</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">inst</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">break</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">closeInstance</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">INSTANCE</code><code class="o">*</code><code class="w"> </code><code class="n">inst</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">id</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getInstanceId</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">list</code><code class="p">[</code><code class="n">id</code><code class="p">].</code><code class="n">count</code><code class="o">--</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">list</code><code class="p">[</code><code class="n">id</code><code class="p">].</code><code class="n">count</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">free</code><code class="p">(</code><code class="n">inst</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The caller retrieves an <code>INSTANCE</code> by calling <code>openInstance</code>. The <code>INSTANCE</code> might be created by this function call, or it might have already been created by a previous function call and might also be used by another caller.
The caller can then pass the <code>INSTANCE</code> along to the <code>operateOnInstance</code> function calls, to provide this function with the required resource or state information from the <code>INSTANCE</code>. When finished, the caller has to call <code>closeInstance</code> so that the resources can be cleaned up, if no other caller operates on the <code>INSTANCE</code> anymore.</p>
<p><a data-type="xref" href="#fig_shared">Figure 5-5</a> shows an overview of the Shared Instance.</p>
<figure><div class="figure" id="fig_shared">
<img alt="Shared Instance Lifetime" height="931" src="assets/fluc_0505.png" width="1139"/>
<h6><span class="label">Figure 5-5. </span>Shared Instance</h6>
</div></figure>
</div></section>
<section class="notoc" data-pdf-bookmark="Consequences" data-type="sect2"><div class="sect2" id="idm45587921433968">
<h2>Consequences</h2>
<p>Multiple callers now have simultaneous access to a single instance. This quite often implies that you have to cope with mutual exclusion within your implementation in order not to burden the user with such issues. This implies that the duration for a function call varies because the caller never knows if another caller currently uses the same resources and blocks them.</p>
<p>Your software-module, not the caller, has ownership of the instance, and your software-module is responsible for cleaning up resources. The caller is still responsible for releasing the resources so that your software-module knows when to clean everything up—as with the Caller-Owned Instance, this is a pitfall for memory leaks.</p>
<p>Because the software-module has ownership of the instances, it can also clean up the instances without requiring the callers to initiate cleanup. For example, if the software-module receives a shutdown signal from the operating system, it can clean up all instances because it has ownership of them.</p>
</div></section>
<section class="notoc" data-pdf-bookmark="Known Uses" data-type="sect2"><div class="sect2" id="idm45587920900272">
<h2>Known Uses</h2>
<p>The following examples show applications of this pattern:</p>
<ul>
<li>
<p>An example of the use of a Shared Instance is the <em>stdio.h</em> file-functions. A file can be opened by multiple callers via the function <code>fopen</code>. The caller retrieves a Handle to the file and can read from or write to the
file (<code>fread</code>, <code>fprintf</code>). The file is a shared resource. For example, there is one global cursor position in the file for all callers. When a caller finishes operating on the file, it has to be closed with <code>fclose</code>.</p>
</li>
<li>
<p>This pattern and its implementation details for object-oriented programming languages are presented as Counting Handle in the article <a href="https://oreil.ly/inThj">“C++ Patterns: Reference Accounting”</a> by Kevlin Henney. It describes how a shared object on the heap can be accessed and how its lifetime can be handled transparently.</p>
</li>
<li>
<p>The Windows registry can be accessed simultaneously by multiple threads with the function <code>RegCreateKey</code> (which opens the key, if it already exists). The function delivers a Handle that can be used by other functions to operate on the registry key. When the registry operations are finished, the <code>RegCloseKey</code> function has to be called by everybody who opened the key.</p>
</li>
<li>
<p>The Windows functionality to access Mutex (<code>CreateMutex</code>) can be used to
access a shared resource (the Mutex) from multiple threads. With the Mutex, interprocess synchronization can be implemented. When finished working with the Mutex, each caller has to close it by using the function <code>CloseHandle</code>.</p>
</li>
<li>
<p>The B&amp;R Automation Runtime operating system allows multiple callers to access device drivers simultaneously. A caller uses the function <code>DmDeviceOpen</code> to select one of the available devices. The device driver framework checks if the selected driver is available and then provides a Handle to the caller. If multiple callers operate on the same driver, they share the Handle. The callers can then simultaneously interact with the driver (send or read data, interact via IO-controls, etc.), and after this interaction they tell the device driver framework that they are finished by calling <code>DmDeviceClose</code>.</p>
</li>
</ul>
</div></section>
<section class="notoc" data-pdf-bookmark="Applied to Running Example" data-type="sect2"><div class="sect2" id="idm45587920887824">
<h2>Applied to Running Example</h2>
<p>The<a data-primary="data lifetime and ownership" data-secondary="Shared Instance pattern" data-startref="dshainpat" data-type="indexterm" id="idm45587920866688"/><a data-primary="Shared Instance pattern" data-startref="shainspat" data-type="indexterm" id="idm45587920865600"/> driver now additionally implements the following functions:</p>
<p><em>API (header file)</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">openSender</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">sendByte</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">data</code><code class="p">);</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="nf">closeSender</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">);</code><code class="w"/></pre>
<p><br/><em>Implementation</em></p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">openSender</code><code class="p">(</code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">destination_ip</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">isInSenderList</code><code class="p">(</code><code class="n">destination_ip</code><code class="p">))</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getSenderFromList</code><code class="p">(</code><code class="n">destination_ip</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="k">else</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">createSender</code><code class="p">(</code><code class="n">destination_ip</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="n">increaseNumberOfCallers</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">s</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">sendByte</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">data</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">number_of_sent_bytes</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="cm">/* send data via socket stored in Sender s */</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="n">closeSender</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">Sender</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">decreaseNumberOfCallers</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="p">(</code><code class="n">numberOfCallers</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="cm">/* close socket stored in Sender s */</code><code class="w"/>
<code class="w">    </code><code class="n">free</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The API of the running example did not change a lot—instead of having create/destroy functions, your driver now provides open/close functions. By calling such a function, the caller retrieves the Handle for the sender and indicates to the driver that this caller is now operating a sender, but the driver does not necessarily create this sender at that point in time. That might have already been done by an earlier call to the driver (maybe performed by a different thread). Also, a close call might not actually destroy the sender. The ownership of this sender remains in the driver 
<span class="keep-together">implementation</span>, which can decide when to destroy the senders (for example, when all callers close the sender, or if some termination signal is received).</p>
<p>The fact that you now have a Shared Instance instead of a Caller-Owned Instance is mostly transparent to the caller. But the driver implementation changed—it has to remember if a specific sender was already created and provide this shared instance instead of creating a new one. When opening a sender, the caller does not know whether this sender will be newly created or whether an existing sender is retrieved. Depending on this, the duration of the function call might vary.</p>
<p>The presented running driver example showed different kinds of ownership and data lifetime in a single example. We saw how a simple Ethernet driver evolved by adding functionality. First, a Stateless Software-Module was sufficient because the driver did not require any state information. Next, such state information was required, and it was realized by having a Software-Module with Global State in the driver. Then, the need for more performant send functions and for multiple callers for these send functions came up and was first implemented by the Caller-Owned Instance and in a next step by the Shared Instance.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45587921444448">
<h1>Summary</h1>
<p>The<a data-primary="data lifetime and ownership" data-secondary="overview of patterns for" data-type="indexterm" id="idm45587920624656"/> patterns in this chapter showed different ways of structuring your C programs and how long different instances in your program live. <a data-type="xref" href="#lifetime_comparison">Table 5-2</a> gives an overview of the patterns and compares their consequences.</p>
<table id="lifetime_comparison">
<caption><span class="label">Table 5-2. </span>Comparing patterns on lifetime and ownership</caption>
<thead>
<tr>
<th/>
<th>Stateless Software-Module</th>
<th>Software-Module with Global State</th>
<th>Caller-Owned Instance</th>
<th>Shared Instance</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Resource sharing between functions</p></td>
<td><p>Not possible</p></td>
<td><p>Single set of resources</p></td>
<td><p>Set of resources per instance ( = per caller)</p></td>
<td><p>Set of resources per instance (shared by multiple callers)</p></td>
</tr>
<tr>
<td><p>Resource ownership</p></td>
<td><p>Nothing to own</p></td>
<td><p>The software-module owns the static data</p></td>
<td><p>The caller owns the instance</p></td>
<td><p>The software-module owns instances and provides references</p></td>
</tr>
<tr>
<td><p>Resource lifetime</p></td>
<td><p>No resources live longer than a function call</p></td>
<td><p>Static data lives forever in the software-module</p></td>
<td><p>Instances live until callers destroy them</p></td>
<td><p>Instances live until the software-module destroys them</p></td>
</tr>
<tr>
<td><p>Resource initialization</p></td>
<td><p>Nothing to initialize</p></td>
<td><p>At compile time or at startup</p></td>
<td><p>By the caller when creating an instance</p></td>
<td><p>By the software-module when the first caller opens an instance</p></td>
</tr>
</tbody>
</table>
<p>With these patterns, a C programmer has some basic guidance about the design options for organizing programs into software-modules and the design options regarding ownership and lifetime when constructing instances.</p>
</div></section>
<section data-pdf-bookmark="Further Reading" data-type="sect1"><div class="sect1" id="idm45587920563552">
<h1>Further Reading</h1>
<p>The<a data-primary="data lifetime and ownership" data-secondary="further reading on" data-type="indexterm" id="idm45587920562416"/> patterns in this chapter cover how to provide access to instances and who has ownership of these instances. A very similar topic is covered by a subset of the patterns from the book <em>Remoting Patterns</em> by Markus Voelter et al. (Wiley, 2007). The book presents patterns for building distributed object middleware, and three of these patterns focus on lifetime and ownership of objects created by remote servers. Compared to that, the patterns presented in this chapter focus on a different context. They are not patterns for remote systems, but for local procedural programs. They focus on C programming, but can also be used for other procedural programming languages. Still, some of the underlying ideas in the patterns are very similar to those in 
<span class="keep-together"><em>Remoting Patterns</em></span>.</p>
</div></section>
<section data-pdf-bookmark="Outlook" data-type="sect1"><div class="sect1" id="idm45587920559856">
<h1>Outlook</h1>
<p>The next chapter presents different kinds of interfaces for software-modules with a special focus on how to make the interface flexible. The patterns elaboarate on the trade-off between simplicity and flexibility.</p>
</div></section>
</div></section></div></body></html>