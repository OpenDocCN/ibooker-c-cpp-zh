["```cpp\n#include <any>\n#include <cstdlib>\n#include <string>\nusing namespace std::string_literals;\n\nint main()\n{\n   std::any a;          // Creating an empty 'any'\n   a = 1;               // Storing an 'int' inside the 'any';\n   a = \"some string\"s;  // Replacing the 'int' with a 'std::string'\n\n   // There is nothing we can do with the 'any' except for getting the value back\n   std::string s = std::any_cast<std::string>( a );\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n#include <cstdlib>\n#include <memory>\n\nint main()\n{\n   {\n      // Creating a 'std::shared_ptr' with a custom deleter\n      //   Note that the deleter is not part of the type!\n      std::shared_ptr<int> s{ new int{42}, [](int* ptr){ delete ptr; } };\n   }\n   // The 'std::shared_ptr' is destroyed at the end of the scope,\n   //   deleting the 'int' by means of the custom deleter.\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n// This function takes only unique_ptrs that use the default deleter,\n//   and thus is artificially restricted\ntemplate< typename T >\nvoid func1( std::unique_ptr<T> ptr );\n\n// This function does not care about the way the resource is cleaned up,\n//   and thus is truly generic\ntemplate< typename T, typename D >\nvoid func2( std::unique_ptr<T,D> ptr );\n```", "```cpp\n//---- <Circle.h> ----------------\n\nclass Circle\n{\n public:\n   explicit Circle( double radius )\n      : radius_( radius )\n   {}\n\n   double radius() const { return radius_; }\n   /* Several more getters and circle-specific utility functions */\n\n private:\n   double radius_;\n   /* Several more data members */\n};\n\n//---- <Square.h> ----------------\n\nclass Square\n{\n public:\n   explicit Square( double side )\n      : side_( side )\n   {}\n\n   double side() const { return side_; }\n   /* Several more getters and square-specific utility functions */\n\n private:\n   double side_;\n   /* Several more data members */\n};\n```", "```cpp\n//---- <Shape.h> ---------------- \n#include <memory>\n#include <utility>\n\nnamespace detail {\n\nclass ShapeConcept  ![1](assets/1.png)\n{\n public:\n   virtual ~ShapeConcept() = default;\n   virtual void draw() const = 0;  ![2](assets/2.png)\n   virtual std::unique_ptr<ShapeConcept> clone() const = 0;  ![3](assets/3.png)\n};\n\ntemplate< typename ShapeT\n        , typename DrawStrategy >\nclass OwningShapeModel : public ShapeConcept  ![4](assets/4.png)\n{\n public:\n   explicit OwningShapeModel( ShapeT shape, DrawStrategy drawer )  ![5](assets/5.png)\n      : shape_{ std::move(shape) }\n      , drawer_{ std::move(drawer) }\n   {}\n\n   void draw() const override { drawer_(shape_); }  ![8](assets/8.png)\n\n   std::unique_ptr<ShapeConcept> clone() const override\n   {\n      return std::make_unique<OwningShapeModel>( *this );  ![9](assets/9.png)\n   }\n\n private:\n   ShapeT shape_;  ![6](assets/6.png)\n   DrawStrategy drawer_;  ![7](assets/7.png)\n};\n\n} // namespace detail \n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nclass Shape\n{\n public:\n   template< typename ShapeT\n           , typename DrawStrategy >\n   Shape( ShapeT shape, DrawStrategy drawer )  ![10](assets/10.png)\n   {\n      using Model = detail::OwningShapeModel<ShapeT,DrawStrategy>;  ![11](assets/11.png)\n      pimpl_ = std::make_unique<Model>( std::move(shape)  ![12](assets/12.png)\n                                      , std::move(drawer) );\n   }\n\n   // ... \n private:\n   // ... \n   std::unique_ptr<detail::ShapeConcept> pimpl_;  ![13](assets/13.png)\n};\n\n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nclass Shape\n{\n public:\n   // ... \n   Shape( Shape const& other )  ![14](assets/14.png)\n      : pimpl_( other.pimpl_->clone() )\n   {}\n\n   Shape& operator=( Shape const& other )  ![15](assets/15.png)\n   {\n      // Copy-and-Swap Idiom\n      Shape copy( other );\n      pimpl_.swap( copy.pimpl_ );\n      return *this;\n   }\n\n   ~Shape() = default;\n   Shape( Shape&& ) = default;\n   Shape& operator=( Shape&& ) = default;\n\n private:\n   friend void draw( Shape const& shape )  ![16](assets/16.png)\n   {\n      shape.pimpl_->draw();\n   }\n\n   // ... };\n\n```", "```cpp\n//---- <Main.cpp> ---------------- \n#include <Circle.h>\n#include <Square.h>\n#include <Shape.h>\n#include <cstdlib>\n\nint main()\n{\n   // Create a circle as one representative of a concrete shape type\n   Circle circle{ 3.14 };\n\n   // Create a drawing strategy in the form of a lambda\n   auto drawer = []( Circle const& c ){ /*...*/ };\n\n   // Combine the shape and the drawing strategy in a 'Shape' abstraction\n   // This constructor call will instantiate a 'detail::OwningShapeModel' for\n   // the given 'Circle' and lambda types\n   Shape shape1( circle, drawer );\n\n   // Draw the shape\n   draw( shape1 );  ![17](assets/17.png)\n\n   // Create a copy of the shape by means of the copy constructor\n   Shape shape2( shape1 );\n\n   // Drawing the copy will result in the same output\n   draw( shape2 );  ![18](assets/18.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\n//---- <YourMain.cpp> ----------------\n\nint main()\n{\n   // Create a circle as one representative of a concrete shape type\n   Circle circle{ 3.14 };\n\n   // Bind the circle to some drawing functionality\n   auto drawingCircle = [=]() { myCircleDrawer(circle); };\n\n   // Type-erase the circle equipped with drawing behavior\n   Shape shape( drawingCircle );\n\n   // Drawing the shape\n   draw( shape );\n\n   // ...\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\nint main()\n{\n   // ...\n\n   if( shape1 == shape2 ) { /*...*/ }  // Does not compile!\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\nbool operator==( Shape const& lhs, Shape const& rhs )\n{\n   return lhs.area() == rhs.area();\n}\n```", "```cpp\n#include <Circle.h>\n#include <Square.h>\n#include <cstdlib>\n\nint main()\n{\n   Shape shape1( Circle{3.14} );\n   Shape shape2( Square{2.71} );\n\n   if( shape1 == shape2 ) { /*...*/ }\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nnamespace detail {\n\nclass ShapeConcept\n{\n public:\n   // ...\n   virtual bool isEqual( ShapeConcept const* c ) const = 0;\n};\n\ntemplate< typename ShapeT\n        , typename DrawStrategy >\nclass OwningShapeModel : public ShapeConcept\n{\n public:\n   // ... \n   bool isEqual( ShapeConcept const* c ) const override\n   {\n      using Model = OwningShapeModel<ShapeT,DrawStrategy>;\n      auto const* model = dynamic_cast<Model const*>( c );  ![19](assets/19.png)\n      return ( model && shape_ == model->shape_ );\n   }\n\n private:\n   // ... };\n\n} // namespace detail \n\nclass Shape\n{\n   // ... \n private:\n   friend bool operator==( Shape const& lhs, Shape const& rhs )\n   {\n      return lhs.pimpl_->isEqual( rhs.pimpl_.get() );\n   }\n\n   friend bool operator!=( Shape const& lhs, Shape const& rhs )\n   {\n      return !( lhs == rhs );\n   }\n\n   // ... };\n\n//---- <Circle.h> ---------------- \nclass Circle\n{\n   // ... };\n\nbool operator==( Circle const& lhs, Circle const& rhs )\n{\n   return lhs.radius() == rhs.radius();\n}\n\n//---- <Square.h> ---------------- \nclass Square\n{\n   // ... };\n\nbool operator==( Square const& lhs, Square const& rhs )\n{\n   return lhs.side() == rhs.side();\n}\n\n```", "```cpp\nclass Document  // Type-erased 'Document'\n{\n public:\n   // ...\n   void exportToJSON( /*...*/ ) const;\n   void serialize( ByteStream& bs, /*...*/ ) const;\n   // ...\n};\n\n// Artificial coupling to 'ByteStream', although only the JSON export is needed\nvoid exportDocument( Document const& doc )\n{\n   // ...\n   doc.exportToJSON( /* pass necessary arguments */ );\n   // ...\n}\n```", "```cpp\nDocument doc = /*...*/;  // Type-erased 'Document'\ndoc.exportToJSON( /* pass necessary arguments */ );\ndoc.serialize( /* pass necessary arguments */ );\n\nJSONExportable jdoc = doc;  // Type-erased 'JSONExportable'\njdoc.exportToJSON( /* pass necessary arguments */ );\n\nSerializable sdoc = doc;  // Type-erased 'Serializable'\nsdoc.serialize( /* pass necessary arguments */ );\n```", "```cpp\n#include <array>\n#include <cstdlib>\n#include <memory>\n\ntemplate< size_t Capacity = 32U, size_t Alignment = alignof(void*) >  ![2](assets/2.png)\nclass Shape\n{\n public:\n   // ... \n private:\n   // ... \n   Concept* pimpl()  ![3](assets/3.png)\n   {\n      return reinterpret_cast<Concept*>( buffer_.data() );\n   }\n\n   Concept const* pimpl() const  ![4](assets/4.png)\n   {\n      return reinterpret_cast<Concept const*>( buffer_.data() );\n   }\n\n   alignas(Alignment) std::array<std::byte,Capacity> buffer_;  ![1](assets/1.png)\n};\n\n```", "```cpp\ntemplate< size_t Capacity = 32U, size_t Alignment = alignof(void*) >\nclass Shape\n{\n public:\n   // ... \n private:\n   struct Concept\n   {\n      virtual ~Concept() = default;\n      virtual void draw() const = 0;\n      virtual void clone( Concept* memory ) const = 0;  ![5](assets/5.png)\n      virtual void move( Concept* memory ) = 0;  ![6](assets/6.png)\n   };\n\n   template< typename ShapeT, typename DrawStrategy >\n   struct OwningModel : public Concept\n   {\n      OwningModel( ShapeT shape, DrawStrategy drawer )\n         : shape_( std::move(shape) )\n         , drawer_( std::move(drawer) )\n      {}\n\n      void draw() const override\n      {\n         drawer_( shape_ );\n      }\n\n      void clone( Concept* memory ) const override  ![5](assets/5.png)\n      {\n         std::construct_at( static_cast<OwningModel*>(memory), *this );\n\n         // or:\n         // auto* ptr =\n         //    const_cast<void*>(static_cast<void const volatile*>(memory));\n         // ::new (ptr) OwningModel( *this );\n      }\n\n      void move( Concept* memory ) override  ![6](assets/6.png)\n      {\n         std::construct_at( static_cast<OwningModel*>(memory), std::move(*this) );\n\n         // or:\n         // auto* ptr =\n         //    const_cast<void*>(static_cast<void const volatile*>(memory));\n         // ::new (ptr) OwningModel( std::move(*this) );\n      }\n\n      ShapeT shape_;\n      DrawStrategy drawer_;\n   };\n\n   // ... \n   alignas(Alignment) std::array<std::byte,Capacity> buffer_;\n};\n\n```", "```cpp\ntemplate< size_t Capacity = 32U, size_t Alignment = alignof(void*) >\nclass Shape\n{\n public:\n   // ... \n   Shape( Shape const& other )\n   {\n      other.pimpl()->clone( pimpl() );  ![7](assets/7.png)\n   }\n\n   Shape& operator=( Shape const& other )\n   {\n      // Copy-and-Swap Idiom\n      Shape copy( other );  ![8](assets/8.png)\n      buffer_.swap( copy.buffer_ );\n      return *this;\n   }\n\n   Shape( Shape&& other ) noexcept\n   {\n      other.pimpl()->move( pimpl() );  ![9](assets/9.png)\n   }\n\n   Shape& operator=( Shape&& other ) noexcept\n   {\n      // Copy-and-Swap Idiom\n      Shape copy( std::move(other) );  ![10](assets/10.png)\n      buffer_.swap( copy.buffer_ );\n      return *this;\n   }\n\n   ~Shape()  ![11](assets/11.png)\n   {\n      std::destroy_at( pimpl() );\n      // or: pimpl()->~Concept();\n   }\n\n private:\n   // ... \n   alignas(Alignment) std::array<std::byte,Capacity> buffer_;\n};\n\n```", "```cpp\ntemplate< size_t Capacity = 32U, size_t Alignment = alignof(void*) >\nclass Shape\n{\n public:\n   template< typename ShapeT, typename DrawStrategy >\n   Shape( ShapeT shape, DrawStrategy drawer )\n   {\n      using Model = OwningModel<ShapeT,DrawStrategy>;\n\n      static_assert( sizeof(Model) <= Capacity, \"Given type is too large\" );\n      static_assert( alignof(Model) <= Alignment, \"Given type is misaligned\" );\n\n      std::construct_at( static_cast<Model*>(pimpl())\n                       , std::move(shape), std::move(drawer) );\n      // or:\n      // auto* ptr =\n      //    const_cast<void*>(static_cast<void const volatile*>(pimpl()));\n      // ::new (ptr) Model( std::move(shape), std::move(drawer) );\n   }\n\n   // ...\n\n private:\n   // ...\n};\n```", "```cpp\ntemplate< typename StoragePolicy >\nclass Shape;\n```", "```cpp\n#include <utility>\n\nstruct DynamicStorage\n{\n   template< typename T, typename... Args >\n   T* create( Args&&... args ) const\n   {\n      return new T( std::forward<Args>( args )... );\n   }\n\n   template< typename T >\n   void destroy( T* ptr ) const noexcept\n   {\n      delete ptr;\n   }\n};\n```", "```cpp\n#include <array>\n#include <cstddef>\n#include <memory>\n#include <utility>\n\ntemplate< size_t Capacity, size_t Alignment >\nstruct InClassStorage\n{\n   template< typename T, typename... Args >\n   T* create( Args&&... args ) const\n   {\n      static_assert( sizeof(T) <= Capacity, \"The given type is too large\" );\n      static_assert( alignof(T) <= Alignment, \"The given type is misaligned\" );\n\n      T* memory = const_cast<T*>(reinterpret_cast<T const*>(buffer_.data()));\n      return std::construct_at( memory, std::forward<Args>( args )... );\n\n      // or:\n      // void* const memory = static_cast<void*>(buffer_.data());\n      // return ::new (memory) T( std::forward<Args>( args )... );\n   }\n\n   template< typename T >\n   void destroy( T* ptr ) const noexcept\n   {\n      std::destroy_at(ptr);\n      // or: ptr->~T();\n   }\n\n   alignas(Alignment) std::array<std::byte,Capacity> buffer_;\n};\n```", "```cpp\ntemplate< typename StoragePolicy >\nclass Shape\n{\n public:\n   template< typename ShapeT >\n   Shape( ShapeT shape )\n   {\n      using Model = OwningModel<ShapeT>;\n      pimpl_ = policy_.template create<Model>( std::move(shape) )  ![12](assets/12.png)\n   }\n\n   ~Shape() { policy_.destroy( pimpl_ ); }  ![13](assets/13.png)\n\n   // ... All other member functions, in particular the\n   //     special members functions, are not shown \n private:\n   // ...\n   [[no_unique_address]] StoragePolicy policy_{};  ![14](assets/14.png)\n   Concept* pimpl_{};\n};\n\n```", "```cpp\n//---- <Shape.h> ---------------- \n#include <cstddef>\n#include <memory>\n\nclass Shape\n{\n public:\n   // ... \n private:\n   // ... \n   template< typename ShapeT\n           , typename DrawStrategy >\n   struct OwningModel  ![15](assets/15.png)\n   {\n      OwningModel( ShapeT value, DrawStrategy drawer )\n         : shape_( std::move(value) )\n         , drawer_( std::move(drawer) )\n      {}\n\n      ShapeT shape_;\n      DrawStrategy drawer_;\n   };\n\n   using DestroyOperation = void(void*);   ![16](assets/16.png)\n   using DrawOperation    = void(void*);   ![17](assets/17.png)\n   using CloneOperation   = void*(void*);  ![18](assets/18.png)\n\n   std::unique_ptr<void,DestroyOperation*> pimpl_;  ![19](assets/19.png)\n   DrawOperation*  draw_ { nullptr };               ![20](assets/20.png)\n   CloneOperation* clone_{ nullptr };               ![21](assets/21.png)\n};\n\n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nclass Shape\n{\n public:\n   template< typename ShapeT\n           , typename DrawStrategy >\n   Shape( ShapeT shape, DrawStrategy drawer )\n      : pimpl_(   ![22](assets/22.png)\n            new OwningModel<ShapeT,DrawStrategy>( std::move(shape)\n                                                , std::move(drawer) )\n          , []( void* shapeBytes ){  ![23](assets/23.png)\n               using Model = OwningModel<ShapeT,DrawStrategy>;\n               auto* const model = static_cast<Model*>(shapeBytes);  ![24](assets/24.png)\n               delete model;  ![25](assets/25.png)\n            } )\n      , draw_(  ![26](assets/26.png)\n            []( void* shapeBytes ){\n               using Model = OwningModel<ShapeT,DrawStrategy>;\n               auto* const model = static_cast<Model*>(shapeBytes);\n               (*model->drawer_)( model->shape_ );\n            } )\n      , clone_(  ![1](assets/27.png)\n            []( void* shapeBytes ) -> void* {\n               using Model = OwningModel<ShapeT,DrawStrategy>;\n               auto* const model = static_cast<Model*>(shapeBytes);\n               return new Model( *model );\n            } )\n   {}\n\n   // ... \n private:\n   // ... };\n\n```", "```cpp\n//---- <Shape.h> ----------------\n\n// ...\n\nclass Shape\n{\n public:\n   // ...\n\n   Shape( Shape const& other )\n      : pimpl_( clone_( other.pimpl_.get() ), other.pimpl_.get_deleter() )\n      , draw_ ( other.draw_ )\n      , clone_( other.clone_ )\n   {}\n\n   Shape& operator=( Shape const& other )\n   {\n      // Copy-and-Swap Idiom\n      using std::swap;\n      Shape copy( other );\n      swap( pimpl_, copy.pimpl_ );\n      swap( draw_, copy.draw_ );\n      swap( clone_, copy.clone_ );\n      return *this;\n   }\n\n   ~Shape() = default;\n   Shape( Shape&& ) = default;\n   Shape& operator=( Shape&& ) = default;\n\n private:\n   // ...\n};\n```", "```cpp\n#include <cstdlib>\n\nclass Shape { /*...*/ };  // Classic base class \nclass Circle : public Shape { /*...*/ };  // Deriving class \nvoid useShape( Shape const& shape )\n{\n   shape.draw( /*...*/ );\n}\n\nint main()\n{\n   Circle circle{ 3.14 };\n\n   // Automatic and cheap conversion from 'Circle const&' to 'Shape const&'\n   useShape( circle );  ![1](assets/1.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\n#include <cstdlib>\n\nclass Circle { /*...*/ };  // Nonpolymorphic geometric primitive \nclass Shape { /*...*/ };  // Type erasure wrapper class as shown before \nvoid useShape( Shape const& shape )\n{\n   draw(shape);\n}\n\nint main()\n{\n   Circle circle{ 3.14 };\n   auto drawStrategy = []( Circle const& c ){ /*...*/ };\n\n   // Creates a temporary 'Shape' object, involving\n   //   a copy operation and a memory allocation\n   useShape( { circle, drawStrategy } );  ![2](assets/2.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\n#include <cstdlib>\n#include <functional>\n\nint compute( int i, int j, std::function<int(int,int)> op )\n{\n   return op( i, j );\n}\n\nint main()\n{\n   int const i = 17;\n   int const j = 10;\n\n   int const sum = compute( i, j, [offset=15]( int x, int y ) {\n      return x + y + offset;\n   } );\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <Shape.h> ---------------- \n#include <memory>\n\nclass ShapeConstRef\n{\n public:\n   template< typename ShapeT, typename DrawStrategy >\n   ShapeConstRef( ShapeT& shape, DrawStrategy& drawer )  ![6](assets/6.png)\n      : shape_{ std::addressof(shape) }\n      , drawer_{ std::addressof(drawer) }\n      , draw_{ []( void const* shapeBytes, void const* drawerBytes ){\n           auto const* shape = static_cast<ShapeT const*>(shapeBytes);\n           auto const* drawer = static_cast<DrawStrategy const*>(drawerBytes);\n           (*drawer)( *shape );\n        } }\n   {}\n\n private:\n   friend void draw( ShapeConstRef const& shape )\n   {\n      shape.draw_( shape.shape_, shape.drawer_ );\n   }\n\n   using DrawOperation = void( void const*,void const* );\n\n   void const* shape_{ nullptr };    ![3](assets/3.png)\n   void const* drawer_{ nullptr };   ![4](assets/4.png)\n   DrawOperation* draw_{ nullptr };  ![5](assets/5.png)\n};\n\n```", "```cpp\n//---- <Main.cpp> ---------------- \n#include <Circle.h>\n#include <Shape.h>\n#include <cstdlib>\n\nvoid useShapeConstRef( ShapeConstRef shape )\n{\n   draw( shape );\n}\n\nint main()\n{\n   // Create a circle as one representative of a concrete shape type\n   Circle circle{ 3.14 };\n\n   // Create a drawing strategy in the form of a lambda\n   auto drawer = []( Circle const& c ){ /*...*/ };\n\n   // Draw the circle directly via the 'ShapeConstRef' abstraction\n   useShapeConstRef( { circle, drawer } );  ![7](assets/7.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\n#include <Cirlce.h>\n#include <Shape.h>\n#include <cstdlib>\n\nint main()\n{\n   // Create a circle as one representative of a concrete shape type\n   Circle circle{ 3.14 };\n\n   // Create a drawing strategy in the form of a lambda\n   auto drawer = []( Circle const& c ){ /*...*/ };\n\n   // Combine the shape and the drawing strategy in a 'Shape' abstraction\n   Shape shape1( circle, drawer );\n\n   // Draw the shape\n   draw( shape1 );\n\n   // Create a reference to the shape\n   // Works already, but the shape reference will store a pointer\n   // to the 'shape1' instance instead of a pointer to the 'circle'.\n   ShapeConstRef shaperef( shape1 );  ![8](assets/8.png)\n\n   // Draw via the shape reference, resulting in the same output\n   // This works, but only by means of two indirections!\n   draw( shaperef );  ![9](assets/9.png)\n\n   // Create a deep copy of the shape via the shape reference\n   // This is _not_ possible with the simple nonowning implementation!\n   // With the simple implementation, this creates a copy of the 'shaperef'\n   // instance. 'shape2' itself would act as a reference and there would be\n   // three indirections... sigh.\n   Shape shape2( shaperef );  ![10](assets/10.png)\n\n   // Drawing the copy will again result in the same output\n   draw( shape2 );\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\n//---- <Shape.h> ---------------- \n#include <memory>\n#include <utility>\n\nnamespace detail {\n\nclass ShapeConcept\n{\n public:\n   // ...\n   virtual void clone( ShapeConcept* memory ) const = 0;  ![11](assets/11.png)\n};\n\n// ... \n} // namespace detail \n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nnamespace detail {\n\n// ... \ntemplate< typename ShapeT\n        , typename DrawStrategy >\nclass NonOwningShapeModel : public ShapeConcept\n{\n public:\n   NonOwningShapeModel( ShapeT& shape, DrawStrategy& drawer )\n      : shape_{ std::addressof(shape) }\n      , drawer_{ std::addressof(drawer) }\n   {}\n\n   void draw() const override { (*drawer_)(*shape_); }  ![14](assets/14.png)\n\n   std::unique_ptr<ShapeConcept> clone() const override  ![15](assets/15.png)\n   {\n      using Model = OwningShapeModel<ShapeT,DrawStrategy>;\n      return std::make_unique<Model>( *shape_, *drawer_ );\n   }\n\n   void clone( ShapeConcept* memory ) const override  ![16](assets/16.png)\n   {\n      std::construct_at( static_cast<NonOwningShapeModel*>(memory), *this );\n\n      // or:\n      // auto* ptr =\n      //    const_cast<void*>(static_cast<void const volatile*>(memory));\n      // ::new (ptr) NonOwningShapeModel( *this );\n   }\n\n private:\n   ShapeT* shape_{ nullptr };  ![12](assets/12.png)\n   DrawStrategy* drawer_{ nullptr };  ![13](assets/13.png)\n};\n\n// ... \n} // namespace detail \n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nnamespace detail {\n\ntemplate< typename ShapeT\n        , typename DrawStrategy >\nclass OwningShapeModel : public ShapeConcept\n{\n public:\n   // ... \n   void clone( ShapeConcept* memory ) const  ![17](assets/17.png)\n   {\n      using Model = NonOwningShapeModel<ShapeT const,DrawStrategy const>;\n\n      std::construct_at( static_cast<Model*>(memory), shape_, drawer_ );\n\n      // or:\n      // auto* ptr =\n      //    const_cast<void*>(static_cast<void const volatile*>(memory));\n      // ::new (ptr) Model( shape_, drawer_ );\n   }\n};\n\n// ... \n} // namespace detail \n```", "```cpp\n//---- <Shape.h> ---------------- \n#include <array>\n#include <cstddef>\n#include <memory>\n\n// ... \nclass ShapeConstRef\n{\n public:\n   // ... \n private:\n   // ... \n   // Expected size of a model instantiation:\n   //     sizeof(ShapeT*) + sizeof(DrawStrategy*) + sizeof(vptr)\n   static constexpr size_t MODEL_SIZE = 3U*sizeof(void*);  ![19](assets/19.png)\n\n   alignas(void*) std::array<std::byte,MODEL_SIZE> raw_;  ![18](assets/18.png)\n};\n\n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nclass ShapeConstRef\n{\n public:\n   // ... \n private:\n   friend void draw( ShapeConstRef const& shape )\n   {\n      shape.pimpl()->draw();\n   }\n\n   ShapeConcept* pimpl()  ![20](assets/20.png)\n   {\n      return reinterpret_cast<ShapeConcept*>( raw_.data() );\n   }\n\n   ShapeConcept const* pimpl() const  ![21](assets/21.png)\n   {\n      return reinterpret_cast<ShapeConcept const*>( raw_.data() );\n   }\n\n   // ... };\n\n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nclass ShapeConstRef\n{\n public:\n   // Type 'ShapeT' and 'DrawStrategy' are possibly cv qualified;\n   // lvalue references prevent references to rvalues\n   template< typename ShapeT\n           , typename DrawStrategy >\n   ShapeConstRef( ShapeT& shape\n                , DrawStrategy& drawer )  ![22](assets/22.png)\n   {\n      using Model =\n         detail::NonOwningShapeModel<ShapeT const,DrawStrategy const>;  ![23](assets/23.png)\n      static_assert( sizeof(Model) == MODEL_SIZE, \"Invalid size detected\" );  ![24](assets/24.png)\n      static_assert( alignof(Model) == alignof(void*), \"Misaligned detected\" );\n\n      std::construct_at( static_cast<Model*>(pimpl()), shape_, drawer_ );  ![1](assets/25.png)\n\n      // or:\n      // auto* ptr =\n      //    const_cast<void*>(static_cast<void const volatile*>(pimpl()));\n      // ::new (ptr) Model( shape_, drawer_ );\n   }\n\n   // ... \n private:\n   // ... };\n\n```", "```cpp\n//---- <Shape.h> ---------------- \n// ... \nclass ShapeConstRef\n{\n public:\n   // ... \n   ShapeConstRef( Shape& other )       { other.pimpl_->clone( pimpl() ); }  ![26](assets/26.png)\n   ShapeConstRef( Shape const& other ) { other.pimpl_->clone( pimpl() ); }\n\n   ShapeConstRef( ShapeConstRef const& other )\n   {\n      other.pimpl()->clone( pimpl() );\n   }\n\n   ShapeConstRef& operator=( ShapeConstRef const& other )\n   {\n      // Copy-and-swap idiom\n      ShapeConstRef copy( other );\n      raw_.swap( copy.raw_ );\n      return *this;\n   }\n\n   ~ShapeConstRef()\n   {\n      std::destroy_at( pimpl() );\n      // or: pimpl()->~ShapeConcept();\n   }\n\n   // Move operations explicitly not declared ![27](assets/27.png)\n\n private:\n   // ... };\n\n```", "```cpp\n//---- <Shape.h> ----------------\n\n// ...\n\nclass Shape\n{\n public:\n   // ...\n\n   Shape( ShapeConstRef const& other )\n      : pimpl_{ other.pimpl()->clone() }\n   {}\n\n private:\n   // ...\n}\n```"]