<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 10. The Singleton Pattern" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_singleton_pattern">
<h1><span class="label">Chapter 10. </span>The Singleton Pattern</h1>
<p>In<a data-primary="Singleton pattern" data-secondary="basic guidelines for" data-type="indexterm" id="idm45043072409536"/> this chapter, we take a look at the (in-)famous <em>Singleton</em> pattern. I know, you may
already be acquainted with Singleton, and you may already have a strong opinion about
it. It is even possible that you consider Singleton an antipattern and thus
ask yourself how I mustered the courage to include it in this book. Well, I am aware that
Singleton is not particularly popular and in many circles has a rather bad reputation,
in particular because of the global nature of Singletons. From that perspective,
however, it might be very surprising to learn that there are a couple of
“Singleton”-like instances in the C++ Standard Library. Seriously! And, honestly,
they work fantastically! Therefore, we should seriously talk about <em>what</em> a Singleton
is, <em>when</em> Singleton works, and <em>how</em> to deal with Singleton properly.</p>
<p>In <a data-type="xref" href="#treat_singleton_as_an_implementation_pattern_not_a_design_pattern">“Guideline 37: Treat Singleton as an Implementation Pattern, Not a Design Pattern”</a>, I will explain
the Singleton pattern and demonstrate how it works 
<span class="keep-together">by a very</span> commonly used
implementation, the so-called<a data-primary="Meyers' Singleton" data-type="indexterm" id="idm45043072404736"/> <em>Meyers’ Singleton</em>. I will, however, also make a strong
argument to <em>not</em> treat Singleton as a design pattern but as an <em>implementation pattern</em>.</p>
<p>In <a data-type="xref" href="#design_singletons_for_change_and_testability">“Guideline 38: Design Singletons for Change 
<span class="keep-together">and Testability</span>”</a>, we 
<span class="keep-together">accept the</span> fact that sometimes
we need a solution to represent the few global aspects in our code. This is what the
Singleton pattern is often used for. This also means that we are confronted by the
usual problems of Singletons: global state; many strong, artificial dependencies;
and an impeded changeability and testability. While these sound like excellent reasons
to avoid Singleton after all, I will show you that by proper software design, you can
combine the Singleton benefits with excellent changeability and testability.</p>
<section data-pdf-bookmark="Guideline 37: Treat Singleton as an Implementation Pattern, Not a Design Pattern" data-type="sect1"><div class="sect1" id="treat_singleton_as_an_implementation_pattern_not_a_design_pattern">
<h1>Guideline 37: Treat Singleton as an Implementation Pattern, Not a Design Pattern</h1>
<p>Let<a data-primary="Singleton pattern" data-secondary="as implementation pattern" data-secondary-sortas="implementation pattern" data-type="indexterm" id="SDPimple10"/><a data-primary="implementation patterns" data-secondary="Singleton pattern as" data-type="indexterm" id="IPsingleton10"/> me start by addressing the elephant in the room:</p>
<blockquote>
<p>Singleton is <em>not</em> a design pattern.</p></blockquote>
<p>If you haven’t heard about Singleton before, then this might not make any sense at all,
but bear with me. I promise to explain Singleton shortly. If you <em>have</em> heard about
Singleton before, then I assume you’re either nodding
in agreement with a sympathizing “I know” look on your face, or you are utterly stunned and
initially don’t know what to say. “But why not?” you eventually dare to ask. “Isn’t it one
of the original design patterns from the Gang of Four book?” Yes, you’re correct:
Singleton is one of the 23 original patterns documented in the GoF book. At the time of
writing, <a href="https://oreil.ly/jzuFw">Wikipedia</a> calls it a design
pattern, and it is even listed as a design pattern in Steve McConnell’s bestseller <em>Code
Complete</em>.<sup><a data-type="noteref" href="ch10.xhtml#idm45043072392832" id="idm45043072392832-marker">1</a></sup> Nevertheless,
it still isn’t a design pattern, because it doesn’t have the properties of a design pattern.
Let me explain.</p>
<section data-pdf-bookmark="The Singleton Pattern Explained" data-type="sect2"><div class="sect2" id="idm45043072391536">
<h2>The Singleton Pattern Explained</h2>
<p>Sometimes<a data-primary="Singleton pattern" data-secondary="as implementation pattern" data-secondary-sortas="implementation pattern" data-tertiary="Singleton explained" data-type="indexterm" id="idm45043072389968"/> you may want to guarantee that there is only one, and <em>exactly</em> one,
instance of a particular class. In other words, you have a Highlander situation: “There
can be only one.”<sup><a data-type="noteref" href="ch10.xhtml#idm45043072387744" id="idm45043072387744-marker">2</a></sup>
This might make sense for the system-wide database, the one and only logger, the system clock,
the system configuration, or, in short, any class that should not be instantiated multiple
times, since it represents something that exists only once. That is the intent of the
Singleton pattern.</p>
<div data-type="tip"><h1>The Singleton Pattern</h1>
<p>Intent: “Ensure<a data-primary="Singleton pattern" data-secondary="intent of" data-type="indexterm" id="idm45043072384976"/> a class has only one instance, and provide a global point of access to it.”<sup><a data-type="noteref" href="ch10.xhtml#idm45043072383840" id="idm45043072383840-marker">3</a></sup></p>
</div>
<p>This intent is visualized by the Gang of Four with the UML diagram in
<a data-type="xref" href="#fig_singleton_original">Figure 10-1</a>, which introduces the <code>instance()</code> function as the global
point of access to the unique instance.</p>
<figure><div class="figure" id="fig_singleton_original">
<img alt="The UML representation of the _Singleton_ pattern." height="327" src="assets/cpsd_1001.png" width="1331"/>
<h6><span class="label">Figure 10-1. </span>The UML representation of the <em>Singleton</em> pattern</h6>
</div></figure>
<p>There<a data-primary="Singleton pattern" data-secondary="as implementation pattern" data-secondary-sortas="implementation pattern" data-tertiary="UML diagram" data-type="indexterm" id="idm45043072378176"/> are multiple ways to restrict the number of instantiations to exactly one.
Definitely one of the most useful and therefore most commonly used forms of Singleton is
the Meyers’ Singleton.<sup><a data-type="noteref" href="ch10.xhtml#idm45043072376432" id="idm45043072376432-marker">4</a></sup> The following <code>Database</code>
class is implemented as a Meyers’ Singleton:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Database.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Database</code><code class="w"> </code><code class="k">final</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">static</code><code class="w"> </code><code class="n">Database</code><code class="o">&amp;</code><code class="w"> </code><code class="n">instance</code><code class="p">(</code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g37_1" id="code_g37_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">static</code><code class="w"> </code><code class="n">Database</code><code class="w"> </code><code class="n">db</code><code class="p">;</code><code class="w">  </code><code class="c1">// The one, unique instance
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">db</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="n">write</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="nf">read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... More database-specific functionality
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Potentially access to data members
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="n">Database</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="p">}</code><code class="w">  </code><a class="co" href="#para_g37_2" id="code_g37_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">Database</code><code class="p">(</code><code class="w"> </code><code class="n">Database</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">delete</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Database</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Database</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">delete</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Database</code><code class="p">(</code><code class="w"> </code><code class="n">Database</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">delete</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="n">Database</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Database</code><code class="o">&amp;</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">delete</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... Potentially some data members
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The Meyers’ Singleton evolves around the fact that it’s possible to access the
single instance of the <code>Database</code> class onlhy via the <code>public</code>, <code>static</code> <code>instance()</code> function
(<a class="co" href="#code_g37_1" id="para_g37_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Database.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// First access, database object is created</code>
<code class="w">   </code><code class="n">Database</code><code class="o">&amp;</code><code class="w"> </code><code class="n">db1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Database</code><code class="o">::</code><code class="n">instance</code><code class="p">();</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="c1">// Second access, returns a reference to the same object</code>
<code class="w">   </code><code class="n">Database</code><code class="o">&amp;</code><code class="w"> </code><code class="n">db2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Database</code><code class="o">::</code><code class="n">instance</code><code class="p">();</code><code class="w"/>
<code class="w">   </code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">db1</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="o">&amp;</code><code class="n">db2</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Indeed, this function is the only way to get a <code>Database</code>: all functionality that could
possibly be used to create, copy, or move an instance is either declared in the <code>private</code>
section or is explicitly <code>delete</code>d.<sup><a data-type="noteref" href="ch10.xhtml#idm45043072064080" id="idm45043072064080-marker">5</a></sup>
Although this appears to be pretty straightforward, one implementation detail is
of special interest: note that the default constructor is explicitly defined and not
<code>default</code>ed
(<a class="co" href="#code_g37_2" id="para_g37_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
The reason is if it were <code>default</code>ed, up to 
<span class="keep-together">C++17</span>, it would be
possible to create a <code>Database</code> with an empty set of braces, i.e., via
<a href="https://oreil.ly/9h4IB"><em>value initialization</em></a>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Database</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... As before</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">Database</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">  </code><code class="c1">// Compiler generated default constructor</code>

<code class="w">   </code><code class="c1">// ... As before</code>
<code class="p">};</code><code class="w"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">Database</code><code class="w"> </code><code class="n">db</code><code class="p">;</code><code class="w">    </code><code class="c1">// Does not compile: Default initialization</code>
<code class="w">   </code><code class="n">Database</code><code class="w"> </code><code class="n">db</code><code class="p">{};</code><code class="w">  </code><code class="c1">// Works, since value initialization results in aggregate</code>
<code class="w">                   </code><code class="c1">//   initialization, because Database is an aggregate type</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Up to C++17, the <code>Database</code> class counts as an<a data-primary="aggregate types" data-type="indexterm" id="idm45043071993888"/> <em>aggregate type</em>, which
means that <em>value initialization</em> would be performed via
<a href="https://oreil.ly/HSuYl"><em>aggregate initialization</em></a>.
<em>Aggregate initialization</em>, in turn, ignores the default constructor, including
the fact that it is <code>private</code>, and simply performs a <em>zero initialization</em> of the object.
Thus, value initialization enables you to still create an instance. If, however,
you provide the default constructor, then the class does not count as an aggregate
type, which prevents aggregate initialization.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071990224" id="idm45043071990224-marker">6</a></sup></p>
<p>The <code>instance()</code> function<a data-primary="static local variables" data-type="indexterm" id="idm45043071988960"/> is implemented in terms of a
<a href="https://oreil.ly/mqUoK"><em>static local variable</em></a>.
This means that the first time control passes through the declaration, the variable is
initialized in a thread-safe way, and on all further calls the initialization is skipped.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071987280" id="idm45043071987280-marker">7</a></sup> On every call, the first and all subsequent calls, the function returns a reference to the static local variable.</p>
<p>The rest of the <code>Database</code> class is pretty much what you would expect from a class
representing a database: there are some <code>public</code>, database-related functions (e.g., <code>write()</code>
and <code>read()</code>) and there could be some data members, including access functions. In
other words, except for the <code>instance()</code> member function and the special members,
<code>Database</code> is just a normal class.</p>
</div></section>
<section data-pdf-bookmark="Singleton Does Not Manage or Reduce Dependencies" data-type="sect2"><div class="sect2" id="idm45043072390944">
<h2>Singleton Does Not Manage or Reduce Dependencies</h2>
<p>Now, with<a data-primary="Singleton pattern" data-secondary="as implementation pattern" data-secondary-sortas="implementation pattern" data-tertiary="versus design pattern" data-tertiary-sortas="design pattern" data-type="indexterm" id="idm45043071947264"/> one possible implementation of a Singleton in mind, let’s go back to my
claim that Singleton is not a design pattern. First, let’s remind ourselves of the
properties of a design pattern, which I defined in
<a data-type="xref" href="ch03.xhtml#understand_the_purpose_of_design_patterns">“Guideline 11: Understand the Purpose of Design Patterns”</a>:</p>
<p>A design pattern:</p>
<ul>
<li>
<p>Has a name</p>
</li>
<li>
<p>Carries an intent</p>
</li>
<li>
<p>Introduces an abstraction</p>
</li>
<li>
<p>Has been proven</p>
</li>
</ul>
<p>The Singleton pattern definitely has a name, and it definitely has an intent. No
question there. I would also claim that it has been proven over the years (although
there may be skeptical voices that point out that Singleton is rather infamous).
However, there is no kind of abstraction: no base class, no template parameters,
nothing. 
<span class="keep-together">Singleton</span> does not represent an abstraction itself, and it does not introduce
an abstraction. In fact, it isn’t concerned with the structure of code or with the
interaction and interdependencies of entities, and hence it isn’t aiming
at managing or reducing dependencies.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071938896" id="idm45043071938896-marker">8</a></sup> This, though, is what I defined to
be an integral part of software design. Instead, Singleton is focused on restricting
the number of instantiations to exactly one. Thus, Singleton is not
a design pattern but merely an implementation pattern.</p>
<p>“Then why is it listed as a design pattern in so many important sources?” you ask.
This is a fair and good question. There may be three answers to that. First, in other
programming languages, in particular languages where every class can automatically
represent an abstraction, the situation may be different. While I acknowledge this,
I still believe that the intent of the Singleton pattern is primarily targeted for
implementation details and not for dependencies and decoupling.</p>
<p>Second, Singleton is very commonly used (although often also <em>mis</em>used), so it is
definitely a pattern. Since there are Singletons in many different programming languages,
it does not appear to be just an idiom of the C++ programming language. As
a consequence, it appears reasonable to call it a design pattern. This chain of
arguments may sound plausible to you, but I feel it falls short of distinguishing between
software design and implementation details. This is why in
<a data-type="xref" href="ch03.xhtml#understand_the_purpose_of_design_patterns">“Guideline 11: Understand the Purpose of Design Patterns”</a>, I introduced the term <em>implementation
pattern</em> to distinguish between different kinds of language-agnostic patterns
such as 
<span class="keep-together">Singleton</span>.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071934080" id="idm45043071934080-marker">9</a></sup></p>
<p>And third, I believe that we are still in the process of understanding software design
and design patterns. There is no common definition of software design. For that reason,
I came up with one in <a data-type="xref" href="ch01.xhtml#understand_the_importance_of_software_design">“Guideline 1: Understand the Importance of 
<span class="keep-together">Software Design</span>”</a>. There is no
common definition of design patterns, either. This is why I came up with one in
<a data-type="xref" href="ch03.xhtml#understand_the_purpose_of_design_patterns">“Guideline 11: Understand the Purpose of Design Patterns”</a>. I strongly believe that we must
talk more about software design and more about patterns to come to a common
understanding of the necessary terminology, especially in C++.</p>
<p>In summary, you do not use a Singleton to decouple software entities. So despite the
fact that it is described in the famous GoF book, or in <em>Code Complete</em>, or even listed as
a design pattern on <a href="https://oreil.ly/i8lyX">Wikipedia</a>,
it does not serve the purpose of a design pattern. Singleton is merely dealing
with implementation details, and as such you should treat it as an implementation
pattern.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043071923152">
<h5>Guideline 37: Treat Singleton an Implementation Pattern, Not a Design Pattern</h5>
<ul>
<li>
<p>The<a data-primary="" data-startref="SDPimple10" data-type="indexterm" id="idm45043071921120"/> goal of Singleton is not to decouple or manage dependencies, and thus it does not fulfill the expectations of a design pattern.</p>
</li>
<li>
<p>Apply the Singleton pattern with the intent to restrict the number of instances of a particular class to exactly one.<a data-primary="" data-startref="IPsingleton10" data-type="indexterm" id="idm45043071919024"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 38: Design Singletons for Change &#10;and Testability" data-type="sect1"><div class="sect1" id="design_singletons_for_change_and_testability">
<h1>Guideline 38: Design Singletons for Change 
<span class="keep-together">and Testability</span></h1>
<p>Singleton<a data-primary="Singleton pattern" data-secondary="designing for change and testability" data-type="indexterm" id="SPchange10"/><a data-primary="testability" data-secondary="designing Singleton for change and" data-type="indexterm" id="Tchange10"/> is indeed a rather infamous pattern: there are many voices out there that describe
Singleton as a general problem in code, as an antipattern, as dangerous, or even as evil.
Therefore, there is a lot of advice out there to avoid the pattern, among others,
<a href="https://oreil.ly/Mai2n">Core Guideline I.3</a>:<sup><a data-type="noteref" href="ch10.xhtml#idm45043071911616" id="idm45043071911616-marker">10</a></sup></p>
<blockquote>
<p>Avoid singletons.</p></blockquote>
<p>One of the primary reasons why people dislike Singleton is that it often causes
artificial dependencies and obstructs testability. As such, it runs contrary to two of
the most important and most general guidelines in this book: <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a> and
<a data-type="xref" href="ch01.xhtml#design_for_testability">“Guideline 4: Design for Testability”</a>. From that perspective, Singleton indeed appears to be a
problem in code and should be avoided. However, despite all the good-intentioned warnings,
the pattern is persistently used by many developers. The reasons for that are manifold
but probably mainly related to two facts: first, sometimes (and let’s agree on <em>sometimes</em>)
it is desirable to express the fact that something exists only once and should be
available for many entities in the code. Second, sometimes Singleton appears to be
the proper solution, as there <em>are</em> global aspects to represent.</p>
<p>So, let’s do the following: instead of arguing that Singleton is always bad and evil,
let’s focus on those few situations where we need to represent a global aspect in
our 
<span class="keep-together">program</span> and discuss how to represent this aspect properly, but still design
for change and testability.</p>
<section data-pdf-bookmark="Singletons Represent Global State" data-type="sect2"><div class="sect2" id="idm45043071905328">
<h2>Singletons Represent Global State</h2>
<p>Singletons<a data-primary="Singleton pattern" data-secondary="designing for change and testability" data-tertiary="representation of global state" data-type="indexterm" id="idm45043071903584"/><a data-primary="testability" data-secondary="designing Singleton for change and" data-tertiary="representation of global state" data-type="indexterm" id="idm45043071902256"/><a data-primary="global state" data-type="indexterm" id="idm45043071901024"/> are mostly used to represent entities in a program that logically
and/or physically exist only once and that should be used by many other classes and
functions.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071900224" id="idm45043071900224-marker">11</a></sup>
Common examples are the system-wide database, logger, clock, or configuration. These
examples, including the term <em>system-wide</em>, give an indication of the nature of
these entities: they commonly represent globally available functionality or data, i.e.,
global state. From that perspective, the Singleton pattern appears to make sense:
by preventing everyone from creating new instances, and by forcing everyone to use <em>the
one</em> instance, you can guarantee uniform and consistent access to this global state
across all using entities.</p>
<p>This representation and introduction of global state, however, explains why Singleton is commonly considered a problem. As Michael Feathers expressed
it:<sup><a data-type="noteref" href="ch10.xhtml#idm45043071898096" id="idm45043071898096-marker">12</a></sup></p>
<blockquote>
<p>The singleton pattern is one of the mechanisms people use to make global variables. In
general, global variables are a bad idea for a couple of reasons. One of them is opacity.</p></blockquote>
<p>Global variables are indeed a bad idea, particularly for one important reason: the
term <em>variable</em> suggests that we are talking about<a data-primary="mutable global state" data-type="indexterm" id="idm45043071894976"/> <em>mutable</em> global state. And that
kind of state can indeed cause a lot of headaches. To be explicit, mutable global state
is frowned upon (in general, but especially in a multithreaded environment), as it is
difficult, costly, and likely both to control access and guarantee correctness.
Furthermore, global (mutable) state is very hard to reason about, as read and write
access to this state usually happens invisibly within some function, which, based on
its interface, does not reveal the fact that it uses the global state. And last but
not least, if you have several globals, whose lifetimes depend on one another and that
are distributed over several compilation units, you<a data-primary="static initialization order fiasco (SIOF)" data-type="indexterm" id="idm45043071893728"/><a data-primary="SIOF (static initialization order fiasco)" data-type="indexterm" id="idm45043071892928"/> might be facing the <em>static
initialization order fiasco</em> (<em>SIOF</em>).<sup><a data-type="noteref" href="ch10.xhtml#idm45043071891216" id="idm45043071891216-marker">13</a></sup> Obviously,
it is beneficial to avoid global state as much as possible.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071889696" id="idm45043071889696-marker">14</a></sup></p>
<p>The problem of global state, however, is a problem that we can’t resolve by avoiding
Singletons. It’s a general problem, unrelated to any particular pattern. The same
problem, for instance, also exists for the<a data-primary="Monostate pattern" data-type="indexterm" id="idm45043071888016"/> Monostate pattern, which enforces a single,
global state but allows for any number of instantiations.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071887072" id="idm45043071887072-marker">15</a></sup> So on the contrary, Singleton can help deal
with the global state by constraining access to it. For instance, as Miško Hevery explains
in his 2008 article, Singletons that provide a unidirectional data flow to <em>or</em> from
some global state are acceptable:<sup><a data-type="noteref" href="ch10.xhtml#idm45043071883440" id="idm45043071883440-marker">16</a></sup> a
Singleton implementing a logger would only allow you to write data but not read
it. A Singleton representing a system-wide configuration or clock would only allow
you to read the data but not write it, thus representing a global <em>constant</em>. The
restriction to unidirectional data flow helps avoid many of the usual problems with
global state. Or in the words of Miško Hevery (the emphasis being mine):<sup><a data-type="noteref" href="ch10.xhtml#idm45043071881136" id="idm45043071881136-marker">17</a></sup></p>
<blockquote>
<p><em>Appropriate</em> use of “Global” or semi-Global states can greatly simplify the design
of applications […].</p></blockquote>
</div></section>
<section data-pdf-bookmark="Singletons Impede Changeability and Testability" data-type="sect2"><div class="sect2" id="idm45043071879216">
<h2>Singletons Impede Changeability and Testability</h2>
<p>Global state<a data-primary="Singleton pattern" data-secondary="designing for change and testability" data-tertiary="as impediment of changeability and testability" data-tertiary-sortas="impediment of changeability and testability" data-type="indexterm" id="idm45043071877024"/><a data-primary="testability" data-secondary="designing Singleton for change and" data-tertiary="as impediment of changeability and testability" data-tertiary-sortas="impediment of changeability and testability" data-type="indexterm" id="idm45043071875312"/> is an intrinsic problem of Singletons. However, even if we feel comfortable
with representing global state with a Singleton, there are serious consequences:
functions that use Singletons depend on the represented global data and thus become
harder to change and harder to test. To better understand this, let’s revive the 
<span class="keep-together"><code>Database</code></span>
Singleton from <a data-type="xref" href="#treat_singleton_as_an_implementation_pattern_not_a_design_pattern">“Guideline 37: Treat Singleton as an Implementation Pattern, Not a Design Pattern”</a>, which
is now actively used by a couple of arbitrary classes, namely <code>Widget</code> and <code>Gadget</code>:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Widget.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Database.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">doSomething</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">      </code><code class="n">Database</code><code class="o">::</code><code class="n">instance</code><code class="p">().</code><code class="n">read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;Gadget.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Database.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Gadget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">doSomething</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">      </code><code class="n">Database</code><code class="o">::</code><code class="n">instance</code><code class="p">().</code><code class="n">write</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p><code>Widget</code> and <code>Gadget</code> both require access to the system-wide <code>Database</code>. For that reason, they
call the <code>Database::instance()</code> function and subsequently the <code>read()</code> and <code>write()</code>
functions.</p>
<p>Since they use the <code>Database</code> and thus depend on it, we would like them to reside in
architecture levels <em>below</em> the level of the <code>Database</code> Singleton. That is because,
as you remember from <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>, we can call it a proper architecture
only if all dependency arrows run toward the high levels (see <a data-type="xref" href="#fig_singleton_database_1">Figure 10-2</a>).</p>
<figure><div class="figure" id="fig_singleton_database_1">
<img alt="The _desired_ dependency graph for a +Database+ implemented as _Singleton_." height="1301" src="assets/cpsd_1002.png" width="1439"/>
<h6><span class="label">Figure 10-2. </span>The <em>desired</em> dependency graph for a <code>Database</code> implemented as a <em>Singleton</em></h6>
</div></figure>
<p>Although<a data-primary="Singleton pattern" data-secondary="as implementation pattern" data-secondary-sortas="implementation pattern" data-tertiary="desired dependency graph" data-type="indexterm" id="idm45043071724352"/> this dependency structure may be desirable, unfortunately it is only an
illusion: the <code>Database</code> class is not an abstraction but a concrete implementation,
representing the dependency on a very specific database! Therefore, the <em>real</em>
dependency structure is inverted and looks something like <a data-type="xref" href="#fig_singleton_database_2">Figure 10-3</a>.</p>
<p>The<a data-primary="Singleton pattern" data-secondary="as implementation pattern" data-secondary-sortas="implementation pattern" data-tertiary="actual dependency graph" data-type="indexterm" id="idm45043071720720"/> <em>actual</em> dependency structure utterly fails the Dependency Inversion Principle (DIP)
(see <a data-type="xref" href="ch02.xhtml#pay_attention_to_the_ownership_of_abstractions">“Guideline 9: Pay Attention to the Ownership of Abstractions”</a>): all dependency arrows point toward
the lower level. In other words, right now there is no software architecture!</p>
<figure><div class="figure" id="fig_singleton_database_2">
<img alt="The _real_ dependency graph for a +Database+ implemented as _Singleton_." height="1301" src="assets/cpsd_1003.png" width="1439"/>
<h6><span class="label">Figure 10-3. </span>The <em>actual</em> dependency graph for a <code>Database</code> implemented as a <em>Singleton</em></h6>
</div></figure>
<p>Since the <code>Database</code> is a concrete class and not an abstraction, there are strong and
unfortunately even invisible dependencies from all over the code to the specific
implementation details and design choices of the <code>Database</code> class. This may—in the
worst case—include a dependency on vendor-specific details that become visible
throughout the code, manifest in many different places, and later make changes
excruciatingly hard or even impossible. Due to that, the code becomes much more
difficult to change.</p>
<p>Also consider how badly tests are affected by this dependency. All tests that use
one of the functions depending on the <code>Database</code> Singleton become themselves dependent
on the Singleton. This means, for instance, that for every test using the
<code>Widget::do​Something()</code> function, you would always have to provide the one and only
<code>Database</code> class. The unfortunate, but also simple, reason is that none of these functions
provide you with a way to substitute the <code>Database</code> with something else: any kind of stub,
mock, or fake.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071710704" id="idm45043071710704-marker">18</a></sup>
They all treat the <code>Database</code> Singleton as their shiny, precious secret.
Testability is therefore severely impeded, and writing tests becomes so much harder that
you might be tempted to not write them at all.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071708112" id="idm45043071708112-marker">19</a></sup></p>
<p>This example indeed demonstrates the usual problems with Singletons and the unfortunate
artificial dependencies they introduce. These dependencies make the system more inflexible and
more rigid, and thus harder to change and test. That, of course, should not be.
On the contrary, it should be easy to replace a database implementation with another one,
and it should be easy to test functionality that uses a database. For these exact reasons,
we must make sure that the <code>Database</code> becomes a true implementation detail on the low level
of a proper architecture.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071706768" id="idm45043071706768-marker">20</a></sup></p>
<p>“But wait a second, you just said that if the <code>Database</code> is an implementation detail, there
is no architecture, right?” Yes, I said that. And there is nothing we can do as it is: the
<code>Database</code> Singleton does not represent any abstraction and does not enable us to deal
with dependencies at all. Singleton is just not a design pattern. So in order to remove the
dependencies on the <code>Database</code> class and make the architecture work, we will have
to design for change and testability by introducing an abstraction and using a
real design pattern. To achieve that, let’s take a look at an example with a good
way to deal with global aspects, using Singletons from the C++ Standard
Library.</p>
</div></section>
<section data-pdf-bookmark="Inverting the Dependencies on a Singleton" data-type="sect2"><div class="sect2" id="idm45043071703408">
<h2>Inverting the Dependencies on a Singleton</h2>
<p>I’m<a data-primary="Singleton pattern" data-secondary="designing for change and testability" data-tertiary="inverting Singleton dependencies" data-type="indexterm" id="idm45043071701392"/><a data-primary="testability" data-secondary="designing Singleton for change and" data-tertiary="inverting Singleton dependencies" data-type="indexterm" id="idm45043071700080"/> returning to a true El Dorado of design patterns, which I have used several times
to demonstrate different design patterns: the C++17 polymorphic memory resources:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;array&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstddef&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory_resource&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;vector&gt;</code><code class="cp">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">array</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">byte</code><code class="p">,</code><code class="mi">1000</code><code class="o">&gt;</code><code class="w"> </code><code class="n">raw</code><code class="p">;</code><code class="w">  </code><code class="c1">// Note: not initialized!
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">monotonic_buffer_resource</code><code class="w">
</code><code class="w">      </code><code class="n">buffer</code><code class="p">{</code><code class="w"> </code><code class="n">raw</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">raw</code><code class="p">.</code><code class="n">size</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">null_memory_resource</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_1" id="code_g38_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">string</code><code class="o">&gt;</code><code class="w"> </code><code class="n">strings</code><code class="p">{</code><code class="w"> </code><code class="o">&amp;</code><code class="n">buffer</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>In this example, we configure the
<a href="https://oreil.ly/uVQoS"><code>std::pmr::monotonic_buffer_resource</code></a>,
called <code>buffer</code>, to work only with the static memory contained in the given <code>std::array</code> <code>raw</code>
(<a class="co" href="#code_g38_1" id="para_g38_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
If this memory is depleted, <code>buffer</code> will try to acquire new memory via its upstream
allocator, which we specify to be
<a href="https://oreil.ly/p0V3c"><code>std::pmr::null​_memory_resource()</code></a>.
Allocating via this allocator will never return any memory but will always fail with the
<code>std::bad_alloc()</code> exception. Thus, <code>buffer</code> is restricted to the 1,000 bytes provided by <code>raw</code>.</p>
<p>While you should immediately remember and recognize this as an example of the Decorator
design pattern, this also serves as an example of the Singleton pattern: the
<code>std::pmr::null_memory_resource()</code> function returns a pointer to the same allocator
every time the function is called and thus acts as a single point of access to the
one and only instance of <code>std::pmr::null_memory_resource</code>. Thus, the returned allocator
acts as a Singleton. Although this Singleton does not provide a unidirectional flow of
data (after all, we can both allocate memory and give it back), Singleton still feels like
a reasonable choice, as it represents one kind of global state: memory.</p>
<p>It is particularly interesting and important to note that this Singleton does
not make you depend on the specific implementation details of the allocator. Quite the
opposite: the <code>std::pmr::null_memory_resource()</code> function returns a pointer to
<a href="https://oreil.ly/9wYhs"><code>std::pmr::memory_resource</code></a>.
This class represents a base class for all kinds of allocators (at least in the realm
of C++17), and thus serves as an abstraction. Still,
<code>std::pmr::null_memory_resource()</code> represents a specific allocator, a specific choice,
which we now depend on. As this functionality is in the Standard Library, we tend to
not recognize it as a dependency, but generally speaking it is: we are not provided
with an opportunity to replace the standard-specific 
<span class="keep-together">implementation.</span></p>
<p>This changes if we replace the call to <code>std::pmr::null_memory_resource()</code> with a call to
<a href="https://oreil.ly/chMJ7"><code>std::pmr::get_default_resource()</code></a>
(<a class="co" href="#code_g38_2" id="para_g38_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;memory_resource&gt;</code><code class="cp">
</code><code class="c1">// ...
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">monotonic_buffer_resource</code><code class="w">
</code><code class="w">      </code><code class="n">buffer</code><code class="p">{</code><code class="w"> </code><code class="n">raw</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">raw</code><code class="p">.</code><code class="n">size</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">get_default_resource</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_2" id="code_g38_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>The <code>std::pmr::get_default_resource()</code> function also returns a pointer to
<code>std::pmr::memory_resource</code>, which represents an abstraction for the system-wide default
allocator. By default, the returned allocator is returned by the
<a href="https://oreil.ly/w4lHB"><code>std::new_delete_resource()</code></a>
function. However, amazingly, this default can be customized by the
<a href="https://oreil.ly/wQBy6"><code>std::pmr::set_default_resource()</code></a>
function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">namespace</code><code class="w"> </code><code class="nn">std</code><code class="o">::</code><code class="nn">pmr</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="n">memory_resource</code><code class="o">*</code><code class="w"> </code><code class="nf">set_default_resource</code><code class="p">(</code><code class="n">memory_resource</code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="k">noexcept</code><code class="p">;</code><code class="w"/>

<code class="p">}</code><code class="w"> </code><code class="c1">// namespace std::pmr</code></pre>
<p>With this function, we can define the <code>std::pmr::null_memory_resource()</code> as the new
system-wide default allocator
(<a class="co" href="#code_g38_3" id="para_g38_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">// ...
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">set_default_resource</code><code class="p">(</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">null_memory_resource</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_3" id="code_g38_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">monotonic_buffer_resource</code><code class="w">
</code><code class="w">      </code><code class="n">buffer</code><code class="p">{</code><code class="w"> </code><code class="n">raw</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">raw</code><code class="p">.</code><code class="n">size</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">get_default_resource</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>With <code>std::pmr::set_default_resource()</code>, you are able to customize the system-wide
allocator. In other words, this function provides you with the ability to inject the
dependency on this allocator. Does this ring a bell? Does this sound familiar?
I very much hope this makes you think about another, essential design pattern…<em>drum roll</em>…yes, correct: the Strategy design pattern.<sup><a data-type="noteref" href="ch10.xhtml#idm45043071262592" id="idm45043071262592-marker">21</a></sup></p>
<p>Indeed, this is a Strategy. Using this design pattern is a fantastic choice,
because it has an amazing effect on the architecture. While
<code>std::pmr::memory_resource</code> represents an abstraction from all possible allocators
and thus can reside on the high level of the architecture, any concrete implementation
of an allocator, including all (vendor-)specific implementation details, can reside
on the lowest level of the architecture. As a demonstration, consider this sketch of the 
<span class="keep-together"><code>CustomAllocator</code></span> class:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;CustomAllocator.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;memory_resource&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">CustomAllocator</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">pmr</code><code class="o">::</code><code class="n">memory_resource</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// There is no need to enforce a single instance</code>
<code class="w">   </code><code class="n">CustomAllocator</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="c1">// No explicitly declared copy or move operations</code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">do_allocate</code><code class="p">(</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">bytes</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">alignment</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">do_deallocate</code><code class="p">(</code><code class="w"> </code><code class="kt">void</code><code class="o">*</code><code class="w"> </code><code class="n">ptr</code><code class="p">,</code><code class="w"> </code><code class="kt">size_t</code><code class="w"> </code><code class="n">bytes</code><code class="p">,</code><code class="w"/>
<code class="w">                       </code><code class="kt">size_t</code><code class="w"> </code><code class="n">alignment</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="nf">do_is_equal</code><code class="p">(</code><code class="w"/>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">pmr</code><code class="o">::</code><code class="n">memory_resource</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">noexcept</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/></pre>
<p>Note that <code>CustomAllocator</code> <code>public</code>ly inherits from <code>std::pmr::memory_resource</code> in
order to qualify as a C++17 allocator. Due to that, you can establish an instance
of <code>CustomAllocator</code> as the new system-wide default allocator with the
<code>std::pmr::set_default_resource()</code> function
(<a class="co" href="#code_g38_4" id="para_g38_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;CustomAllocator.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="n">CustomAllocator</code><code class="w"> </code><code class="n">custom_allocator</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">std</code><code class="o">:</code><code class="o">:</code><code class="n">pmr</code><code class="o">:</code><code class="o">:</code><code class="n">set_default_resource</code><code class="p">(</code><code class="w"> </code><code class="o">&amp;</code><code class="n">custom_allocator</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_4" id="code_g38_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="w">
</code></pre>
<p>While the <code>std::pmr::memory_resource</code> base class resides on the highest level of the
architecture, <code>CustomAllocator</code> is logically introduced on the lowest architectural
level (see <a data-type="xref" href="#fig_singleton_memory_resource">Figure 10-4</a>). Thus, the Strategy pattern causes an
inversion of 
<span class="keep-together">dependencies</span> (see <a data-type="xref" href="ch02.xhtml#pay_attention_to_the_ownership_of_abstractions">“Guideline 9: Pay Attention to the Ownership of Abstractions”</a>):
despite the Singleton-ness of the allocators, despite representing global state,
you depend on an abstraction instead of the concrete implementation details.</p>
<figure><div class="figure" id="fig_singleton_memory_resource">
<img alt="The dependency inversion achieved via the +std::pmr::memory_resource+ abstraction." height="950" src="assets/cpsd_1004.png" width="1439"/>
<h6><span class="label">Figure 10-4. </span>The dependency inversion achieved via the <code>std::pmr::memory_resource</code> abstraction</h6>
</div></figure>
<p>As a side note, it’s worth pointing out that with this approach you can trivially
avoid any dependency on the order of initialization of globals (i.e., SIOF), since
you can explicitly manage the initialization order by creating all Singletons on
the stack and in a single compilation unit:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// The one and only system-wide clock has no lifetime dependencies.</code>
<code class="w">   </code><code class="c1">// Thus it is created first</code>
<code class="w">   </code><code class="n">SystemClock</code><code class="w"> </code><code class="n">clock</code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="c1">// The one and only system-wide configuration depends on the clock.</code>
<code class="w">   </code><code class="n">SystemConfiguration</code><code class="w"> </code><code class="n">config</code><code class="p">{</code><code class="w"> </code><code class="o">&amp;</code><code class="n">clock</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Applying the Strategy Design Pattern" data-type="sect2"><div class="sect2" id="idm45043070960720">
<h2>Applying the Strategy Design Pattern</h2>
<p>Based<a data-primary="Singleton pattern" data-secondary="designing for change and testability" data-tertiary="applying Strategy design pattern" data-type="indexterm" id="idm45043070920720"/><a data-primary="testability" data-secondary="designing Singleton for change and" data-tertiary="applying Strategy design pattern" data-type="indexterm" id="idm45043070919568"/><a data-primary="Strategy design pattern" data-secondary="applying to Singleton pattern" data-type="indexterm" id="idm45043070918416"/> on this previous example, you should now have an idea how to fix our 
<span class="keep-together"><code>Database</code></span> example. As a reminder, the goal is to keep the <code>Database</code> class as the default database
implementation but to make it an implementation detail, i.e., to remove all dependencies
on the concrete implementation. All you need to do is apply the 
<span class="keep-together">Strategy</span> design
pattern to introduce an abstraction, alongside a global point of access and a global point
for<a data-primary="dependency injection" data-type="indexterm" id="idm45043070915376"/> <em>dependency injection</em>, on the high level of our architecture. This will enable anyone
(and I really mean anyone, as you also follow the Open-Closed Principle (OCP); see
<a data-type="xref" href="ch01.xhtml#design_for_extension">“Guideline 5: Design for Extension”</a>) to introduce a custom database implementation (both concrete
implementations as well as test stubs, mocks, or fakes) on the lowest level.</p>
<p>So let’s introduce the following <code>PersistenceInterface</code> abstraction
(<a class="co" href="#code_g38_5" id="para_g38_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;PersistenceInterface.h&gt; ----------------
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">PersistenceInterface</code><code class="w">  </code><a class="co" href="#para_g38_5" id="code_g38_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">PersistenceInterface</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="nf">read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w">  </code><a class="co" href="#para_g38_6" id="code_g38_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">do_read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="nf">write</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g38_7" id="code_g38_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">do_write</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ... More database specific functionality
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="n">do_read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_6" id="code_g38_6_2"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="nf">do_write</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_7" id="code_g38_7_2"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="nf">get_persistence_interface</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_8" id="code_g38_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">set_persistence_interface</code><code class="p">(</code><code class="w"> </code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">persistence</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_9" id="code_g38_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="c1">// Declaration of the one 'instance' variable
</code><code class="k">extern</code><code class="w"> </code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">instance</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g38_10" id="code_g38_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code></pre>
<p>The <code>PersistenceInterface</code> base class provides the interface for all possible database
implementations. For instance, it introduces a <code>read()</code> and a <code>write()</code> function, split
into the <code>public</code> interface part and the <code>private</code> implementation part, based on the
example set by the <code>std::pmr::memory_resource</code> class
(<a class="co" href="#code_g38_6" id="para_g38_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a> and
<a class="co" href="#code_g38_7" id="para_g38_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).<sup><a data-type="noteref" href="ch10.xhtml#idm45043070746416" id="idm45043070746416-marker">22</a></sup>
Of course, in reality it would introduce a few more database-specific functions, but let
<code>read()</code> and <code>write()</code> be sufficient for this example.</p>
<p>In addition to the <code>PersistenceInterface</code>, you would also introduce a global point of
access called <code>get_persistence_interface()</code>
(<a class="co" href="#code_g38_8" id="para_g38_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>)
and a function to enable <em>dependency injection</em> called <code>set_persistence_interface()</code>
(<a class="co" href="#code_g38_9" id="para_g38_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).
These two functions allow you to access and set the global persistence system
(<a class="co" href="#code_g38_10" id="para_g38_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).</p>
<p>The <code>Database</code> class now inherits from the <code>PersistenceInterface</code> base class and implements
the required interface (hopefully adhering to the Liskov Substitution Principle (LSP);
see <a data-type="xref" href="ch02.xhtml#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>):</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Database.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Database</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">PersistenceInterface</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... Potentially access to data members</code>

<code class="w">   </code><code class="c1">// Make the class immobile by deleting the copy and move operations</code>
<code class="w">   </code><code class="n">Database</code><code class="p">(</code><code class="w"> </code><code class="n">Database</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">delete</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">Database</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Database</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">delete</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">Database</code><code class="p">(</code><code class="w"> </code><code class="n">Database</code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">delete</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">Database</code><code class="o">&amp;</code><code class="w"> </code><code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="w"> </code><code class="n">Database</code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">delete</code><code class="p">;</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="n">do_read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">bool</code><code class="w"> </code><code class="nf">do_write</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ... More database-specific functionality</code>

<code class="w">   </code><code class="c1">// ... Potentially some data members</code>
<code class="p">};</code><code class="w"/></pre>
<p>In our special setting, the <code>Database</code> class represents the default database implementation.
We need to create a default instance of the database, in case no other persistence
system is specified via the <code>set_persistence_interface()</code> function. However, if
any other persistence system is established as the system-wide database before <code>Database</code>
is created, we must not create an instance, as this would cause unnecessary and unfortunate
overhead. This behavior is achieved by implementing the <code>get​_persistence_interface()</code> function
with two<a data-primary="static local variables" data-type="indexterm" id="idm45043070515120"/><a data-primary="Immediately Invoked Lambda Expression (IILE)" data-type="indexterm" id="idm45043070514480"/> <em>static local variables</em> and an <em>Immediately Invoked Lambda Expression (IILE)</em>
(<a class="co" href="#code_g38_11" id="para_g38_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>):</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;PersistenceInterface.cpp&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;Database.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="c1">// Definition of the one 'instance' variable
</code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">instance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">nullptr</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="nf">get_persistence_interface</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="c1">// Local object, initialized by an
</code><code class="w">   </code><code class="c1">//   'Immediately Invoked Lambda Expression (IILE)'
</code><code class="w">   </code><code class="k">static</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="n">init</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="p">(</code><code class="p">)</code><code class="p">{</code><code class="w">  </code><a class="co" href="#para_g38_11" id="code_g38_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">      </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="o">!</code><code class="n">instance</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">         </code><code class="k">static</code><code class="w"> </code><code class="n">Database</code><code class="w"> </code><code class="n">db</code><code class="p">;</code><code class="w">
</code><code class="w">         </code><code class="n">instance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">db</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="p">}</code><code class="w">
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w">  </code><code class="c1">// or false, as the actual value does not matter.
</code><code class="w">   </code><code class="p">}</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="c1">// Note the '()' after the lambda expression. This invokes the lambda.
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">instance</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="kt">void</code><code class="w"> </code><code class="nf">set_persistence_interface</code><code class="p">(</code><code class="w"> </code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">persistence</code><code class="w"> </code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">instance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">persistence</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>The first time the execution flow enters the <code>get_persistence_interface()</code> function, the
<code>init</code> static local variable is initialized. If, at this point in time, the <code>instance</code> is
already set, no <code>Database</code> is created. However, if it is not, the <code>Database</code> instance is
created as another static local variable inside the lambda and bound to the <code>instance</code>
variable:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;PersistenceInterface.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// First access, database object is created</code>
<code class="w">   </code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">persistence</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_persistence_interface</code><code class="p">();</code><code class="w"/>

<code class="w">   </code><code class="c1">// ...</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This implementation achieves the desired effect: <code>Database</code> becomes an implementation
detail, which no other code depends on and which can be replaced at any time by a custom database implementation (see <a data-type="xref" href="#fig_singleton_database_3">Figure 10-5</a>). Thus, despite the
Singleton-ness of <code>Database</code>, it does not introduce dependencies, and it can be easily
changed and easily replaced for testing purposes.</p>
<figure><div class="figure" id="fig_singleton_database_3">
<img alt="The dependency graph for the refactored, non-_Singleton_ +Database+." height="1195" src="assets/cpsd_1005.png" width="1439"/>
<h6><span class="label">Figure 10-5. </span>The dependency graph for the refactored, non-<em>Singleton</em> <code>Database</code></h6>
</div></figure>
<p>“Wow, this<a data-primary="Singleton pattern" data-secondary="designing for change and testability" data-tertiary="refactored dependency graph" data-type="indexterm" id="idm45043070278720"/><a data-primary="testability" data-secondary="designing Singleton for change and" data-tertiary="refactored dependency graph" data-type="indexterm" id="idm45043070277456"/> is a great solution. I bet I can use that in a few places in my own codebase!”
you say, with an impressed and appreciative look on your face. “But I see a potential
problem: since I have to inherit from an interface class, this is an intrusive solution.
What should I do if I can’t change a given Singleton class?” Well, in that case
you have two nonintrusive design patterns to choose from. Either you already have an
inheritance hierarchy in place, in which case you can introduce an Adapter to wrap the
given Singleton (see <a data-type="xref" href="ch06.xhtml#use_adapters_to_standardize_interfaces">“Guideline 24: Use Adapters to Standardize Interfaces”</a>), or you don’t have an
inheritance hierarchy in place yet, in which case you can put the External Polymorphism
design pattern to good use (see
<a data-type="xref" href="ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism">“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”</a>).</p>
<p>“OK, but I see another, more serious problem: is this code truly thread-safe?”
Honestly, no, it is not. To give one example for a possible problem: it could happen that
during the first call to <code>get_persistence_interface()</code>, which may take some time due to the
setup of the <code>Database</code> instance, the <code>set_persistence_interface()</code> is called. In that case,
either the <code>Database</code> is created in vain or the call to 
<span class="keep-together"><code>set_persistence_interface()</code></span> is
lost. However, perhaps surprisingly, this is not something that we need to address. Here’s
why: remember that the <code>instance</code> represents global state. If we assume that
<code>set_persistence_interface()</code> can be called from anywhere in the code at any time, in
general we can’t expect that after calling 
<span class="keep-together"><code>set_persistence_interface()</code></span>, a call to
<code>get_persistence_interface()</code> would return the set value. Hence, calling the
<code>set_persistence_interface()</code> function from anywhere in the code is like pulling the rug
from under somebody’s feet. This is comparable to calling <code>std::move()</code> on any lvalue:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">f</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="o">&amp;</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">T</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">move</code><code class="p">(</code><code class="n">value</code><code class="p">);</code><code class="w">  </code><code class="c1">// Very bad move (literally)!</code>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
<p>From this perspective, the <code>set_persistence_interface()</code> function should be used at the
very beginning of the program or at the beginning of a single test, not arbitrarily.</p>
<p>“Shouldn’t we make sure that the <code>set_persistence_interface()</code> function can be
called only once?” you ask. We most certainly could do that, but this would artificially
limit its use for testing purposes: we would not be able to reset the persistence system
at the beginning of every single test.</p>
</div></section>
<section data-pdf-bookmark="Moving Toward Local Dependency Injection" data-type="sect2"><div class="sect2" id="idm45043070960464">
<h2>Moving Toward Local Dependency Injection</h2>
<p>“OK, I see. One<a data-primary="Singleton pattern" data-secondary="designing for change and testability" data-tertiary="local dependency injection" data-type="indexterm" id="idm45043070172448"/><a data-primary="testability" data-secondary="designing Singleton for change and" data-tertiary="local dependency injection" data-type="indexterm" id="idm45043070171184"/><a data-primary="dependency injection" data-type="indexterm" id="idm45043070169936"/> last question: since this solution involves global state that can be changed,
wouldn’t it be better to use a more direct and more local dependency injection to the
lower-level classes? Consider the following modification of the <code>Widget</code> class, which is
given its dependency upon construction:”</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Widget.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;PersistenceInterface.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">Widget</code><code class="p">(</code><code class="w"> </code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">persistence</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><code class="c1">// Dependency injection</code>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">persistence_</code><code class="p">(</code><code class="n">persistence</code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{}</code><code class="w"/>

<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">doSomething</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">      </code><code class="n">persistence_</code><code class="o">-&gt;</code><code class="n">read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">persistence_</code><code class="p">{};</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>I completely agree with you. This may be the next step to address the problem of global
state. However, before we analyze this approach, keep in mind that this idea is
only an option since we have already inverted the dependencies. Thanks to introducing
an abstraction in the high level of our architecture, we suddenly have choices and can
talk about alternative solutions. Hence, the first and most important step is to properly
manage the dependencies. But back to your suggestion: I really like the approach. The
interface of the <code>Widget</code> class becomes more “honest” and clearly displays all of its
dependencies. And since the dependency is passed via the constructor argument, the dependency
injection becomes more intuitive and more natural.</p>
<p>Alternatively, you could pass the dependency on the <code>Widget::doSomething()</code> function
directly:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Widget.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;PersistenceInterface.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">doSomething</code><code class="p">(</code><code class="w"> </code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">persistence</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">      </code><code class="n">persistence</code><code class="o">-&gt;</code><code class="n">read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>While this approach may not be the best for a member function, this may be your only
option for free functions. And again, the function becomes a little more “honest” by
explicitly stating its dependencies.</p>
<p>However, there is a flip side to this direct dependency injection: this approach may
quickly become unwieldy in large call stacks. Passing a dependency through several levels
of your software stack to make them available at the point they are needed is neither
convenient nor intuitive. Additionally, especially in the presence of several Singletons,
the solution quickly becomes cumbersome: passing, for instance, a 
<span class="keep-together"><code>PersistenceInterface</code></span>,
an <code>Allocator</code>, and the system-wide <code>Configuration</code> through many layers of function calls
just to be able to use them on the lowest level truly is not the most elegant approach.
For that reason, you may want to combine the ideas of providing a global access point and a local dependency injection, for instance, by
introducing a wrapper function:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="c1">//---- &lt;Widget.h&gt; ----------------
</code><code class="w">
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;PersistenceInterface.h&gt;</code><code class="cp">
</code><code class="w">
</code><code class="k">class</code><code class="w"> </code><code class="nc">Widget</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">doSomething</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g38_12" id="code_g38_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="n">doSomething</code><code class="p">(</code><code class="w"> </code><code class="n">get_persistence_interface</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">doSomething</code><code class="p">(</code><code class="w"> </code><code class="n">PersistenceInterface</code><code class="o">*</code><code class="w"> </code><code class="n">persistence</code><code class="p">,</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g38_13" id="code_g38_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="c1">// ...
</code><code class="w">      </code><code class="n">persistence</code><code class="o">-</code><code class="o">&gt;</code><code class="n">read</code><code class="p">(</code><code class="w"> </code><code class="cm">/*some arguments*/</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">      </code><code class="c1">// ...
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>While we still provide the previous <code>doSomething()</code> function
(<a class="co" href="#code_g38_12" id="para_g38_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>),
we now additionally provide an overload that accepts a <code>PersistenceInterface</code> as a function
argument
(<a class="co" href="#code_g38_13" id="para_g38_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).
The second function does all the work, whereas the first function now merely acts as a
wrapper, which injects the globally set <code>PersistenceInterface</code>. In this combination,
it’s possible to make local decisions and to locally inject the desired dependency,
but at the same time it is not necessary to pass the dependency through many layers
of function calls.</p>
<p>However, truth be told, while these solutions may work very well in this database example and
also in the context of managing memory, it might not be the right approach for every single
Singleton problem. So don’t believe that this is the only possible solution. After all, it
depends. However, it is a great example of the general process of software design: identify
the aspect that changes or causes dependencies, then separate concerns by extracting a fitting
abstraction. Depending on your intent, you will just have applied a design pattern. So
consider naming your solution accordingly, and by that leave traces of your reasoning for
others to pick up on.</p>
<p>In summary, the Singleton pattern certainly is not one of the glamorous patterns. It
simply comes with too many disadvantages, most importantly the usual flaws of global state.
But still, despite the many negative aspects, if used judiciously, Singleton can be the
right solution for representing the few global aspects in your code in some situations.
If it is, prefer Singletons with unidirectional data flow, and design your
Singletons for change and testability by inverting the dependencies and enabling
dependency injection with the Strategy design pattern.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043069850656">
<h5>Guideline 38: Design Singletons for Change and Testability</h5>
<ul>
<li>
<p>Be aware that Singleton represents global state, with all its flaws.</p>
</li>
<li>
<p>Avoid global state as much as possible.</p>
</li>
<li>
<p>Use Singleton judiciously and just for the few global aspects in your code.</p>
</li>
<li>
<p>Prefer Singletons with unidirectional data flow.</p>
</li>
<li>
<p>Use the Strategy design pattern to invert dependencies on your Singleton to remove the usual impediments to changeability and testability.<a data-primary="" data-startref="SPchange10" data-type="indexterm" id="idm45043069797472"/><a data-primary="" data-startref="Tchange10" data-type="indexterm" id="idm45043069796624"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45043072392832"><sup><a href="ch10.xhtml#idm45043072392832-marker">1</a></sup> Steve McConnell, <em>Code Complete: A Practical Handbook of Software Construction</em>, 2nd ed. (Microsoft Press, 2004).</p><p data-type="footnote" id="idm45043072387744"><sup><a href="ch10.xhtml#idm45043072387744-marker">2</a></sup> “There can be only one” is the tagline of the 1986 movie <a href="https://oreil.ly/XT6uF"><em>Highlander</em></a> featuring Christopher Lambert.</p><p data-type="footnote" id="idm45043072383840"><sup><a href="ch10.xhtml#idm45043072383840-marker">3</a></sup> Erich Gamma et al., <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p><p data-type="footnote" id="idm45043072376432"><sup><a href="ch10.xhtml#idm45043072376432-marker">4</a></sup> The Meyers’ Singleton is explained in Item 4 of Scott Meyers’s <em>Effective C++</em>.</p><p data-type="footnote" id="idm45043072064080"><sup><a href="ch10.xhtml#idm45043072064080-marker">5</a></sup> I know that the explicit handling of the copy and move assignment operators appears to be overkill, but this gives me the opportunity to remind you about the <a href="https://oreil.ly/fzS3f">Rule of 5</a>.</p><p data-type="footnote" id="idm45043071990224"><sup><a href="ch10.xhtml#idm45043071990224-marker">6</a></sup> This behavior has changed in C++20, since the declaration of any constructor by the user is now enough to make a type nonaggregate.</p><p data-type="footnote" id="idm45043071987280"><sup><a href="ch10.xhtml#idm45043071987280-marker">7</a></sup> To be precise and to avoid complaints, if the static local variable is zero or constant initialized, the initialization can happen before the function is entered. In our example, the variable is indeed created in the first pass.</p><p data-type="footnote" id="idm45043071938896"><sup><a href="ch10.xhtml#idm45043071938896-marker">8</a></sup> In fact, a naive implementation of Singleton is creating lots of artificial dependencies itself; see <a data-type="xref" href="#design_singletons_for_change_and_testability">“Guideline 38: Design Singletons for Change 
<span class="keep-together">and Testability</span>”</a>.</p><p data-type="footnote" id="idm45043071934080"><sup><a href="ch10.xhtml#idm45043071934080-marker">9</a></sup> Without going into detail, I argue that there are several more so-called “design patterns” that fall in the category of implementation patterns, such as the<a data-primary="Monostate pattern" data-type="indexterm" id="idm45043071933280"/> <em>Monostate</em> pattern, the<a data-primary="Memento pattern" data-type="indexterm" id="idm45043071932064"/> <em>Memento</em> pattern, and the<a data-primary="idioms" data-secondary="RAII" data-type="indexterm" id="idm45043071930784"/><a data-primary="RAII idiom" data-type="indexterm" id="idm45043071929776"/> <em>RAII idiom</em>, which <a href="https://oreil.ly/qD1L8">Wikipedia</a> lists as design patterns. While this might make sense in languages other than C++, the intent of RAII is most certainly not to reduce dependencies but to automate cleanup and encapsulate  <span class="keep-together">responsibility</span>.</p><p data-type="footnote" id="idm45043071911616"><sup><a href="ch10.xhtml#idm45043071911616-marker">10</a></sup> Another such piece of advice is the CppCon 2020 talk by Peter Muldoon’s <a href="https://oreil.ly/su4Xb">“Retiring the Singleton Pattern: Concrete Suggestions for What to Use Instead”</a>, which provides many useful techniques for how to deal with Singletons in your codebase.</p><p data-type="footnote" id="idm45043071900224"><sup><a href="ch10.xhtml#idm45043071900224-marker">11</a></sup> If a Singleton is used for anything else, you should be very suspicious and consider it a misuse of the Singleton pattern.</p><p data-type="footnote" id="idm45043071898096"><sup><a href="ch10.xhtml#idm45043071898096-marker">12</a></sup> Michael Feathers, <em>Working Effectively with Legacy Code</em>.</p><p data-type="footnote" id="idm45043071891216"><sup><a href="ch10.xhtml#idm45043071891216-marker">13</a></sup> The best summary of SIOF I’m aware of is given by Jonathan Müller in his accordingly named talk <a href="https://oreil.ly/nvkHT">“Meeting C++ 2020”</a>.</p><p data-type="footnote" id="idm45043071889696"><sup><a href="ch10.xhtml#idm45043071889696-marker">14</a></sup> “Globals are bad, m’kay?” as stated by Guy Davidson and Kate Gregory in <em>Beautiful C++: 30 Core Guidelines for Writing Clean, Safe, and Fast Code</em> (Addison-Wesley).</p><p data-type="footnote" id="idm45043071887072"><sup><a href="ch10.xhtml#idm45043071887072-marker">15</a></sup> The Monostate pattern, to my best knowledge, was first mentioned in the September issue of the 1996 <em>C++ Report</em> in the article “Monostate Classes: The Power of One” by Steve Ball and John Crawford (see Stanley B. Lippmann, ed., <em>More C++ Gems</em> (Cambridge University Press)). It is also described in Martin Reddy’s <em>API Design for C++</em> (Morgan Kaufmann). Monostate, in contrast to Singleton, allows any number of instances of a type, but makes sure that there is only a single state for all instances. As such, the pattern should not be confused with <code>std::monostate</code>, which is used as a well-behaved empty alternative in <code>std::variant</code>.</p><p data-type="footnote" id="idm45043071883440"><sup><a href="ch10.xhtml#idm45043071883440-marker">16</a></sup> Miško Hevery, <a href="https://oreil.ly/wQgJC">“Root Cause of Singletons”</a>, <em>The Testability Explorer</em> (blog), August 2008.</p><p data-type="footnote" id="idm45043071881136"><sup><a href="ch10.xhtml#idm45043071881136-marker">17</a></sup> Ibid.</p><p data-type="footnote" id="idm45043071710704"><sup><a href="ch10.xhtml#idm45043071710704-marker">18</a></sup> For an explanation about the different kinds of test doubles, see Martin Fowler’s article <a href="https://oreil.ly/K4vR3">“Mocks Aren’t Stubs”</a>. For examples of how to use these in C++, refer to Jeff Langr’s <em>Modern C++ Programming with Test-Driven Development</em>.</p><p data-type="footnote" id="idm45043071708112"><sup><a href="ch10.xhtml#idm45043071708112-marker">19</a></sup> But I am sure you won’t be deterred from writing the tests anyway, despite it being difficult.</p><p data-type="footnote" id="idm45043071706768"><sup><a href="ch10.xhtml#idm45043071706768-marker">20</a></sup> This is also one of the strong arguments in Robert C. Martin’s <em>Clean Architecture</em>.</p><p data-type="footnote" id="idm45043071262592"><sup><a href="ch10.xhtml#idm45043071262592-marker">21</a></sup> For the design pattern experts, I should explicitly point out that the <code>std::pmr::get_default_resource()</code> function itself fulfills the intent of another design pattern: the <em>Facade</em> design pattern. Unfortunately, I do not go into detail about Facade in this book.</p><p data-type="footnote" id="idm45043070746416"><sup><a href="ch10.xhtml#idm45043070746416-marker">22</a></sup> The separation into a <code>public</code> interface and a <code>private</code> implementation is an example of the Template Method design pattern. Unfortunately, in this book I can’t go into detail about the many benefits of this design  <span class="keep-together">pattern</span>.</p></div></div></section></div></body></html>