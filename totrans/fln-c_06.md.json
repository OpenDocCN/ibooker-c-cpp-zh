["```cpp\nint result = sum(10, 20);\n```", "```cpp\n/* Returns the sum of the two parameters */\nint sum(int summand1, int summand2);\n```", "```cpp\nint sum(int summand1, int summand2)\n{\n  /* calculate result only depending on parameters and\n not requiring any state information */\n  return summand1 + summand2;\n}\n```", "```cpp\nvoid sendByte(char data, char* destination_ip);\nchar receiveByte();\n```", "```cpp\nvoid sendByte(char data, char* destination_ip)\n{\n  /* open socket to destination_ip, send data via this socket and close\n the socket */\n}\n\nchar receiveByte()\n{\n  /* open socket for receiving data, wait some time and return\n the received data */\n}\n```", "```cpp\nint result;\nresult = addNext(10);\nresult = addNext(20);\n```", "```cpp\n/* Adds the parameter 'value' to the values accumulated\n with previous calls of this function. */\nint addNext(int value);\n```", "```cpp\nstatic int sum = 0;\n\nint addNext(int value)\n{\n  /* calculation of the result depending on the parameter\n and on state information from previous function calls */\n  sum = sum + value;\n  return sum;\n}\n```", "```cpp\nvoid sendByte(char data, char* destination_ip);\nchar receiveByte();\nint getNumberOfSentBytes();\nint getNumberOfReceivedBytes();\n```", "```cpp\nstatic int number_of_sent_bytes = 0;\nstatic int number_of_received_bytes = 0;\n\nvoid sendByte(char data, char* destination_ip)\n{\n  number_of_sent_bytes++;\n  /* socket stuff */\n}\n\nchar receiveByte()\n{\n  number_of_received_bytes++;\n  /* socket stuff */\n}\n\nint getNumberOfSentBytes()\n{\n  return number_of_sent_bytes;\n}\n\nint getNumberOfReceivedBytes()\n{\n  return number_of_received_bytes;\n}\n```", "```cpp\nstruct INSTANCE* inst;\ninst = createInstance();\noperateOnInstance(inst);\n/* access inst->x or inst->y */\ndestroyInstance(inst);\n```", "```cpp\nstruct INSTANCE\n{\n  int x;\n  int y;\n};\n\n/* Creates an instance which is required for working\n with the function 'operateOnInstance' */\nstruct INSTANCE* createInstance();\n\n/* Operates on the data stored in the instance */\nvoid operateOnInstance(struct INSTANCE* inst);\n\n/* Cleans up an instance created with 'createInstance' */\nvoid destroyInstance(struct INSTANCE* inst);\n```", "```cpp\nstruct INSTANCE* createInstance()\n{\n  struct INSTANCE* inst;\n  inst = malloc(sizeof(struct INSTANCE));\n  return inst;\n}\n\nvoid operateOnInstance(struct INSTANCE* inst)\n{\n  /* work with inst->x and inst->y */\n}\n\nvoid destroyInstance(struct INSTANCE* inst)\n{\n  free(inst);\n}\n```", "```cpp\n  struct Sender\n  {\n    char destination_ip[16];\n    int socket;\n  };\n\n  struct Sender* createSender(char* destination_ip);\n  void sendByte(struct Sender* s, char data);\n  void destroySender(struct Sender* s);\n```", "```cpp\nstruct Sender* createSender(char* destination_ip)\n{\n  struct Sender* s = malloc(sizeof(struct Sender));\n  /* create socket to destination_ip and store it in Sender s*/\n  return s;\n}\n\nvoid sendByte(struct Sender* s, char data)\n{\n  number_of_sent_bytes++;\n  /* send data via socket stored in Sender s */\n}\n\nvoid destroySender(struct Sender* s)\n{\n  /* close socket stored in Sender s */\n  free(s);\n}\n```", "```cpp\nstruct Sender* s = createSender(\"192.168.0.1\");\nchar* dataToSend = \"Hello World!\";\nchar* pointer = dataToSend;\nwhile(*pointer != '\\0')\n{\n  sendByte(s, *pointer);\n  pointer++;\n}\ndestroySender(s);\n```", "```cpp\nstruct INSTANCE* inst = openInstance(INSTANCE_TYPE_B);\n/* operate on the same instance as caller2 */\noperateOnInstance(inst);\ncloseInstance(inst);\n```", "```cpp\nstruct INSTANCE* inst = openInstance(INSTANCE_TYPE_B);\n/* operate on the same instance as caller1 */\noperateOnInstance(inst);\ncloseInstance(inst);\n```", "```cpp\nstruct INSTANCE\n{\n  int x;\n  int y;\n};\n\n/* to be used as IDs for the function openInstance */\n#define INSTANCE_TYPE_A 1\n#define INSTANCE_TYPE_B 2\n#define INSTANCE_TYPE_C 3\n\n/* Retrieve an instance identified by the parameter 'id'. That instance is\n created if no instance of that 'id' was yet retrieved from any\n other caller. */\nstruct INSTANCE* openInstance(int id);\n\n/* Operates on the data stored in the instance. */\nvoid operateOnInstance(struct INSTANCE* inst);\n\n/* Releases an instance which was retrieved with 'openInstance'.\n If all callers release an instance, it gets destroyed. */\nvoid closeInstance(struct INSTANCE* inst);\n```", "```cpp\n#define MAX_INSTANCES 4\n\nstruct INSTANCELIST\n{\n  struct INSTANCE* inst;\n  int count;\n};\n\nstatic struct INSTANCELIST list[MAX_INSTANCES];\n\nstruct INSTANCE* openInstance(int id)\n{\n  if(list[id].count == 0)\n  {\n    list[id].inst =  malloc(sizeof(struct INSTANCE));\n  }\n  list[id].count++;\n  return list[id].inst;\n}\n\nvoid operateOnInstance(struct INSTANCE* inst)\n{\n  /* work with inst->x and inst->y */\n}\n\nstatic int getInstanceId(struct INSTANCE* inst)\n{\n  int i;\n  for(i=0; i<MAX_INSTANCES; i++)\n  {\n    if(inst == list[i].inst)\n    {\n      break;\n    }\n  }\n  return i;\n}\n\nvoid closeInstance(struct INSTANCE* inst)\n{\n  int id = getInstanceId(inst);\n  list[id].count--;\n  if(list[id].count == 0)\n  {\n    free(inst);\n  }\n}\n```", "```cpp\nstruct Sender* openSender(char* destination_ip);\nvoid sendByte(struct Sender* s, char data);\nvoid closeSender(struct Sender* s);\n```", "```cpp\nstruct Sender* openSender(char* destination_ip)\n{\n  struct Sender* s;\n  if(isInSenderList(destination_ip))\n  {\n    s = getSenderFromList(destination_ip);\n  }\n  else\n  {\n    s = createSender(destination_ip);\n  }\n  increaseNumberOfCallers(s);\n  return s;\n}\n\nvoid sendByte(struct Sender* s, char data)\n{\n  number_of_sent_bytes++;\n  /* send data via socket stored in Sender s */\n}\n\nvoid closeSender(struct Sender* s)\n{\n  decreaseNumberOfCallers(s);\n  if(numberOfCallers(s) == 0)\n  {\n    /* close socket stored in Sender s */\n    free(s);\n  }\n}\n```"]