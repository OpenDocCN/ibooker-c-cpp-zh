["```cpp\nvoid setup() {\n  // put your setup code here, to run once:\n  // Tell our board we want to write to the built-in LED\n  pinMode(LED_BUILTIN, OUTPUT);          ![1](Images/1.png) ![2](Images/2.png)\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  // A high value is 'on' for an LED\n  digitalWrite(LED_BUILTIN, HIGH);       ![3](Images/3.png)\n  // Now wait for 500 milliseconds\n  delay(500);\n  // And write a low value to turn our LED off\n  digitalWrite(LED_BUILTIN, LOW);        ![4](Images/4.png)\n  // and wait another 500ms\n  delay(500);\n}\n```", "```cpp\n#define LED_BUILTIN 13\n#define HIGH 1\n#define LOW  0\n```", "```cpp\ntypedef unsigned char byte;\n```", "```cpp\n// Output pins, have to make sure they support PWM\n#define RED    5\n#define GREEN  6\n#define BLUE   9\n\n// Some helper values\n#define RATE 5000\n#define PI_2 6.283185\n\n// Color channel values for our LED\nbyte red;\nbyte green;\nbyte blue;\n\nvoid setup() {\n  // Set our output pins\n  pinMode(RED, OUTPUT);\n  pinMode(GREEN, OUTPUT);\n  pinMode(BLUE, OUTPUT);\n\n  // Start the LED \"off\"\n  digitalWrite(RED, 0);\n  digitalWrite(GREEN, 0);\n  digitalWrite(BLUE, 0);\n\n  // Get our PRNG ready, then pick our random colors\n  randomSeed(analogRead(0));\n\n  // And pick our random color, but make sure it's relatively bright\n  red = random(128,255);\n  green = random(128,255);\n  blue = random(128,255);\n\n  // Finally show the LED for a few seconds before starting the animation\n  analogWrite(RED, red);\n  analogWrite(GREEN, green);\n  analogWrite(BLUE, blue);\n  delay(RATE);\n}\n\nvoid loop() {\n  double ms_in_radians = (millis() % RATE) * PI_2 / RATE;\n  double breath = (sin(ms_in_radians) + 1.0) / 2.0;\n  analogWrite(RED, red * breath);\n  analogWrite(GREEN, green * breath);\n  analogWrite(BLUE, blue * breath);\n  delay(10);\n}\n```", "```cpp\n// TMP36 is a 10-bit (0 - 1023) analog sensor\n// 10mV / C with 500mV offset for temps below 0\n#define TMP36_PIN 0\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  int raw = analogRead(TMP36_PIN);\n  float asVolts = raw * 5.0 / 1024;  // Connected to 5V\n  float asC = (asVolts - 0.5) * 100;\n  Serial.print(asC);\n  Serial.println(\" degrees C\");\n  float asF = (asC * 1.8) + 32;\n  Serial.print(asF);\n  Serial.println(\" degrees F\");\n  delay(5000);\n}\n```", "```cpp\n#include <TM1637Display.h>\n```", "```cpp\n// Our 4-digit display uses a TM1637 chip and I2C #include <TM1637Display.h> ![1](Images/1.png)\n\n// Name our pins #define CLK       2 ![2](Images/2.png)\n#define DIO       3\n\n// Create our 4-segment display object TM1637Display display(CLK, DIO);            ![3](Images/3.png)\n\nvoid setup() {\n  // Get our display ready and set a medium brightness\n  display.clear();                          ![4](Images/4.png)\n  display.setBrightness(0x0f);\n  display.showNumberDec(1234);\n}\n\nvoid loop() {                               ![5](Images/5.png)\n}\n```", "```cpp\nbool useC = false; // display temp in Celsius?\n\nvoid loop() {\n  // ...\n  int toggle = digitalRead(BUTTON);\n  if (toggle == LOW) {\n    useC = !useC;\n  }\n  // ...\n}\n```", "```cpp\n// TMP36 is a 10-bit (0 - 1023) analog sensor\n// 10mV / C with 500mV offset for temps below 0\n// Our 4-digit display uses a TM1637 chip and I2C\n#include <TM1637Display.h>\n\n// Name our pins\n#define TMP36_PIN 0\n#define CLK       2\n#define DIO       3\n#define BUTTON    8\n\n// Create our 4-segment display object\nTM1637Display display(CLK, DIO);\n\n// Build the letters \"F\" and \"C\"\n// Segment bits run clockwise from top (bit 1) to center (64)\nuint8_t segmentF[] = { 1 | 32 | 64 | 16 };\nuint8_t segmentC[] = { 1 | 32 | 16 | 8 };\n\n// Keep track of scale\nbool useC = false;\n\n// Manage button at human time\nbool debounce = false;\n\nvoid setup() {\n  Serial.begin(115200);\n  display.clear();\n  display.setBrightness(0x0f);\n  pinMode(BUTTON, INPUT_PULLUP);\n}\n\nvoid loop() {\n  int raw = analogRead(TMP36_PIN);\n  float asVolts = raw * 5.0 / 1024;  // Connected to 5V\n  float asC = (asVolts - 0.5) * 100;\n  int wholeC = (int)(asC + 0.5);\n  int wholeF = (int)((asC * 1.8) + 32 + 0.5);\n  Serial.print(raw);\n  Serial.print(\" \");\n  Serial.println(asC);\n  if (useC) {\n    display.showNumberDec(wholeC, false, 3, 0);\n    display.setSegments(segmentC, 1, 3);\n  } else {\n    display.showNumberDec(wholeF, false, 3, 0);\n    display.setSegments(segmentF, 1, 3);\n  }\n  if (debounce) {\n    debounce = false;\n    delay(1000);\n  } else {\n    for (int i =0; i < 1000; i += 10) {\n      int toggle = digitalRead(BUTTON);\n      if (toggle == LOW) {\n        useC = !useC;\n        debounce = true;\n        break;\n      }\n      delay(10);\n    }\n  }\n}\n```", "```cpp\nconst PROGMEM uint32_t colors[] = {\n  0xCC000000, 0x00CC0000, 0x0000CC00, 0x000000CC,\n  0xCC336699, 0xCC663399, 0xCC339966, 0xCC996633\n};\n```", "```cpp\nuint32_t firstColor = pgm_read_dword(&colors[0]);\n```", "```cpp\nsetup() {\n  Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n  // ...\n  Serial.println(\"Setting pin modes...\");\n  // ...\n  Serial.println(\"Ready\");\n}\n```", "```cpp\nSketch uses 4548 bytes (14%) of program storage space. Maximum is 32256 bytes.\nGlobal variables use 275 bytes (13%) of dynamic memory,\nleaving 1773 bytes for local variables. Maximum is 2048 bytes.\n```", "```cpp\nsetup() {\n  Serial.begin(115200);\n  Serial.println(F(\"Initializing...\"));\n  // ...\n  Serial.println(F(\"Setting pin modes...\"));\n  // ...\n  Serial.println(F(\"Ready\"));\n}\n```", "```cpp\nSketch uses 4608 bytes (14%) of program storage space. Maximum is 32256 bytes.\nGlobal variables use 225 bytes (10%) of dynamic memory,\nleaving 1823 bytes for local variables. Maximum is 2048 bytes.\n```", "```cpp\n#include <EEPROM.h>\n\nfloat temperature;\n\nvoid setup() {\n  EEPROM.get(0, temperature);\n  // ... other initialization stuff\n}\n\nvoid loop() {\n  // ... things happen, temperature changes\n  EEPROM.put(0, temperature);\n  // things continue to happen ...\n}\n```", "```cpp\n#include <Adafruit_NeoPixel.h>\n#include <EEPROM.h>\n\n#define RING_PIN    3\n#define RING_COUNT 24\n#define BUTTON_PIN  2\n\nint previousState = HIGH;\nint pause = 250;\nint countdown = -1;\n\nconst PROGMEM uint32_t colors[] = {\n  0xCC000000, 0x00CC0000, 0x0000CC00, 0x000000CC,\n  0xCC336699, 0xCC663399, 0xCC339966, 0xCC996633\n};\nconst byte colorCount = 8;\nbyte colorIndex;\n\nAdafruit_NeoPixel ring(RING_COUNT, RING_PIN, NEO_GRBW);\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n  retrieveIndex();\n  ring.begin();             // Initialize our ring\n  ring.setBrightness(128);  // Set a comfortable mid-level brightness\n  ring.fill(pgm_read_dword(&colors[colorIndex]));\n  ring.show();\n}\n\nvoid loop() {\n  int toggle = digitalRead(BUTTON_PIN);\n  if (toggle != previousState) {\n    if (toggle == LOW) {\n      // \"falling\" state, so do our work\n      previousState = LOW;\n      colorIndex++;\n      if (colorIndex >= colorCount) {\n        colorIndex = 0;\n      }\n      ring.fill(pgm_read_dword(&colors[colorIndex]));\n      ring.show();\n      countdown = 10;\n    } else {\n      // \"rising\", just record the new state\n      previousState = HIGH;\n    }\n  }\n  if (countdown > 0) {\n    countdown--;\n  } else if (countdown == 0) {\n    // Time's up! Record the current color index to EEPROM\n    countdown = -1; // stop counting down\n    storeIndex();\n  }\n  delay(100);\n}\n\nvoid retrieveIndex() {\n  Serial.print(F(\"RETRIEVE ... \"));\n  EEPROM.get(0, colorIndex);\n  if (colorIndex >= colorCount) {\n    Serial.println(F(\"ERROR, using default\"));\n    // Got a bad value from EEPROM, use default of 0\n    colorIndex = 0;\n    // And try to store this good value\n    storeIndex();\n  } else {\n    Serial.print(colorIndex);\n    Serial.println(F(\" OK\"));\n  }\n}\n\nvoid storeIndex() {\n  Serial.print(F(\"STORE ... \"));\n  Serial.print(colorIndex);\n  EEPROM.put(0, colorIndex);\n  Serial.println(F(\" OK\"));\n}\n```", "```cpp\n#include <Adafruit_NeoPixel.h>\n\n#define RING_PIN    3\n#define RING_COUNT 24\n#define BUTTON_PIN  2\n\nint pause = 1000;                                            ![1](Images/1.png)\n\nAdafruit_NeoPixel ring(RING_COUNT, RING_PIN, NEO_GRBW);\n\nvoid nextPause() {                                           ![2](Images/2.png)\n  if (pause == 250) {\n    pause = 1000;\n  } else {\n    pause /= 2;\n  }\n}\n\nvoid setup() {\n  pinMode(BUTTON_PIN, INPUT_PULLUP);                         ![3](Images/3.png)\n  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN),         ![4](Images/4.png)\n      nextPause, FALLING);\n  ring.begin();             // Initialize our ring ![5](Images/5.png)\n  ring.setBrightness(128);  // Set a comfortable brightness\n  ring.show();              // Start with all pixels off }\n\nvoid loop() {\n  for (int p = 0; p < RING_COUNT; p++) {                     ![6](Images/6.png)\n    ring.clear();\n    ring.setPixelColor(p, 0, 255, 0, 0);\n    ring.show();\n    delay(pause);\n  }\n}\n```"]