- en: Chapter 6\. Flexible APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章\. 灵活 API
- en: Designing interfaces with the right level of flexibility and the right level
    of abstraction is one of the most important things when writing software, because
    interfaces represent a contract that often cannot be changed once the system is
    in operation. Because of this it is important to put stable declarations into
    the interface and to abstract implementation details, which should have the flexibility
    to change at a later point in time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，设计具有适当灵活性和适当抽象级别的接口是最重要的事情之一，因为接口代表了一个合同，一旦系统开始运行往往就无法更改。因此，将稳定的声明放入接口中并抽象实现细节非常重要，这些细节在以后可能需要更改的情况下应具有灵活性。
- en: For object-oriented programming languages, you’ll find much guidance on how
    to design interfaces (for example, in the form of design patterns), but there
    is not much guidance of this kind for procedural programming languages like C.
    There are the SOLID design principles (see nearby sidebar) that tell you in general
    how to design good software. However, for the C programming language, detailed
    design guidance on how to design interfaces is hard to find, and that’s where
    the patterns from this chapter come in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向对象的编程语言，你会发现有很多关于如何设计接口的指导（例如，设计模式形式上的）。但对于像 C 这样的过程化编程语言，关于如何设计接口的详细指导却很难找到。在这里，本章的模式就有了用武之地。
- en: '[Figure 6-1](#overview_flexible_api) shows the four patterns covered in this
    chapter, as well as related patterns, and [Table 6-1](#tab_flexible_api) contains
    a short description of the four patterns. Keep in mind that not all of the patterns
    should always be applied in all possible contexts. Generally it is advisable to
    design a system to not be more complex than it has to be. This means that some
    of the presented patterns should only be applied if the gained flexibility is
    already required by your API or will likely be required in the future. If it is
    not likely to be required, then the pattern should perhaps not be applied to keep
    the API as simple as possible.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](#overview_flexible_api) 展示了本章涵盖的四种模式及相关模式，[表 6-1](#tab_flexible_api)
    包含了这四种模式的简要描述。请注意，并非所有模式在所有可能的情境下都应该应用。通常建议设计一个系统，使其不比必要复杂。这意味着只有在你的 API 已经需要或将来可能需要的情况下，才应该应用一些提出的模式。如果不太可能需要，那么为了尽可能保持
    API 的简单性，可能就不应该应用这些模式。'
- en: '![Overview of the patterns on flexible APIs](assets/fluc_0601.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![灵活 API 模式概述](assets/fluc_0601.png)'
- en: Figure 6-1\. Overview of patterns for flexible APIs
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 灵活 API 模式概述
- en: Table 6-1\. Patterns for flexible APIs
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. 灵活 API 的模式
- en: '|  | Pattern name | Summary |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|  | 模式名称 | 摘要 |'
- en: '| --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  | Header Files | You want a functionality that you implement to be accessible
    to code from other implementation files, but you want to hide your implementation
    details from the caller. Therefore, provide function declarations in your API
    for any functionality you want to provide to your user. Hide any internal functions,
    internal data, and your function definitions (the implementations) in your implementation
    file and don’t provide this implementation file to the user. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|  | 头文件 | 你希望你实现的功能可以被其他实现文件中的代码访问，但你希望隐藏实现细节不让调用者看到。因此，在你的 API 中为任何你想要提供给用户的功能提供函数声明。将任何内部函数、内部数据和函数定义（实现）隐藏在你的实现文件中，不将这些实现文件提供给用户。
    |'
- en: '|  | Handle | You have to share state information or operate on shared resources
    in your function implementations, but you don’t want your caller to see or even
    access all that state information and shared resources. Therefore, have a function
    to create the context on which the caller operates and return an abstract pointer
    to internal data for that context. Require the caller to pass that pointer to
    all your functions, which can then use the internal data to store state information
    and resources. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  | 处理 | 在你的函数实现中需要共享状态信息或操作共享资源，但你不希望调用者看到或甚至访问所有这些状态信息和共享资源。因此，设计一个函数来创建调用者操作的上下文，并返回该上下文的内部数据的抽象指针。要求调用者将该指针传递给所有你的函数，这样函数可以使用内部数据来存储状态信息和资源。
    |'
- en: '|  | Dynamic Interface | It should be possible to call implementations with
    slightly deviating behaviors, but it should not be necessary to duplicate any
    code, not even the control logic implementation and interface declaration. Therefore,
    define a common interface for the deviating functionalities in your API and require
    the caller to provide a callback function for that functionality, which you then
    call in your function implementation. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  | 动态接口 | 应该可以调用具有稍有不同行为的实现，但不应该需要复制任何代码，甚至不包括控制逻辑实现和接口声明。因此，在你的 API 中为这些不同的功能定义一个通用接口，并要求调用者提供一个回调函数来处理这些功能，然后在你的函数实现中调用这个回调函数。
    |'
- en: '|  | Function Control | You want to call implementations with slightly deviating
    behaviors, but you don’t want to duplicate any code, not even the control logic
    implementation or the interface declaration. Therefore, add a parameter to your
    function that passes meta-information about the function call and that specifies
    the actual functionality to be performed. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  | 函数控制 | 你想调用具有稍有不同行为的实现，但不想复制任何代码，甚至不包括控制逻辑实现或接口声明。因此，在你的函数中添加一个参数，传递有关函数调用的元信息，并指定要执行的实际功能。
    |'
- en: As a running example, in this chapter you want to implement a device driver
    for your Ethernet network interface card. The firmware of this card provides several
    registers with which you can send or receive data and with which you can configure
    the card. You want to build some abstraction of these hardware details, and you
    want to make sure that a user of your API is not affected if you change some parts
    of your implementation. To achieve this, you build an API consisting of Header
    Files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个运行的例子，在本章中，你想为你的以太网网络接口卡实现一个设备驱动程序。该卡的固件提供了几个寄存器，你可以用它们发送或接收数据，并且你可以配置该卡。你想建立一些关于这些硬件细节的抽象，并且你想确保
    API 的用户不会受到影响，即使你更改了实现的某些部分。为了实现这一点，你构建了一个由头文件组成的 API。
- en: Header Files
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头文件
- en: Context
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: You write a larger piece of software in C. You split that software up into several
    functions, and you implement these functions in several files because you want
    to make your program modular and easy to maintain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 C 语言中编写了一个较大的软件程序。你将这个软件程序拆分为多个函数，并在多个文件中实现这些函数，因为你希望使你的程序模块化且易于维护。
- en: Problem
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**You want a functionality that you implement to be accessible to code from
    other implementation files, but you want to hide your implementation details from
    the caller.**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**你希望实现的功能可以被其他实现文件中的代码访问，但你希望隐藏来自调用者的实现细节。**'
- en: Unlike many object-oriented languages, C does not provide any built-in support
    for defining APIs, abstracting functionality, or enforcing that the caller can
    only access this abstraction. C only provides a mechanism to include files into
    other files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多面向对象的语言不同，C 语言不提供任何内置支持来定义 API、抽象功能或强制调用者只能访问这种抽象。C 语言只提供了一种机制，即将文件包含到其他文件中。
- en: The caller of your code could use that mechanism to simply include your implementation
    file. But then the caller could access all internal data in that file, such as
    variables or functions with file scope that you only intend to use internally.
    Once the caller uses this internal functionality, it might not be easy to change
    it later on, so the code becomes tightly coupled in places where you might not
    want that to happen. If the caller includes the implementation file, the names
    of the internal variables and functions might clash with names used by the caller.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 调用你的代码的人可以使用这种机制简单地包含你的实现文件。但是调用者可以访问该文件中的所有内部数据，例如你仅打算在内部使用的具有文件范围的变量或函数。一旦调用者使用这些内部功能，稍后更改它可能就不容易了，因此在你可能不希望发生的地方，代码变得紧密耦合。如果调用者包含了实现文件，内部变量和函数的名称可能会与调用者使用的名称冲突。
- en: Solution
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Provide function declarations in your API for any functionality you want
    to provide to your user. Hide any internal functions, internal data, and your
    function definitions (the implementations) in your implementation file and don’t
    provide this implementation file to the user.**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**为你的 API 提供功能声明，以便向用户提供任何想要提供的功能。隐藏任何内部函数、内部数据和函数定义（实现）在你的实现文件中，并且不要将此实现文件提供给用户。**'
- en: In C, it is a common convention that anybody who uses functions of your software
    only uses functions defined in your header file (**.h* file) and does not use
    other functions in your implementation (your **.c* files). In some cases, this
    abstraction can be partially enforced (for example, you cannot use a `static`
    function from another file), but the C language does not support such enforcements
    to the full extent. Therefore, the convention of not accessing other implementation
    files is even more important than the enforcement mechanisms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，通常约定任何使用你软件函数的人仅使用头文件中定义的函数（**.h* 文件），而不使用实现中的其他函数（你的 **.c* 文件）。在某些情况下，可以部分强制执行此抽象（例如，无法使用来自另一个文件的
    `static` 函数），但 C 语言不完全支持这种强制执行。因此，不访问其他实现文件的约定比强制执行机制更为重要。
- en: Within the header file, make sure to include all related artifacts needed by
    your functions in the header file. It should not be neccessary for your caller
    to include other header files in order to be able to use the functionality from
    your header file. If you have common declarations (like data types or `#defines`)
    that are needed in multiple header files, then put these declarations into a separate
    header file and include it in the other header files that need the declarations.
    To ensure that the header files are not included multiple times in a compilation
    unit, protect them with Include Guards.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，确保包含所有函数所需的相关构件。调用者使用头文件功能时不需要包含其他头文件。如果有常用声明（如数据类型或 `#define`），这些声明需放入单独的头文件中，并在需要的其他头文件中包含它。为确保头文件在编译单元中不被多次包含，使用包含保护。
- en: Only put functions into the same header file if they are related. If the functions
    operate on the same Handle or perform an operation in the same domain (like math
    calculations), then that is an indicator to put them into the same header file.
    In general, if you can think of a relevant use case that requires all of the functions,
    then you should put them into the same header file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在相关时将函数放入同一头文件中。如果函数操作相同句柄或在相同领域中执行操作（如数学计算），则应将它们放入同一头文件中。总体而言，如果能想到相关的使用情况需要所有函数，则应将它们放入同一头文件中。
- en: Clearly document the behavior of your API in the header file. The user should
    not be required to have a look at the implementation in order to understand how
    the functions provided in the API work.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中清晰地记录 API 的行为。用户不需要查看实现即可理解 API 提供的函数如何工作。
- en: 'The following code shows an example of a Header File:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了头文件的示例：
- en: '*API (h-file)*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*API（h 文件）*'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Implementation (c-file)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现（c 文件）*'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Consequences
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响
- en: You have a very clear separation between the things relevant for your caller
    (the **.h* file) and the implementation details that the caller does not have
    to care about (the **.c* file). Thus, you abstracted some functionality for the
    caller.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调用者相关的内容（**.h* 文件），与调用者无需关心的实现细节（**.c* 文件）之间有非常明确的分离。因此，你为调用者抽象了一些功能。
- en: Having many header files will influence your build times. On the one hand this
    enables you to split your implementations into separate files, and your toolchain
    will be able to have an incremental build that only rebuilds files that changed.
    On the other hand, a complete rebuild will have slightly increased build times
    compared to having all the code in one file, because all the files have to be
    opened and read for the build.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个头文件将影响构建时间。一方面，这使得你可以将实现分割到单独的文件中，且工具链可以进行增量构建，仅重新构建已更改的文件。另一方面，与将所有代码放入一个文件相比，完全重建将稍微增加构建时间，因为需要打开和读取所有文件。
- en: If you discover that your functions require more interaction between one another
    or that they have to be called in different contexts that require different internal
    state information, then you have to think about how to realize that with your
    API. A Handle can help in such cases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现你的函数需要更多相互交互或者需要在不同上下文中调用需要不同内部状态信息的情况，那么需要考虑如何通过 API 实现。句柄在这种情况下可以提供帮助。
- en: The caller of your functions now relies on the abstraction and might rely on
    the fact that the behavior of these functions does not change. The API might have
    to be kept stable. To add new functionality, you can always add new functions
    to the API. But in some cases you might want to extend existing functions, and
    to be able to cope with such future changes, you have to consider how to make
    your functions flexible while keeping them stable. Handles, Dynamic Interfaces,
    or Function Controls can help in such cases.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您的函数的调用者现在依赖于抽象层，并可能依赖于这些函数的行为不会改变的事实。API 可能必须保持稳定。要添加新功能，您可以始终向 API 添加新函数。但在某些情况下，您可能希望扩展现有函数，为了能够应对这样的未来变化，您必须考虑如何使函数灵活，同时保持它们的稳定性。句柄、动态接口或功能控制可以在这种情况下有所帮助。
- en: Known Uses
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: Pretty much every C program that is larger than a simple “Hello World” program
    contains header files.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎所有比简单的“Hello World”程序更大的 C 程序都包含头文件。
- en: Using a header file in C is analogous to using interfaces in Java or abstract
    classes in C++.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C 中使用头文件类似于在 Java 中使用接口或在 C++ 中使用抽象类。
- en: The Pimpl Idiom describes how to hide private implementation details and not
    put them into the header file. You can find a description of that idiom in the
    Portland Pattern Repository.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pimpl 惯用法描述了如何隐藏私有实现细节并将它们不放入头文件中。您可以在 Portland Pattern Repository 中找到该惯用法的描述。
- en: Applied to Running Example
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'Your first device driver API looks like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一个设备驱动程序 API 如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The user of your API does not have to cope with implementation details like
    how you access Ethernet registers, and you are free to change these details without
    affecting the user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 API 的用户不必应对诸如如何访问以太网寄存器之类的实现细节，您可以自由更改这些细节而不影响用户。
- en: 'Now your requirements for your driver change. Your system has a second, identical
    Ethernet network interface card, and it should be possible to operate both of
    them. Here are two straightforward options to achieve this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对驱动程序的需求发生了变化。您的系统有第二个相同的以太网网络接口卡，并且应该可以操作这两个接口。以下是两种实现此目标的直接选项：
- en: You copy your code and have one piece of code for each network interface card.
    In the copied code, you only modify the address of the exact interface to be accessed.
    However, such code duplication is never a good idea and makes maintenance of your
    code much more difficult.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您复制您的代码，并为每个网络接口卡编写一段代码。在复制的代码中，您只修改要访问的确切接口的地址。然而，这种代码复制从来不是一个好主意，并且使您的代码维护困难得多。
- en: You add a parameter to address the network interface card (for example, a device
    name string) to each function. But it’s quite likely that more than just one parameter
    will have to be shared between the functions, and passing each of them to every
    function makes the usage of your API cumbersome.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您向每个函数添加一个参数来解析网络接口卡（例如，设备名称字符串）。但很可能不止一个参数需要在函数之间共享，而将每个参数传递给每个函数使得您的 API 使用起来很麻烦。
- en: A better idea to support multiple Ethernet network interface cards is to introduce
    Handles to your API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多个以太网网络接口卡的更好想法是向您的 API 引入句柄。
- en: Handle
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 句柄
- en: Context
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You want to provide a set of functions to your caller, and these functions operate
    on shared resources or they share state information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望向您的调用者提供一组函数，并且这些函数操作共享资源或它们共享状态信息。
- en: Problem
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**You have to share state information or operate on shared resources in your
    function implementations, but you don’t want your caller to see or even access
    all that state information and shared resources.**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**在您的函数实现中，您必须共享状态信息或操作共享资源，但您不希望您的调用者看到或甚至访问所有这些状态信息和共享资源。**'
- en: That state information and shared resources should remain invisible to your
    caller because later on you might want to change it or add to it without requiring
    any changes to your caller’s code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那些状态信息和共享资源应该对您的调用者保持不可见，因为以后您可能想要更改它或添加到它，而无需更改调用者的代码。
- en: In object-oriented programming languages, such data on which functions can operate
    is realized by class member variables. These class member variables can be made
    private if the caller should not be able to access them. However, C does not natively
    support classes and private member variables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的编程语言中，函数可以操作的数据是通过类成员变量来实现的。如果不希望调用者能够访问这些数据，则可以将这些类成员变量设为私有。然而，C 并不本地支持类和私有成员变量。
- en: Simply having a Software-Module with Global State holding static global variables
    in your implementation file for storing shared data between your functions is
    not an option for you, because it should be possible to call your functions in
    multiple contexts. The function calls for each of your callers should be able
    to build up their state information. And even though that information should remain
    invisible to your callers, you need a way to identify which information belongs
    to which specific caller and how to access that information in your function implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的实现文件中仅具有保持静态全局变量的全局状态的软件模块对你来说不是一个选项，因为应该能够在多个上下文中调用你的函数。每个调用者的函数调用应该能够建立它们的状态信息。尽管这些信息对你的调用者应该保持不可见，但你需要一种方法来识别哪些信息属于哪个特定的调用者，以及如何在你的函数实现中访问这些信息。
- en: Solution
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Have a function to create the context on which the caller operates and return
    an abstract pointer to internal data for that context. Require the caller to pass
    that pointer to all your functions, which can then use the internal data to store
    state information and resources.**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**有一个函数用于创建调用者操作的上下文，并返回指向该上下文内部数据的抽象指针。要求调用者将该指针传递给所有你的函数，然后这些函数可以使用内部数据来存储状态信息和资源。**'
- en: Your functions know how to interpret this abstract pointer, which is an opaque
    data type also called Handle. However, the data structure that you point to should
    not be part of the API. The API only provides the functionality to relay hidden
    data to the functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数知道如何解释这个抽象指针，这是一种不透明数据类型，也称为处理。然而，你指向的数据结构不应成为应用程序接口的一部分。应用程序接口仅提供将隐藏数据传递到函数的功能。
- en: 'The Handle can be implemented as a pointer to an Aggregate Instance like a
    `struct`. The `struct` should contain all required state information or other
    variables—it usually holds variables similar to those you would declare as member
    variables for objects in object-oriented programming. The `struct` should be hidden
    in your implementation. The API only contains the definition of a pointer to the
    `struct` as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可以实现为指向聚合实例的指针，如一个`struct`。该`struct`应包含所有必需的状态信息或其他变量——通常它保存与面向对象编程中对象的成员变量类似的变量。该`struct`应在你的实现中隐藏起来。应用程序接口仅包含指向`struct`的指针的定义，如下面的代码所示：
- en: '*API*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用程序接口*'
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Implementation*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*实施*'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Have one function in your API for creating a Handle. That function returns the
    Handle to the caller. The caller can then call other functions of your API that
    require the Handle. In most cases, you also need a function to delete the Handle
    by cleaning up all the allocated resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序接口中有一个函数用于创建一个处理。该函数将处理返回给调用者。然后调用者可以调用你的应用程序接口中需要处理的其他函数。在大多数情况下，你还需要一个函数来删除处理，清理所有分配的资源。
- en: Consequences
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: You can now share state information and resources between your functions without
    requiring the caller to worry about it and without giving the caller the opportunity
    to make the code depend on these internals.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在你的函数之间共享状态信息和资源，而无需让调用者担心它，也不会让调用者有机会让代码依赖于这些内部。
- en: Multiple instances of data are supported. You can call the function that creates
    the Handle multiple times to obtain multiple contexts, and then you can work with
    these contexts independently from one another.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多个数据实例。你可以多次调用创建处理的函数以获取多个上下文，然后你可以独立地使用这些上下文进行工作。
- en: If your functions that operate on the Handle are changed at a later point in
    time and have to share different or additional data, the members of the `struct`
    can simply be changed without requiring any changes to the caller’s code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果稍后更改对处理操作的函数，并且必须共享不同或额外的数据，那么可以简单地更改`struct`的成员，而无需更改调用者的代码。
- en: The declarations of your functions explicitly show that they are tightly coupled,
    because they all require the Handle. This makes it, on one hand, easy to see which
    functions should go into the same Header File, and on the other hand, makes it
    very easy for the caller to spot which functions should be applied together.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数声明明确显示它们紧密耦合，因为它们都需要处理。这一方面可以很容易地看出哪些函数应该放在同一个头文件中，另一方面，也让调用者非常容易地发现哪些函数应该一起应用。
- en: With the Handle, you now require the caller to provide one additional parameter
    to all function calls, and each additional parameter makes the code harder to
    read.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过 Handle，你需要调用方为所有函数调用提供一个额外的参数，而每个额外的参数会使代码变得更难阅读。
- en: Known Uses
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知的用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了该模式的应用：
- en: The C standard library contains the definition of `FILE` in *stdio.h*. This
    `FILE` is defined in most implementations as a pointer to a `struct`, and the
    `struct` is not part of the header file. The `FILE` handle is created by the function
    `fopen`, and several other functions can then be called for an opened file (`fwrite`,
    `fread`, etc.).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 标准库在 *stdio.h* 中包含了 `FILE` 的定义。这个 `FILE` 在大多数实现中被定义为指向一个 `struct` 的指针，而这个
    `struct` 不是头文件的一部分。`FILE` 句柄由函数 `fopen` 创建，并且打开的文件可以调用多个其他函数（`fwrite`、`fread`
    等）。
- en: The `struct` `AES_KEY` in the OpenSSL code is used to exchange the context between
    several functions related to AES encryption (`AES_set_decrypt_key`, `AES_​set_​encrypt_​key`).
    The `struct` and its members are not hidden in the implementation, but instead
    they are part of the header file because some parts of other OpenSSL code need
    to know the size of the `struct`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL 代码中的 `struct AES_KEY` 用于在几个与 AES 加密相关的函数之间交换上下文（`AES_set_decrypt_key`、`AES_set_encrypt_key`）。这个
    `struct` 及其成员并没有在实现中隐藏，而是作为头文件的一部分，因为 OpenSSL 的其他部分需要知道这个 `struct` 的大小。
- en: The code for the logging functionality of the Subversion project operates on
    a Handle. The `struct` `logger_t` is defined in the implementation file of the
    logging functionality, and a pointer to this `struct` is defined in the corresponding
    header file.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion 项目的日志功能代码操作的是一个 Handle。`logger_t` 结构在日志功能的实现文件中定义，而该结构的指针则在相应的头文件中定义。
- en: This pattern is described in *C Interfaces and Implementations* by David R.
    Hanson (Addison-Wesley, 1996) as Opaque Pointer Type and in *Patterns in C* by
    Adam Tornhill (Leanpub, 2014) as “First Class Abstract Data Type Pattern.”
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式在 David R. Hanson 的《C 接口与实现》（Addison-Wesley, 1996）中被描述为不透明指针类型，在 Adam Tornhill
    的《C 中的模式》（Leanpub, 2014）中被描述为“第一类抽象数据类型模式”。
- en: Applied to Running Example
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于正在运行的示例
- en: 'You can now support as many Ethernet interface cards as you want. Each created
    instance of your driver produces its own data-context that is then passed to the
    functions via the Handle. Now you have the following code for your device driver
    API:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以支持任意数量的以太网接口卡。每个创建的驱动程序实例都会产生自己的数据上下文，然后通过 Handle 传递给函数。现在，你的设备驱动程序 API
    如下所示：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Your requirements have changed again. Now you have to support multiple different
    Ethernet network interface cards, for example, from different vendors. The cards
    provide similar functionality, but they differ in the details of how the registers
    have to be accessed, and thus different implementations for the drivers are needed.
    Two straightforward options to support this would be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你的需求再次发生了变化。现在你需要支持多个不同供应商的以太网网络接口卡，例如来自不同供应商的卡。这些卡提供类似的功能，但在访问寄存器的细节上有所不同，因此需要针对驱动程序进行不同的实现。支持这一点的两个直接选项如下：
- en: You have two separate driver APIs. This approach has the drawback that it is
    cumbersome for the users to build mechanisms for selecting the driver at runtime.
    Also, having two separate APIs duplicates code because the two device drivers
    at minimum share a common control flow (for example, for creating or destroying
    the driver).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有两个单独的驱动程序 API。这种方法的缺点在于，用户在运行时构建选择驱动程序的机制会很麻烦。此外，拥有两个单独的 API 会导致代码重复，因为至少两个设备驱动程序共享一个通用控制流程（例如，用于创建或销毁驱动程序）。
- en: You add functions like `sendByteDriverA` and `sendByteDriverB` to your API.
    However, you usually want your API to be rather minimal because having all driver
    functions in a single API can be confusing for the API user. Also, the user’s
    code depends on all function signatures included via your API, and if code depends
    on something, that something should be rather minimal (as stated by the interface
    segregation principle).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在 API 中添加了像 `sendByteDriverA` 和 `sendByteDriverB` 这样的函数。然而，通常你希望你的 API 尽可能精简，因为在单个
    API 中拥有所有驱动函数可能会让 API 用户感到困惑。此外，用户的代码依赖于通过你的 API 包含的所有函数签名，如果代码依赖于某些东西，那么这些东西应该尽可能精简（正如接口隔离原则所述）。
- en: A better idea to support different Ethernet network interface cards is to provide
    a Dynamic Interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 支持不同以太网网络接口卡的更好方法是提供一个动态接口。
- en: Dynamic Interface
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态接口
- en: Context
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You or your caller want to implement multiple functionalities that follow a
    similar control logic, but that deviate in their behavior.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你或你的调用者希望实现多个遵循相似控制逻辑但在行为上有所不同的功能。
- en: Problem
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**It should be possible to call implementations with slightly deviating behaviors,
    but it should not be necessary to duplicate any code, not even the control logic
    implementation and interface declaration.**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**应该可以调用具有略有不同行为的实现，但不应该需要复制任何代码，甚至不是控制逻辑实现和接口声明。**'
- en: You want to be able to add additional implementation behaviors to the declared
    interface later on, without requiring callers who use the existing implementation
    behaviors to change anything in their code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能够在以后为已声明的接口添加额外的实现行为，而无需要求使用现有实现行为的调用者更改其代码。
- en: Maybe you do not only want to provide differing behaviors to your caller without
    duplicating your own code, but you also want to provide the callers a mechanism
    to bring in their own implementation behaviors.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你不仅希望为调用者提供不同的行为而不复制自己的代码，还希望为调用者提供一种机制来引入他们自己的实现行为。
- en: Solution
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Define a common interface for the deviating functionalities in your API and
    require the caller to provide a callback function for that functionality, which
    you then call in your function implementation.**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**在你的API中为不同的功能定义一个共同的接口，并要求调用者为该功能提供一个回调函数，然后在你的函数实现中调用它。**'
- en: 'To implement such an interface in C, define function signatures in your API.
    The caller then implements functions according to these signatures and attaches
    them via function pointers. They can either be attached and stored permanently
    inside your software-module or they can be attached with each function call as
    shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C中实现这样的接口，需要在你的API中定义函数签名。然后调用者根据这些签名实现函数，并通过函数指针将它们附加。它们可以被永久附加和存储在你的软件模块内，或者可以在每次函数调用时附加，如下面的代码所示：
- en: '*API*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*API*'
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Implementation*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现*'
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Caller*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用者*'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure to clearly document, next to the definition of the function signature,
    what behavior the function implementations should have. Also, document the behavior
    in case no such function implementation is attached to your function call. Maybe
    then you’d abort the program (Samurai Principle) or maybe you’d provide some default
    functionalty as fallback.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要清楚地记录函数签名的定义旁边，函数实现应该具有什么行为。还要记录如果没有附加这样的函数实现到你的函数调用中会发生什么行为。也许你会中止程序（武士原则），或者你会提供一些默认功能作为后备。
- en: Consequences
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The caller can use different implementations and there is still no code duplication.
    Neither the control logic, the interface, nor the interface documentation is duplicated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以使用不同的实现，而且仍然没有代码重复。控制逻辑、接口和接口文档都没有重复。
- en: Implementations can be added by the caller at a later point in time without
    changing the API. This means that the role of the API designer and the implementation
    provider can be completely separated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以在以后由调用者添加而无需更改API。这意味着API设计者和实现提供者的角色可以完全分开。
- en: In your code, you now execute the caller’s code. Thus, you must trust that the
    caller knows what the function has to do. In case of bugs in your caller’s code,
    it might still happen that your code will initially be suspected because, after
    all, the faulty behavior occurs in the context of your code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中，你现在执行调用者的代码。因此，你必须相信调用者知道函数该做什么。如果调用者的代码中存在错误，你的代码可能会被怀疑，毕竟错误行为发生在你的代码上下文中。
- en: Using function pointers implies that you have a platform-specific and programming-language-specific
    interface. You can use this pattern only if the caller’s code is also written
    in C. You cannot add marshaling functionality to this interface and provide it
    to a caller who is, for example, writing applications with Java code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数指针意味着你有一个特定于平台和编程语言的接口。只有当调用者的代码也是用C编写时，才能使用这种模式。你不能向使用Java代码编写应用程序的调用者添加编组功能并提供给他们这个接口。
- en: Known Uses
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: The following examples show applications of this pattern
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这种模式的应用场景
- en: James Grenning describes this pattern and a variant as Dynamic Interface and
    Per-Type Dynamic Interface in the article [“SOLID Design for Embedded C”](https://oreil.ly/kGZVG).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 詹姆斯·格伦宁在文章[“嵌入式C的SOLID设计”](https://oreil.ly/kGZVG)中描述了这种模式及其变体，称为动态接口和每种类型的动态接口。
- en: The presented solution is a C-version of the Strategy design pattern. You can
    find alternative C implementations of that pattern in the books *Patterns in C*
    by Adam Tornhill (Leanpub, 2014) and *C Interfaces and Implementations* by David
    R. Hanson (Addison-Wesley, 1996).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的解决方案是策略设计模式的 C 版本。您可以在 Adam Tornhill 的书籍 *Patterns in C*（Leanpub, 2014）和
    David R. Hanson 的书籍 *C Interfaces and Implementations*（Addison-Wesley, 1996）中找到该模式的替代
    C 实现。
- en: Device driver frameworks often use function pointers where the driver inserts
    its function at startup. The device drivers in the Linux kernel usually work that
    way.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备驱动框架通常使用函数指针，在驱动程序启动时驱动程序将其函数插入其中。Linux 内核中的设备驱动程序通常工作方式如此。
- en: The function `svn_sort__hash` of the source code of the Subversion project sorts
    a list according to some key value. The function takes the function pointer `comparison_func`
    as a parameter. The `comparison_func` has to return information, namely, which
    of two provided key values is greater than the other.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion 项目源代码中的函数 `svn_sort__hash` 根据某些键值对列表进行排序。该函数以函数指针 `comparison_func`
    作为参数。`comparison_func` 必须返回信息，即两个提供的键值中哪个大于另一个。
- en: The OpenSSL function `OPENSSL_LH_new` creates a hash table. The caller has to
    provide a function pointer to a hash function that is used as a callback when
    operating on the hash table.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL 函数 `OPENSSL_LH_new` 创建哈希表。调用者必须提供一个指向哈希函数的函数指针，用作在哈希表上操作时的回调。
- en: The Wireshark code contains the function pointer `proto_tree_foreach_func` that
    is provided as a function parameter when traversing tree structures. The function
    pointer is used to decide which actions to perform on the tree elements.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark 代码包含函数指针 `proto_tree_foreach_func`，在遍历树结构时作为函数参数提供。该函数指针用于决定在树元素上执行哪些操作。
- en: Applied to Running Example
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: Your driver API now supports multiple different Ethernet network interface cards.
    The specific drivers for these network interface cards have to implement the send
    and receive functions and provide them in a separate header file. The API user
    can then include and attach these specific send and receive functions to the API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您的驱动程序 API 现在支持多个不同的以太网网络接口卡。这些网络接口卡的具体驱动程序必须实现发送和接收功能，并在单独的头文件中提供它们。API 用户可以将这些特定的发送和接收功能包含并附加到
    API 中。
- en: 'You have the benefit that users of your API can bring in their own driver implementation.
    Thus, you as the API designer are independent from the provider of the driver
    implementation. Integrating new drivers does not require any API changes, which
    means it does not require any work from you as the API designer. All that is possible
    with the following API:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 API 的用户可以带入他们自己的驱动程序实现，这是一个优点。因此，作为 API 设计者，您独立于驱动程序实现的提供者。集成新驱动程序不需要任何 API
    更改，这意味着您作为 API 设计者不需要做任何工作。这一切都可以通过以下 API 实现：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, the requirements changed. Now you don’t just have to support Ethernet
    network interface cards, but also other interface cards (like USB interface cards).
    From the view of the API, these interfaces have some similar functionalities (the
    send and receive data functions), but they also have some completely different
    functionalities (for example, a USB interface has no IP address to set, but might
    require other configurations).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，需求发生了变化。现在不仅要支持以太网网络接口卡，还要支持其他接口卡（如 USB 接口卡）。从 API 的角度来看，这些接口具有一些相似的功能（发送和接收数据函数），但也有一些完全不同的功能（例如，USB
    接口没有 IP 地址需要设置，但可能需要其他配置）。
- en: A straightforward solution for this would be to provide two different APIs for
    the different driver types. But this would duplicate code for the send/receive
    and create/destroy functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的一个简单解决方案是为不同的驱动程序类型提供两个不同的 API。但这将复制发送/接收和创建/销毁功能的代码。
- en: A better solution to support different kinds of device drivers in a single abstract
    API is to introduce Function Control.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个抽象的单一 API 中支持不同类型的设备驱动的更好解决方案是引入功能控制。
- en: Function Control
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能控制
- en: Context
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: You want to implement multiple functionalities that follow a similar control
    logic, but that deviate in their behavior.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望实现多个功能，这些功能遵循类似的控制逻辑，但在行为上有所不同。
- en: Problem
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '**You want to call implementations with slightly deviating behaviors, but you
    don’t want to duplicate any code, not even the control logic implementation or
    the interface declaration.**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**您希望调用具有稍有不同行为的实现，但您不希望复制任何代码，甚至不是控制逻辑实现或接口声明。**'
- en: The caller should be able to use specific existing behaviors that you implemented.
    It should even be possible for you to add new behaviors later on without touching
    the existing implementations and without requiring changes to the existing caller’s
    code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者应该能够使用您实现的特定现有行为。甚至可以在以后添加新行为而无需触及现有实现或需要修改现有调用者代码。
- en: Having a Dynamic Interface is not an option for you because you do not want
    to offer the callers the flexibility of attaching their own implementation. That
    might be because the interface should be easier to use for the caller. Or it might
    be because you cannot easily attach the implementations of your caller, which
    is the case if your caller, for example, uses another programming language to
    access your functionality.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您而言，拥有动态接口并不是一个选项，因为您不希望为调用者提供附加其自己实现的灵活性。这可能是因为接口应更易于调用者使用。或者这可能是因为您不能轻松地附加调用者的实现，例如，如果您的调用者使用另一种编程语言访问您的功能。
- en: Solution
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Add a parameter to your function that passes meta-information about the function
    call and that specifies the actual functionality to be performed.**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**向您的函数添加一个参数，该参数传递有关函数调用的元信息，并指定要执行的实际功能。**'
- en: Compared to a Dynamic Interface, you do not require the caller to provide the
    implementation, but instead the caller selects from existing implementations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态接口相比，您不需要调用者提供实现，而是调用者从现有实现中进行选择。
- en: 'To implement this pattern, you apply data-based abstraction by adding an additional
    parameter (for example, an `enum` or `#define` integer value) that specifies the
    function’s behavior. The parameter is then evaluated in the implementation, and
    depending on the value of the parameter, different implementations are called:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此模式，您通过添加额外的参数（例如，一个`enum`或`#define`整数值）来应用基于数据的抽象，该参数指定函数的行为。然后在实现中对参数进行评估，并根据参数值调用不同的实现。
- en: '*API*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*API*'
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Implementation*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现*'
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_flexible_apis_CO1-1)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_flexible_apis_CO1-1)'
- en: When adding new functionality at a later point in time, you can simply add a
    new `enum` or `#define` value and select the corresponding new implementation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后添加新功能时，您只需添加一个新的`enum`或`#define`值，并选择相应的新实现即可。
- en: Consequences
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The caller can use different implementations and there is still no code duplication.
    Neither the control logic, the interface, nor the interface documentation is duplicated.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以使用不同的实现方式，并且没有代码重复。控制逻辑、接口或接口文档都不会重复。
- en: It is easy to add new functionality at a later time. Existing implementations
    do not have to be touched to do that, and the existing caller’s code is not affected
    by the change.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易在以后添加新功能。无需触及现有实现，现有调用者的代码也不会受到更改的影响。
- en: Compared to Dynamic Interface, this pattern is easier for selecting functionalities
    across different programs or platforms (for example, remote procedure calls) because
    no program-specific pointers are passed via the API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态接口相比，此模式更易于在不同程序或平台（例如远程过程调用）之间选择功能，因为API未通过程序特定的指针传递。
- en: When providing the selection of different implementation behaviors in one function,
    you might be tempted to pack multiple functionalities that do not closely belong
    together into a single function. This violates the single-responsibility principle.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数中提供不同实现行为的选择时，您可能会被诱惑将不太相关的多个功能打包到单个函数中。这违反了单一责任原则。
- en: Known Uses
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知用途
- en: 'The following examples show applications of this pattern:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了此模式的应用：
- en: 'Device drivers often use Function Control to pass specific functionalities
    that do not fit into common init/read/write functions. For device drivers this
    pattern is commonly known as I/O-Control. That concept is described in the book
    *Making Embedded Systems: Design Patterns for Great Software* by Elecia White
    (O’Reilly, 2011).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '设备驱动程序通常使用功能控制来传递不适合于常见初始化/读写功能的特定功能。对于设备驱动程序，这种模式通常称为I/O-Control。该概念在Elecia
    White的书《Making Embedded Systems: Design Patterns for Great Software》（O’Reilly,
    2011）中有所描述。'
- en: Some Linux syscalls were extended to have flags that extend the syscalls’ functionality
    depending on the value of the flag without breaking old code.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些Linux系统调用已扩展以具有标志，这些标志根据标志的值扩展系统调用的功能，而不会破坏旧代码。
- en: The concept of data-driven APIs in general is described in the book *API Design
    for *C++** by Martin Reddy (Morgan Kaufmann, 2011).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin Reddy（Morgan Kaufmann，2011）在书籍《API Design for *C++** 中描述了通用数据驱动 API 的概念。
- en: The OpenSSL code uses the function `CTerr` to log errors. This function takes
    an `enum` parameter to specify how and where the error should be logged.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL 代码使用函数 `CTerr` 记录错误。此函数接受一个 `enum` 参数，用于指定错误应如何以及在哪里记录。
- en: The POSIX socket function `ioctl` takes a numeric parameter `cmd` that determines
    which actual action will be performed on a socket. The allowed values for the
    parameter are defined and documented in a header file, and since the first release
    of that header file, many additional values and thus function behaviors were added.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 套接字函数 `ioctl` 接受一个数值参数 `cmd`，该参数决定套接字上将执行哪些实际操作。参数的允许值在头文件中定义和记录，自头文件首次发布以来，已添加了许多额外的值和函数行为。
- en: The function `svn_fs_ioctl` of the Subversion project performs some filesystem-specific
    input or output operations. The function takes the `struct` `svn_fs_ioctl_code_t`
    as a parameter. This `struct` contains a numeric value that determines which kind
    of operation should be performed.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion 项目的函数 `svn_fs_ioctl` 执行一些特定于文件系统的输入或输出操作。该函数将 `struct svn_fs_ioctl_code_t`
    作为参数。此 `struct` 包含一个数值，该数值决定应执行哪种类型的操作。
- en: Applied to Running Example
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于运行示例
- en: 'The following code shows the final version of your device driver API:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了您的设备驱动程序 API 的最终版本：
- en: '*Driver.h*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*Driver.h*'
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*EthIOCTL.h*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*EthIOCTL.h*'
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*UsbIOCTL.h*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*UsbIOCTL.h*'
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Users who want to use the Ethernet- or USB-specific functions (for example,
    the application actually sending or receiving data via the interface) have to
    know which driver type they operate on in order to call the right I/O-control
    and also have to include the *EthIOCTL.h* or *UsbIOCTL.h* files.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使用以太网或 USB 特定功能（例如，实际通过接口发送或接收数据的应用程序）的用户必须知道他们操作的驱动程序类型，以便调用正确的 I/O 控制，还必须包含
    *EthIOCTL.h* 或 *UsbIOCTL.h* 文件。
- en: '[Figure 6-2](#fig_func_ctl) shows the include-relationships of the source code
    files of this final version of our device driver API. Note that the *EthApplication.c*
    code does not depend on USB-specific header files. If, for example, an additional
    USB-IOCTL is added, the *EthApplication.c* shown in the code does not even need
    to be recompiled, because none of the files it depends on are changed.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-2](#fig_func_ctl) 显示了我们设备驱动程序 API 最终版本的源代码文件的包含关系。请注意，*EthApplication.c*
    代码不依赖于 USB 特定的头文件。例如，如果添加了额外的 USB-IOCTL，所示代码中的 *EthApplication.c* 甚至不需要重新编译，因为它所依赖的文件都未更改。'
- en: '![sketches/function-control.png](assets/fluc_0602.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![sketches/function-control.png](assets/fluc_0602.png)'
- en: Figure 6-2\. File relationships for function control
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 函数控制的文件关系
- en: Keep in mind that of all the code snippets presented in this chapter, this last,
    most flexible code snippet of the device drivers might not always be what you
    are looking for. You buy increased flexibility with complexity of your interface,
    and while you have to make your code as flexible as needed, you should also always
    try to keep it as simple as possible.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在本章中呈现的所有代码片段中，这些设备驱动程序的最后、最灵活的代码片段可能并非始终适合您的需求。您通过增加接口的复杂性来获得更大的灵活性，尽管您必须使代码尽可能灵活，但也应尽量保持简单。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter discussed four API patterns for C and showed their application
    in a running example of how to design a device driver. Header Files tells you
    the basic concept of hiding implementation details in c-files while providing
    a well-defined interface in your h-files. The pattern Handle is about the well-known
    concept of passing opaque data types between functions to share state information.
    Dynamic Interface makes it possible to not duplicate program logic by allowing
    the injection of caller-specific code via a callback function. Function Control
    uses an additional function parameter that specifies the actual action that should
    be performed by the function call. These patterns showed basic C design options
    to make an interface more flexible by introducing abstractions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 C 语言的四种 API 模式，并展示了它们在设备驱动程序设计中的应用示例。头文件告诉您在 c 文件中隐藏实现细节的基本概念，同时在您的 h
    文件中提供了一个明确定义的接口。Handle 模式涉及将不透明数据类型在函数之间传递以共享状态信息的广为人知的概念。动态接口通过允许通过回调函数注入调用特定代码来避免重复程序逻辑成为可能。函数控制使用额外的函数参数来指定函数调用中应执行的实际操作。这些模式展示了通过引入抽象使接口更灵活的基本
    C 设计选项。
- en: Further Reading
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you’re ready for more, here are some resources that can help you further
    your knowledge of designing APIs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您准备进一步学习，以下是一些资源，可以帮助您进一步了解设计API的知识。
- en: The article [“SOLID Design for Embedded C”](https://oreil.ly/07SUX) by James
    Grenning covers the five SOLID design principles in general and presents ways
    to implement flexibility for C interfaces. What makes this article unique is that
    it is the only article that covers the topic of interfaces specifically for C
    and also includes detailed code snippets.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章 [“SOLID Design for Embedded C”](https://oreil.ly/07SUX)，作者James Grenning，介绍了五个SOLID设计原则的一般概念，并展示了如何为C接口实现灵活性。这篇文章的独特之处在于它是唯一一篇专门讨论C接口主题的文章，同时还包含了详细的代码片段。
- en: The book *Patterns in C* by Adam Tornhill (Leanpub, 2014) presents several patterns
    that include C code snippets. The patterns include C versions of Gang of Four
    patterns like Strategy or Observer as well as C-specific patterns and idioms.
    The book does not explicitly focus on interfaces, but some of the patterns describe
    interactions on an interface level.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍 *Patterns in C*，作者Adam Tornhill（Leanpub，2014），介绍了几种包含C代码片段的设计模式。这些模式包括Gang
    of Four模式（如策略或观察者）的C版本，以及特定于C的模式和习惯用法。该书并未专门关注接口，但部分模式描述了接口层面的交互。
- en: The book *API Design for *C++** by Martin Reddy (Morgan Kaufmann, 2011) covers
    design principles for interfaces, object-oriented interface patterns with C++
    examples, and interface quality issues with interfaces like testing and documentation.
    The book addresses C++ design, but some parts of the book are also relevant for
    C.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍 *API Design for *C++**，作者Martin Reddy（Morgan Kaufmann，2011），涵盖了接口设计原则，带有C++示例的面向对象接口模式，以及像测试和文档等接口质量问题。该书主要讨论了C++设计，但部分内容也适用于C。
- en: The book *C Interfaces and Implementations* by David R. Hanson (Addison-Wesley,
    1996) presents interface design, including C code for specific components implemented
    in C.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍 *C Interfaces and Implementations*，作者David R. Hanson（Addison-Wesley，1996），介绍了接口设计，包括在C中实现特定组件的C代码。
- en: Outlook
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望
- en: 'The next chapter goes into detail on how to find the right level of abstraction
    and the right interface for one very specific kind of application: it describes
    how to design and implement iterators.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章详细介绍了如何找到特定类型应用程序的正确抽象级别和正确接口：它描述了如何设计和实现迭代器。
