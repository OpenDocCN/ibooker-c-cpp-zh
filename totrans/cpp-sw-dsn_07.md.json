["```cpp\n//---- <ElectricEngine.h> ---------------- \nclass ElectricEngine\n{\n public:\n   void start();\n   void stop();\n\n private:\n   // ... };\n\n//---- <ElectricCar.h> ---------------- \n#include <ElectricEngine.h>\n// ... \nclass ElectricCar\n{\n public:\n   ElectricCar( /*maybe some engine arguments*/ );\n\n   void drive();\n   // ...\n private:\n   ElectricEngine engine_;  ![1](assets/1.png)\n\n   // ... more car-specific data members (wheels, drivetrain, ...) };\n\n//---- <ElectricCar.cpp> ---------------- \n#include <ElectricCar.h>\n\nElectricCar::ElectricCar( /*maybe some engine arguments*/ )\n   : engine_{ /*engine arguments*/ }\n   // ... Initialization of the other data members {}\n\n// ... \n```", "```cpp\n//---- <ElectricCar.h> ---------------- \n#include <memory>\n// ... struct ElectricEngine;  // Forward declaration \nclass ElectricCar\n{\n public:\n   ElectricCar( /*maybe some engine arguments*/ );\n\n   void drive();\n   // ...\n private:\n   std::unique_ptr<ElectricEngine> engine_;  ![2](assets/2.png)\n\n   // ... more car-specific data members (wheels, drivetrain, ...) };\n\n//---- <ElectricCar.cpp> ---------------- \n#include <ElectricCar.h>\n#include <ElectricEngine.h>  ![3](assets/3.png)\n\nElectricCar::ElectricCar( /*maybe some engine arguments*/ )\n   : engine_{ std::make_unique<ElectricEngine>( /*engine arguments*/ ) }\n   // ... Initialization of the other data members {}\n\n// ... Other 'ElectricCar' member functions, using the pointer to an //     'ElectricEngine'. \n```", "```cpp\n//---- <Engine.h> ---------------- \nclass Engine  ![4](assets/4.png)\n{\n public:\n   virtual ~Engine() = default;\n   virtual void start() = 0;\n   virtual void stop() = 0;\n   // ... more engine-specific functions \n private:\n   // ... };\n\n//---- <ElectricCar.h> ---------------- \n#include <Engine.h>\n#include <memory>\n\nclass ElectricCar\n{\n public:\n   void drive();\n   // ...\n private:\n   std::unique_ptr<Engine> engine_;  ![5](assets/5.png)\n\n   // ... more car-specific data members (wheels, drivetrain, ...) };\n\n//---- <ElectricEngine.h> ---------------- \n#include <Engine.h>\n\nclass ElectricEngine : public Engine\n{\n public:\n   void start() override;\n   void stop() override;\n\n private:\n   // ... };\n\n//---- <ElectricCar.cpp> ---------------- \n#include <ElectricCar.h>\n#include <ElectricEngine.h>\n\nElectricCar::ElectricCar( /*maybe some engine arguments*/ )\n   : engine_{ std::make_unique<ElectricEngine>( /*engine arguments*/ ) }  ![6](assets/6.png)\n   // ... Initialization of the other data members {}\n\n// ... Other 'ElectricCar' member functions, primarily using the 'Engine' //     abstraction, but potentially also explicitly dealing with an //     'ElectricEngine'. \n```", "```cpp\n//---- <Car.h> ---------------- \n#include <Engine.h>\n#include <memory>\n#include <utility>\n\nclass Car\n{\n protected:\n   explicit Car( std::unique_ptr<Engine> engine )  ![7](assets/7.png)\n      : pimpl_( std::move(engine) )\n   {}\n\n public:\n   virtual ~Car() = default;\n   virtual void drive() = 0;\n   // ... more car-specific functions \n protected:\n   Engine*       getEngine()       { return pimpl_.get(); }  ![9](assets/9.png)\n   Engine const* getEngine() const { return pimpl_.get(); }\n\n private:\n   std::unique_ptr<Engine> pimpl_;  // Pointer-to-implementation (pimpl) ![8](assets/8.png)\n\n   // ... more car-specific data members (wheels, drivetrain, ...) };\n\n```", "```cpp\n//---- <ElectricCar.h> ---------------- \n#include <Engine.h>\n#include <memory>\n\nclass ElectricCar : public Car  ![10](assets/10.png)\n{\n public:\n   explicit ElectricCar( /*maybe some engine arguments*/ );\n\n   void drive() override;\n   // ... };\n\n//---- <ElectricCar.cpp> ---------------- \n#include <ElectricCar.h>\n#include <ElectricEngine.h>\n\nElectricCar::ElectricCar( /*maybe some engine arguments*/ )\n   : Car( std::make_unique<ElectricEngine>( /*engine arguments*/ ) )  ![11](assets/11.png)\n{}\n\n// ... \n```", "```cpp\nclass Person\n{\n public:\n   // ...\n   int year_of_birth() const;\n   // ... Many more access functions\n\n private:\n   std::string forename_;\n   std::string surname_;\n   std::string address_;\n   std::string city_;\n   std::string country_;\n   std::string zip_;\n   int year_of_birth_;\n   // ... Potentially many more data members\n};\n```", "```cpp\n//---- <Person.h> ---------------- \n#include <memory>\n\nclass Person\n{\n public:\n   // ... \n private:\n   struct Impl;  ![12](assets/12.png)\n   std::unique_ptr<Impl> const pimpl_;  ![13](assets/13.png)\n};\n\n//---- <Person.cpp> ---------------- \n#include <Person.h>\n#include <string>\n\nstruct Person::Impl  ![14](assets/14.png)\n{\n   std::string forename;\n   std::string surname;\n   std::string address;\n   std::string city;\n   std::string country;\n   std::string zip;\n   int year_of_birth;\n   // ... Potentially many more data members };\n\n```", "```cpp\n//---- <Person.h> ---------------- \n//#include <memory> \nclass Person\n{\n public:\n   // ...\n   Person();   ![15](assets/15.png)\n   ~Person();  ![16](assets/16.png)\n\n   Person( Person const& other );  ![17](assets/17.png)\n   Person& operator=( Person const& other );  ![18](assets/18.png)\n\n   Person( Person&& other );  ![19](assets/19.png)\n   Person& operator=( Person&& other );  ![20](assets/20.png)\n\n   int year_of_birth() const;  ![21](assets/21.png)\n   // ... Many more access functions \n private:\n   struct Impl;\n   std::unique_ptr<Impl> const pimpl_;\n};\n\n//---- <Person.cpp> ---------------- \n//#include <Person.h> //#include <string> \nstruct Person::Impl\n{\n   // ... };\n\nPerson::Person()  ![15](assets/15.png)\n   : pimpl_{ std::make_unique<Impl>() }\n{}\n\nPerson::~Person() = default;  ![16](assets/16.png)\n\nPerson::Person( Person const& other )  ![17](assets/17.png)\n   : pimpl_{ std::make_unique<Impl>(*other.pimpl_) }\n{}\n\nPerson& Person::operator=( Person const& other )  ![18](assets/18.png)\n{\n   *pimpl_ = *other.pimpl_;\n   return *this;\n}\n\nPerson::Person( Person&& other )  ![19](assets/19.png)\n   : pimpl_{ std::make_unique<Impl>(std::move(*other.pimpl_)) }\n{}\n\nPerson& Person::operator=( Person&& other )  ![20](assets/20.png)\n{\n   *pimpl_ = std::move(*other.pimpl_);\n   return *this;\n}\n\nint Person::year_of_birth() const  ![21](assets/21.png)\n{\n   return pimpl_->year_of_birth;\n}\n\n// ... Many more Person member functions \n```", "```cpp\nclass DatabaseEngine\n{\n public:\n   virtual ~DatabaseEngine() = default;\n   // ... Many database-specific functions };\n\nclass Database\n{\n public:\n   explicit Database( std::unique_ptr<DatabaseEngine> engine );\n   // ... Many database-specific functions \n private:\n   std::unique_ptr<DatabaseEngine> engine_;\n};\n\n// The database is unaware of any implementation details and requests them //   via its constructor from outside -> Strategy design pattern Database::Database( std::unique_ptr<DatabaseEngine> engine )  ![22](assets/22.png)\n   : engine_{ std::move(engine) }\n{}\n\n```", "```cpp\nclass Database\n{\n public:\n   explicit Database();\n   // ...\n private:\n   std::unique_ptr<DatabaseEngine> pimpl_;\n};\n\n// The database knows about the required implementation details, but does //   not want to depend too strongly on it -> Bridge design pattern Database::Database()\n   : pimpl_{ std::make_unique<ConcreteDatabaseEngine>( /*some arguments*/ ) }  ![23](assets/23.png)\n{}\n\n```", "```cpp\n#include <string>\n\n//---- <Person1.h> ----------------\n\nclass Person1\n{\n public:\n   // ...\n private\n   std::string forename_;\n   std::string surname_;\n   std::string address_;\n   std::string city_;\n   std::string country_;\n   std::string zip_;\n   int year_of_birth_;\n};\n```", "```cpp\n//---- <Person2.h> ----------------\n\n#include <memory>\n\nclass Person2\n{\n public:\n   explicit Person2( /*...various person arguments...*/ );\n   ~Person2();\n   // ...\n\n private:\n   struct Impl;\n   std::unique_ptr<Impl> pimpl_;\n};\n\n//---- <Person2.cpp> ----------------\n\n#include <Person2.h>\n#include <string>\n\nstruct Person2::Impl\n{\n   std::string forename;\n   std::string surname;\n   std::string address;\n   std::string city;\n   std::string country;\n   std::string zip;\n   int year_of_birth;\n};\n\nPerson2::Person2( /*...various person arguments...*/ )\n   : pimpl{ std::make_unique<Impl>( /*...various person arguments...*/ ) }\n{}\n\nPerson2::~Person2() = default;\n```", "```cpp\n//---- <Person3.h> ----------------\n\n#include <memory>\n#include <string>\n\nclass Person3\n{\n public:\n   explicit Person3( /*...various person arguments...*/ );\n   ~Person3();\n   // ...\n\n private:\n   std::string forename_;\n   std::string surname_;\n   int year_of_birth_;\n\n   struct Impl;\n   std::unique_ptr<Pimpl> pimpl_;\n};\n\n//---- <Person3.cpp> ----------------\n\n#include <Person3.h>\n\nstruct Person3::Impl\n{\n   std::string address;\n   std::string city;\n   std::string country;\n   std::string zip;\n};\n\nPerson3::Person3( /*...various person arguments...*/ )\n   : forename_{ /*...*/ }\n   , surname_{ /*...*/ }\n   , year_of_birth_{ /*...*/ }\n   , pimpl_{ std::make_unique<Impl>( /*...address-related arguments...*/ ) }\n{}\n\nPerson3::~Person3() = default;\n```", "```cpp\n//---- <Animal.h> ----------------\n\nclass Animal\n{\n public:\n   virtual ~Animal() = default;\n   virtual void makeSound() const = 0;\n   // ... more animal-specific functions\n};\n```", "```cpp\n//---- <Sheep.h> ----------------\n\n#include <Animal.h>\n#include <string>\n\nclass Sheep : public Animal\n{\n public:\n   explicit Sheep( std::string name ) : name_{ std::move(name) } {}\n\n   void makeSound() const override;\n   // ... more animal-specific functions\n\n private:\n   std::string name_;\n};\n\n//---- <Sheep.cpp> ----------------\n\n#include <Sheep.h>\n#include <iostream>\n\nvoid Sheep::makeSound() const\n{\n   std::cout << \"baa\\n\";\n}\n```", "```cpp\n#include <Sheep.h>\n#include <cstdlib>\n#include <memory>\n\nint main()\n{\n   // Creating the one and only Dolly\n   std::unique_ptr<Animal> const dolly = std::make_unique<Sheep>( \"Dolly\" );\n\n   // Triggers Dolly's beastly sound\n   dolly->makeSound();\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <Animal.h> ----------------\n\nclass Animal\n{\n public:\n   virtual ~Animal() = default;\n   virtual void makeSound() const = 0;\n   virtual std::unique_ptr<Animal> clone() const = 0; // Prototype design pattern\n};\n```", "```cpp\n//---- <Sheep.h> ----------------\n\n#include <Animal.h>\n\nclass Sheep : public Animal\n{\n public:\n   explicit Sheep( std::string name ) : name_{ std::move(name) } {}\n\n   void makeSound() const override;\n   std::unique_ptr<Animal> clone() const override;  // Prototype design pattern\n\n private:\n   std::string name_;\n};\n\n//---- <Sheep.cpp> ----------------\n\n#include <Sheep.h>\n#include <iostream>\n\nvoid Sheep::makeSound() const\n{\n   std::cout << \"baa\\n\";\n}\n\nstd::unique_ptr<Animal> Sheep::clone() const\n{\n   return std::make_unique<Sheep>(*this);  // Copy-construct a sheep\n}\n```", "```cpp\n#include <Sheep.h>\n#include <cstdlib>\n#include <memory>\n\nint main()\n{\n   std::unique_ptr<Animal> dolly = std::make_unique<Sheep>( \"Dolly\" );\n   std::unique_ptr<Animal> dollyClone = dolly->clone();\n\n   dolly->makeSound();       // Triggers the first Dolly's beastly sound\n   dollyClone->makeSound();  // The clone sounds just like Dolly\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n#include <cstdlib>\n#include <variant>\n\nclass Dog {};\nclass Cat {};\nclass Sheep {};\n\nint main()\n{\n   std::variant<Dog,Cat,Sheep> animal1{ /* ... */ };\n\n   auto animal2 = animal1;  // Creating a copy of the animal\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <Shape.h> ---------------- \nclass Shape\n{\n public:\n   virtual ~Shape() = default;\n\n   virtual void draw( /*some arguments*/ ) const = 0;  ![1](assets/1.png)\n};\n\n//---- <Circle.h> ---------------- \n#include <Shape.h>\n#include <memory>\n#include <functional>\n#include <utility>\n\nclass Circle : public Shape\n{\n public:\n   using DrawStrategy = std::function<void(Circle const&, /*...*/)>;  ![2](assets/2.png)\n\n   explicit Circle( double radius, DrawStrategy drawer )\n      : radius_( radius )\n      , drawer_( std::move(drawer) )\n   {\n      /* Checking that the given radius is valid and that\n         the given 'std::function' instance is not empty */\n   }\n\n   void draw( /*some arguments*/ ) const override  ![3](assets/3.png)\n   {\n      drawer_( *this, /*some arguments*/ );\n   }\n\n   double radius() const { return radius_; }\n\n private:\n   double radius_;\n   DrawStrategy drawer_;\n};\n\n```", "```cpp\n//---- <Circle.h> ----------------\n\nclass Circle\n{\n public:\n   explicit Circle( double radius )\n      : radius_( radius )\n   {\n      /* Checking that the given radius is valid */\n   }\n\n   double radius() const { return radius_; }\n   /* Several more getters and circle-specific utility functions */\n\n private:\n   double radius_;\n   /* Several more data members */\n};\n\n//---- <Square.h> ----------------\n\nclass Square\n{\n public:\n   explicit Square( double side )\n      : side_( side )\n   {\n      /* Checking that the given side length is valid */\n   }\n\n   double side() const { return side_; }\n   /* Several more getters and square-specific utility functions */\n\n private:\n   double side_;\n   /* Several more data members */\n};\n```", "```cpp\n//---- <Shape.h> ---------------- \n#include <functional>\n#include <stdexcept>\n#include <utility>\n\nclass ShapeConcept\n{\n public:\n   virtual ~ShapeConcept() = default;\n\n   virtual void draw() const = 0;  ![4](assets/4.png)\n\n   // ... Potentially more polymorphic operations };\n\ntemplate< typename ShapeT >\nclass ShapeModel : public ShapeConcept  ![5](assets/5.png)\n{\n public:\n   using DrawStrategy = std::function<void(ShapeT const&)>;  ![7](assets/7.png)\n\n   explicit ShapeModel( ShapeT shape, DrawStrategy drawer )\n      : shape_{ std::move(shape) }\n      , drawer_{ std::move(drawer) }\n   {\n      /* Checking that the given 'std::function' is not empty */\n   }\n\n   void draw() const override { drawer_(shape_); }  ![9](assets/9.png)\n\n   // ... Potentially more polymorphic operations \n private:\n   ShapeT shape_;  ![6](assets/6.png)\n   DrawStrategy drawer_;  ![8](assets/8.png)\n};\n\n```", "```cpp\ntemplate< typename ShapeT\n        , typename DrawStrategy >  ![10](assets/10.png)\nclass ShapeModel : public ShapeConcept\n{\n public:\n   explicit ShapeModel( ShapeT shape, DrawStrategy drawer )\n      : shape_{ std::move(shape) }\n      , drawer_{ std::move(drawer) }\n   {}\n\n   void draw() const override { drawer_(shape_); }\n\n private:\n   ShapeT shape_;\n   DrawStrategy drawer_;\n};\n\n```", "```cpp\nstruct DefaultDrawer\n{\n   template< typename T >\n   void operator()( T const& obj ) const {\n      draw(obj);\n   }\n};\n\ntemplate< typename ShapeT\n        , typename DrawStrategy = DefaultDrawer >\nclass ShapeModel : public ShapeConcept\n{\n public:\n   explicit ShapeModel( ShapeT shape, DrawStrategy drawer = DefaultDrawer{} )\n   // ... as before\n};\n```", "```cpp\n//---- <OpenGLDrawStrategy.h> ---------------- \n#include <Circle>\n#include <Square>\n#include /* OpenGL graphics library headers */\n\nclass OpenGLDrawStrategy\n{\n public:\n   explicit OpenGLDrawStrategy( /* Drawing related arguments */ );\n\n   void operator()( Circle const& circle ) const;  ![11](assets/11.png)\n   void operator()( Square const& square ) const;  ![12](assets/12.png)\n\n private:\n   /* Drawing related data members, e.g. colors, textures, ... */\n};\n\n```", "```cpp\n#include <Circle.h>\n#include <Square.h>\n#include <Shape.h>\n#include <OpenGLDrawStrategy.h>\n#include <memory>\n#include <vector>\n\nint main()\n{\n   using Shapes = std::vector<std::unique_ptr<ShapeConcept>>;  ![13](assets/13.png)\n\n   using CircleModel = ShapeModel<Circle,OpenGLDrawStrategy>;  ![14](assets/14.png)\n   using SquareModel = ShapeModel<Square,OpenGLDrawStrategy>;  ![15](assets/15.png)\n\n   Shapes shapes{};\n\n   // Creating some shapes, each one\n   //   equipped with an OpenGL drawing strategy\n   shapes.emplace_back(\n      std::make_unique<CircleModel>(\n         Circle{2.3}, OpenGLDrawStrategy(/*...red...*/) ) );\n   shapes.emplace_back(\n      std::make_unique<SquareModel>(\n         Square{1.2}, OpenGLDrawStrategy(/*...green...*/) ) );\n   shapes.emplace_back(\n      std::make_unique<CircleModel>(\n         Circle{4.1}, OpenGLDrawStrategy(/*...blue...*/) ) );\n\n   // Drawing all shapes\n   for( auto const& shape : shapes )\n   {\n      shape->draw();\n   }\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nint draw( int i )  ![16](assets/16.png)\n{\n   // ... drawing an int, for instance by printing it to the command line }\n\nint main()\n{\n   auto shape = std::make_unique<ShapeModel<int>>( 42 );  ![17](assets/17.png)\n\n   shape->draw();  // Drawing the integer ![18](assets/18.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nclass DocumentConcept\n{\n public:\n   // ...\n   virtual ~Document() = default;\n\n   virtual void exportToJSON( /*...*/ ) const = 0;\n   virtual void serialize( ByteStream& bs, /*...*/ ) const = 0;\n   // ...\n};\n\ntemplate< typename DocumentT >\nclass DocumentModel\n{\n public:\n   // ...\n   void exportToJSON( /*...*/ ) const override;\n   void serialize( ByteStream& bs, /*...*/ ) const override;\n   // ...\n\n private:\n   DocumentT document_;\n};\n```", "```cpp\nvoid exportDocument( DocumentConcept const& doc )\n{\n   // ...\n   doc.exportToJSON( /* pass necessary arguments */ );\n   // ...\n}\n```", "```cpp\nclass JSONExportable\n{\n public:\n   // ...\n   virtual ~JSONExportable() = default;\n\n   virtual void exportToJSON( /*...*/ ) const = 0;\n   // ...\n};\n\nclass Serializable\n{\n public:\n   // ...\n   virtual ~Serializable() = default;\n\n   virtual void serialize( ByteStream& bs, /*...*/ ) const = 0;\n   // ...\n};\n\ntemplate< typename DocumentT >\nclass DocumentModel\n   : public JSONExportable\n   , public Serializable\n{\n public:\n   // ...\n   void exportToJSON( /*...*/ ) const override;\n   void serialize( ByteStream& bs, /*...*/ ) const override;\n   // ...\n\n private:\n   DocumentT document_;\n};\n```", "```cpp\nvoid exportDocument( JSONExportable const& exportable )\n{\n   // ...\n   exportable.exportToJSON( /* pass necessary arguments */ );\n   // ...\n}\n```"]