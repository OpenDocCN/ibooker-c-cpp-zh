- en: Chapter 2\. The Art of Building Abstractions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。构建抽象的艺术
- en: Abstractions play a vital role in software design and software architecture.
    In other words, good abstractions are the key to managing complexity. Without
    them, good design and proper architecture are hard to imagine. Still, building
    good abstractions and using them well is surprisingly difficult. As it turns out,
    building and using abstractions comes with a lot of subtleties, and therefore
    feels more like an art than a science. This chapter goes into detail about the
    meaning of abstractions and the art of building them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象在软件设计和软件架构中发挥着至关重要的作用。换句话说，良好的抽象是管理复杂性的关键。没有它们，良好的设计和适当的架构是难以想象的。然而，构建良好的抽象并有效使用它们却是令人惊讶地困难。事实证明，构建和使用抽象带来了许多微妙之处，因此更像是一门艺术而非科学。本章详细探讨了抽象的含义和构建抽象的艺术。
- en: 'In [“Guideline 6: Adhere to the Expected Behavior of Abstractions”](#adhere_to_the_expected_behavior_of_abstractions),
    we will talk about the purpose of abstractions. We will also talk about the fact
    that abstractions represent a set of requirements and expectations and why it
    is so important to adhere to the expected behavior of abstractions. In that context
    I will introduce another design principle, the *Liskov Substitution Principle*
    (LSP).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 6：遵循抽象的预期行为”](#adhere_to_the_expected_behavior_of_abstractions)，我们将讨论抽象的目的。我们还将讨论抽象代表一组要求和期望的事实，以及为什么坚持抽象的预期行为如此重要。在这个背景下，我将介绍另一个设计原则，即“里氏替换原则”（LSP）。
- en: 'In [“Guideline 7: Understand the Similarities Between Base Classes and Concepts”](#understand_the_similarities_between_base_classes_and_concepts),
    we will compare the two most commonly used abstractions: base classes and concepts.
    You will understand that from a semantic point of view both approaches are very
    similar since both are able to express expected behavior.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 7：理解基类和概念之间的相似性”](#understand_the_similarities_between_base_classes_and_concepts)，我们将比较两种最常用的抽象：基类和概念。您将了解到，从语义角度来看，这两种方法都非常相似，因为它们都能表达预期的行为。
- en: 'In [“Guideline 8: Understand the Semantic Requirements of Overload Sets”](#understand_the_semantic_requirements_of_overload_sets),
    I will extend the discussion about semantic requirements and talk about a third
    kind of abstraction: function overloading. You will understand that all functions,
    being part of an overload set, also have an expected behavior and thus also have
    to adhere to the LSP.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 8：理解重载集的语义要求”](#understand_the_semantic_requirements_of_overload_sets)，我将扩展对语义要求的讨论，并讨论第三种类型的抽象：函数重载。您将了解到，所有函数作为重载集的一部分，也都有预期的行为，因此也必须遵守LSP。
- en: 'In [“Guideline 9: Pay Attention to the Ownership of Abstractions”](#pay_attention_to_the_ownership_of_abstractions),
    I will focus on the architectural meaning of abstractions. I will explain what
    an architecture is and what we expect from the high and low levels of an architecture.
    I will also show you that from an architectural point of view, it is not enough
    to *just* introduce an abstraction to resolve dependencies. To explain this, I
    will introduce the *Dependency Inversion Principle* (DIP), vital advice on how
    to build an architecture by means of abstractions.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 9：关注抽象的所有权”](#pay_attention_to_the_ownership_of_abstractions)，我将专注于抽象的建筑意义。我将解释什么是架构，以及我们对架构的高低层次的期望。我还将向您展示，从架构的角度来看，仅仅引入抽象以解决依赖关系是不够的。为了解释这一点，我将介绍“依赖反转原则”（DIP），这是通过抽象构建架构的重要建议。
- en: 'In [“Guideline 10: Consider Creating an Architectural Document”](#consider_creating_an_architectural_document),
    we will talk about the benefits of an architectural document. Hopefully, this
    will be an incentive to create one in case this wasn’t already on your radar.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 10：考虑创建架构文档”](#consider_creating_an_architectural_document)，我们将讨论架构文档的好处。希望这将是一个创造一个架构文档的动机，以防这已经不在您的计划中。
- en: 'Guideline 6: Adhere to the Expected Behavior of Abstractions'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南 6：遵循抽象的预期行为
- en: One of the key aspects of decoupling software, and thus one of the key aspects
    of software design, is the introduction of abstractions. For that reason, you
    would expect that this is a relatively straightforward, easy thing to do. Unfortunately,
    as it turns out, building abstractions is difficult.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦软件的一个关键方面，因此也是软件设计的一个关键方面，是引入抽象。因此，您可能会期望这是一件相对简单、容易的事情。不幸的是，事实证明，构建抽象是困难的。
- en: To demonstrate what I mean, let’s take a look at an example. I have selected
    *the* classic example for that purpose. Chances are, you might already know this
    example. If so, please feel free to skip it. However, if you’re not familiar with
    the example, then this may serve as an eye-opener.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我的意思，让我们看一个例子。我选择了*经典*的例子作为例证。你可能已经知道这个例子。如果是这样，请随意跳过它。然而，如果你对这个例子不熟悉，那么这可能会让你眼前一亮。
- en: An Example of Violating Expectations
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 违反期望的一个例子
- en: 'Let’s start with a `Rectangle` base class:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个`Rectangle`基类开始：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First of all, this class is designed as a base class, since it provides a virtual
    destructor ([![1](assets/1.png)](#code_g6_1)). Semantically, a `Rectangle` represents
    an abstraction for different kinds of rectangles. And technically, you can properly
    destroy an object of derived type via a pointer to `Rectangle`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个类被设计为一个基类，因为它提供了一个虚析构函数（[![1](assets/1.png)](#code_g6_1)）。从语义上讲，`Rectangle`表示不同类型的矩形的抽象。从技术上讲，你可以通过指向`Rectangle`的指针正确销毁派生类型的对象。
- en: 'Second, the `Rectangle` class comes with two data members: `width` and `height`
    ([![2](assets/2.png)](#code_g6_2)). That is to be expected, since a rectangle
    has two side lengths, which are represented by `width` and `height`. The `getWidth()`
    and `getHeight()` member functions can be used to query the two side lengths ([![3](assets/3.png)](#code_g6_3)),
    and via the `setWidth()` and `setHeight()` member functions, we can set the `width`
    and `height` ([![4](assets/4.png)](#code_g6_4)). It’s important to note that I
    can set these two independently; i.e., I can set the `width` without having to
    modify the `height`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`Rectangle`类带有两个数据成员：`width`和`height`（[![2](assets/2.png)](#code_g6_2)）。这是可以预期的，因为矩形有两个边长，分别由`width`和`height`表示。`getWidth()`和`getHeight()`成员函数可以用来查询这两个边长（[![3](assets/3.png)](#code_g6_3)），通过`setWidth()`和`setHeight()`成员函数，我们可以设置`width`和`height`（[![4](assets/4.png)](#code_g6_4)）。重要的是要注意，我可以独立设置这两个值；也就是说，我可以设置`width`而不必修改`height`。
- en: Finally, there is a `getArea()` member function ([![5](assets/5.png)](#code_g6_5)).
    `getArea()` computes the area of the rectangle, which is of course implemented
    by returning the product of `width` and `height`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个`getArea()`成员函数（[![5](assets/5.png)](#code_g6_5)）。`getArea()`计算矩形的面积，当然是通过返回`width`和`height`的乘积来实现的。
- en: 'Of course there may be more functionality, but the given members are the ones
    that are important for this example. As it is, this seems to be a pretty nice
    `Rectangle` class. Obviously, we’re off to a good start. But, of course there’s
    more. For instance, there is the `Square` class:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可能会有更多的功能，但给定的成员是这个示例中重要的成员。目前看来，这个`Rectangle`类似乎相当不错。显然，我们有了一个良好的开端。但当然还有更多。例如，还有`Square`类：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Square` class publicly inherits from the `Rectangle` class ([![6](assets/6.png)](#code_g6_6)).
    And that seems pretty reasonable: from a mathematical perspective, a square appears
    to be a special kind of rectangle.^([1](ch02.xhtml#idm45043120890480))'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Square`类公开继承自`Rectangle`类（[![6](assets/6.png)](#code_g6_6)）。从数学的角度来看，这似乎相当合理：一个正方形看起来就是一种特殊的矩形。^([1](ch02.xhtml#idm45043120890480))'
- en: 'A `Square` is special, in the sense that it has only one side length. But the
    `Rectangle` base class comes with two lengths: `width` and `height`. For that
    reason, we have to make sure that the invariants of the `Square` are always preserved.
    In this given implementation with two data members and two getter functions, we
    have to make sure that both data members always have the same value. Therefore,
    we override the `setWidth()` member function to set both `width` and `height`
    ([![7](assets/7.png)](#code_g6_7)). We also override the `setHeight()` member
    function to set both `width` and `height` ([![8](assets/8.png)](#code_g6_8)).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Square`是特殊的，因为它只有一个边长。但是`Rectangle`基类有两个长度：`width`和`height`。因此，我们必须确保`Square`的不变量始终得到保留。在这个给定的实现中，我们有两个数据成员和两个获取函数，我们必须确保这两个数据成员始终具有相同的值。因此，我们重写`setWidth()`成员函数来同时设置`width`和`height`（[![7](assets/7.png)](#code_g6_7)）。我们还重写`setHeight()`成员函数来同时设置`width`和`height`（[![8](assets/8.png)](#code_g6_8)）。
- en: Once we have done that, a `Square` will always have equal side lengths, and
    the `getArea()` function will always return the correct area of a `Square` ([![9](assets/9.png)](#code_g6_9)).
    Nice!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这些，一个`Square`将始终具有相等的边长，并且`getArea()`函数将始终返回一个`Square`的正确面积（[![9](assets/9.png)](#code_g6_9)）。不错！
- en: 'Let’s put these two classes to good use. For instance, we could think about
    a function that transforms different kinds of rectangles:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们充分利用这两个类。例如，我们可以考虑一个函数，用于转换不同类型的矩形：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `transform()` function takes any kind of `Rectangle` by means of a reference
    to non-`const` ([![10](assets/10.png)](#code_g6_10)). That’s reasonable, because
    we want to change the given rectangle. A first possible way to change the rectangle
    is to set the `width` via the `setWidth()` member function to `7` ([![11](assets/11.png)](#code_g6_11)).
    Then we could change the `height` of the rectangle to `4` via the `setHeight()`
    member function ([![12](assets/12.png)](#code_g6_12)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform()`函数通过对非`const`引用接收任何类型的`Rectangle`。这是合理的，因为我们希望修改给定的矩形。首先可以通过`setWidth()`成员函数将矩形的`width`设置为`7`（[![11](assets/11.png)](#code_g6_11)）。然后，我们可以通过`setHeight()`成员函数将矩形的`height`设置为`4`（[![12](assets/12.png)](#code_g6_12)）。'
- en: At this point, I would argue that you have an implicit assumption. I am pretty
    certain that you assume that the area of the rectangle is `28`, because, of course,
    `7` times `4` is `28`. That is an assumption we can test via an assertion ([![13](assets/13.png)](#code_g6_13)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我会认为你有一个隐含的假设。我相当肯定你假设矩形的面积是`28`，因为当然，`7`乘以`4`等于`28`。这是一个我们可以通过断言进行测试的假设（[![13](assets/13.png)](#code_g6_13))。
- en: 'The only thing missing is to actually call the `transform()` function. That’s
    what we do in the `main()` function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一还缺少的是实际调用`transform()`函数。这就是我们在`main()`函数中所做的：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `main()` function, we create a special kind of rectangle: a `Square`
    ([![14](assets/14.png)](#code_g6_14)).^([2](ch02.xhtml#idm45043120674128)) This
    square is passed to the `transform()` function, which of course works, since a
    reference to a `Square` can be implicitly converted to a reference to a `Rectangle`
    ([![15](assets/15.png)](#code_g6_15)).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们创建了一种特殊类型的矩形：一个`Square`（[![14](assets/14.png)](#code_g6_14))。^([2](ch02.xhtml#idm45043120674128))
    这个正方形被传递给`transform()`函数，当然可以工作，因为`Square`的引用可以隐式转换为`Rectangle`的引用（[![15](assets/15.png)](#code_g6_15))。
- en: 'If I were to ask you, “What happens?” I’m pretty sure you would answer, “The
    `assert()` fails!” Yes, indeed, the `assert()` will fail. The expression passed
    to the `assert()` will evaluate to `false`, and `assert()` will crash the process
    with a `SIGKILL` signal. Well, that’s certainly unfortunate. So let’s do a postmortem
    analysis: why does the `assert()` fail? Our expectation in the `transform()` function
    is that we can change the width and height of a rectangle independently. This
    expectation is explicitly expressed with the two function calls to `setWidth()`
    and `setHeight()`. However, unexpectedly, this special kind of rectangle does
    not allow that: to preserve its own invariants, the `Square` class must always
    make sure that both side lengths are equal. Thus, the `Square` class has to violate
    this expectation. This violation of the expectation in an abstraction is a violation
    of the LSP.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我问你，“会发生什么？”我非常确定你会回答，“`assert()`失败了！” 是的，确实如此，`assert()`将失败。传递给`assert()`的表达式将求值为`false`，并且`assert()`将使用`SIGKILL`信号使进程崩溃。嗯，这确实很不幸。因此，让我们进行事后分析：为什么`assert()`会失败？我们在`transform()`函数中的期望是可以独立改变矩形的宽度和高度。这个期望明确地通过对`setWidth()`和`setHeight()`的两次函数调用来表达。然而，出乎意料的是，这种特殊类型的矩形却不允许这样做：为了保持其自身的不变性，`Square`类必须始终确保两个边长相等。因此，`Square`类必须违反这个期望。在抽象层面上违反期望是LSP的违反。
- en: The Liskov Substitution Principle
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 里氏替换原则（Liskov Substitution Principle）
- en: The LSP is the third of the SOLID principles and is concerned with *behavioral
    subtyping*, i.e., with the expected behavior of an abstraction. This design principle
    is named after [Barbara Liskov](https://oreil.ly/XkNi4), who initially introduced
    it in 1988 and clarified it with Jeannette Wing in 1994:^([3](ch02.xhtml#idm45043120621936))
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: LSP是SOLID原则中的第三条，涉及*行为子类型化*，即抽象的预期行为。这个设计原则以[Barbara Liskov](https://oreil.ly/XkNi4)的名字命名，她于1988年首次提出，并在1994年与Jeannette
    Wing澄清了它：^([3](ch02.xhtml#idm45043120621936))
- en: 'Subtype Requirement: Let <math alttext="phi left-parenthesis x right-parenthesis"><mrow><mi>φ</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> be a property provable about objects
    <math alttext="x"><mi>x</mi></math> of type T. Then <math alttext="phi left-parenthesis
    y right-parenthesis"><mrow><mi>φ</mi> <mo>(</mo> <mi>y</mi> <mo>)</mo></mrow></math>
    should be true for objects <math alttext="y"><mi>y</mi></math> of type S where
    S is a subtype of T.'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 子类型要求：设<math alttext="phi left-parenthesis x right-parenthesis"><mrow><mi>φ</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>是关于类型T的对象<math alttext="x"><mi>x</mi></math>可证明的属性。那么对于类型S的对象<math
    alttext="y"><mi>y</mi></math>（其中S是T的子类型），<math alttext="phi left-parenthesis y
    right-parenthesis"><mrow><mi>φ</mi> <mo>(</mo> <mi>y</mi> <mo>)</mo></mrow></math>应该为真。
- en: 'This principle formulates what we commonly call an [*IS-A*](https://oreil.ly/isoda)
    relationship. This relationship, i.e., the expectations in an abstraction, *must*
    be adhered to in a subtype. That includes the following properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则阐述了我们通常称为[*IS-A*](https://oreil.ly/isoda)关系的概念。这种关系，即抽象中的期望，必须在子类型中遵守。这包括以下属性：
- en: 'Preconditions cannot be strengthened in a subtype: a subtype cannot expect
    more in a function than what the super type expresses. That would violate the
    expectations in the abstraction:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前置条件在子类型中不能被加强：子类型不能在函数中期望超类型所表达的更多。这将违反抽象中的期望：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Postconditions cannot be weakened in a subtype: a subtype cannot promise less
    when leaving a function than the super type promises. Again, that would violate
    the expectations in the abstraction:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后置条件在子类型中不能被削弱：子类型在离开函数时不能比超类型承诺更少。再次强调，这会违反抽象中的期望。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Function return types in a subtype must be *covariant*: member functions of
    the subtype can return a type that is itself a subtype of the return type of the
    corresponding member function in the super type. This property has direct language
    support in C++. However, the subtype cannot return any super type of the return
    type of the corresponding function in the super type:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数子类型中的返回类型必须是*协变*的：子类型的成员函数可以返回一个类型，该类型本身是超类型中对应成员函数返回类型的子类型。这种属性在C++中有直接的语言支持。然而，子类型不能返回超类型的任何返回类型：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Function parameters in a subtype must be *contravariant*: in a member function,
    the subtype can accept a super type of the function parameter in the corresponding
    member function of the super type. This property does *not* have direct language
    support in C++:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数子类型中的参数必须是*逆变*的：在成员函数中，子类型可以接受超类型的函数参数，并在超类型的对应成员函数中使用。这种属性在C++中没有直接的语言支持：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Invariants of the super type must be preserved in a subtype: any expectation
    about the state of a super type must always be valid before and after all calls
    to any member function, including the member functions of the subtype:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超类型的不变量必须在子类型中保留：关于超类型状态的任何期望，在所有成员函数调用之前和之后，包括子类型的成员函数，在子类型中必须始终有效。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our example, the expectation in a `Rectangle` is that we can change the two
    side lengths independently, or, more formally, that the result of `getWidth()`
    does not change after `setHeight()` is called. This expectation is intuitive for
    any kind of rectangle. However, the `Square` class itself introduces the invariant
    that all sides must always be equal, or else the `Square` would not properly express
    our idea of a square. But by protecting its own invariants, the `Square` unfortunately
    violates the expectations in the base class. Thus, the `Square` class doesn’t
    fulfill the expectations in the `Rectangle` class, and the hierarchy in this example
    doesn’t express an IS-A relationship. Therefore, a `Square` cannot be used in
    all the places a `Rectangle` is expected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，在`Rectangle`中的期望是我们可以独立改变两个边长，或者更正式地说，在调用`setHeight()`之后，`getWidth()`的结果不会改变。这种期望对于任何类型的矩形都是直观的。然而，`Square`类本身引入了所有边必须始终相等的不变量，否则`Square`无法正确表达我们对正方形的理解。但通过保护自身的不变量，`Square`不幸地违反了基类中的期望。因此，在这个例子中，`Square`类无法满足`Rectangle`类的期望，并且这个层次结构并不表达一个IS-A关系。因此，`Square`不能在所有需要`Rectangle`的地方使用。
- en: “But isn’t a square a rectangle?” you ask. “Isn’t that properly expressing the
    geometrical relation?”^([4](ch02.xhtml#idm45043119856288)) Yes, there may be a
    geometrical relation between squares and rectangles, but in this example the inheritance
    relationship is broken. This example demonstrates that the mathematical IS-A relationship
    is indeed different from the LSP IS-A relationship. While in geometry a square
    is always a rectangle, in computer science it really depends on the actual interface
    and thus the expectations. As long as there are the two independent `setWidth()`
    and `setHeight()` functions, a `Square` will always violate the expectations.
    “I understand,” you say. “Nobody would claim that, geometrically, a square is
    still a square after changing its width, right?” Exactly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “但是一个正方形不是一个矩形吗？”你问道。“这难道不能正确地表达几何关系吗？”^([4](ch02.xhtml#idm45043119856288))
    是的，正方形和矩形之间可能存在几何关系，但在这个例子中，继承关系是破坏的。这个例子表明数学上的IS-A关系与LSP的IS-A关系确实是不同的。在几何学中，正方形总是矩形，但在计算机科学中，这真的取决于实际的接口和期望。只要有两个独立的`setWidth()`和`setHeight()`函数，一个`Square`总是会违反期望。“我明白了，”你说。“没人会声称，在几何上，改变宽度后的正方形仍然是正方形，对吧？”确实如此。
- en: The example also demonstrates that inheritance is not a natural or intuitive
    feature, but a hard feature. As stated in the beginning, building abstractions
    is hard. Whenever you use inheritance, you *must* make sure that all expectations
    in the base class are fulfilled and that the derived type behaves as expected.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该例子还表明继承不是一种自然或直观的特性，而是一种困难的特性。正如开头所述，构建抽象是困难的。每当使用继承时，*必须*确保基类中的所有期望都得到满足，并且派生类型的行为如预期般。
- en: Criticism of the Liskov Substitution Principle
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对里斯科夫替换原则的批评
- en: 'Some people argue that the LSP, as explained earlier, is in fact not what is
    described in the conference paper “Data Abstraction and Hierarchy” by Barbara
    Liskov and that the notion of subtyping is flawed. And that is correct: we usually
    do not substitute derived objects for base objects, but we use a derived object
    as a base object. However, this literal and strict interpretation of Liskov’s
    statements does not play any role in the kinds of abstractions that we build on
    a daily basis. In their 1994 paper “A Behavioral Notion of Subtyping,” Barbara
    Liskov and Jeannette Wing proposed the term *behavioral subtyping*, which is the
    common understanding of the LSP today.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为，正如早先解释的那样，LSP实际上并不是由芭芭拉·里斯科夫和会议论文“数据抽象与层次结构”中描述的那样，并且子类型的概念是有缺陷的。这是正确的：我们通常不会用派生对象替代基对象，而是将派生对象用作基对象。然而，这种对里斯科夫声明的字面和严格解释在我们日常构建的抽象类型中并不起任何作用。在她们1994年的论文“子类型的行为概念”中，芭芭拉·里斯科夫和Jeanette
    Wing提出了术语*行为子类型*，这是今天对LSP的共同理解。
- en: 'Other people argue that because of potential violations of the LSP, a base
    class does not serve the purpose of an abstraction. The rationale is that using
    code would also depend on the (mis-)behavior of derived types. This argument unfortunately
    turns the world upside down. A base class *does* represent an abstraction, because
    calling code can and should only and exclusively depend on the *expected* behavior
    of this abstraction. It’s that dependency that makes LSP violations programming
    errors. Unfortunately, sometimes people try to fix LSP violations by introducing
    special workarounds:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人认为，由于可能违反LSP，基类并不符合抽象的目的。理由是使用代码也将依赖（误）用于派生类型的行为。不幸的是，这种论点颠倒了世界。基类*确实*代表了一种抽象，因为调用代码只能且应仅仅依赖于这种抽象的*预期*行为。正是这种依赖性使得LSP违规成为编程错误。不幸的是，有时人们试图通过引入特殊的解决方案来修复LSP违规：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This kind of workaround will indeed introduce a dependency in the behavior of
    the derived types. And a very unfortunate dependency, indeed! This should always
    be considered an LSP violation and very bad practice.^([5](ch02.xhtml#idm45043119792896))
    It doesn’t serve as a general argument against the abstracting properties of a
    base class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方法确实会引入派生类型行为的依赖性。而且是非常不幸的依赖性！这应始终被视为LSP的违规和非常糟糕的实践。^([5](ch02.xhtml#idm45043119792896))
    它并不能作为反对基类抽象属性的普遍论点。
- en: The Need for Good and Meaningful Abstractions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要良好和有意义的抽象
- en: To properly decouple software entities, it is fundamentally important that we
    can count on our abstractions. Without meaningful abstractions that we, the human
    readers of code, *fully* understand, we cannot write robust and reliable software.
    Therefore, adherence to the LSP is essential for the purpose of software design.
    However, a vital part is also the clear and unambiguous communication of the expectations
    of an abstraction. In the best case, this happens by means of software itself
    (*self-documenting code*), but it also entails a proper documentation of abstractions.
    As a good example, I recommend the [iterator concepts documentation](https://oreil.ly/OBpAg)
    in the C++ standard, which clearly lists the expected behavior, including pre-
    and post-conditions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确解耦软件实体，我们能够依赖我们的抽象是非常重要的。如果没有我们作为代码的人类读者*完全*理解的有意义的抽象，我们就无法编写健壮可靠的软件。因此，遵循LSP对软件设计至关重要。然而，同样重要的一部分是对抽象期望的清晰明确的传达。在最佳情况下，这通过软件本身实现（*自描述代码*）来实现，但也包括对抽象的适当文档化。作为一个很好的例子，我推荐查看C++标准中的[迭代器概念文档](https://oreil.ly/OBpAg)，其中清楚地列出了预期的行为，包括前置和后置条件。
- en: 'Guideline 7: Understand the Similarities Between Base Classes and Concepts'
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指导原则 7：理解基类和概念之间的相似之处
- en: 'In [“Guideline 6: Adhere to the Expected Behavior of Abstractions”](#adhere_to_the_expected_behavior_of_abstractions),
    I may have created the impression that the LSP is concerned only with inheritance
    hierarchies and base classes. To make sure that this impression doesn’t stick,
    allow me to explicitly state that the LSP is *not* limited to dynamic (runtime)
    polymorphism and inheritance hierarchies. On the contrary, we can apply the LSP
    just as well to static (compile-time) polymorphism and templated code.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指导原则 6：遵循抽象的预期行为”](#adhere_to_the_expected_behavior_of_abstractions)，我可能给人造成了LSP仅涉及继承层次结构和基类的印象。为了确保这种印象不会固定下来，让我明确声明LSP*不*仅限于动态（运行时）多态性和继承层次结构。相反，我们同样可以将LSP应用于静态（编译时）多态性和模板化代码。
- en: 'To make the point, let me ask you a question: what’s the difference between
    the following two code snippets?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我问你一个问题：下面两个代码片段有什么区别？
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I’m pretty sure your first answer is that the first code snippet shows a solution
    using dynamic polymorphism, and the second one shows static polymorphism. Yes,
    great! What else? OK, yes, of course, the syntax is different, too. OK, I see,
    I should ask my question a little more precisely: in which way do these two solutions
    differ *semantically*?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确定你的第一个答案是第一个代码片段展示了使用动态多态性的解决方案，而第二个代码片段展示了静态多态性。是的，很好！还有什么？好的，是的，当然，语法也不同。好的，我明白了，我应该更精确地问我的问题：这两种解决方案在*语义上*有什么不同？
- en: Well, if you think about it, then you might find that from a semantic point
    of view the two solutions are very similar indeed. In the first code snippet,
    the `useDocument()` function works only with classes derived from the `Document`
    base class. Thus, we can say that the function works only with classes adhering
    to the expectations of the `Document` abstraction. In the second code snippet,
    the `use​Docu⁠ment()` function works only with classes that implement the `Document`
    concept. In other words, the function works only with classes adhering to the
    expectations of the `Document` abstraction.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，如果你仔细思考一下，你可能会发现从语义上讲，这两种解决方案确实非常相似。在第一个代码片段中，`useDocument()` 函数只与派生自`Document`基类的类一起工作。因此，我们可以说该函数只与符合`Document`抽象期望的类一起工作。在第二个代码片段中，`use​Docu⁠ment()`
    函数只与实现`Document`概念的类一起工作。换句话说，该函数只与符合`Document`抽象期望的类一起工作。
- en: If you now have the feeling of déjà vu, then my choice of words hopefully struck
    a chord. Yes, in both code snippets, the `useDocument()` function works only with
    classes adhering to the expectations of the `Document` abstraction. So despite
    the fact that the first code snippet is based on a runtime abstraction and the
    second function represents a compile-time abstraction, these two functions are
    very similar from a semantic point of view.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在有一种似曾相识的感觉，那么我的措辞希望引起共鸣。是的，在这两个代码片段中，`useDocument()` 函数只与符合`Document`抽象期望的类一起工作。因此，尽管第一个代码片段基于运行时抽象，第二个函数代表编译时抽象，从语义上讲，这两个函数非常相似。
- en: Both the base class and the concept represent a set of requirements (syntactic
    requirements, but also semantic requirements). As such, both represent a formal
    description of the expected behavior and thus are the means to express and communicate
    expectations for calling code. Thus, concepts can be considered the equivalent,
    the static counterpart, of base classes. And from this point of view, it makes
    perfect sense to also consider the LSP for template code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 基类和概念都代表一组要求（语法要求，但也包括语义要求）。因此，两者都代表了对期望行为的正式描述，因此是表达和传达调用代码期望的手段。因此，概念可以被视为基类的等价物，即静态对应物。从这个角度看，也完全有理由考虑模板代码的LSP（里氏替换原则）。
- en: “I’m not buying that,” you say. “I’ve heard that C++20 concepts cannot express
    semantics!”^([6](ch02.xhtml#idm45043119546544)) Well, to this I can only respond
    with a definitive yes and no. Yes, C++20 concepts cannot fully express semantics,
    that’s correct. But on the other hand, concepts still express expected behavior.
    Consider, for instance, the C++20 form of the `std::copy()` algorithm:^([7](ch02.xhtml#idm45043119543760))
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: “我不买账，” 你说，“我听说 C++20 的概念不能表达语义！”^([6](ch02.xhtml#idm45043119546544)) 嗯，对此我只能肯定地说是和不是。是的，C++20
    的概念不能完全表达语义，这是正确的。但另一方面，概念仍然表达了期望的行为。例如，考虑 `std::copy()` 算法的 C++20 形式：^([7](ch02.xhtml#idm45043119543760))
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `std::copy()` algorithm expects three arguments. The first two arguments
    represent the range of elements that need to be copied (the *input range*). The
    third argument represents the first element we need to copy to (the *output range*).
    A general expectation is that the *output range* is big enough that all the elements
    from the *input range* can be copied to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::copy()` 算法期望三个参数。前两个参数表示需要复制的元素范围（*输入范围*）。第三个参数表示我们需要复制到的第一个元素（*输出范围*）。一般期望是*输出范围*足够大，可以将所有*输入范围*的元素复制到其中。'
- en: 'There are more expectations that are implicitly expressed via the names for
    the iterator types: `InputIt` and `OutputIt`. `InputIt` represents a type of *input
    iterator*. The C++ standard states all the expectations of such iterator types,
    such as the availability of an (in-)equality comparison, the ability to traverse
    a range with a prefix and postfix increment (`operator++()` and `operator++(int)`),
    and the ability to access elements with the dereference operator (`operator*()`).
    `OutputIt`, on the other hand, represents a type of *output iterator*. Here, the
    C++ standard also explicitly states all expected operations.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器类型的命名隐含表达了更多的期望：`InputIt` 和 `OutputIt`。`InputIt` 表示一种*输入迭代器*类型。C++ 标准规定了所有这类迭代器类型的期望，例如可用性比较（不等比较），通过前缀和后缀递增遍历范围（`operator++()`
    和 `operator++(int)`），以及通过解引用操作符访问元素（`operator*()`）。另一方面，`OutputIt` 表示一种*输出迭代器*类型。在这里，C++
    标准也明确规定了所有期望的操作。
- en: '`InputIt` and `OutputIt` may not be C++20 concepts, but they represent the
    same idea: these named template parameters don’t just give you an idea about what
    kind of type is required; they also express expected behavior. For instance, we
    expect that subsequent increments of `first` will eventually yield `last`. If
    any given concrete iterator type does not behave this way, `std::copy()` will
    not work as expected. This would be a violation of the expected behavior, and
    as such, a violation of the LSP.^([8](ch02.xhtml#idm45043119253776)) Therefore,
    both `InputIt` and `OutputIt` represent LSP abstractions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputIt` 和 `OutputIt` 或许不是 C++20 的概念，但它们代表相同的概念：这些命名的模板参数不仅告诉你需要的类型是什么，还表达了期望的行为。例如，我们期望
    `first` 的后续递增最终会产生 `last`。如果任何具体的迭代器类型不能按照这种方式行为，`std::copy()` 将不能按预期工作。这将是对期望行为的违反，因此也是LSP的违反。^([8](ch02.xhtml#idm45043119253776))
    因此，`InputIt` 和 `OutputIt` 都代表LSP的抽象。'
- en: 'Note that since concepts represent an LSP abstraction, i.e., a set of requirements
    and expectations, they are subject to the *Interface Segregation Principle* (ISP)
    as well (see [“Guideline 3: Separate Interfaces to Avoid Artificial Coupling”](ch01.xhtml#separate_interfaces_to_avoid_artificial_coupling)).
    Just as you should separate concerns in the definition of requirements in the
    form of base classes (say, “interface” classes), you should separate concerns
    when defining a concept. The Standard Library iterators do that by building on
    one another, thus allowing you to select the desired level of requirements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于概念代表了LSP的抽象，即一组要求和期望，它们也适用于*接口隔离原则*（ISP）（见[“指南 3：分离接口以避免人为耦合”](ch01.xhtml#separate_interfaces_to_avoid_artificial_coupling)）。正如您应该在基类定义要求的定义中分离关注点（比如说，“接口”类），您在定义概念时也应该分离关注点。标准库迭代器通过相互构建来实现这一点，从而允许您选择所需的要求级别：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since both named template parameters and C++20 concepts serve the same purpose
    and since both represent LSP abstractions, from now on, in all subsequent guidelines,
    I will use the term *concept* to refer to both of them. Thus, with the term *concept*,
    I will refer to any way to represent a set of requirements (in most cases for
    template arguments, but sometimes even more generally). If I want to refer to
    either of these two specifically, I will make it explicitly clear.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命名模板参数和C++20概念都用于表示LSP抽象，从现在开始，在所有后续的指南中，我将使用术语*概念*来指代它们。因此，用术语*概念*，我将指代任何表达一组要求的方式（在大多数情况下是用于模板参数，但有时甚至更广泛）。如果我想特指其中的任何一个，我会明确表明。
- en: In summary, any kind of abstraction (dynamic and static) represents a set of
    requirements with that expected behavior. These expectations need to be fulfilled
    by concrete implementations. Thus, the LSP clearly represents essential guidance
    for all kinds of IS-A relationships.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，任何抽象（动态和静态）都代表了一组期望的行为要求。这些期望需要由具体的实现来满足。因此，LSP清晰地代表了所有IS-A关系的基本指导。
- en: 'Guideline 8: Understand the Semantic Requirements of Overload Sets'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南 8：理解重载集的语义要求
- en: 'In [“Guideline 6: Adhere to the Expected Behavior of Abstractions”](#adhere_to_the_expected_behavior_of_abstractions),
    I introduced you to the LSP and hopefully made a strong argument: *every* abstraction
    represents a set of semantic requirements! In other words, an abstraction expresses
    expected behavior, which needs to be fulfilled. Otherwise, you (very likely) will
    have a problem. In [“Guideline 7: Understand the Similarities Between Base Classes
    and Concepts”](#understand_the_similarities_between_base_classes_and_concepts),
    I extended the LSP discussion to concepts and demonstrated that the LSP can and
    *should* also be applied to static abstractions.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“指南 6：遵循抽象的预期行为”](#adhere_to_the_expected_behavior_of_abstractions)中，我向您介绍了LSP，并希望做出了强有力的论证：*每个*抽象都代表了一组语义要求！换句话说，抽象表达了需要满足的预期行为。否则，您（很可能）会遇到问题。在[“指南
    7：理解基类与概念之间的相似性”](#understand_the_similarities_between_base_classes_and_concepts)中，我扩展了LSP的讨论到概念，并展示了LSP也可以和*应该*应用于静态抽象。
- en: 'That’s not the end of the story, though. As stated before: *every* abstraction
    represents a set of requirements. There is one more kind of abstraction that we
    have not yet taken into account, one that’s unfortunately often overlooked, despite
    its power, and hence one that we should not forget in the discussion: function
    overloading. “Function overloading? You mean the fact that a class can have several
    functions with the same name?” Yes, absolutely. You probably have experienced
    that this is indeed a pretty powerful feature. Think, for instance, about the
    two overloads of the `begin()` member function inside the `std::vector`: depending
    on whether you have a `const` or a non-`const` vector, the corresponding overload
    is picked. Without you even noticing. Pretty powerful! But honestly, this isn’t
    really much of an abstraction. While it’s convenient and helpful to overload member
    functions, I have a different kind of function overloading in mind, the kind that
    truly represents a form of abstraction: free functions.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是故事的结局。正如之前所述：*每一个*抽象都代表一组需求。还有一种抽象我们尚未考虑到，这种抽象经常被忽视，尽管它非常强大，因此在讨论中我们不应忘记它：函数重载。“函数重载？你指的是一个类可以有几个同名函数的事实？”
    是的，完全正确。您可能已经体验过，这确实是一个非常强大的特性。例如，请考虑`std::vector`中的两个`begin()`成员函数的重载：根据您是否有一个`const`或非`const`向量，选择相应的重载。甚至无需您注意。非常强大！但说实话，这并不是真正的抽象。虽然重载成员函数很方便和有帮助，但我心中想到的是一种不同类型的函数重载，一种真正代表一种形式的抽象：自由函数。
- en: 'The Power of Free Functions: A Compile-Time Abstraction Mechanism'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自由函数的力量：一种编译时抽象机制
- en: 'Next to concepts, function overloading by means of free functions represents
    a second compile-time abstraction: based on some given types, the compiler figures
    out which function to call from a set of identically named functions. This is
    what we call an *overload set*. This is an extremely versatile and powerful abstraction
    mechanism with many, many great design characteristics. First of all, you can
    add a free function to any type: you can add one to an `int`, to `std::string`,
    and to any other type. Nonintrusively. Try that with a member function, and you
    will realize that this just does not work. Adding a member function is intrusive.
    You can’t add anything to a type that cannot have a member function or to a type
    that you cannot modify. Thus, a free function perfectly lives up to the spirit
    of the Open-Closed Principle (OCP): you can extend the functionality by simply
    adding code, without the need to modify already existing code.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了概念外，通过自由函数进行函数重载代表第二种编译时抽象：基于某些给定类型，编译器从一组同名函数中找出应该调用哪一个函数。这就是我们称之为*重载集*的东西。这是一种极其灵活和强大的抽象机制，具有许多出色的设计特性。首先，您可以向任何类型添加自由函数：您可以向`int`、`std::string`和任何其他类型添加自由函数。非侵入式地。尝试使用成员函数这样做，您会意识到这根本行不通。添加成员函数是侵入式的。您无法向不能拥有成员函数的类型或不能修改的类型添加任何东西。因此，自由函数完美地体现了开闭原则（OCP）的精神：您可以通过简单添加代码来扩展功能，而无需修改已存在的代码。
- en: 'This gives you a significant design advantage. Consider, for instance, the
    following code example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您带来了显著的设计优势。例如，考虑以下代码示例：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `traverseRange()` function performs a traditional, iterator-based loop
    over the given `range`. To acquire iterators, it calls the `begin()` and `end()`
    member functions on the `range`. While this code will work for a large number
    of container types, it will not work for a built-in array:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`traverseRange()` 函数在给定的`range`上执行传统的基于迭代器的循环。为了获取迭代器，它调用了`range`上的`begin()`和`end()`成员函数。尽管这段代码对许多容器类型都有效，但对于内置数组来说是不起作用的：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code will not compile, as the compiler will complain about the missing
    `begin()` and `end()` member functions for the given array type. “Isn’t that why
    we should avoid using built-in arrays and use `std::array` instead?” I completely
    agree: you should use `std::array` instead. This is also very nicely explained
    by [Core Guideline SL.con.1](https://oreil.ly/FRrfz):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将无法编译，因为编译器会抱怨给定数组类型缺少`begin()`和`end()`成员函数。“这难道不是我们应该避免使用内置数组而使用`std::array`的原因吗？”
    我完全同意：您应该使用`std::array`。这也被[核心指南 SL.con.1](https://oreil.ly/FRrfz)非常好地解释了：
- en: Prefer using STL `array` or `vector` instead of a C array.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 建议使用STL的`array`或`vector`而不是C数组。
- en: 'However, while this is good practice, let’s not lose sight of the design issues
    of the `traverseRange()` function: `traverseRange()` is restricting itself by
    depending on the `begin()` and `end()` member functions. Thus, it creates an artificial
    requirement on the `Range` type to support a member `begin()` and a member `end()`
    function and, by that, limits its own applicability. There is a simple solution,
    however, a simple way to make the function much more widely applicable: build
    on the overload set of free `begin()` and `end()` functions:^([9](ch02.xhtml#idm45043118921264))'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然这是一个良好的实践，但我们不应忽视`traverseRange()`函数的设计问题：`traverseRange()`通过依赖于`begin()`和`end()`成员函数而限制了自己。因此，它对`Range`类型施加了一个人为的要求，要求支持一个`begin()`和一个`end()`函数，并且由此限制了它自身的适用性。然而，有一个简单的解决方案，一种使该函数更广泛适用的简单方式：利用自由的`begin()`和`end()`函数的重载集合：[^9]
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function is still doing the same thing as before, but in this form it
    doesn’t restrict itself by any artificial requirement. And indeed, there is no
    restriction: *any* type can have a free `begin()` and `end()` function or, if
    it is missing, can be equipped with one. Nonintrusively. Thus, this function works
    with any kind of `Range` and doesn’t have to be modified or overloaded if some
    type does not meet the requirement. It is more widely applicable. It is truly
    generic.^([10](ch02.xhtml#idm45043118837984))'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这个函数仍然在以前做同样的事情，但在这种形式下，它不受任何人为要求的限制。事实上，没有任何限制：*任何*类型都可以拥有自由的`begin()`和`end()`函数，或者如果缺少这些函数，则可以被赋予这些函数。非侵入式地。因此，这个函数可以与任何类型的`Range`一起使用，如果某些类型不满足要求，也无需修改或重载。它的适用范围更广。它真正地通用。[^10]
- en: 'Free functions have more advantages, though. As already discussed in [“Guideline
    4: Design for Testability”](ch01.xhtml#design_for_testability), free functions
    are a very elegant technique to separate concerns, fulfilling the Single-Responsibility
    Principle (SRP). By implementing an operation outside a class, you automatically
    reduce the dependencies of that class to the operation. Technically, this becomes
    immediately clear, since in contrast to member functions, free functions don’t
    have an implicit first argument, the `this` pointer. At the same time, this promotes
    the function to become a separate, isolated service, which can be used by many
    other classes as well. Thus, you promote reuse and reduce duplication. This very,
    very nicely adheres to the idea of the Don’t Repeat Yourself (DRY) principle.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，自由函数还有更多的优势。正如在[“指导原则4：设计可测试性”](ch01.xhtml#design_for_testability)中已经讨论过的那样，自由函数是一种非常优雅的技术，可以分离关注点，实现单一职责原则（SRP）。通过在类外部实现操作，你自动减少了该类对该操作的依赖。从技术上讲，这变得立即清晰，因为与成员函数相比，自由函数没有隐式的第一个参数，即`this`指针。与此同时，这也促使该函数成为一个独立的、孤立的服务，可以被许多其他类使用。因此，你促进了重用并减少了重复。这非常好地符合不要重复你自己（DRY）原则的思想。
- en: 'The beauty of this is wonderfully demonstrated in Alexander Stepanov’s brainchild,
    the Standard Template Library (STL).^([11](ch02.xhtml#idm45043118832496)) One
    part of the STL philosophy is to loosely couple the different pieces of functionality
    and promote reuse by separating concerns as free functions. That’s why containers
    and algorithms are two separate concepts within the STL: conceptually, containers
    don’t know about the algorithms, and algorithms don’t know about containers. The
    abstraction between them is accomplished via iterators that allow you to combine
    the two in seemingly endless ways. A truly remarkable design. Or to say it in
    the words of Scott Meyers:^([12](ch02.xhtml#idm45043118831152))'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点在亚历山大·斯特帕诺夫的杰作、标准模板库（STL）中表现得淋漓尽致。[^11] STL 哲学的一部分是通过将不同功能模块松散耦合并通过将关注点分离为自由函数来促进重用。这就是为什么在STL中，容器和算法是两个独立的概念：从概念上讲，容器不知道算法，算法也不知道容器。它们之间的抽象是通过迭代器实现的，允许你以看似无限的方式组合这两者。这是一个非常值得注意的设计。或者用斯科特·迈尔斯的话来说：[^12]
- en: There was never any question that the [standard template] library represented
    a breakthrough in efficient and extensible design.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标准模板库从未被怀疑过代表了高效和可扩展设计的突破。
- en: '“But what about `std::string`? `std::string` comes with dozens of member functions,
    including many algorithms.” You’re making a good point, but more in the sense
    of a counter example. Today the community agrees that the design of `std::string`
    is not great. Its design promotes coupling, duplication, and growth: in every
    new C++ standard, there are a couple of new, additional member functions. And
    growth means modifications and subsequently the risk of accidentally changing
    something. This is a risk that you want to avoid in your design. However, in its
    defense, `std::string` was not part of the original STL. It was not designed alongside
    the STL containers (`std::vector`, `std::list`, `std::set`, etc.) and was adapted
    to the STL design only later. That explains why it’s different from the other
    STL containers and does not completely share their beautiful design goal.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “但`std::string`呢？ `std::string`自带几十个成员函数，包括许多算法。” 你提出了一个很好的观点，但更多的是作为一个反例。如今，社区一致认为`std::string`的设计并不理想。它的设计促进了耦合、重复和增长：在每一个新的C++标准中，都会有一些新的额外成员函数。增长意味着修改，随之而来的是意外更改的风险。这是你在设计中要避免的风险。然而，作为其辩护，`std::string`并不是STL的原始部分。它并未与STL容器（`std::vector`、`std::list`、`std::set`等）一同设计，并且后来才适应了STL的设计。这解释了为什么它与其他STL容器不同，并且并不完全分享它们美丽的设计目标。
- en: 'The Problem of Free Functions: Expectations on the Behavior'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自由函数的问题：对行为的期望
- en: Apparently, free functions are remarkably powerful and seriously important for
    generic programming. They play a vital role in the design of the STL and the design
    of the C++ Standard Library as a whole, which builds on the power of this abstraction
    mechanism.^([13](ch02.xhtml#idm45043118788608)) However, all of this power can
    only work if a set of overload functions adheres to a set of rules and certain
    expectations. It can only work if it adheres to the LSP.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，自由函数在通用编程中非常强大且非常重要。它们在STL的设计和整个C++标准库的设计中发挥着至关重要的作用，这建立在这种抽象机制的力量之上。^([13](ch02.xhtml#idm45043118788608))
    然而，所有这些力量只有在一组重载函数遵循一组规则和特定的期望时才能发挥作用。只有它遵循LSP时才能发挥作用。
- en: 'For instance, let’s imagine that you have written your own `Widget` type and
    want to provide a custom `swap()` operation for it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你已经为自己编写了一个`Widget`类型，并想为其提供一个定制的`swap()`操作：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Your `Widget` only needs to be a simple wrapper for `int` values, called `i`
    and `j`. You provide the corresponding `swap()` function as an accompanying free
    function. And you implement `swap()` by swapping only the `i` value, not the `j`
    value. Further imagine that your `Widget` type is used by some other developer,
    maybe a kind coworker. At some point, this coworker calls the `swap()` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Widget`只需是一个简单的包装器，用于`int`值，称为`i`和`j`。你提供了相应的`swap()`函数作为一个附带的自由函数。你通过仅交换`i`值而不是`j`值来实现`swap()`。进一步想象一下，你的`Widget`类型被其他开发者使用，也许是一个友好的同事。在某个时刻，这个同事调用了`swap()`函数：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Can you imagine the surprise of your coworker when after the `swap()` operation
    the content of `w1` is not `(2,22)` but `(2,11)` instead? How unexpected is it
    that only part of the object is swapped? Can you imagine how frustrated your coworker
    must be after an hour of debugging? And what would happen if this wasn’t a *kind*
    coworker?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象当`swap()`操作后，`w1`的内容不是`(2,22)`而是`(2,11)`时你同事的惊讶吗？仅交换对象的部分内容是多么意外的事情？你能想象你的同事在一个小时的调试后会有多么沮丧吗？如果这不是一个*友好*的同事会发生什么呢？
- en: Clearly, the implementation of `swap()` doesn’t fulfill the expectations of
    a `swap()` function. Clearly, anyone would expect that the entire observable state
    of the object is swapped. Clearly, there are behavioral expectations. Thus, if
    you buy into an overload set, you’re immediately and inevitably subject to fulfill
    the expected behavior of the overload set. In other words, you have to adhere
    to the LSP.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`swap()`函数的实现并未满足`swap()`函数的期望。显然，任何人都会期望整个可观察状态的对象被交换。显然，这里有行为期望。因此，如果你接受重载集，你立即且不可避免地要遵循重载集的预期行为。换句话说，你必须遵循LSP。
- en: '“I see the problem, I get that. I promise to adhere to the LSP,” you say. That’s
    great, and this is an honorable intention. The problem is that it might not always
    be entirely clear what the expected behavior is, especially for an overload set
    that is scattered across a big codebase. You might not know about all the expectations
    and all the details. Thus sometimes, even if you’re aware of this problem and
    pay attention, you might still not do the “right” thing. This is what several
    people in the community are worried about: the unrestricted ability to add potentially
    LSP-violating functionality into an overload set.^([14](ch02.xhtml#idm45043118634976))
    And as stated before, it’s easy to do. Anyone, anywhere, can add free functions.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: “我明白问题，我理解了。我承诺遵守LSP规则”，你说道。这非常好，这是一个光荣的意图。问题在于，可能并不总是完全清楚预期的行为是什么，特别是对于散布在庞大代码库中的重载集。你可能不知道所有的期望和所有的细节。因此，有时即使你意识到了这个问题并且关注了它，你可能仍然没有做出“正确”的事情。这就是社区中一些人担心的问题：在重载集中添加可能违反LSP的功能的不受限制的能力。^([14](ch02.xhtml#idm45043118634976))
    正如之前所述，这是很容易做到的。任何人，在任何地方，都可以添加自由函数。
- en: 'As always, every approach and every solution has advantages, and also disadvantages.
    On the one hand, it is enormously beneficial to exploit the power of overload
    sets, but on the other hand, it is potentially very difficult to do the right
    thing. These two sides of the same coin are also expressed by [Core Guideline
    C.162](https://oreil.ly/IyZwR) and [Core Guideline C.163](https://oreil.ly/8VWH1):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，每种方法和每种解决方案都有其优势，也有其缺点。一方面，充分利用重载集的力量是非常有益的，但另一方面，做正确的事情可能非常困难。这两面同一枚硬币的表达也被
    [核心指导方针 C.162](https://oreil.ly/IyZwR) 和 [核心指导方针 C.163](https://oreil.ly/8VWH1)
    所表达。
- en: Overload operations that are roughly equivalent.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重载那些大致等效的操作。
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Core Guideline C.162
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 核心指导方针 C.162
- en: Overload only for operations that are roughly equivalent.
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只为大致等效的操作进行重载。
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Core Guideline C.163
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 核心指导方针 C.163
- en: Whereas C.162 expresses the advantages of having the same name for semantically
    equivalent functions, C.163 expresses the problem of having the same name for
    semantically different functions. Every C++ developer should be aware of the tension
    between these two guidelines. Additionally, to adhere to the expected behavior,
    every C++ developer is well advised to be aware of existing overload sets (`std::swap()`,
    `std::begin()`, `std::cbegin()`, `std::end()`, `std::cend()`, `std::data()`, `std::size()`,
    etc.) and to know about common naming conventions. For instance, the name `find()`
    should be used only for a function that performs a linear search over a range
    of elements. For any function that performs a binary search, the name `find()`
    would raise the wrong expectations and would not communicate the precondition
    that the range needs to be sorted. And then, of course, the names `begin()` and
    `end()` should always fulfill the expectation to return a pair of iterators that
    can be used to traverse a range. They should not start or end some kind of process.
    This task would be better performed by a `start()` and a `stop()` function.^([15](ch02.xhtml#idm45043118570624))
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 而C.162表达了为语义上等效的函数使用相同名称的优势，C.163则表达了为语义上不同的函数使用相同名称的问题。每个C++开发者都应该意识到这两个指导方针之间的紧张关系。此外，为了遵守预期的行为，每个C++开发者都应该了解现有的重载集（如
    `std::swap()`、`std::begin()`、`std::cbegin()`、`std::end()`、`std::cend()`、`std::data()`、`std::size()`
    等），并了解常见的命名约定。例如，名称 `find()` 应该仅用于执行线性搜索的函数。对于执行二分搜索的任何函数，使用名称 `find()` 将引发错误的期望，并且不会传达范围需要排序的前提条件。当然，名称
    `begin()` 和 `end()` 应该始终满足返回可以用于遍历范围的迭代器对的期望。它们不应该开始或结束某种过程。这个任务最好由 `start()`
    和 `stop()` 函数来执行。^([15](ch02.xhtml#idm45043118570624))
- en: '“Well, I agree with all these points,” you say. “However, I’m primarily using
    virtual functions, and since these cannot be implemented in terms of free functions,
    I can’t really use all of this advice on overload sets, right?” It may surprise
    you, but this advice still applies to you. Since the ultimate goal is to reduce
    dependencies, and since virtual functions may cause quite a significant amount
    of coupling, one of the goals will be to “free” these, too. In fact, in many of
    the subsequent guidelines, and perhaps most prominently in [“Guideline 19: Use
    Strategy to Isolate How Things Are Done”](ch05.xhtml#use_strategy_to_isolate_how_things_are_done)
    and [“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”](ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism),
    I will tell the story of how to extract and separate virtual functions in the
    form of, but not limited to, free functions.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，我同意所有这些观点，”你说道。“但是，我主要使用虚函数，而由于这些函数无法用自由函数实现，所以我实际上无法完全应用重载集的所有建议，对吧？”也许会让你惊讶，但这些建议仍然适用于你。因为最终目标是减少依赖关系，而虚函数可能导致相当大量的耦合，因此其中一个目标将是“释放”它们。事实上，在许多后续的准则中，也许最显著的是[“准则
    19：使用策略隔离操作方式”](ch05.xhtml#use_strategy_to_isolate_how_things_are_done)和[“准则 31：使用外部多态性进行非侵入式运行时多态性”](ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism)，我将讲述如何以自由函数的形式提取和分离虚函数，但并不限于此。
- en: 'In summary, function overloading is a powerful compile-time abstraction mechanism
    that you should not underestimate. In particular, generic programming heavily
    exploits this power. However, don’t take this power too lightly: remember that
    just as with base classes and concepts, an overload set represents a set of semantic
    requirements and thus is subject to the LSP. The expected behavior of an overload
    set must be adhered to, or things will not work well.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，函数重载是一个强大的编译时抽象机制，不容小觑。特别是，泛型编程大量利用了这种力量。然而，不要轻视这种力量：要记住，就像基类和概念一样，重载集合代表一组语义要求，因此受到LSP的约束。必须遵守重载集的预期行为，否则事情将会变得不尽如人意。
- en: 'Guideline 9: Pay Attention to the Ownership of Abstractions'
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准则 9：注意抽象的所有权
- en: 'As stated in [“Guideline 2: Design for Change”](ch01.xhtml#design_for_change),
    change is the one constant in software development. Your software should be prepared
    for change. One of the essential ingredients for dealing with change is the introduction
    of abstractions (see also [“Guideline 6: Adhere to the Expected Behavior of Abstractions”](#adhere_to_the_expected_behavior_of_abstractions)).
    Abstractions help reduce dependencies and thus make it easier to change details
    in isolation. However, there is more to introducing abstractions than just adding
    base classes or templates.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“准则 2：为变更而设计”](ch01.xhtml#design_for_change)中所述，变更是软件开发中的唯一常量。你的软件应该为变更做好准备。处理变更的一个基本要素是引入抽象（还请参阅[“准则
    6：遵循抽象的预期行为”](#adhere_to_the_expected_behavior_of_abstractions)）。抽象有助于减少依赖关系，从而更容易独立地变更细节。然而，引入抽象不仅仅是添加基类或模板这么简单。
- en: The Dependency Inversion Principle
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: The need for abstractions is also expressed by Robert Martin:^([16](ch02.xhtml#idm45043118546768))
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 需要抽象的必要性也由Robert Martin表达：^([16](ch02.xhtml#idm45043118546768))
- en: The most flexible systems are those in which source code dependencies refer
    only to abstractions, not to concretions.
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最灵活的系统是那些源代码依赖仅引用抽象而不是具体实现的系统。
- en: This piece of wisdom is commonly known as the Dependency Inversion Principle
    (DIP), which is the fifth of the SOLID principles. Simply stated, it advises that
    for the sake of dependencies, you should depend on abstractions instead of concrete
    types or implementation details. Note that this statement doesn’t say anything
    about inheritance hierarchies but only mentions abstractions in general.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这条智慧被称为依赖反转原则（DIP），它是SOLID原则中的第五条。简而言之，它建议为了依赖关系，你应该依赖于抽象而不是具体类型或实现细节。请注意，这个声明并未提到继承层次结构，而只是一般提到抽象。
- en: 'Let’s take a look at the situation illustrated in [Figure 2-1](#fig_dip_1).^([17](ch02.xhtml#idm45043118540336))
    Imagine you are implementing the logic for an automated teller machine (ATM).
    An ATM provides several kinds of operations: you can withdraw money, deposit money,
    and transfer money. Since all of these operations deal with real money, they should
    either run to full completion or, in case of any kind of error, be aborted and
    all changes rolled back. This kind of behavior (either 100% success or a complete
    rollback) is what we commonly call a *transaction*. Consequently, we can introduce
    an abstraction named `Transaction`. All abstractions (`Deposit`, `Withdrawal`,
    and `Transfer`) inherit from the `Transaction` class (depicted by the UML inheritance
    arrow).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在[图2-1](#fig_dip_1)中所示的情况。想象一下，您正在实现自动取款机（ATM）的逻辑。ATM提供几种操作：您可以取钱、存钱和转账。由于所有这些操作涉及实际资金，它们应该要么完全成功，要么在任何错误的情况下中止并回滚所有更改。这种行为（要么100%成功，要么完全回滚）是我们通常称为*事务*的。因此，我们可以引入一个名为`Transaction`的抽象。所有抽象类（`Deposit`、`Withdrawal`和`Transfer`）都继承自`Transaction`类（由UML继承箭头表示）。
- en: '![A visualization of the initially strong dependency relation between several
    transactions and a UI](assets/cpsd_0201.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![几个交易和UI之间初始强依赖关系的可视化](assets/cpsd_0201.png)'
- en: Figure 2-1\. Initial strong dependency relationship between several transactions
    and a UI
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. 几个交易和UI之间的初始强依赖关系
- en: 'All transactions are in need of input data entered by a bank customer via the
    user interface. This user interface is provided by the `UI` class, which provides
    many different functions to query for the entered data: `requestDepositAmount()`,
    `request​WithdrawalAmount()`, `requestTransferAmount()`, `informInsufficientFunds()`,
    and potentially more functions. All three abstractions directly call these functions
    whenever they need information. This relationship is depicted by the little solid
    arrow, which indicates that the abstractions depend on the `UI` class.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有交易都需要银行客户通过用户界面输入的输入数据。这个用户界面由`UI`类提供，该类提供许多不同的功能来查询输入的数据：`requestDepositAmount()`、`requestWithdrawalAmount()`、`requestTransferAmount()`、`informInsufficientFunds()`等，可能还有更多的功能。所有三个抽象类在需要信息时直接调用这些函数。这种关系由小实箭头表示，表明这些抽象类依赖于`UI`类。
- en: 'While this setup may work for some time, your trained eye might have already
    spotted a potential problem: what happens if something changes? For instance,
    what happens if a new transaction is added to the system?'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种设置可能在一段时间内有效，但您的训练眼睛可能已经发现了一个潜在的问题：如果发生了变化会怎样？例如，如果系统添加了一个新的交易怎么办？
- en: Let’s assume that we must add a `SpeedTransfer` transaction for VIP customers.
    This might require us to change and extend the `UI` class with a couple of new
    functions (for instance, `requestSpeedTransferAmount()` and `requestVIPNumber()`).
    That, in turn, also affects all of the other transactions, since they directly
    depend on the `UI` class. In the best case, these transactions simply have to
    be recompiled and retested (still, this takes time!); in the worst case, they
    might have to be redeployed in case they are delivered in separate shared libraries.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须为VIP客户添加一个`SpeedTransfer`交易。这可能需要我们改变并扩展`UI`类，添加一些新功能（例如，`requestSpeedTransferAmount()`和`requestVIPNumber()`）。这反过来也会影响所有其他交易，因为它们直接依赖于`UI`类。在最好的情况下，这些交易只需重新编译和重新测试（尽管这需要时间！）；在最坏的情况下，它们可能必须重新部署，因为它们是以单独的共享库交付的。
- en: 'The underlying reason for all of that extra effort is a broken architecture.
    All transactions indirectly depend on one another via the concrete dependency
    on the `UI` class. And that is a very unfortunate situation from an architectural
    point of view: the transaction classes reside at the high level of our architecture,
    while the `UI` class resides at the low level. In this example, the high level
    depends on the low level. And that is just wrong: in a proper architecture, this
    dependency should be inverted.^([18](ch02.xhtml#idm45043118524784))'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些额外工作背后的根本原因是一个破碎的架构。所有交易间接地通过对`UI`类的具体依赖而相互依赖。从架构角度来看，这是非常不幸的情况：交易类位于我们架构的高层，而`UI`类位于低层。在这个例子中，高层依赖低层。这是错误的：在一个合适的架构中，这种依赖关系应该被反转。^([18](ch02.xhtml#idm45043118524784))
- en: 'All transactions indirectly depend on one another due to the dependency on
    the `UI` class. Furthermore, the high level of our architecture depends on the
    low level. This is a pretty unfortunate situation indeed, a situation that we
    should resolve properly. “But that’s simple!” you say. “We just introduce an abstraction!”
    That’s exactly what Robert Martin expressed in his statement: we need to introduce
    an abstraction in order not to depend on the concrete implementation in the `UI`
    class.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有交易由于对UI类的依赖而间接依赖于彼此。此外，我们的架构高层依赖于低层。这确实是一个非常不幸的情况，一个我们应该正确解决的情况。“但这很简单！”你说。“我们只需引入一个抽象！”这正是Robert
    Martin在他的声明中表达的：我们需要引入一个抽象，以免依赖UI类的具体实现。
- en: 'However, a single abstraction wouldn’t solve the problem. The three kinds of
    transactions would still be indirectly coupled. No, as [Figure 2-2](#fig_dip_2)
    illustrates, we need three abstractions: one for each transaction.^([19](ch02.xhtml#idm45043118521184))'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个单一的抽象并不能解决问题。三种交易仍然会间接耦合。不，正如[图2-2](#fig_dip_2)所示，我们需要三个抽象：每个交易一个。^([19](ch02.xhtml#idm45043118521184))
- en: '![A visualization of the relaxed dependency relation between several transactions
    and a UI](assets/cpsd_0202.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![可视化图像，放松了几个交易与UI之间的依赖关系](assets/cpsd_0202.png)'
- en: Figure 2-2\. The relaxed dependency relationship between several transactions
    and a UI
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2\. 几个交易与UI之间放松的依赖关系
- en: By introducing the `DepositUI`, `WithdrawalUI`, and `TransferUI` classes, we’ve
    broken the dependency among the three transactions. The three transactions are
    no longer dependent on the concrete `UI` class, but on a lightweight abstraction
    that represents only those operations that the relevant transaction truly requires.
    If we now introduce the `SpeedTransfer` transaction, we can also introduce the
    `SpeedTransferUI` abstraction, so none of the other transactions will be affected
    by the changes introduced in the `UI` class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入DepositUI、WithdrawalUI和TransferUI类，我们打破了三个交易之间的依赖关系。这三个交易不再依赖具体的UI类，而是依赖一个轻量级的抽象，该抽象仅表示相关交易真正需要的操作。如果我们现在引入SpeedTransfer交易，我们也可以引入SpeedTransferUI抽象，这样其他交易不会受到UI类引入的更改的影响。
- en: “Oh, yes, I get it! This way we have fulfilled three design principles!” You
    sound impressed. “We’ve introduced an abstraction to cut the dependency on the
    implementation details of the user interface. That must be the DIP. And we’ve
    followed the ISP and removed the dependencies among the different transactions.
    And as a bonus, we have also nicely grouped the things that truly belong together.
    That’s the SRP, right? That’s amazing! Let’s celebrate!”
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，是的，我明白了！这样我们就满足了三个设计原则！” 你听起来很印象深刻。“我们引入了一个抽象来削减对用户界面实现细节的依赖。那一定是DIP。而且我们遵循了ISP，并且移除了不同交易之间的依赖。作为奖励，我们还很好地将真正属于一起的东西进行了分组。这就是SRP，对吧？太棒了！让我们来庆祝一下！”
- en: Wait, wait, wait…Before you go off to uncork your best bottle of champagne to
    celebrate solving this dependency problem, let’s take a closer look at the problem.
    So yes, you are correct, we follow the ISP by separating the concerns of the `UI`
    class. By segregating it into three client-specific interfaces, we’ve resolved
    the dependency situation among the three transactions. This is indeed the ISP.
    Very nice!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，等等……在你跑去开香槟庆祝解决这个依赖问题之前，让我们仔细看看问题。没错，你是对的，我们通过将UI类分离为三个特定于客户端的接口，来遵循ISP分离关注点。通过这种方式，我们解决了三个交易之间的依赖情况。这确实是ISP。非常好！
- en: 'Unfortunately, we haven’t resolved our architectural problem yet, so no, we
    do not follow the DIP (yet). But I get the misunderstanding: it does appear as
    if we have inverted the dependencies. [Figure 2-3](#fig_dip_3) shows that we have
    really introduced an inversion of dependencies: instead of depending on the concrete
    `UI` class, we now depend on abstractions.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们还没有解决我们的架构问题，所以不，我们还没有遵循DIP（尽管）。但我理解了误解：看起来我们确实反转了依赖关系。[图2-3](#fig_dip_3)显示我们确实引入了依赖关系的反转：现在我们不再依赖具体的UI类，而是依赖抽象。
- en: '![Visualization of the local inversion of dependencies by introduction of three
    abstract UI classes](assets/cpsd_0203.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![可视化图像，通过引入三个抽象UI类局部反转依赖关系](assets/cpsd_0203.png)'
- en: Figure 2-3\. The local inversion of dependencies by introduction of three abstract
    UI classes
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. 通过引入三个抽象UI类局部反转依赖关系
- en: However, what we have introduced is a *local* inversion of dependencies. Yes,
    a local inversion only, not a global inversion. From an architectural point of
    view, we still have a dependency from the high level (our transaction classes)
    to the low level (our UI functionality). So no, it is not enough to *just* introduce
    an abstraction. It’s also important to consider *where* to introduce the abstraction.
    Robert Martin expressed this with the following two points:^([20](ch02.xhtml#idm45043118499872))
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们引入的是一个 *局部* 依赖倒置。是的，仅仅是局部的倒置，而不是全局的倒置。从架构的角度来看，我们仍然有一个从高层次（我们的事务类）到低层次（我们的UI功能）的依赖。因此，仅仅引入一个抽象是不够的。还重要的是考虑
    *在哪里* 引入这个抽象。Robert Martin用以下两点表达了这一点：^([20](ch02.xhtml#idm45043118499872))
- en: High-level modules should not depend on low-level modules. Both should depend
    on abstractions.
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高层次模块不应依赖于低层次模块。两者都应依赖于抽象。
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Abstractions should not depend on details. Details should depend on abstractions.
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象不应依赖于细节。细节应依赖于抽象。
- en: 'The first point clearly expresses an essential property of an architecture:
    the high level, i.e., the stable part(s) of our software, should not depend on
    the low level, i.e., the implementation details. That dependency should be inverted,
    meaning that the low level should depend on the high level. Luckily, the second
    point gives us an idea how to achieve that: we assign the three abstractions to
    the high level. [Figure 2-4](#fig_dip_4) illustrates the dependencies when we
    consider abstractions part of the high level.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个观点清楚地表达了架构的一个关键属性：即高层次，即我们软件的稳定部分，不应依赖于低层次，即实现细节。该依赖关系应该被倒置，意味着低层次应该依赖于高层次。幸运的是，第二个观点给了我们一个实现的思路：我们将三个抽象分配给高层次。[图 2-4](#fig_dip_4)
    描述了当我们将抽象视为高层次的一部分时的依赖关系。
- en: '![Visualization of the inversion of dependencies by assigning the three abstractions
    to the high level](assets/cpsd_0204.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![通过将三个抽象分配给高层次实现依赖倒置的可视化](assets/cpsd_0204.png)'
- en: Figure 2-4\. Inversion of dependencies by assigning the abstractions to the
    high level
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. 通过将抽象分配给高层次实现依赖倒置
- en: 'By assigning the abstractions to the high level and by making the high level
    the owner of the abstractions, we truly follow the DIP: all arrows now run from
    the low level to the high level. Now we do have a proper architecture.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将抽象分配给高层次，并使高层次成为抽象的所有者，我们真正遵循了DIP：所有箭头现在都从低层次指向高层次。现在我们确实有了一个合适的架构。
- en: “Wait a second!” You look a little confused. “That’s it? All we need is to perform
    a mental shift of the architectural boundary?” Well, it may very well be more
    than just a mental shift. This may result in moving the dependent header files
    for the UI classes from one module to another and also completely rearranging
    the dependent include statements. It’s not just a mental shift—it is a reassignment
    of ownership.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下！”你看起来有些困惑。“就这样？我们所需要的只是进行一次架构边界的思维转变？”嗯，这很可能不仅仅是一次思维转变。这可能导致将UI类的依赖头文件从一个模块移动到另一个模块，并完全重新排列依赖的包含语句。这不仅仅是一次思维转变——这是所有权的重新分配。
- en: “But now we no longer group the things that belong together,” you argue. “The
    user interface functionality is now spread across both levels. Isn’t that a violation
    of the SRP?” No, it isn’t. On the contrary, only after assigning the abstractions
    to the high level do we now properly follow the SRP. It’s not the `UI` classes
    that belong together; it’s the transaction classes and the dependent `UI` abstractions
    that should be grouped together. Only in this way can we steer the dependency
    in the right direction; only in this way do we have an architecture. Thus, for
    a proper dependency inversion, the abstraction *must* be owned by the high level.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: “但现在我们不再把那些应该放在一起的东西分组了，”你反驳道。“用户界面功能现在分布在两个层次上。这不是违反了单一职责原则吗？”不，不是的。相反，在将抽象分配给高层次之后，我们现在才真正遵循了单一职责原则。应该被分组在一起的不是`UI`类，而是事务类和依赖的`UI`抽象。只有这样，我们才能正确引导依赖关系；只有这样，我们才有了一个架构。因此，为了正确的依赖倒置，抽象
    *必须* 属于高层次。
- en: Dependency Inversion in a Plug-In Architecture
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置在插件架构中
- en: 'Perhaps this fact makes more sense if we consider the situation depicted in
    [Figure 2-5](#fig_dip_5). Imagine you have created the next-generation text editor.
    The core of this new text editor is represented by the `Editor` class on the lefthand
    side. To ensure that this text editor will be successful, you want to make sure
    that the fan community can participate in the development. Therefore, one vital
    ingredient for your success is the ability of the community to add new functionality
    in the form of plug-ins. However, the initial setting is pretty flawed from an
    architectural point of view and will hardly satisfy your fan community: the `Editor`
    directly depends on the concrete `VimMode​Plu⁠gin` class. Since the `Editor` class
    is part of the high level of the architecture, which you should consider as your
    own realm, the `VimMode​Plugin` is part of the low level of the architecture,
    which is the realm of your fan community. Since the `Editor` directly depends
    on the `VimMode​Plu⁠gin`, and because that essentially means that your community
    can define their interfaces as they please, you would have to change the editor
    for every new plug-in. As much as you love to work on your brainchild, there’s
    only so much time you can devote to adapting to different kinds of plug-ins. Unfortunately,
    your fan community will soon be disappointed and move on to another text editor.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或许，如果我们考虑[图 2-5](#fig_dip_5)中描述的情景，这个事实会更加有意义。想象一下，你创建了下一代文本编辑器。这款新文本编辑器的核心在左侧由`Editor`类表示。为了确保这款文本编辑器能够成功，你希望粉丝社区能够参与开发。因此，你成功的关键因素之一是社区能够以插件形式添加新功能。然而，从架构的角度来看，初始设置相当有缺陷，几乎无法满足你的粉丝社区：`Editor`直接依赖于具体的`VimMode​Plu⁠gin`类。由于`Editor`类属于架构的高层，你应该将其视为自己的领域，而`VimMode​Plugin`则属于架构的低层，这是你的粉丝社区的领域。由于`Editor`直接依赖于`VimMode​Plu⁠gin`，这基本上意味着你的社区可以按照他们的意愿定义接口，你必须为每个新的插件更改编辑器。尽管你很乐意为你的心血之作工作，但适应不同类型的插件的时间是有限的。不幸的是，你的粉丝社区很快就会感到失望，转而使用其他文本编辑器。
- en: '![Visualization of a broken plug-in architecture: the high-level +Editor+ class
    depends on the low-level +VimModePlugin+ class](assets/cpsd_0205.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![破损的插件架构可视化：高层的+Editor+类依赖低层的+VimModePlugin+类](assets/cpsd_0205.png)'
- en: 'Figure 2-5\. Broken plug-in architecture: the high-level `Editor` class depends
    on the low-level `VimModePlugin` class'
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 破损的插件架构：高层`Editor`类依赖低层`VimModePlugin`类
- en: Of course, that shouldn’t happen. In the given `Editor` example, it certainly
    isn’t a good idea to make the `Editor` class depend on all the concrete plug-ins.
    Instead, you should reach for an abstraction, for instance, in the form of a `Plugin`
    base class. The `Plugin` class now represents the abstraction for all kinds of
    plug-ins. However, it doesn’t make sense to introduce the abstraction in the low
    level of the architecture (see [Figure 2-6](#fig_dip_6)). Your `Editor` would
    still depend on the whims of your fan community.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种情况是不应该发生的。在给定的`Editor`示例中，让`Editor`类依赖所有具体插件的做法显然不明智。相反，你应该使用抽象概念，例如`Plugin`基类的形式。现在，`Plugin`类代表了所有类型插件的抽象。然而，在架构的低层引入这种抽象是没有意义的（参见[图 2-6](#fig_dip_6)）。你的`Editor`仍然依赖于粉丝社区的心血来潮。
- en: '![Visualization of a broken plug-in architecture: the high-level +Editor+ class
    depends on the low-level +Plugin+ class](assets/cpsd_0206.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![破损的插件架构可视化：高层的+Editor+类依赖低层的+Plugin+类](assets/cpsd_0206.png)'
- en: 'Figure 2-6\. Broken plug-in architecture: the high-level `Editor` class depends
    on the low-level `Plugin` class'
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 破损的插件架构：高层`Editor`类依赖低层`Plugin`类
- en: 'This misdirected dependency also becomes apparent when looking at the source
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看源代码时，这种误导性的依赖关系也变得显而易见：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only way to build a proper plug-in architecture is to assign the abstraction
    to the high level. The abstraction *must* belong to *you*, not to your fan community.
    [Figure 2-7](#fig_dip_7) demonstrates that this resolves the architectural dependency
    and frees your `Editor` class from the dependencies on plug-ins. This resolves
    both the DIP, because the dependency is properly inverted, and the SRP, because
    the abstraction belongs to the high level.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 建立正确的插件架构的唯一方法是将抽象分配给高层。抽象*必须*属于*你*，而不是属于你的粉丝社区。[图 2-7](#fig_dip_7)展示了这样做如何解决架构依赖，并解放了`Editor`类对插件的依赖。这同时解决了DIP，因为依赖关系被正确地反转了，以及SRP，因为抽象属于高层。
- en: '![Visualization of a correct plug-in architecture: the low-level +VimModePlugin+
    class depends on the high-level +Plugin+ class](assets/cpsd_0207.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![正确的插件架构可视化：低级别的 +VimModePlugin+ 类依赖于高级别的 +Plugin+ 类](assets/cpsd_0207.png)'
- en: 'Figure 2-7\. Correct plug-in architecture: the low-level `VimModePlugin` class
    depends on the high-level `Plugin` class'
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. 正确的插件架构：低级别的 `VimModePlugin` 类依赖于高级别的 `Plugin` 类
- en: 'A look at the source code reveals that the direction of dependencies has been
    fixed: the `VimModePlugin` depends on your code, and not vice versa:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查看源代码发现，依赖方向已经固定：`VimModePlugin` 依赖于你的代码，而不是相反的：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Again, to get a proper dependency inversion, the abstraction must be owned
    by the high level. In this context, the `Plugin` class represents the set of requirements
    that needs to be fulfilled by all plug-ins (see again [“Guideline 6: Adhere to
    the Expected Behavior of Abstractions”](#adhere_to_the_expected_behavior_of_abstractions)).
    The `Editor` defines and thus owns these requirements. It doesn’t depend on them.
    Instead, the different plug-ins depend on the requirements. That is dependency
    inversion. Hence, the DIP is not just about the introduction of an abstraction
    but also about the ownership of that abstraction.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '再次强调，要实现适当的依赖反转，抽象必须由高层拥有。在这种情况下，`Plugin` 类代表了所有插件需要满足的要求集合（再次参见 [“Guideline
    6: Adhere to the Expected Behavior of Abstractions”](#adhere_to_the_expected_behavior_of_abstractions)）。`Editor`
    定义并拥有这些要求，而不是依赖它们。不同的插件依赖于这些要求。这就是依赖反转。因此，DIP 不仅仅是引入抽象的概念，也涉及对该抽象的所有权问题。'
- en: Dependency Inversion via Templates
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过模板实现依赖反转
- en: 'So far I might have given you the impression that the DIP is concerned with
    only inheritance hierarchies and base classes. However, dependency inversion is
    also achieved with templates. In that context, however, the question of ownership
    is resolved automatically. As an example, let’s consider the `std::copy_if()`
    algorithm:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我可能给你的印象是 DIP 只涉及继承层次和基类。然而，依赖反转也可以通过模板实现。在这种情况下，所有权问题会自动解决。例如，让我们考虑 `std::copy_if()`
    算法：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This `copy_if()` algorithm also adheres to the DIP. The dependency inversion
    is achieved with the concepts `InputIt`, `OutputIt`, and `UnaryPredicate`. These
    three concepts represent the requirements on the passed iterators and predicates
    that need to be fulfilled by calling code. By specifying these requirements through
    concepts, i.e., by owning these concepts, `std::copy_if()` makes other code depend
    on itself and does not itself depend on other code. This dependency structure
    is depicted in [Figure 2-8](#fig_dip_algorithms): both containers and predicates
    depend on the requirements expressed by the corresponding algorithm. Thus, if
    we consider the architecture within the Standard Library, then `std::copy_if()`
    is part of the high level of the architecture, and containers and predicates (function
    objects, lambdas, etc.) are part of the low level of the architecture.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy_if()` 算法也遵循了 DIP。依赖反转通过概念 `InputIt`、`OutputIt` 和 `UnaryPredicate` 实现。这三个概念代表了传递的迭代器和谓词需要满足调用代码的要求。通过概念指定这些要求，即通过拥有这些概念，`std::copy_if()`
    使其他代码依赖于它自身，而不是它自己依赖于其他代码。该依赖结构在 [Figure 2-8](#fig_dip_algorithms) 中描述：容器和谓词都依赖于对应算法表达的要求。因此，如果我们考虑标准库内部的架构，那么
    `std::copy_if()` 就是架构的高层，而容器和谓词（函数对象、lambda 等）则是架构的低层。'
- en: '![Visualization of the dependency structure of STL algorithms](assets/cpsd_0208.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![STL 算法依赖结构的可视化](assets/cpsd_0208.png)'
- en: Figure 2-8\. Dependency structure of the STL algorithms
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-8\. STL 算法的依赖结构
- en: Dependency Inversion via Overload Sets
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过重载集实现依赖反转
- en: 'Inheritance hierarchies and concepts are not the only means to invert dependencies.
    Any kind of abstraction is able to do so. Therefore, it shouldn’t come as a surprise
    that overload sets also enable you to follow the DIP. As you have seen in [“Guideline
    8: Understand the Semantic Requirements of Overload Sets”](#understand_the_semantic_requirements_of_overload_sets),
    overload sets represent an abstraction and, as such, a set of semantic requirements
    and expectations. In comparison to base classes and concepts, though, there is
    unfortunately no code that explicitly describes the requirements. But if these
    requirements are owned by a higher level in your architecture, you can achieve
    dependency inversion. Consider, for instance, the following `Widget` class template:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 继承层次结构和概念并不是倒置依赖的唯一手段。任何形式的抽象都能实现这一点。因此，应该不会感到意外，过载集也能帮助你遵循DIP。正如你在[“指南8：理解过载集的语义要求”](#understand_the_semantic_requirements_of_overload_sets)中看到的那样，过载集代表了一种抽象，因此也代表了一组语义要求和期望。然而，与基类和概念相比，遗憾的是没有明确描述这些要求的代码。但是，如果这些要求由架构的更高层级拥有，你就可以实现依赖反转。例如，考虑以下`Widget`类模板：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Widget` owns a data member of an unknown type `T`. Despite the fact that `T`
    is unknown, it is possible to implement a custom `swap()` function for `Widget`
    by building on the semantic expectations of the `swap()` function. This implementation
    works, as long as the `swap()` function for `T` adheres to all expectations for
    `swap()` and follows the LSP:^([21](ch02.xhtml#idm45043118079056))'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget`拥有一个未知类型`T`的数据成员。尽管`T`是未知的，但可以通过依赖于`swap()`函数的语义期望来为`Widget`实现一个自定义的`swap()`函数。只要`T`的`swap()`函数符合所有`swap()`函数的期望并遵循LSP[^21]，这个实现就可以工作。'
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In consequence, the `Widget` `swap()` function itself follows the expectations
    and adds to the overload set, similar to what a derived class would do. The dependency
    structure for the `swap()` overload set is shown in [Figure 2-9](#fig_dip_swap).
    Since the requirements, or the expectations, for the overload set are part of
    the high level of the architecture, and since any implementation of `swap()` depends
    on these expectations, the dependency runs from the low level toward the high
    level. The dependency is therefore properly inverted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，`Widget`的`swap()`函数本身符合期望并添加到过载集中，类似于派生类的作用。`swap()`过载集的依赖结构显示在[图2-9](#fig_dip_swap)中。由于过载集的要求或期望属于架构的高层级，并且由于`swap()`的任何实现都依赖于这些期望，因此依赖关系从低层级向高层级正确地反转了。
- en: '![Visualization of the dependency structure of the +swap()+ overload set](assets/cpsd_0209.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![可视化`swap()`过载集的依赖结构](assets/cpsd_0209.png)'
- en: Figure 2-9\. Dependency structure of the `swap()` overload set
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-9：`swap()`过载集的依赖结构
- en: Dependency Inversion Principle Versus Single-Responsibility Principle
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖反转原则与单一责任原则的对比
- en: As we have seen, the DIP is fulfilled by properly assigning ownership and by
    properly grouping the things that truly belong. From that perspective, it sounds
    plausible to consider the DIP as just another special case of the SRP (similar
    to the ISP). However, hopefully you see that the DIP is more than that. As the
    DIP, in contrast to the SRP, is very much concerned with the architectural point
    of view, I consider it a vital piece of advice to build proper global dependency
    structures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的观察，通过正确分配所有权并正确分组真正属于的东西，便能实现依赖反转原则（DIP）。从这个角度来看，认为DIP只是SRP的另一种特例听起来似乎是合理的（类似于ISP）。然而，希望你能看到DIP不仅仅是这样。与SRP不同，DIP非常关注架构的视角，我认为它是建立正确的全局依赖结构的重要建议。
- en: To summarize, in order to build a proper architecture with a proper dependency
    structure, it’s essential to pay attention to the ownership of abstractions. Since
    abstractions represent requirements on the implementations, they should be part
    of the high level to steer all dependencies toward the high level.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，为了构建具有正确依赖结构的适当架构，关注抽象的所有权至关重要。由于抽象代表了对实现的要求，它们应该成为高层级的一部分，以便将所有依赖关系引导到高层级。
- en: 'Guideline 10: Consider Creating an Architectural Document'
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   指南10：考虑创建架构文档'
- en: 'Let’s chat a little about your architecture. Let me start with a very simple
    question: do you have an architectural document? Any plan or description that
    summarizes the major points and fundamental decisions of your architecture and
    that shows the high levels, the low levels, and the dependencies between them?
    If your answer is yes, then you’re free to skip this guideline and continue with
    the next one. If your answer is no, however, then let me ask a few follow-up questions.
    Do you have a *Continuous Integration* (CI) environment? Do you use automated
    tests? Do you apply static code analysis tools? All yes? Good, there’s still hope.
    The only remaining question is: why don’t you have an architectural document?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微聊一下你们的架构。让我从一个非常简单的问题开始：你们有架构文档吗？任何总结架构的主要要点和基本决策，展示高层次、低层次及它们之间依赖关系的计划或描述？如果你的答案是肯定的，那么你可以跳过这个指南，继续下一个。然而，如果你的答案是否定的，那么让我问几个后续问题。你们有*持续集成*（CI）环境吗？你们使用自动化测试吗？你们使用静态代码分析工具吗？都是肯定的？很好，还有希望。唯一剩下的问题是：为什么你们没有架构文档呢？
- en: '“Oh, come on, don’t turn a mosquito into an elephant. A missing architectural
    document is not the end of the world! After all, we are Agile, we can change things
    quickly!” Imagine my completely blank expression, followed by a long sigh. Well,
    honestly, I was afraid this would be your explanation. It’s unfortunately what
    I hear far too often. There may be a misunderstanding: the ability to quickly
    change things is not the point of an Agile methodology. Sadly, I also have to
    tell you that your answer doesn’t make any sense. You could just as well have
    answered with “After all, we like chocolate!” or “After all, we wear carrots around
    our necks!” To explain what I mean, I will quickly summarize the point of the
    Agile methodology and then subsequently explain why you should invest in an architectural
    document.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，拜托，别小题大做。缺少架构文档并不是世界末日！毕竟，我们是敏捷的，我们可以快速改变事物！” 想象一下我的完全空白的表情，然后是一个长长的叹息。好吧，老实说，我很担心这会是你的解释。不幸的是，这是我经常听到的。可能存在误解：快速改变事物并不是敏捷方法的要点。遗憾的是，我还得告诉你，你的回答毫无意义。你也可以回答“毕竟，我们喜欢巧克力！”或者“毕竟，我们在脖子上戴胡萝卜！”来解释我的意思，我将快速概述敏捷方法的要点，然后解释为什么你应该投资于架构文档。
- en: 'The expectation that Agile methods help to change things quickly is pretty
    widespread. However, as several authors in the recent past have clarified, the
    major, and probably only, point of the Agile methodology is to get quick feedback.^([22](ch02.xhtml#idm45043117917248))
    In Agile methods, the entire software development process is built around it:
    quick feedback due to business practices (such as planning, small releases, and
    acceptance tests), quick feedback due to team practices (e.g., collective ownership,
    CI, and stand-up meetings), and quick feedback due to technical practices (such
    as test-driven development, refactoring, and pair programming). However, contrary
    to popular belief, the quick feedback does not mean that you can change your software
    quickly and easily. Though quick feedback is, of course, key to quickly knowing
    that something has to be done, you gain the ability to quickly change your software
    only with good software design and architecture. These two save you the Herculean
    effort to change things; quick feedback only tells you something is broken.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于敏捷方法能快速改变事物的期望非常普遍。然而，正如近期几位作者所澄清的那样，敏捷方法的主要，可能也是唯一的目的是快速获取反馈。^([22](ch02.xhtml#idm45043117917248))
    在敏捷方法中，整个软件开发过程都围绕这一点构建：由于业务实践（如规划、小发布和验收测试）带来的快速反馈，由于团队实践（例如集体所有权、CI和站会），以及由于技术实践（如测试驱动开发、重构和配对编程）带来的快速反馈。然而，与普遍认为的相反，快速反馈并不意味着你可以快速轻松地改变你的软件。尽管快速反馈当然是迅速知道需要做些什么的关键，但只有良好的软件设计和架构才能使你快速改变软件，这两者可以帮你节省大量的精力去改变事物；快速反馈只是告诉你有什么东西是出了问题的。
- en: “OK, you’re right. I get your point—it is important to pay attention to good
    software design and architecture. But what’s the point of an architectural document?”
    I’m glad we agree. And that is an excellent question. I see we are making progress.
    To explain the purpose of an architectural document, let me give you another definition
    of architecture:^([23](ch02.xhtml#idm45043117913072))
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: “好吧，你说得对。我理解你的观点——关注良好的软件设计和架构是很重要的。但架构文档有什么用？”我很高兴我们达成了共识。这是个很好的问题。看来我们在取得进展。为了解释架构文档的目的，让我给你另一个关于架构的定义：^([23](ch02.xhtml#idm45043117913072))
- en: In most successful software projects, the expert developers working on that
    project have a shared understanding of the system design. This shared understanding
    is called ‘architecture.’
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在大多数成功的软件项目中，参与项目的专业开发者对系统设计有共同的理解。这种共同的理解称为‘架构’。
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ralph Johnson
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ralph Johnson
- en: 'Ralph Johnson describes *architecture* as the shared understanding of a codebase—the
    global vision. Let’s assume that there is no architectural document, nothing that
    summarizes the global picture—the global vision of your codebase. Let’s also assume
    that you believe you have a very clear idea of the architecture of your codebase.
    Then here are a few more questions: how many developers are on your team? Are
    you certain that all of these developers are familiar with the architecture in
    your head? Are you certain that all of them share the same vision? Are you certain
    that they all help you move forward *in the same direction*?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Ralph Johnson将*架构*描述为对代码库的共同理解——整体视角。让我们假设没有架构文档，没有总结代码库的整体图景——你代码库的整体视角。同时假设你认为自己对代码库的架构有非常清晰的理解。那么这里有几个问题：你团队有多少开发者？你确定所有这些开发者都熟悉你心中的架构吗？你确定他们都分享同样的愿景吗？你确定他们都会帮助你朝*同一个方向*前进吗？
- en: 'If your answers are yes, then you might not have gotten the point yet. It is
    fairly certain that every developer has different experiences and a slightly different
    terminology. It is also fairly certain that every developer sees the code differently
    and has a slightly different idea of the current architecture. And this slightly
    different view of the current state of affairs may lead to a slightly different
    vision for the future. While this might not be immediately evident over a short
    period of time, there is a good chance that surprises will happen in the long
    run. Misunderstandings. Misinterpretations. This is exactly the point of an architectural
    document: one common document that unifies the ideas, visions, and essential decisions
    in one place; helps maintain and communicate the state of the architecture; and
    helps avoid any misunderstandings.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的答案是肯定的，那么你可能还没有理解到重点。几乎可以肯定，每个开发者都有不同的经历和略有不同的术语。同样可以肯定，每个开发者对代码的看法也各不相同，并且对当前架构有略有不同的想法。而这种对当前事务状态略有不同的看法可能会导致对未来略有不同的展望。虽然这在短期内可能不明显，但长远来看，出现意外的可能性很大。误解。误解释。这正是架构文档的要点：一个统一的文档，将思想、愿景和重要决策集中在一起；帮助维护和传达架构的状态；并帮助避免任何误解。
- en: This document also preserves ideas, visions, and decisions. Imagine that one
    of your leading software architects, one of the brains behind the architecture
    of your codebase, leaves the organization. Without a document with the fundamental
    decisions, this loss of manpower will also cause a loss of essential information
    about your codebase. As a consequence, you will lose consistency in the vision
    of your architecture and also, more importantly, some confidence to adapt or change
    architectural decisions. No new hire will ever be able to replace that knowledge
    and experience, and no one will be able to extract all that information from the
    code. Thus, the code will become more rigid, more “legacy.” This promotes decisions
    to rewrite large parts of the code, with questionable outcomes, as the new code
    will initially lack a lot of the wisdom of the old code.^([24](ch02.xhtml#idm45043117907168))
    Thus, without an architectural document, your long-term success is at stake.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文档还保留了想法、愿景和决策。想象一下，你们代码库架构背后的一位主要软件架构师离开了组织。如果没有包含基本决策的文档，这种人力流失也会导致对你代码库的关键信息的丢失。因此，你将失去架构愿景的一致性，更重要的是，失去调整或更改架构决策的信心。任何新员工都无法取代那些知识和经验，也没有人能从代码中提取所有这些信息。因此，代码将变得更加僵化，更加“遗留”。这促使决策重写大部分代码，结果可能成问题，因为新代码最初将缺乏旧代码的许多智慧。^([24](ch02.xhtml#idm45043117907168))
    因此，没有架构文档，你的长期成功岌岌可危。
- en: 'The value in such an architectural document becomes obvious if we take a look
    at how seriously architecture is taken at construction sites. Construction is
    not even going to start without a plan. A plan that everyone agrees to. Or let’s
    imagine what would happen if there was no plan: “Hey, I said the garage should
    be to the left of the house!” “But I built it to the left of the house.” “Yes,
    but I meant my left, not your left!”'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们认真看待建筑工地上对架构的认真程度，这种架构文档的价值显而易见。没有计划，建筑甚至无法开始。一个所有人都同意的计划。或者让我们想象一下，如果没有计划会发生什么：“嘿，我说车库应该在房子的左边！”
    “但我把它建在房子的左边。” “是的，但我指的是我的左边，而不是你的左边！”
- en: 'This is exactly the kind of problem that can be avoided by investing time in
    an architectural document. “Yes, yes, you’re right,” you admit, “but such a document
    is *soooo* much work. And all of this information is in the code anyway. It adapts
    with the code, while the document goes out of date *soooo* quickly!” Well, not
    if you’re doing it properly. An architectural document shouldn’t go out of date
    quickly because it should primarily reflect the big picture of your codebase.
    It shouldn’t contain the little details that indeed can change very often; instead,
    it should contain the overall structure, the connections between key players,
    and the major technological decisions. All these things are not expected to change
    (although we all agree that “not expected to change” doesn’t mean that they won’t
    change; after all, *soft*ware is expected to change). And yes, you are correct:
    these details are, of course, also part of the code. After all, the code contains
    all the details and thus can be said to represent the ultimate truth. However,
    it doesn’t help if the information is not easy to come by, is hidden from plain
    sight, and requires an archaeological effort to extract.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是通过投资于架构文档可以避免的问题类型。“是的，是的，你是对的”，你承认，“但这样的文档工作量*真的*很大。而且所有这些信息都在代码中。随着代码的变化，文档变得*如此*快速过时！”嗯，如果你做得正确的话，情况就不会这样。架构文档不应该快速过时，因为它应主要反映你代码库的大局。它不应包含确实可能经常变化的细节；相反，它应包含整体结构、关键参与者之间的连接以及主要技术决策。所有这些事情不应该变化（尽管我们都同意，“不应该变化”并不意味着它们不会变化；毕竟，*软*件是预计会变化的）。是的，你说得对：这些细节当然也是代码的一部分。毕竟，代码包含所有细节，因此可以说代表了终极真理。然而，如果信息不易获取，藏匿于视线之外，并需要考古式的努力来提取，这并没有帮助。
- en: I am also aware that, in the beginning, the endeavor to create an architectural
    document does sound like a lot of work. An enormous amount of work. All I can
    do is encourage you to get started somehow. Initially, you do not have to document
    your architecture in all its glory, but maybe you start with only the most fundamental
    structural decisions. Some tools can already use this information to compare your
    assumed architectural state and its actual state.^([25](ch02.xhtml#idm45043117901616))
    Over time, more and more architectural information can be added, documented, and
    maybe even tested by tools, which leads to more and more commonly available, established
    wisdom for your entire team.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我也意识到创建架构文档的努力似乎是一项很大的工作。是一项巨大的工作。我所能做的就是鼓励你设法开始。起初，你不必在文档中展示其全部荣耀，也许你可以从只有最基本的结构决策开始。一些工具已经可以使用这些信息来比较你假设的架构状态及其实际状态。^([25](ch02.xhtml#idm45043117901616))
    随着时间的推移，可以添加、记录甚至由工具测试更多的架构信息，这将为整个团队提供越来越普遍、已确立的智慧。
- en: '“But how do I keep this document up to date?” you ask. Of course, you’ll have
    to maintain this document, integrate new decisions, update old decisions, etc.
    However, since this document should only contain information about the aspects
    that do not often change, there should be no need to constantly touch and refactor
    it. It should be enough to schedule a short meeting of the senior developers every
    one or two weeks to discuss if and how the architecture has evolved. Thus, it
    is hard to imagine this document becoming a bottleneck in the development process.
    In this regard, consider this document a bank deposit safe: it is invaluable to
    have all of the accumulated decisions of the past when you need them and to keep
    the information secure, but you wouldn’t open it every single day.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: “但是我如何保持这个文档的更新？”你问道。当然，你需要维护这个文档，整合新的决策，更新旧的决策等等。然而，由于这个文档应该只包含那些不经常变化的信息，因此没有必要经常触及和重构它。每一两周安排一次高级开发人员的简短会议来讨论架构是否发生了变化，应该足够了。因此，很难想象这个文档会成为开发过程中的瓶颈。在这方面，请将这个文档视为一个银行保险箱：当你需要时，它拥有所有积累的过去决策，保持信息安全，但你不会每天都打开它。
- en: In summary, the benefits of having an architectural document by far outweigh
    the risks and efforts. The architectural document should be considered an essential
    part of any project and an integral part of the maintenance and communication
    efforts. It should be considered equally important as a CI environment or automated
    tests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，拥有架构文档的好处远远超过了风险和努力。架构文档应被视为任何项目的基本组成部分，并且是维护和沟通工作的一部分。它应被视为与CI环境或自动化测试同等重要的组成部分。
- en: ^([1](ch02.xhtml#idm45043120890480-marker)) In one of my training classes several
    years ago, I was “gently” reminded that from a mathematical perspective, a square
    is not a rectangle but a rhombus. My knees still shake when I think about that
    lecture. Therefore, I specifically say “appears to be” instead of “is” to denote
    the naive impression that unaware people like me might have had.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm45043120890480-marker)) 在我几年前的培训班上，有人“轻柔地”提醒我，从数学的角度来看，正方形不是长方形而是菱形。每当我想到那堂课时，我的膝盖仍然在颤抖。因此，我特意说“似乎是”而不是“是”，来表示像我这样无知的人可能会有的幼稚印象。
- en: ^([2](ch02.xhtml#idm45043120674128-marker)) Not mathematically, but in this
    implementation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm45043120674128-marker)) 虽然不是从数学角度，而是在这种实现中。
- en: ^([3](ch02.xhtml#idm45043120621936-marker)) The LSP was first introduced by
    Barbara Liskov in the paper [“Data Abstraction and Hierarchy”](https://oreil.ly/Z9lu1)
    in 1988\. In 1994, it was reformulated in the paper [“A Behavioral Notion of Subtyping”](https://oreil.ly/ic7N3)
    by Barbara Liskov and Jeannette Wing. For her work, Barbara Liskov received the
    Turing Award in 2008.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm45043120621936-marker)) LSP最初由Barbara Liskov在1988年的论文[“数据抽象和层次结构”](https://oreil.ly/Z9lu1)中首次提出。1994年，Barbara
    Liskov和Jeannette Wing在论文[“子类型的行为概念”](https://oreil.ly/ic7N3)中对其进行了重新表述。由于她的工作，Barbara
    Liskov在2008年获得了图灵奖。
- en: ^([4](ch02.xhtml#idm45043119856288-marker)) If you have a strong opinion about
    a square being a rhombus, please forgive me!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm45043119856288-marker)) 如果你对正方形是菱形有强烈的看法，请原谅我！
- en: ^([5](ch02.xhtml#idm45043119792896-marker)) And yet, in a sufficiently large
    codebase, there’s a good chance that you’ll find at least one example of this
    kind of malpractice. In my experience, it’s often the result of too little time
    to rethink and adapt the abstraction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm45043119792896-marker)) 然而，在足够大的代码库中，你很有可能会找到至少一个这种类型的错误示例。根据我的经验，这通常是由于时间不足以重新思考和调整抽象而导致的。
- en: ^([6](ch02.xhtml#idm45043119546544-marker)) This is indeed a very often discussed
    topic. You’ll find a very good summary of this in [foonathan’s blog](https://oreil.ly/HiJP9).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#idm45043119546544-marker)) 这确实是一个经常讨论的话题。你可以在[foonathan的博客](https://oreil.ly/HiJP9)中找到对此的很好总结。
- en: ^([7](ch02.xhtml#idm45043119543760-marker)) In C++20, `std::copy()` is finally
    `constexpr` but does not yet use the `std::input_iterator` and `std::output_iterator`
    concepts. It is still based on the formal description of input and output iterators;
    see [LegacyInputIterator](https://oreil.ly/9vsvC) and [LegacyOutputIterator](https://oreil.ly/ZcJeU).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#idm45043119543760-marker)) 在C++20中，`std::copy()`终于是`constexpr`的，但尚未使用`std::input_iterator`和`std::output_iterator`的概念。它仍然基于输入和输出迭代器的正式描述；参见[LegacyInputIterator](https://oreil.ly/9vsvC)和[LegacyOutputIterator](https://oreil.ly/ZcJeU)。
- en: ^([8](ch02.xhtml#idm45043119253776-marker)) And no, it wouldn’t be a compile-time
    error, unfortunately.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.xhtml#idm45043119253776-marker)) 不，不幸的是，这不会是编译时错误。
- en: '^([9](ch02.xhtml#idm45043118921264-marker)) The free `begin()` and `end()`
    functions are an example of the *Adapter* design pattern; see [“Guideline 24:
    Use Adapters to Standardize Interfaces”](ch06.xhtml#use_adapters_to_standardize_interfaces)
    for more details.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '^([9](ch02.xhtml#idm45043118921264-marker)) 自由的`begin()`和`end()`函数是*适配器*设计模式的一个例子；详见[“Guideline
    24: Use Adapters to Standardize Interfaces”](ch06.xhtml#use_adapters_to_standardize_interfaces)以获取更多详情。'
- en: ^([10](ch02.xhtml#idm45043118837984-marker)) That is why range-based `for` loops
    build on the free `begin()` and `end()` functions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch02.xhtml#idm45043118837984-marker)) 这就是为什么基于范围的`for`循环建立在自由的`begin()`和`end()`函数之上。
- en: ^([11](ch02.xhtml#idm45043118832496-marker)) Alexander Stepanov and Meng Lee,
    [“The Standard Template Library”](https://oreil.ly/vgm61), October 1995.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch02.xhtml#idm45043118832496-marker)) Alexander Stepanov和Meng Lee，《*标准模板库*》（https://oreil.ly/vgm61），1995年10月。
- en: '^([12](ch02.xhtml#idm45043118831152-marker)) Scott Meyers, *Effective STL:
    50 Specific Ways to Improve Your Use of the Standard Template Library* (Addison-Wesley
    Professional, 2001).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '^([12](ch02.xhtml#idm45043118831152-marker)) Scott Meyers，《*Effective STL:
    50 Specific Ways to Improve Your Use of the Standard Template Library*》（Addison-Wesley
    Professional，2001年）。'
- en: '^([13](ch02.xhtml#idm45043118788608-marker)) Free functions are indeed a seriously
    valuable design tool. To give one example of this, allow me to tell a short war
    story. You might know Martin Fowler’s book *Refactoring: Improving the Design
    of Existing Code* (Addison-Wesley), which may be considered one of *the* classics
    for professional software development. The first edition of the book was published
    in 2012 and provided programming examples in Java. The second edition of the book
    was released in 2018, but interestingly rewritten with JavaScript. One of the
    reasons for that choice was the fact that any language having a C-like syntax
    was considered easier to digest for a majority of readers. However, another important
    reason was the fact that JavaScript, unlike Java, provides free functions, which
    Martin Fowler considers a very important tool for decoupling and separating concerns.
    Without this feature, you would be limited in your flexibility to achieve the
    refactoring goal.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch02.xhtml#idm45043118788608-marker)) 自由函数确实是一种非常宝贵的设计工具。举一个例子来说明，让我来讲一个简短的战争故事。你可能知道马丁·福勒（Martin
    Fowler）的书籍《*重构：改善已有代码的设计*》（Addison-Wesley），这本书可以被视为专业软件开发的经典之一。该书的第一版于2012年出版，并提供了Java编程示例。第二版于2018年发布，但有趣的是改用了JavaScript进行重写。选择JavaScript的一个原因是，任何具有类似C语法的语言被认为更容易被多数读者接受。然而，另一个重要原因是JavaScript与Java不同之处在于，它提供了自由函数，马丁·福勒认为这是解耦和分离关注点的重要工具之一。如果没有这个特性，你在达到重构目标时的灵活性将受到限制。
- en: ^([14](ch02.xhtml#idm45043118634976-marker)) A great discussion of this can
    be found in [episode 83 of *Cpp.Chat*](https://cpp.chat/83), where Jon Kalb, Phil
    Nash, and Dave Abrahams discuss the lessons learned from C++ and how they were
    applied in the development of the Swift programming language.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch02.xhtml#idm45043118634976-marker)) 你可以在*Cpp.Chat*的第83集中找到对此的深入讨论（https://cpp.chat/83），Jon
    Kalb、Phil Nash和Dave Abrahams在此讨论了从C++中学到的经验，并如何应用于Swift编程语言的开发中。
- en: '^([15](ch02.xhtml#idm45043118570624-marker)) As Kate Gregory would say, “Naming
    Is Hard: Let’s Do Better.” This is the title of her highly recommended talk from
    [CppCon 2019](https://oreil.ly/TLuqb).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch02.xhtml#idm45043118570624-marker)) 正如凯特·格雷戈里所说，“命名是困难的：让我们做得更好。”这是她在[CppCon
    2019](https://oreil.ly/TLuqb)上非常推荐的演讲的标题。
- en: ^([16](ch02.xhtml#idm45043118546768-marker)) Robert C. Martin, *Clean Architecture*
    (Addison-Wesley, 2017).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch02.xhtml#idm45043118546768-marker)) 罗伯特·C·马丁，《*干净架构*》（Addison-Wesley,
    2017）。
- en: '^([17](ch02.xhtml#idm45043118540336-marker)) This example is taken from Robert
    Martin’s book *Agile Software Development: Principles, Patterns, and Practices*
    (Prentice Hall, 2002). Martin used this example to explain the Interface Segregation
    Principle (ISP), and for that reason, he didn’t go into detail about the question
    of ownership of abstractions. I will try to fill this gap.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch02.xhtml#idm45043118540336-marker)) 这个例子出自罗伯特·马丁的书籍《*敏捷软件开发：原则、模式和实践*》（Prentice
    Hall, 2002）。马丁用这个例子来解释接口隔离原则（ISP），因此他没有详细讨论抽象所有权的问题。我将尝试填补这个空白。
- en: ^([18](ch02.xhtml#idm45043118524784-marker)) If you argue that the `Transaction`
    base class could be on an even higher level, you are correct. You’ve earned yourself
    a bonus point! But for the remainder of the example we won’t need this extra level,
    and therefore I will ignore it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch02.xhtml#idm45043118524784-marker)) 如果你认为`Transaction`基类可以在更高的层次上，那么你是正确的。你赢得了一个奖励点！但在接下来的例子中，我们不需要这个额外的层次，因此我将忽略它。
- en: '^([19](ch02.xhtml#idm45043118521184-marker)) If you’re wondering about the
    two `informInsufficientFunds()` functions: yes, it is possible to implement *both*
    virtual functions (i.e., the one from the `WithdrawalUI` and the one from the
    `TransferUI`) by means of a single implementation in the `UI` class. Of course,
    this works well only as long as these two functions represent the same expectations
    and thus can be implemented as one. However, if they represent different expectations,
    then you’re facing a *Siamese Twin Problem* (see Item 26 in Herb Sutter’s *More
    Exceptional C++: 40 New Engineering Puzzles, Programming Problems, and Solutions*
    (Addison-Wesley). For our example, let’s assume that we can deal with these two
    virtual functions the easy way.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch02.xhtml#idm45043118521184-marker)) 如果你对两个`informInsufficientFunds()`函数感到困惑：是的，可以通过在`UI`类中的单个实现来实现*两个*虚函数（即从`WithdrawalUI`和`TransferUI`）。当然，只有在这两个函数代表相同期望并且可以作为一个函数实现时，才能正常工作。然而，如果它们代表不同的期望，那么你将面临*连体双胞胎问题*（见Herb
    Sutter的《*更出色的C++：40个新工程谜题、编程问题和解决方案*》（Addison-Wesley），第26项）。对于我们的例子，让我们假设我们可以以简单的方式处理这两个虚函数。
- en: ^([20](ch02.xhtml#idm45043118499872-marker)) Martin, *Clean Architecture*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch02.xhtml#idm45043118499872-marker)) 马丁，《*干净架构*》。
- en: ^([21](ch02.xhtml#idm45043118079056-marker)) I know what you’re thinking. However,
    it was just a matter of time until you encountered a “Hello World” example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch02.xhtml#idm45043118079056-marker)) 我知道你在想什么。然而，你早晚会遇到一个“Hello World”的例子。
- en: '^([22](ch02.xhtml#idm45043117917248-marker)) The point is, for instance, made
    by Robert C. Martin, one of the signees of the Agile manifesto, in his book *Clean
    Agile: Back to Basics* (Pearson). A second good summary is given by Bertrand Meyer
    in *Agile! The Good, the Hype and the Ugly* (Springer). Finally, you can also
    consult the second edition of James Shore’s book [*The Art of Agile Development*](https://learning.oreilly.com/library/view/the-art-of/9781492080688/)
    (O’Reilly). A good talk on the misuse of the term *Agile* is Dave Thomas’s [“Agile
    Is Dead” presentation](https://oreil.ly/LJZN1) from GOTO 2015.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([22](ch02.xhtml#idm45043117917248-marker)) 比如，敏捷宣言的签署者之一，罗伯特·C·马丁，在他的书籍《*干净的敏捷：回归基础*》（Pearson）中已经做出了这一点。第二个很好的总结来自贝特兰·梅耶的书《*敏捷！好的、炒作的和丑陋的*》（Springer）。最后，你还可以参考詹姆斯·肖尔的第二版书籍[*《敏捷开发艺术》*](https://learning.oreilly.com/library/view/the-art-of/9781492080688/)（O’Reilly）。关于对“敏捷”术语误用的一个很好的讨论是戴夫·托马斯在GOTO
    2015年的[“敏捷已死”演讲](https://oreil.ly/LJZN1)。
- en: ^([23](ch02.xhtml#idm45043117913072-marker)) Quoted in Martin Fowler, “Who Needs
    an Architect?” *IEEE Software* 20, no. 5 (2003), 11–13, [*https://doi.org/10.1109/MS.2003.1231144*](https://doi.org/10.1109/MS.2003.1231144).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ^([23](ch02.xhtml#idm45043117913072-marker)) 引自马丁·福勒，《谁需要架构师？》*IEEE软件* 20卷5期（2003年），11-13页，[*https://doi.org/10.1109/MS.2003.1231144*](https://doi.org/10.1109/MS.2003.1231144)。
- en: ^([24](ch02.xhtml#idm45043117907168-marker)) Joel Spolsky, whom you may know
    as the author of the [*Joel on Software* blog](https://www.joelonsoftware.com),
    and also as one of the creators of Stack Overflow, named the decision to rewrite
    a large piece of code from scratch [“the single worst strategic mistake that any
    company can make”](https://oreil.ly/ndLhY).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ^([24](ch02.xhtml#idm45043117907168-marker)) 你可能知道乔尔·斯波尔斯基（Joel Spolsky）是[*Joel
    on Software* blog](https://www.joelonsoftware.com)的作者，也是Stack Overflow的创始人之一，他称重写大段代码为[“任何公司可以犯的最严重战略错误”](https://oreil.ly/ndLhY)。
- en: ^([25](ch02.xhtml#idm45043117901616-marker)) One possible tool for this purpose
    is the [Axivion Suite](https://oreil.ly/32kue). You start by defining architectural
    boundaries between your modules, which can be used by the tool to check if the
    architectural dependencies are upheld. Another tool with such capabilities is
    the [Sparx Systems Enterprise Architect](https://oreil.ly/1oC3Y).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ^([25](ch02.xhtml#idm45043117901616-marker)) 用于此目的的一种可能工具是[Axivion Suite](https://oreil.ly/32kue)。你可以开始定义模块之间的架构边界，该工具可用于检查是否保持了架构依赖关系。另一个具有此类功能的工具是[Sparx
    Systems Enterprise Architect](https://oreil.ly/1oC3Y)。
