<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Pointers and References"><div class="chapter" id="smallerc-CHP-6">
<h1><span class="label">Chapter 6. </span>Pointers and References</h1>


<p>Reasonably direct access to memory is one of C’s biggest features for
folks who work on low-level problems like device drivers or embedded systems.
C gives you the tools to micromanage your bytes. That can be a real boon when
you need to worry about every bit of free memory, but it can also be a real
pain to worry about every bit of memory you use. When you want that control,
though, it’s great to have the option. This chapter covers the basics
of finding out where things are located in <a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="explained" id="memory-address-explain"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="explained" id="address-explain"/>memory (their <em>address</em>)
as well as storing and using those locations with
<em>pointers</em>, <a data-type="indexterm" data-primary="pointers" data-secondary="explained" id="pointer-explain"/><a data-type="indexterm" data-primary="variables" data-secondary="pointers" data-see="pointers" id="idm45018724890904"/>variables that store the address of other variables.</p>






<section data-type="sect1" data-pdf-bookmark="Addresses in C"><div class="sect1" id="smallerc-CHP-6-SECT-1">
<h1>Addresses in C</h1>

<p>We’ve touched on the notion of pointers when we discussed using
<code>scanf()</code> to read in base types like integers and floats versus reading in
a string as a character array. You may recall for numbers, I mentioned the
required <code>&amp;</code> prefix. That<a data-type="indexterm" data-primary="&amp; (ampersand), variable prefix" id="idm45018724885992"/><a data-type="indexterm" data-primary="ampersand (&amp;), variable prefix" id="idm45018724885288"/> prefix can be thought of as an “address
of” the operator or function. It returns a numeric value that tells you
where the variable following the <code>&amp;</code> is located in memory. We can actually
print that location out. Take a look at
<a href="https://oreil.ly/z9TrR"><em>ch06/address.c</em></a>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;stdio.h&gt;</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">answer</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
  <code class="kt">double</code> <code class="n">pi</code> <code class="o">=</code> <code class="mf">3.1415926</code><code class="p">;</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"answer's value: %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">answer</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"answer's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">answer</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"pi's value: %0.4f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">pi</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"pi's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">pi</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>In this simple program, we create two variables and initialize them. We use a
few <code>printf()</code> statements to show both their values and their locations in memory.
If we compile and run this example, here’s what we’ll see:</p>

<pre data-type="programlisting">ch06$ gcc address.c
ch06$ ./a.out
answer's value: 42
answer's address: 0x7fff2970ee0c
pi's value: 3.1416
pi's address: 0x7fff2970ee10</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>I should say here is <em>roughly</em> what we’ll see; your setup will likely differ from mine, so the addresses likely won’t match exactly. Indeed, simply running this program successively will almost certainly result in different addresses as well. Where a program is loaded into memory depends on myriad factors. If any of those factors are different, the addresses will probably be different as well.</p>

<p>In all of the examples that follow, it is more useful to pay attention to which addresses are close to which other addresses. The exact values are not important.</p>
</div>

<p>Getting the value stored in <code>answer</code> or <code>pi</code> is straightforward and something we’ve been doing since <a data-type="xref" href="ch02.xhtml#smallerc-CHP-2">Chapter 2</a>. But playing with the address of a variable is new. We even needed a new <code>printf()</code> format specifier, <code>%p</code>, to print them! The mnemonic for that format specifier is “pointer,” which is closely related to “address.” Typically, <em>pointer</em> refers to a variable that stores an address, even though you will see people talk about a specific value as a pointer. You will also run across the term <em>reference</em>, which<a data-type="indexterm" data-primary="references" data-see="pointers" id="idm45018724825208"/> is synonymous with pointer but is more often used when talking about function parameters. For example, tutorials online will say things like “when you pass a reference to this function….” They mean you are passing the address of some variable to the function rather than the value of the variable.</p>

<p>But back to our example. Those printed pointer values sure
look like big numbers! This won’t always be the case, but on systems with gigabytes
or even terabytes of RAM that use logical addresses to help separate and manage multiple
programs, it’s not uncommon. What do those values represent? They are the slots
within our process’s memory where our variables’ values are kept.
<a data-type="xref" href="#smallerc-CHP-6-FIG-address-example">Figure 6-1</a> illustrates the basic setup in memory of our
simple example.</p>

<p>Even without figuring out the exact decimal value of the addresses, you can see they are close together. In fact, the address for <code>pi</code> is four bytes bigger than the address for <code>answer</code>. An <code>int</code> on my machine is four bytes, so hopefully you can see the connection. A <code>double</code> is eight bytes on my system. If we added a third variable to our example, can you guess what address it would have?</p>

<figure><div id="smallerc-CHP-6-FIG-address-example" class="figure">
<img src="Images/smac_0601.png" alt="smac 0601" width="568" height="250"/>
<h6><span class="label">Figure 6-1. </span>Variable values and addresses</h6>
</div></figure>

<p>Let’s go ahead and try it together. The program <a href="https://oreil.ly/6gdjU"><em>ch06/address2.c</em></a>
adds another <code>int</code> variable and then prints its value and address:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;stdio.h&gt;</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">answer</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
  <code class="kt">double</code> <code class="n">pi</code> <code class="o">=</code> <code class="mf">3.1415926</code><code class="p">;</code>
  <code class="kt">int</code> <code class="n">extra</code> <code class="o">=</code> <code class="mi">1234</code><code class="p">;</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"answer's value: %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">answer</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"answer's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">answer</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"pi's value: %0.4f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">pi</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"pi's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">pi</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"extra's value: %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">extra</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"extra's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">extra</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>And here’s the output of our three-variable version:</p>

<pre data-type="programlisting">ch06$ gcc address2.c
ch06$ ./a.out
answer's value: 42
answer's address: 0x7fff9c827498
pi's value: 3.1416
pi's address: 0x7fff9c8274a0
extra's value: 1234
extra's address: 0x7fff9c82749c</pre>

<p>Hmm, actually the variables are not stored in the order we declared them. How strange!
If you look closely, you can see that <code>answer</code> is still stored first (address 0x…498),
followed by <code>extra</code> four bytes later (0x…49c), followed by <code>pi</code> four bytes after that
(0x…4a0). The compiler will often arrange things in a way it deems efficient—and
that efficient ordering won’t always line up with our source code. So even though
the order is a little surprising, we can still see that the variables all stack on top
of each other with exactly as much space as their type <a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="explained" data-startref="memory-address-explain" id="idm45018724613368"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="explained" data-startref="address-explain" id="idm45018724611848"/><a data-type="indexterm" data-primary="pointers" data-secondary="explained" data-startref="pointer-explain" id="idm45018724610632"/>dictates.</p>








<section data-type="sect2" data-pdf-bookmark="The NULL Value and Pointer Errors"><div class="sect2" id="smallerc-CHP-6-SECT-1.1">
<h2>The NULL Value and Pointer Errors</h2>

<p>The <em>stdio.h</em> header<a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="NULL value" id="idm45018724606808"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="NULL value" id="idm45018724605528"/><a data-type="indexterm" data-primary="pointers" data-secondary="NULL value" id="idm45018724604584"/><a data-type="indexterm" data-primary="NULL value in pointers" id="idm45018724603640"/> includes a handy value, <code>NULL</code>, that we can use whenever we need to talk about an “empty” or uninitialized pointer. You can assign <code>NULL</code> to a pointer variable or use it in a comparison to see if a particular pointer is valid. If you like always assigning an initial value to your variables when you declare them, <code>NULL</code> is the value to use with pointers. For example, we could declare two variables, one <code>double</code> and one pointer to a <code>double</code>. We’ll initialize them with “nothing,” but then fill them in later:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">double</code> <code class="n">pi</code> <code class="o">=</code> <code class="mf">0.0</code><code class="p">;</code>
<code class="kt">double</code> <code class="o">*</code><code class="n">pi_ptr</code> <code class="o">=</code> <code class="nb">NULL</code><code class="p">;</code>
<code class="c1">// ...</code>
<code class="n">pi</code> <code class="o">=</code> <code class="mf">3.14156</code><code class="p">;</code>
<code class="n">pi_ptr</code> <code class="o">=</code> <code class="o">&amp;</code><code class="n">pi</code><code class="p">;</code></pre>

<p>You should check for <code>NULL</code> pointers anytime you can’t trust where a pointer came from.
Inside a function where a pointer was passed to you, for example:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">double</code> <code class="nf">messyAreaCalculator</code><code class="p">(</code><code class="kt">double</code> <code class="n">radius</code><code class="p">,</code> <code class="kt">double</code> <code class="o">*</code><code class="n">pi_ptr</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">pi_ptr</code> <code class="o">==</code> <code class="nb">NULL</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"Could not calculate area with a reference to pi!</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
    <code class="k">return</code> <code class="mf">0.0</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="n">radius</code> <code class="o">*</code> <code class="n">radius</code> <code class="o">*</code> <code class="p">(</code><code class="o">*</code><code class="n">pi_ptr</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Not the easiest way to calculate the area of a circle, of course, but the <code>if</code> statement at the beginning is a common pattern. It’s a simple guarantee that you have something to work with. If you forget to check your pointer and try dereferencing it anyway, your program will (usually) halt, and you’ll probably see an error <a data-type="indexterm" data-primary="error messages" data-secondary="empty pointers" id="idm45018724496744"/>like this:</p>

<pre data-type="programlisting">Segmentation fault (core dumped)</pre>

<p>Even if you can’t do anything about the empty pointer, if you check before
using it, you can give the user a nicer error message and avoid crashing.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Arrays"><div class="sect2" id="smallerc-CHP-6-SECT-1.2">
<h2>Arrays</h2>

<p>What <a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="for arrays" data-tertiary-sortas="arrays" id="memory-address-null"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="for arrays" data-secondary-sortas="arrays" id="address-null"/><a data-type="indexterm" data-primary="arrays" data-secondary="in memory" data-secondary-sortas="memory" id="arrays-memory"/><a data-type="indexterm" data-primary="strings" data-secondary="in memory" data-secondary-sortas="memory" id="strings-memory"/>about arrays and strings? Will those go on the stack just like simpler types?
Will they have addresses in the same general part of memory?
Let’s create a couple array variables and see where they land
and how much space they take up.
<a href="https://oreil.ly/UA5ZK"><em>ch06/address3.c</em></a>
has our arrays. I’ve added a size
printout so that we can easily verify how much space is allocated:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;stdio.h&gt;</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">char</code> <code class="n">title</code><code class="p">[</code><code class="mi">30</code><code class="p">]</code> <code class="o">=</code> <code class="s">"Address Example 3"</code><code class="p">;</code>
  <code class="kt">int</code> <code class="n">page_counts</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">78</code><code class="p">,</code> <code class="mi">49</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">50</code> <code class="p">};</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"title's value: %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">title</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"title's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">title</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"title's size: %lu</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">title</code><code class="p">));</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"page_counts' value: {"</code><code class="p">);</code>
  <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">p</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">p</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">;</code> <code class="n">p</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">" %d"</code><code class="p">,</code> <code class="n">page_counts</code><code class="p">[</code><code class="n">p</code><code class="p">]);</code>
  <code class="p">}</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">" }</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"page_counts's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">page_counts</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"page_counts's size: %lu</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">page_counts</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>And here is our output:</p>

<pre data-type="programlisting">title's value: Address Example 3
title's address: 0x7ffe971a5dc0
title's size: 30
page_counts' value: { 14 78 49 18 50 }
page_counts's address: 0x7ffe971a5da0
page_counts's size: 20</pre>

<p>The compiler rearranged our variables again, but we can see that the <code>page_counts</code> array is 20 bytes (5 x 4 bytes per <code>int</code>) and that <code>title</code> gets an address 32 bytes after <code>page_counts</code>. (You can ignore the common parts of the address and do a little math: 0xc0 – 0xa0 == 0x20 == 32.) So what’s in the extra 12 bytes? There is some overhead for an array, and the compiler has kindly made room for it. Happily, we (as programmers or as users) do not have to worry about that overhead. And as programmers we can see the compiler definitely sets aside enough room for the array<a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="for arrays" data-tertiary-sortas="arrays" data-startref="memory-address-null" id="idm45018724308424"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="for arrays" data-secondary-sortas="arrays" data-startref="address-null" id="idm45018724306632"/><a data-type="indexterm" data-primary="arrays" data-secondary="in memory" data-secondary-sortas="memory" data-startref="arrays-memory" id="idm45018724305144"/><a data-type="indexterm" data-primary="strings" data-secondary="in memory" data-secondary-sortas="memory" data-startref="strings-memory" id="idm45018724303656"/> itself.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Local Variables and the Stack"><div class="sect2" id="smallerc-CHP-6-SECT-1.3">
<h2>Local Variables and the Stack</h2>

<p>So<a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="in stack" data-tertiary-sortas="stack" id="memory-address-stack"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="in stack" data-secondary-sortas="stack" id="addresses-stack"/><a data-type="indexterm" data-primary="stack" id="stack"/><a data-type="indexterm" data-primary="local variables" data-secondary="in stack" data-secondary-sortas="stack" id="local-stack"/><a data-type="indexterm" data-primary="variables" data-secondary="scope" data-tertiary="local" id="variables-scope-local-stack"/><a data-type="indexterm" data-primary="scope of variables" data-secondary="local" data-tertiary="in stack" data-tertiary-sortas="stack" id="scope-local-stack"/> where exactly is that “room” being set aside? In the largest terms, the room
is allocated from our computer’s memory, its RAM.
In the case of variables defined
in a function (and remember from <a data-type="xref" href="ch05.xhtml#smallerc-CHP-5-SECT-7">“The main() Function”</a> that <code>main()</code> is a function),
the space is allocated on the <em>stack</em>. That’s the term for the spot in memory where all
local variables are created and kept as you make various function calls. Organizing and
maintaining these memory allocations is one of the primary jobs of your operating system.</p>

<p>Consider this next small program,
<a href="https://oreil.ly/C5xCP"><em>ch06/do_stuff.c</em></a>.
We have the <code>main()</code> function as usual,
and another function, <code>do_stuff()</code>, that, well, does stuff. Not fancy stuff, but it
still creates and prints the details of an <code>int</code> variable. Even 
<span class="keep-together">boring</span> functions
use the stack and help illustrate how function calls fit together in 
<span class="keep-together">memory</span>!</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;stdio.h&gt;</code>

<code class="kt">void</code> <code class="nf">do_stuff</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">local</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Our local variable has a value of %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">local</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"local's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">local</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">count</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Starting count at %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">count</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"count's address: %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">count</code><code class="p">);</code>
  <code class="n">do_stuff</code><code class="p">();</code>
<code class="p">}</code></pre>

<p>And here’s the output:</p>

<pre data-type="programlisting">ch06$ gcc do_stuff.c
ch06$ ./a.out
Starting count at 1
count's address: 0x7fff30f1b644
Our local variable has a value of 12
local's address: 0x7fff30f1b624</pre>

<p>You can see the addresses of <code>count</code> in <code>main()</code> and <code>local</code> in <code>do_stuff()</code> are near each
other. They are both on the stack. <a data-type="xref" href="#smallerc-CHP-6-FIG-stack-variables">Figure 6-2</a> shows the
stack with a little more 
<span class="keep-together">context</span>.</p>

<figure><div id="smallerc-CHP-6-FIG-stack-variables" class="figure">
<img src="Images/smac_0602.png" alt="smac 0602" width="764" height="294"/>
<h6><span class="label">Figure 6-2. </span>Local variables on the stack</h6>
</div></figure>

<p>This is where the name “stack” comes from: the function calls stack up.
If <code>do_stuff()</code> were to call some other function, that function’s variables
would pile on top of <code>local</code>. And when any function completes, its variables are
popped off the stack. That stacking can go on quite awhile, but not forever.
If you don’t provide a proper base case for a recursive function like those in
<a data-type="xref" href="ch05.xhtml#smallerc-CHP-5-SECT-5.1">“Recursive Functions”</a>, for example, this runaway stack allocation is what
eventually causes your program to crash.</p>

<p>You might have caught that the addresses in <a data-type="xref" href="#smallerc-CHP-6-FIG-stack-variables">Figure 6-2</a> are
actually decreasing. The start of the stack can either be at the beginning of the memory
allocated to our program and addresses will count up, or at the end of the allotted space
and addresses will count down. Which version you see depends on the architecture and operating
system. The idea of the stack and its growth, though, remains the same.</p>

<p>The stack also houses any parameters that get passed to a function as well as
any loop or other variables that get declared later in the function. Consider this
snippet:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">float</code> <code class="nf">average</code><code class="p">(</code><code class="kt">float</code> <code class="n">a</code><code class="p">,</code> <code class="kt">float</code> <code class="n">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">float</code> <code class="n">sum</code> <code class="o">=</code> <code class="n">a</code> <code class="o">+</code> <code class="n">b</code><code class="p">;</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">sum</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
      <code class="n">printf</code><code class="p">(</code><code class="s">"Warning!</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"Negative average. Be careful!</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="n">sum</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>In this snippet, the stack will include space for the following elements:</p>

<ul>
<li>
<p>the <code>float</code> return value from <code>average()</code> itself</p>
</li>
<li>
<p>the <code>float</code> parameter <code>a</code></p>
</li>
<li>
<p>the <code>float</code> parameter <code>b</code></p>
</li>
<li>
<p>the <code>float</code> local variable <code>sum</code></p>
</li>
<li>
<p>the <code>int</code> variable <code>i</code> for the loop (only if <code>sum &lt; 0</code>)</p>
</li>
</ul>

<p>The stack is pretty versatile! Pretty much anything having to do with a particular
function will get its memory from <a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="in stack" data-tertiary-sortas="stack" data-startref="memory-address-stack" id="idm45018724098776"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="in stack" data-secondary-sortas="stack" data-startref="addresses-stack" id="idm45018724097096"/><a data-type="indexterm" data-primary="stack" data-startref="stack" id="idm45018724095608"/><a data-type="indexterm" data-primary="local variables" data-secondary="in stack" data-secondary-sortas="stack" data-startref="local-stack" id="idm45018724094664"/><a data-type="indexterm" data-primary="variables" data-secondary="scope" data-tertiary="local" data-startref="variables-scope-local-stack" id="idm45018724093176"/><a data-type="indexterm" data-primary="scope of variables" data-secondary="local" data-tertiary="in stack" data-tertiary-sortas="stack" data-startref="scope-local-stack" id="idm45018724091720"/>the stack.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Global Variables and the Heap"><div class="sect2" id="smallerc-CHP-6-SECT-1.4">
<h2>Global Variables and the Heap</h2>

<p>But <a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="in heap" data-tertiary-sortas="heap" id="memory-address-heap"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="in heap" data-secondary-sortas="heap" id="addresses-heap"/><a data-type="indexterm" data-primary="heap" id="heap"/><a data-type="indexterm" data-primary="global variables" data-secondary="in heap" data-secondary-sortas="heap" id="global-heap"/><a data-type="indexterm" data-primary="variables" data-secondary="scope" data-tertiary="global" id="variables-scope-global-heap"/><a data-type="indexterm" data-primary="scope of variables" data-secondary="global" data-tertiary="in heap" data-tertiary-sortas="heap" id="scope-global-heap"/>what about global variables that are not connected to any particular function?
They get allocated in a separate part of memory called the <em>heap</em>. If “heap”
sounds a little messy, it is. Any bit of memory your program needs that isn’t part
of the stack will be in the heap. <a data-type="xref" href="#smallerc-CHP-6-FIG-stack-and-heap">Figure 6-3</a> illustrates how
to think about the stack and the heap.</p>

<figure><div id="smallerc-CHP-6-FIG-stack-and-heap" class="figure">
<img src="Images/smac_0603.png" alt="smac 0603" width="706" height="568"/>
<h6><span class="label">Figure 6-3. </span>Stack versus heap memory</h6>
</div></figure>

<p>The<a data-type="indexterm" data-primary="stack" data-secondary="heap versus" id="idm45018724075064"/><a data-type="indexterm" data-primary="heap" data-secondary="stack versus" id="idm45018724074056"/> stack and the heap share one logical lump of memory given to your program when you run it. As you make function calls, the stack will grow (down from the “top” in this case). As functions complete their call, the stack shrinks. Global variables make the heap grow (up from the “bottom”). Large arrays or other structures may also be allocated in the heap. (<a data-type="xref" href="#smallerc-CHP-6-SECT-4">“Managing Memory with Arrays”</a> in this chapter looks at how you can manually use memory in this space.) You can free up some parts of the heap to make it shrink, but global variables remain as long as your program is executing.</p>

<p>We’ll look in more detail at how these two parts of memory interact in
<a data-type="xref" href="ch09.xhtml#smallerc-CHP-9-SECT-3.2.1">“Stacks and heaps”</a>.
As both the stack and the heap grow, the free space in the middle gets smaller and smaller. If they meet, you’re in trouble. If the stack cannot grow any further, you won’t be able to call any more functions. If you call a function anyway, you will likely crash your program. Similarly, if there is no space left for the heap to grow, but you try to request some space, the computer has no choice but to halt your program.</p>

<p>Managing to stay out of this trouble is your job as the programmer. C won’t
stop you from making a mistake, but in turn, it gives you room to be quite
clever when circumstances dictate. <a data-type="xref" href="ch10.xhtml#smallerc-CHP-10">Chapter 10</a> looks at several of those circumstances on microcontrollers and discusses some tricks for navigating<a data-type="indexterm" data-primary="memory" data-secondary="addresses" data-tertiary="in heap" data-tertiary-sortas="heap" data-startref="memory-address-heap" id="idm45018724068328"/><a data-type="indexterm" data-primary="addresses (memory)" data-secondary="in heap" data-secondary-sortas="heap" data-startref="addresses-heap" id="idm45018724066568"/><a data-type="indexterm" data-primary="heap" data-startref="heap" id="idm45018724065080"/><a data-type="indexterm" data-primary="global variables" data-secondary="in heap" data-secondary-sortas="heap" data-startref="global-heap" id="idm45018724064136"/><a data-type="indexterm" data-primary="variables" data-secondary="scope" data-tertiary="global" data-startref="variables-scope-global-heap" id="idm45018724062648"/><a data-type="indexterm" data-primary="scope of variables" data-secondary="global" data-tertiary="in heap" data-tertiary-sortas="heap" data-startref="scope-global-heap" id="idm45018724061144"/> them.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Pointer Arithmetic"><div class="sect1" id="smallerc-CHP-6-SECT-2">
<h1>Pointer Arithmetic</h1>

<p>Regardless <a data-type="indexterm" data-primary="pointers" data-secondary="editing variables via" id="pointers-editing"/><a data-type="indexterm" data-primary="variables" data-secondary="editing via pointers" id="variables-editing-pointers"/><a data-type="indexterm" data-primary="editing" data-secondary="variables via pointers" id="edit-variables-pointers"/>of where your variables store their contents, C allows you to work
directly with the addresses in a powerful (and potentially dangerous) way. We
aren’t limited 
<span class="keep-together">to printing</span> out the address of a variable for simple
inspection. We can store it in another variable. And we can use that other
variable to get to the same bit of data and 
<span class="keep-together">manipulate</span> it.</p>

<p>Take a look at
<a href="https://oreil.ly/ONjNE"><em>ch06/pointer.c</em></a>
to see an example of using a variable that points
to another variable. I’ve called out a few key concepts in working
with pointers:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#</code><code class="cp">include &lt;stdio.h&gt;</code><code class="cp">
</code><code>
</code><code class="kt">int</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>  </code><code class="kt">double</code><code> </code><code class="n">total</code><code> </code><code class="o">=</code><code> </code><code class="mf">500.0</code><code class="p">;</code><code>                </code><a class="co" id="co_pointers_and_references_CO1-1" href="#callout_pointers_and_references_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
  </code><code class="kt">int</code><code> </code><code class="n">count</code><code> </code><code class="o">=</code><code> </code><code class="mi">34</code><code class="p">;</code><code>
</code><code>  </code><code class="kt">double</code><code> </code><code class="n">average</code><code> </code><code class="o">=</code><code> </code><code class="n">total</code><code> </code><code class="o">/</code><code> </code><code class="n">count</code><code class="p">;</code><code>
</code><code>  </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">The average of %d units totaling %.1f is %.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code>
</code><code>     </code><code class="n">count</code><code class="p">,</code><code> </code><code class="n">total</code><code class="p">,</code><code> </code><code class="n">average</code><code class="p">)</code><code class="p">;</code><code>
</code><code>
</code><code>  </code><code class="c1">// Now let's reproduce some of that work with pointers
</code><code>  </code><code class="kt">double</code><code> </code><code class="o">*</code><code class="n">total_ptr</code><code> </code><code class="o">=</code><code> </code><code class="o">&amp;</code><code class="n">total</code><code class="p">;</code><code>          </code><a class="co" id="co_pointers_and_references_CO1-2" href="#callout_pointers_and_references_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code class="kt">int</code><code> </code><code class="o">*</code><code class="n">count_ptr</code><code> </code><code class="o">=</code><code> </code><code class="o">&amp;</code><code class="n">count</code><code class="p">;</code><code>
</code><code>  </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">total_ptr is the same as the address of total:</code><code class="se">\n</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">  total_ptr %p == %p &amp;total</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code> </code><code class="n">total_ptr</code><code class="p">,</code><code> </code><code class="o">&amp;</code><code class="n">total</code><code class="p">)</code><code class="p">;</code><code>
</code><code>
</code><code>  </code><code class="c1">// We can manipulate the value at the end of a pointer
</code><code>  </code><code class="c1">// with the '*' prefix (dereferencing)
</code><code>  </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">The current total is: %.1f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">total_ptr</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="c1">// Let's pretend we forgot two units and correct our count:
</code><code>  </code><code class="o">*</code><code class="n">count_ptr</code><code> </code><code class="o">+</code><code class="o">=</code><code> </code><code class="mi">2</code><code class="p">;</code><code>                     </code><a class="co" id="co_pointers_and_references_CO1-3" href="#callout_pointers_and_references_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code class="n">average</code><code> </code><code class="o">=</code><code> </code><code class="o">*</code><code class="n">total_ptr</code><code> </code><code class="o">/</code><code> </code><code class="o">*</code><code class="n">count_ptr</code><code class="p">;</code><code>
</code><code>  </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">The corrected average of %d units totaling %.1f is %.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code>
</code><code>     </code><code class="n">count</code><code class="p">,</code><code> </code><code class="n">total</code><code class="p">,</code><code> </code><code class="n">average</code><code class="p">)</code><code class="p">;</code><code>           </code><a class="co" id="co_pointers_and_references_CO1-4" href="#callout_pointers_and_references_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_pointers_and_references_CO1-1" href="#co_pointers_and_references_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>We start with a normal set of variables and perform a simple calculation.</p></dd>
<dt><a class="co" id="callout_pointers_and_references_CO1-2" href="#co_pointers_and_references_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Next, we create new variables with corresponding pointer types.
E.g., we create <code>total_ptr</code> of type <code>double *</code> as a pointer to our
<code>total</code> variable of type <code>double</code>.</p></dd>
<dt><a class="co" id="callout_pointers_and_references_CO1-3" href="#co_pointers_and_references_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>You can dereference pointers to use or alter the things they point to.</p></dd>
<dt><a class="co" id="callout_pointers_and_references_CO1-4" href="#co_pointers_and_references_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Lastly, we prove that the original, non-pointer variables were in fact
changed by the work we did with their pointer counterparts.</p></dd>
</dl>

<p>Here’s the output:</p>

<pre data-type="programlisting">ch06$ gcc pointer.c
ch06$ ./a.out
The average of 34 units totaling 500.0 is 14.71
total_ptr is the same as the address of total:
  total_ptr 0x7ffdfdc079c8 == 0x7ffdfdc079c8 &amp;total
The current total is: 500.0
The corrected average of 36 units totaling 500.0 is 13.89</pre>

<p>That output isn’t very exciting, but again, it proves we were able to edit the
value of variables like <code>count</code> via the <code>count_ptr</code> pointer. Manipulating data through pointers is pretty advanced stuff. Don’t worry if this topic still feels a little overwhelming. Keep trying the examples and you’ll get more comfortable with the syntax, which in turn will help you think about using pointers with your own future <a data-type="indexterm" data-primary="pointers" data-secondary="editing variables via" data-startref="pointers-editing" id="idm45018723829480"/><a data-type="indexterm" data-primary="variables" data-secondary="editing via pointers" data-startref="variables-editing-pointers" id="idm45018723828232"/><a data-type="indexterm" data-primary="editing" data-secondary="variables via pointers" data-startref="edit-variables-pointers" id="idm45018723827000"/>projects.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Array Pointers"><div class="sect1" id="smallerc-CHP-6-SECT-2.1">
<h1>Array Pointers</h1>

<p>We <a data-type="indexterm" data-primary="arrays" data-secondary="as pointers" data-secondary-sortas="pointers" id="arrays-pointers"/><a data-type="indexterm" data-primary="pointers" data-secondary="arrays as" id="pointers-arrays"/>have actually worked with a pointer already, although it was very cleverly
disguised as an array. Recall our expanded use of the <code>scanf()</code> function in
<a data-type="xref" href="ch02.xhtml#smallerc-CHP-2-SECT-3.3">“scanf() and Parsing Inputs”</a>. When we wanted to scan in a number, we had to use
<code>&amp;</code> with the name of the numeric variable. But scanning strings did not require
that syntax—we simply gave the name of the array. That is because arrays
in C are already pointers, just pointers with an expected structure to make
reading and writing array elements easy.</p>

<p>It turns out that you can work with the contents of an array <em>without</em> the
convenience of the square brackets. You can use exactly the same dereferencing
we just saw in the previous example. With dereferencing, you can add and
subtract simple integers to the array variable to get at individual
elements in that array. But this type of thing is best discussed over code.
Check out <a href="https://oreil.ly/GPhxA"><em>ch06/direct_edit.c</em></a>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#</code><code class="cp">include &lt;stdio.h&gt;</code><code class="cp">
</code><code>
</code><code class="kt">int</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>  </code><code class="kt">char</code><code> </code><code class="n">name</code><code class="p">[</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="s">"</code><code class="s">a.c. Programmer</code><code class="s">"</code><code class="p">;</code><code>             </code><a class="co" id="co_pointers_and_references_CO2-1" href="#callout_pointers_and_references_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
  </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">Before manipulation: %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="o">*</code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="sc">'A'</code><code class="p">;</code><code>                                 </code><a class="co" id="co_pointers_and_references_CO2-2" href="#callout_pointers_and_references_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code class="o">*</code><code class="p">(</code><code class="n">name</code><code> </code><code class="o">+</code><code> </code><code class="mi">2</code><code class="p">)</code><code> </code><code class="o">=</code><code> </code><code class="sc">'C'</code><code class="p">;</code><code>                           </code><a class="co" id="co_pointers_and_references_CO2-3" href="#callout_pointers_and_references_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">After manipulation: %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code class="p">;</code><code>    </code><a class="co" id="co_pointers_and_references_CO2-4" href="#callout_pointers_and_references_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_pointers_and_references_CO2-1" href="#co_pointers_and_references_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>We declare and initialize our string (<code>char</code> array) as usual.</p></dd>
<dt><a class="co" id="callout_pointers_and_references_CO2-2" href="#co_pointers_and_references_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>We can dereference the array variable to read or alter the first character.
This is equivalent to <code>name[0] = <em>A</em></code>.</p></dd>
<dt><a class="co" id="callout_pointers_and_references_CO2-3" href="#co_pointers_and_references_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>We can also dereference an expression involving our array variable. We can
add or subtract <code>int</code> values, which translates to moving forward or backward in
the array by one element. In our code, this line is equivalent to <code>name[2] = <em>C</em></code>.</p></dd>
<dt><a class="co" id="callout_pointers_and_references_CO2-4" href="#co_pointers_and_references_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>And you can see the array variable itself is “unharmed,” although we
did successfully edit the string.</p></dd>
</dl>

<p>Go ahead and compile and run the program. Here’s the output:</p>

<pre data-type="programlisting">ch06$ gcc direct_edit.c
ch06$ ./a.out
Before manipulation: a.c. Programmer
After manipulation: A.C. Programmer</pre>

<p>This type of math and dereferencing works on arrays of other types, as well. You
might see pointer arithmetic in loops that process arrays, for example, where incrementing
the array pointer amounts to moving to the next element in the array. This use
of pointers can be remarkably efficient.
But while the simple manipulations in
<em>direct_edit.c</em> might have been faster historically, modern C compilers are very
(very!) good at optimizing your <a data-type="indexterm" data-primary="arrays" data-secondary="as pointers" data-secondary-sortas="pointers" data-startref="arrays-pointers" id="idm45018723658568"/><a data-type="indexterm" data-primary="pointers" data-secondary="arrays as" data-startref="pointers-arrays" id="idm45018723657240"/>code.</p>
<div data-type="tip"><h6>Tip</h6>
<p>I recommend concentrating on getting the
answer you want before worrying about performance. <a data-type="xref" href="ch10.xhtml#smallerc-CHP-10">Chapter 10</a>
looks at memory and other resources on the Arduino platform where such worrying is

<span class="keep-together">a bit</span> more justified. Even there, optimizing won’t be your first 
<span class="keep-together">concern</span>.</p>
</div>
</div></section>













<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Functions and Pointers"><div class="sect1" id="smallerc-CHP-6-SECT-3">
<h1>Functions and Pointers</h1>

<p>Where <a data-type="indexterm" data-primary="functions" data-secondary="pointers and" id="functions-pointers"/><a data-type="indexterm" data-primary="pointers" data-secondary="functions and" id="pointers-functions"/><a data-type="indexterm" data-primary="functions" data-secondary="arguments" data-tertiary="passing" id="functions-arguments-passing-ref"/><a data-type="indexterm" data-primary="arguments" data-secondary="passing" id="arguments-passing-ref"/><a data-type="indexterm" data-primary="passing" data-secondary="arguments" id="passing-arguments-ref"/>pointers really start to make a difference in your day-to-day life as a
programmer is when you attach them to the parameters or return values of functions.
This feature allows you to create a piece of shareable memory without making it
global. Consider the following functions from
<a href="https://oreil.ly/JJLV4"><em>ch06/increment.c</em></a>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">void</code> <code class="nf">increment_me</code><code class="p">(</code><code class="kt">int</code> <code class="n">me</code><code class="p">,</code> <code class="kt">int</code> <code class="n">amount</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// increment "me" by the "amount"</code>
  <code class="n">me</code> <code class="o">+=</code> <code class="n">amount</code><code class="p">;</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"  Inside increment_me: %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">me</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">increment_me_too</code><code class="p">(</code><code class="kt">int</code> <code class="o">*</code><code class="n">me</code><code class="p">,</code> <code class="kt">int</code> <code class="n">amount</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// increment the variable pointed to by "me" by the "amount"</code>
  <code class="o">*</code><code class="n">me</code> <code class="o">+=</code> <code class="n">amount</code><code class="p">;</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"  Inside increment_me_too: %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">*</code><code class="n">me</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>The first function, <code>increment_me()</code>, should feel familiar. We have passed values
to functions before. Inside <code>increment_me()</code>, we can add <code>amount</code> to <code>me</code> and get
the correct answer. However, we did pass only the <em>value</em> of <code>count</code> from our
<code>main()</code> method. That should mean that the original <code>count</code> variable will remain
untouched.</p>

<p>But <code>increment_me_too()</code> uses a pointer. Instead of a simple value, we can now
pass a <em>reference</em> to <code>count</code>. In this approach, we should find that <code>count</code> has been updated
once we return to <code>main()</code>. Let’s test that expectation. Here’s a minimal
<code>main()</code> method that tries both functions:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">count</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Initial count: %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">count</code><code class="p">);</code>
  <code class="n">increment_me</code><code class="p">(</code><code class="n">count</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Count after increment_me: %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">count</code><code class="p">);</code>
  <code class="n">increment_me_too</code><code class="p">(</code><code class="o">&amp;</code><code class="n">count</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Count after increment_me_too: %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">count</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>And here’s what we get for output:</p>

<pre data-type="programlisting">ch06$ gcc increment.c
ch06$ ./a.out
Initial count: 1
  Inside increment_me: 6
Count after increment_me: 1
  Inside increment_me_too: 6
Count after increment_me_too: 6</pre>

<p>Excellent. We got exactly the behavior we wanted. The <code>increment_me()</code> function
does not affect the value of <code>count</code> passed in from <code>main()</code>, but <code>increment_me_too()</code>
does affect it. You will often see the terms “pass by value” and
“pass by reference” to distinguish the way a function handles the
arguments passed to it. And note that in the case of <code>increment_me_too()</code>, we
have one reference parameter and one value parameter. There is no restriction
on mixing the types. As the programmer, you just have to make sure you use your
function correctly.</p>

<p>Functions can also return a pointer to something they have created in the heap.
This is a popular trick in external libraries, as we’ll <a data-type="indexterm" data-primary="functions" data-secondary="pointers and" data-startref="functions-pointers" id="idm45018723500520"/><a data-type="indexterm" data-primary="pointers" data-secondary="functions and" data-startref="pointers-functions" id="idm45018723499272"/><a data-type="indexterm" data-primary="functions" data-secondary="arguments" data-tertiary="passing" data-startref="functions-arguments-passing-ref" id="idm45018723498056"/><a data-type="indexterm" data-primary="arguments" data-secondary="passing" data-startref="arguments-passing-ref" id="idm45018723496600"/><a data-type="indexterm" data-primary="passing" data-secondary="arguments" data-startref="passing-arguments-ref" id="idm45018723495384"/>see in Chapters
<a data-xrefstyle="select:labelnumber" data-type="xref" href="ch09.xhtml#smallerc-CHP-9">9</a> and <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch11.xhtml#smallerc-CHP-11">11</a>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Managing Memory with Arrays"><div class="sect1" id="smallerc-CHP-6-SECT-4">
<h1>Managing Memory with Arrays</h1>

<p>If you<a data-type="indexterm" data-primary="memory" data-secondary="management" data-tertiary="purpose of" id="idm45018723489928"/><a data-type="indexterm" data-primary="arrays" data-secondary="for memory management" data-tertiary="purpose of" data-secondary-sortas="memory management" id="idm45018723488648"/> know ahead of time you want a large chunk of memory, say, to store
image or audio data, you can allocate your own arrays (and structures; see
<a data-type="xref" href="#smallerc-CHP-6-SECT-5.1">“Defining Structures”</a>). The result of the allocation is a pointer that
you can then pass to any functions that might need to work with your data. You
don’t duplicate any storage this way, and you can check to make sure
you got all the memory you need <em>before</em> you have to use it. That is a definite
boon when working with content from unknown sources. If sufficient memory is not available,
you can provide a polite error message and ask the user to try again rather
than simply crashing without an explanation.</p>








<section data-type="sect2" data-pdf-bookmark="Allocating with malloc()"><div class="sect2" id="smallerc-CHP-6-SECT-4.1">
<h2>Allocating with malloc()</h2>

<p>While<a data-type="indexterm" data-primary="memory" data-secondary="management" data-tertiary="allocation" id="memory-manage-allocate"/><a data-type="indexterm" data-primary="arrays" data-secondary="for memory management" data-tertiary="allocation" data-secondary-sortas="memory management" id="arrays-memory-allocate"/><a data-type="indexterm" data-primary="allocating memory" id="allocate-memory"/><a data-type="indexterm" data-primary="malloc() function" id="malloc"/><a data-type="indexterm" data-primary="functions" data-secondary="malloc()" id="functions-malloc"/> we’ll typically reserve heap work for larger arrays, you can allocate anything you want there. To do so, you use the <code>malloc()</code> function and provide
it a quantity in bytes that you need. The <code>malloc()</code> function is defined in
another header, <code>stdlib.h</code>, so we have to include that header, similar to how we include <code>stdio.h</code>.
We’ll see more of the functions that <code>stdlib.h</code> provides in
<a data-type="xref" href="ch07.xhtml#smallerc-CHP-7-SECT-1.1">“stdio.h”</a>, but for now, just add this line at the top,
below our usual <code>include</code>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;stdio.h&gt;</code>
<code class="cp">#include &lt;stdlib.h&gt;</code>

<code class="c1">// ...</code></pre>

<p>With this header included, we can create a simple program that illustrates
the memory allocation of global and local variables as well as our own, custom
bit of memory in the heap. Take a look at
<a href="https://oreil.ly/zAK5y"><em>ch06/memory.c</em></a>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;stdio.h&gt;</code>
<code class="cp">#include &lt;stdlib.h&gt;</code>

<code class="kt">int</code> <code class="n">result_code</code> <code class="o">=</code> <code class="mi">404</code><code class="p">;</code>
<code class="kt">char</code> <code class="n">result_msg</code><code class="p">[</code><code class="mi">20</code><code class="p">]</code> <code class="o">=</code> <code class="s">"File Not Found"</code><code class="p">;</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">char</code> <code class="n">temp</code><code class="p">[</code><code class="mi">20</code><code class="p">]</code> <code class="o">=</code> <code class="s">"Loading ..."</code><code class="p">;</code>
  <code class="kt">int</code> <code class="n">success</code> <code class="o">=</code> <code class="mi">200</code><code class="p">;</code>

  <code class="kt">char</code> <code class="o">*</code><code class="n">buffer</code> <code class="o">=</code> <code class="p">(</code><code class="kt">char</code> <code class="o">*</code><code class="p">)</code><code class="n">malloc</code><code class="p">(</code><code class="mi">20</code> <code class="o">*</code> <code class="k">sizeof</code> <code class="p">(</code><code class="kt">char</code><code class="p">));</code>

  <code class="c1">// We won't do anything with these various variables,</code>
  <code class="c1">// but we can print out their addresses</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Address of result_code:   %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">result_code</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Address of result_msg:    %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">result_msg</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Address of temp:          %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">temp</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Address of success:       %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">success</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Address of buffer (heap): %p</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">buffer</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>The global declarations of <code>result_code</code> and <code>result_msg</code> as well as
the local variables <code>temp</code> and <code>success</code> should be familiar.
But look at how we declared <code>buffer</code>. You can see the use of <code>malloc()</code>
in a real program. We asked for 20 characters of space. You can specify a
simple number of bytes if you want, but it is usually safer (indeed, often
necessary) to<a data-type="indexterm" data-primary="sizeof operator" id="idm45018723296968"/> use <code>sizeof</code>, as
shown in this example. Different systems will have different rules regarding
type sizes and memory allocation, and <code>sizeof</code> provides an easy guard against
unwitting mistakes.</p>

<p>Let’s take a look at the addresses of our variables in the output:</p>

<pre data-type="programlisting">ch06$ gcc memory.c
ch06$ ./a.out
Address of result_code:   0x55c4f49c8010
Address of result_msg:    0x55c4f49c8020
Address of temp:          0x7fffc84f1840
Address of success:       0x7fffc84f1834
Address of buffer (heap): 0x55c4f542e2a0</pre>

<p>Again, don’t worry about the exact value of those addresses. What we’re
looking for here is their general location. Hopefully, you can see that the
global variables and the <code>buffer</code> pointer we created in the heap manually with
<code>malloc()</code> are all in roughly the same spot. Likewise, the two variables
local to <code>main()</code> are similarly grouped, but in a separate spot.</p>

<p>So <code>malloc()</code> makes room for your data in the heap. We’ll make use of this
allocated space in <a data-type="xref" href="#smallerc-CHP-6-SECT-5.3">“Pointers to Structures”</a>, but we need to look at a
closely related function, <code>free()</code>, first. When you allocate memory using <code>malloc()</code>, you
are responsible for returning that space when you are <a data-type="indexterm" data-primary="memory" data-secondary="management" data-tertiary="allocation" data-startref="memory-manage-allocate" id="idm45018723289128"/><a data-type="indexterm" data-primary="arrays" data-secondary="for memory management" data-tertiary="allocation" data-secondary-sortas="memory management" data-startref="arrays-memory-allocate" id="idm45018723287608"/><a data-type="indexterm" data-primary="allocating memory" data-startref="allocate-memory" id="idm45018723285848"/><a data-type="indexterm" data-primary="malloc() function" data-startref="malloc" id="idm45018723284904"/><a data-type="indexterm" data-primary="functions" data-secondary="malloc()" data-startref="functions-malloc" id="idm45018723283960"/>done.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Deallocating with free()"><div class="sect2" id="smallerc-CHP-6-SECT-4.2">
<h2>Deallocating with free()</h2>

<p>As <a data-type="indexterm" data-primary="memory" data-secondary="management" data-tertiary="deallocation" id="idm45018723280968"/><a data-type="indexterm" data-primary="arrays" data-secondary="for memory management" data-tertiary="deallocation" data-secondary-sortas="memory management" id="idm45018723279688"/><a data-type="indexterm" data-primary="deallocating memory" id="idm45018723278200"/><a data-type="indexterm" data-primary="free() function" id="idm45018723277528"/><a data-type="indexterm" data-primary="functions" data-secondary="free()" id="idm45018723276856"/>you might recall in the discussion of <a data-type="xref" href="#smallerc-CHP-6-FIG-stack-and-heap">Figure 6-3</a>,
if you use up too much of the stack or the heap—or enough of both—you
will run out of memory and your program will crash. One of the benefits of
working with the heap is that you have control over when and how memory is
allocated from and returned to the heap. Of course, as I just noted, the
flipside of this benefit is that you have to remember to do the “giveing back”
part yourself. Many newer languages work to relieve the programmer of that burden, as it is all too easy to forget to clean up after yourself. Perhaps you have even heard of the quasi-official term for this issue: a memory leak.</p>

<p>To return memory and avoid such leaks in C, you use the <code>free()</code> function
(also from <em>stdlib.h</em>). It’s pretty straightforward to use—you just
pass the pointer returned from your corresponding <code>malloc()</code> call. So to free
up <code>buffer</code> when you’re done using it, for example:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="n">free</code><code class="p">(</code><code class="n">buffer</code><code class="p">);</code></pre>

<p>Easy! But again, it’s remembering to use <code>free()</code> that is the difficulty.
That might not seem like such a problem, but it gets increasingly tricky when
you start using functions to create and remove bits of data. How many times did
you call the create functions? Did you call a reciprocal remove function for
each one? What if you try to remove something that was never allocated? All of
these questions make keeping track of your memory usage as troublesome as it is
vital.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="C Structures"><div class="sect1" id="smallerc-CHP-6-SECT-5">
<h1>C Structures</h1>

<p>As you<a data-type="indexterm" data-primary="structures" data-secondary="purpose of" id="idm45018723268040"/><a data-type="indexterm" data-primary="variables" data-secondary="structures" data-see="structures" id="idm45018723267032"/> tackle more interesting problems, your data storage needs will get more complex. If you are working with LCD displays, for example, you will work with pixels that need a color and a location. That location itself will be made up of <em>x</em> and <em>y</em> coordinates. While you can create three separate arrays (one for all the colors, one for all the <em>x</em> coordinates, and finally one for the <em>y</em> coordinates), that collection will be difficult to pass to and from functions and opens up several avenues for bugs—like adding a color but forgetting one of the coordinates. Fortunately, C includes the <code>struct</code> facility to create better containers for your new data needs.</p>

<p>To quote K&amp;R: “A <em>structure</em> is a collection of one or more variables, possibly
of different types, grouped together under a single name for convenient
handling.”<sup><a data-type="noteref" id="idm45018723261080-marker" href="ch06.xhtml#idm45018723261080">1</a></sup> They go on to note that other languages support
this idea<a data-type="indexterm" data-primary="records" data-see="structures" id="idm45018723255400"/><a data-type="indexterm" data-primary="composite types" data-see="structures" id="idm45018723254488"/> as a <em>record</em>. Searching online today you would also encounter the term
<em>composite type</em>. Whatever you call it, this variable grouping feature is very
powerful. Let’s see how it works.</p>








<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Defining Structures"><div class="sect2" id="smallerc-CHP-6-SECT-5.1">
<h2>Defining Structures</h2>

<p>To <a data-type="indexterm" data-primary="structures" data-secondary="creating" id="idm45018723250392"/><a data-type="indexterm" data-primary="struct keyword" id="idm45018723249384"/>create your own structures, you use the <code>struct</code> keyword and name followed by
your list of variables inside curly braces. Then you can access those variables
by name much like you access the elements of an array by index. Here’s a quick
example we could use with a program for bank accounts:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">transaction</code> <code class="p">{</code>
  <code class="kt">double</code> <code class="n">amount</code><code class="p">;</code>
  <code class="kt">int</code> <code class="n">day</code><code class="p">,</code> <code class="n">month</code><code class="p">,</code> <code class="n">year</code><code class="p">;</code>
<code class="p">};</code></pre>

<p>We now have a new “type” we can use with our variables. Instead of
<code>int</code> or <code>char[]</code>, we have <code>struct transaction</code>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">count</code><code class="p">;</code>
  <code class="kt">char</code> <code class="n">message</code><code class="p">[]</code> <code class="o">=</code> <code class="s">"Your money is safe with us!"</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">transaction</code> <code class="n">bill</code><code class="p">,</code> <code class="n">deposit</code><code class="p">;</code>
  <code class="c1">// ...</code>
<code class="p">}</code></pre>

<p>The <code>count</code> and <code>message</code> declarations should look familiar. The next line
declares two more variables, <code>bill</code> and <code>deposit</code>, who share the new
<code>struct transaction</code> type. You can use this new type anywhere you have
been using native types like <code>int</code>. You can create local or global variables
with <code>struct</code> types. You can pass structures to functions or return them
from functions. Working with structures and functions
tends to rely more on pointers, but we’ll look at those details in
<a data-type="xref" href="#smallerc-CHP-6-SECT-5.4">“Functions and Structures”</a>.</p>

<p>Your structure definitions can be quite complex. There is no real restriction
on how many variables they can contain. A structure can even contain nested
<code>struct</code> definitions! You don’t want to go overboard, of course, but
you do have freedom to create just about any kind of record you can imagine.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Assigning and Accessing Structure Members"><div class="sect2" id="smallerc-CHP-6-SECT-5.2">
<h2>Assigning and Accessing Structure Members</h2>

<p>Once <a data-type="indexterm" data-primary="structures" data-secondary="accessing members" id="structure-access"/><a data-type="indexterm" data-primary="accessing" data-secondary="structure members" id="access-structures"/>your structure type is defined, you can declare and initialize variables of
that type using syntax similar to how we handle arrays. For example, if you know
a structure’s values ahead of time, you can use curly braces to<a data-type="indexterm" data-primary="structures" data-secondary="initializing" id="idm45018723137160"/><a data-type="indexterm" data-primary="initializing" data-secondary="structures" id="idm45018723136216"/> initialize
your variable:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="k">struct</code> <code class="n">transaction</code> <code class="n">deposit</code> <code class="o">=</code> <code class="p">{</code> <code class="mf">200.00</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">2021</code> <code class="p">};</code></pre>

<p>The order of the values inside the braces needs to match the order of the variables
you listed in the <code>struct</code> definition. But you can also create a structure variable
and fill it in after the fact. To indicate which field you want to assign, you
use<a data-type="indexterm" data-primary="dot notation" id="idm45018723085144"/><a data-type="indexterm" data-primary=". (period), dot notation" id="idm45018723084536"/><a data-type="indexterm" data-primary="period (.), dot notation" id="idm45018723083928"/> the “dot” operator. You give the structure variable’s name
(<code>bill</code> or <code>deposit</code> in our current example), a period,
and then the member of the structure you are interested in, like <code>day</code> or <code>amount</code>.
With this approach, you can make assignments in any order you like:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="n">bill</code><code class="p">.</code><code class="n">day</code> <code class="o">=</code> <code class="mi">15</code><code class="p">;</code>
  <code class="n">bill</code><code class="p">.</code><code class="n">month</code> <code class="o">=</code> <code class="mi">7</code><code class="p">;</code>
  <code class="n">bill</code><code class="p">.</code><code class="n">year</code> <code class="o">=</code> <code class="mi">2021</code><code class="p">;</code>
  <code class="n">bill</code><code class="p">.</code><code class="n">amount</code> <code class="o">=</code> <code class="mf">56.75</code><code class="p">;</code></pre>

<p>Regardless of how you filled the structure, you use the same dot notation to access a structure’s contents anytime you need them.
For example, to print any details from a transaction, we specify the transaction variable (<code>bill</code> or <code>deposit</code> in our case), the dot, and the field we want, like this:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="n">printf</code><code class="p">(</code><code class="s">"Your deposit of $%0.2f was accepted.</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">deposit</code><code class="p">.</code><code class="n">amount</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Your bill is due on %d/%02d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">bill</code><code class="p">.</code><code class="n">month</code><code class="p">,</code> <code class="n">bill</code><code class="p">.</code><code class="n">day</code><code class="p">);</code></pre>

<p>We can print these inner elements to the screen. We can assign new values to them.
We can use them in calculations. You can do everything with the pieces inside your
structure that you do with other variables.
The point of the structure is simply to make it easier
to keep related pieces of data together. But these structures also keep data <em>distinct</em>.
Consider assigning the <code>amount</code> variable in both our <code>bill</code> and our <code>deposit</code>:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="n">deposit</code><code class="p">.</code><code class="n">amount</code> <code class="o">=</code> <code class="mf">200.00</code><code class="p">;</code>
  <code class="n">bill</code><code class="p">.</code><code class="n">amount</code> <code class="o">=</code> <code class="mf">56.75</code><code class="p">;</code></pre>

<p>There is never any confusion over which <code>amount</code> you mean, even though we used the <code>amount</code> name in both assignments. If we add some tax to our <code>bill</code> after it was set up, for example, that will not affect how much money we include in our <code>deposit</code>:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="n">bill</code><code class="p">.</code><code class="n">amount</code> <code class="o">=</code> <code class="n">bill</code><code class="p">.</code><code class="n">amount</code> <code class="o">+</code> <code class="n">bill</code><code class="p">.</code><code class="n">amount</code> <code class="o">*</code> <code class="mf">0.05</code><code class="p">;</code>

  <code class="n">printf</code><code class="p">(</code><code class="s">"Our final bill: $%0.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">bill</code><code class="p">.</code><code class="n">amount</code><code class="p">);</code> <code class="c1">// $59.59</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Our deposit: $%0.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="p">)</code>                <code class="c1">// $200.00</code></pre>

<p>Hopefully, that separation makes sense. With structures, you can talk about bills and deposits as entities in their own right, while understanding that the details of any individual bill or deposit remain unique to that<a data-type="indexterm" data-primary="structures" data-secondary="accessing members" data-startref="structure-access" id="idm45018722972024"/><a data-type="indexterm" data-primary="accessing" data-secondary="structure members" data-startref="access-structures" id="idm45018722878408"/> transaction.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Pointers to Structures"><div class="sect2" id="smallerc-CHP-6-SECT-5.3">
<h2>Pointers to Structures</h2>

<p>If <a data-type="indexterm" data-primary="pointers" data-secondary="to structures" data-secondary-sortas="structures" id="pointers-structures"/><a data-type="indexterm" data-primary="structures" data-secondary="pointers to" id="structures-pointers"/>you build a good composite type that encapsulates just the right data, you will likely
start using these types in more and more places. You can use them for global and local
variables or as parameter types or even function return types. In the wild, however, you
will more often see programmers working with pointers to structures rather than structures
themselves.</p>

<p class="pagebreak-before less_space">To create (or destroy) pointers to structures, you can use exactly the same operators and
functions that are available for simple types. If you already have a <code>struct</code> variable,
for example, you can get its address with the <code>&amp;</code> operator. If you created an instance
of your structure with <code>malloc()</code>, you use <code>free()</code> to return that memory to the heap.
Here are a few examples of using these features and functions with our <code>struct transaction</code>
type:</p>
<pre data-type="programlisting" data-code-language="c">
<code class="k">struct</code> <code class="n">transaction</code> <code class="n">tmp</code> <code class="o">=</code> <code class="p">{</code> <code class="mf">68.91</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2020</code> <code class="p">};</code>
<code class="k">struct</code> <code class="n">transaction</code> <code class="o">*</code><code class="n">payment</code><code class="p">;</code>
<code class="k">struct</code> <code class="n">transaction</code> <code class="o">*</code><code class="n">withdrawal</code><code class="p">;</code>

<code class="n">payment</code> <code class="o">=</code> <code class="o">&amp;</code><code class="n">tmp</code><code class="p">;</code>
<code class="n">withdrawal</code> <code class="o">=</code> <code class="n">malloc</code><code class="p">(</code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code> <code class="n">transaction</code><code class="p">));</code>
</pre>

<p>Here, <code>tmp</code> is a normal <code>struct transaction</code> variable and we initialize it using curly braces. Both <code>payment</code> and <code>withdrawal</code> are declared as pointers. We can assign the address of a <code>struct transaction</code> variable like we do with <code>payment</code>, or we can allocate memory on the heap (to fill in later) like we do with <code>withdrawal</code>.</p>

<p>When we go to fill in <code>withdrawal</code>, however, we have to remember that we have
a pointer, so <code>withdrawal</code> requires dereferencing before we can apply the dot.
Not only that, the dot operator has a higher order of precedence than the dereference operator, so you have to use parentheses to get the operators applied correctly. That can be a little tedious, so we often use an alternate notation for accessing the members of a <code>struct</code> pointer. The “arrow” operator, <code>-&gt;</code>, allows <a data-type="indexterm" data-primary="-&gt; (arrow) operator" id="idm45018722806504"/><a data-type="indexterm" data-primary="arrow (-&gt;) operator" id="idm45018722805880"/>us to use a <code>struct</code> pointer without dereferencing it. You place the arrow between the structure variable’s name and the name of the intended member just like with the dot operator:</p>

<pre data-type="programlisting" data-code-language="c"><code class="c1">// With dereferencing:</code>
<code class="p">(</code><code class="o">*</code><code class="n">withdrawal</code><code class="p">).</code><code class="n">amount</code> <code class="o">=</code> <code class="o">-</code><code class="mf">20.0</code><code class="p">;</code>

<code class="c1">// With the arrow operator:</code>
<code class="n">withdrawal</code><code class="o">-&gt;</code><code class="n">day</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="n">withdrawal</code><code class="o">-&gt;</code><code class="n">month</code> <code class="o">=</code> <code class="mi">8</code><code class="p">;</code>
<code class="n">withdrawal</code><code class="o">-&gt;</code><code class="n">year</code> <code class="o">=</code> <code class="mi">2021</code><code class="p">;</code></pre>

<p>This difference can be a little frustrating, but eventually you’ll get used to
it. Pointers to structures provide an efficient means of sharing relevant information
between different parts of your program. Their biggest advantage is that pointers
do not have the overhead of moving or copying all of the internal pieces of their
structures. This advantage becomes apparent when you start using <a data-type="indexterm" data-primary="pointers" data-secondary="to structures" data-secondary-sortas="structures" data-startref="pointers-structures" id="idm45018722753464"/><a data-type="indexterm" data-primary="structures" data-secondary="pointers to" data-startref="structures-pointers" id="idm45018722752104"/>structures with
functions.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Functions and Structures"><div class="sect2" id="smallerc-CHP-6-SECT-5.4">
<h2>Functions and Structures</h2>

<p>Consider<a data-type="indexterm" data-primary="functions" data-secondary="structures and" id="functions-structures"/><a data-type="indexterm" data-primary="structures" data-secondary="functions and" id="structures-functions"/><a data-type="indexterm" data-primary="pointers" data-secondary="with functions and structures" data-secondary-sortas="functions and structures" id="pointers-functions-structures"/> writing a function to print out the contents of a transaction in a nice format.
We could pass the structure as is to a function. We just use the <code>struct transaction</code> type
in our parameter list and then pass a normal variable when we call it:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">void</code> <code class="nf">printTransaction1</code><code class="p">(</code><code class="k">struct</code> <code class="n">transaction</code> <code class="n">tx</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"%2d/%02d/%4d: %10.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">tx</code><code class="p">.</code><code class="n">month</code><code class="p">,</code> <code class="n">tx</code><code class="p">.</code><code class="n">day</code><code class="p">,</code> <code class="n">tx</code><code class="p">.</code><code class="n">year</code><code class="p">,</code> <code class="n">tx</code><code class="p">.</code><code class="n">amount</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// ...</code>
<code class="n">printTransaction1</code><code class="p">(</code><code class="n">bill</code><code class="p">);</code>
<code class="n">printTransaction1</code><code class="p">(</code><code class="n">deposit</code><code class="p">);</code></pre>

<p>Pretty simple, but recall our discussion of how function calls work with the stack. In this
example, all of the fields of <code>bill</code> or <code>deposit</code> will have to be put on the stack when we
call <code>printTransaction1()</code>. That takes extra time and space. Indeed, in the very earliest
versions of C, this wasn’t even allowed! That’s obviously not true any longer,
but passing pointers to and from functions is still faster. Here’s a pointer version
of our <code>printTransaction1()</code> function:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">void</code> <code class="nf">printTransaction2</code><code class="p">(</code><code class="k">struct</code> <code class="n">transaction</code> <code class="o">*</code><code class="n">ptr</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"%2d/%02d/%4d: %10.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">month</code><code class="p">,</code> <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">day</code><code class="p">,</code> <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">year</code><code class="p">,</code> <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">amount</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// ...</code>
<code class="n">printTransaction2</code><code class="p">(</code><code class="o">&amp;</code><code class="n">tmp</code><code class="p">);</code>
<code class="n">printTransaction2</code><code class="p">(</code><code class="n">payment</code><code class="p">)</code>
<code class="n">printTransaction2</code><code class="p">(</code><code class="n">withdrawal</code><code class="p">);</code></pre>

<p>The only thing required to go on the stack was the address of one <code>struct transaction</code>
object. Much cleaner.</p>

<p>Passing pointers this way has an interesting, intended
feature: we can change the contents of a structure in the function. Recall from
<a data-type="xref" href="ch05.xhtml#smallerc-CHP-5-SECT-3.1">“Passing Simple Types”</a> that without pointers, we end up passing values via the
stack that initialize the parameters of the function. Nothing we do to those
parameters while inside the function affects the original arguments from wherever the
function was called.</p>

<p>If we pass a pointer, however, we can use that pointer to change the insides of the
structure. And those changes persist because we are working on the actual structure,
not a copy of its values. For example, we could create a function to add tax to any
transaction:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">void</code> <code class="nf">addTax</code><code class="p">(</code><code class="k">struct</code> <code class="n">transaction</code> <code class="o">*</code><code class="n">ptr</code><code class="p">,</code> <code class="kt">double</code> <code class="n">rate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">double</code> <code class="n">tax</code> <code class="o">=</code> <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">amount</code> <code class="o">*</code> <code class="n">rate</code><code class="p">;</code>
  <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">amount</code> <code class="o">+=</code> <code class="n">tax</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// ... back in main</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Our bill amount before tax: $%.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">bill</code><code class="p">.</code><code class="n">amount</code><code class="p">);</code>
  <code class="n">addTax</code><code class="p">(</code><code class="o">&amp;</code><code class="n">bill</code><code class="p">,</code> <code class="mf">0.05</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Our bill amount after tax: $%.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">bill</code><code class="p">.</code><code class="n">amount</code><code class="p">);</code>
<code class="c1">// ...</code></pre>

<p>Notice that we do not change <code>bill.amount</code> in the <code>main()</code> function. We simply pass
its address to <code>addTax()</code> along with a tax rate.
Here’s the output of those <code>printf()</code> 
<span class="keep-together">statements</span>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">Our</code> <code class="n">bill</code> <code class="n">amount</code> <code class="n">before</code> <code class="nl">tax</code><code class="p">:</code> <code class="err">$</code><code class="mf">56.75</code>
<code class="n">Our</code> <code class="n">bill</code> <code class="n">amount</code> <code class="n">after</code> <code class="nl">tax</code><code class="p">:</code> <code class="err">$</code><code class="mf">59.59</code></pre>

<p>Exactly what we were hoping for. Because it proves so powerful, passing structures
by reference is very common. Not everything needs to be in a structure, and not every
structure has to be passed by reference, but in large programs, the organization and
efficiency you get are definitely appealing.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>This ability to alter the contents of a structure using a pointer is usually desirable.
But if for some reason you <em>don’t</em> want to change a member
while you’re using a pointer to its structure, be sure not to
assign anything to that member. You can, of course, always
put a copy of that member’s value into a temporary variable first, and
then work with the temporary <a data-type="indexterm" data-primary="functions" data-secondary="structures and" data-startref="functions-structures" id="idm45018722489976"/><a data-type="indexterm" data-primary="structures" data-secondary="functions and" data-startref="structures-functions" id="idm45018722488728"/><a data-type="indexterm" data-primary="pointers" data-secondary="with functions and structures" data-secondary-sortas="functions and structures" data-startref="pointers-functions-structures" id="idm45018722487512"/>variable.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Pointer Syntax Recap"><div class="sect1" id="smallerc-CHP-6-SECT-6">
<h1>Pointer Syntax Recap</h1>

<p>I <a data-type="indexterm" data-primary="pointers" data-secondary="syntax" id="pointers-syntax"/>introduced enough new and somewhat esoteric bits of C’s syntax in this
chapter that I wanted to recap things here for quick reference:</p>

<ul>
<li>
<p>We defined new data types with the <code>struct</code> keyword.</p>
</li>
<li>
<p>We used the “dot” operator (<code>.</code>) for accessing the contents of a structure.</p>
</li>
<li>
<p>We used the “arrow” operator (<code>-&gt;</code>) for accessing the contents of a structure though a pointer.</p>
</li>
<li>
<p>We allocated our own space for data using <code>malloc()</code>.</p>
</li>
<li>
<p>We worked with that space using the <code>&amp;</code> (“address of”) and <code>*</code> (“dereference”) 
<span class="keep-together">operators</span>.</p>
</li>
<li>
<p>When we’re done with the data, we can release its space using <code>free()</code>.</p>
</li>
</ul>

<p>Let’s see these new concepts and
definitions in context. Consider the following program,
<a href="https://oreil.ly/xeqqL"><em>ch06/structure.c</em></a>.
Rather than use callouts in this slightly longer listing, I have added
several inline comments to highlight key points. That way you can look up these
details quickly here in the book, or in your code editor if you’re working
on one of your own 
<span class="keep-together">programs</span>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="c1">// Include the usual stdio, but also stdlib for access</code>
<code class="c1">// to the malloc() and free() functions, and NULL</code>
<code class="cp">#include &lt;stdio.h&gt;</code>
<code class="cp">#include &lt;stdlib.h&gt;</code>

<code class="c1">// We can use the struct keyword to define new, composite types</code>
<code class="k">struct</code> <code class="n">transaction</code> <code class="p">{</code>
  <code class="kt">double</code> <code class="n">amount</code><code class="p">;</code>
  <code class="kt">int</code> <code class="n">month</code><code class="p">,</code> <code class="n">day</code><code class="p">,</code> <code class="n">year</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// That new type can be used with function parameters</code>
<code class="kt">void</code> <code class="nf">printTransaction1</code><code class="p">(</code><code class="k">struct</code> <code class="n">transaction</code> <code class="n">tx</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"%2d/%02d/%4d: %10.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">tx</code><code class="p">.</code><code class="n">month</code><code class="p">,</code> <code class="n">tx</code><code class="p">.</code><code class="n">day</code><code class="p">,</code> <code class="n">tx</code><code class="p">.</code><code class="n">year</code><code class="p">,</code> <code class="n">tx</code><code class="p">.</code><code class="n">amount</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// We can also use a pointer to that type with parameters</code>
<code class="kt">void</code> <code class="nf">printTransaction2</code><code class="p">(</code><code class="k">struct</code> <code class="n">transaction</code> <code class="o">*</code><code class="n">ptr</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// Check to make sure our pointer isn't empty</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">ptr</code> <code class="o">==</code> <code class="nb">NULL</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"Invalid transaction.</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="c1">// Yay! We have a transaction, print out its details with -&gt;</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"%2d/%02d/%4d: %10.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">month</code><code class="p">,</code> <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">day</code><code class="p">,</code> <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">year</code><code class="p">,</code>
        <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">amount</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Passing a structure pointer to a function means we can alter</code>
<code class="c1">// the contents of the structure if necessary</code>
<code class="kt">void</code> <code class="nf">addTax</code><code class="p">(</code><code class="k">struct</code> <code class="n">transaction</code> <code class="o">*</code><code class="n">ptr</code><code class="p">,</code> <code class="kt">double</code> <code class="n">rate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">double</code> <code class="n">tax</code> <code class="o">=</code> <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">amount</code> <code class="o">*</code> <code class="n">rate</code><code class="p">;</code>
  <code class="n">ptr</code><code class="o">-&gt;</code><code class="n">amount</code> <code class="o">+=</code> <code class="n">tax</code><code class="p">;</code>
<code class="p">}</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="c1">// We can declare local (or global) variables with our new type</code>
  <code class="k">struct</code> <code class="n">transaction</code> <code class="n">bill</code><code class="p">;</code>

  <code class="c1">// We can assign initial values inside curly braces</code>
  <code class="k">struct</code> <code class="n">transaction</code> <code class="n">deposit</code> <code class="o">=</code> <code class="p">{</code> <code class="mf">200.00</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">2021</code> <code class="p">};</code>

  <code class="c1">// Or we can assign values at any time after with the dot operator</code>
  <code class="n">bill</code><code class="p">.</code><code class="n">amount</code> <code class="o">=</code> <code class="mf">56.75</code><code class="p">;</code>
  <code class="n">bill</code><code class="p">.</code><code class="n">month</code> <code class="o">=</code> <code class="mi">7</code><code class="p">;</code>
  <code class="n">bill</code><code class="p">.</code><code class="n">day</code> <code class="o">=</code> <code class="mi">15</code><code class="p">;</code>
  <code class="n">bill</code><code class="p">.</code><code class="n">year</code> <code class="o">=</code> <code class="mi">2021</code><code class="p">;</code>

  <code class="c1">// We can pass structure variables to functions just like other variables</code>
  <code class="n">printTransaction1</code><code class="p">(</code><code class="n">deposit</code><code class="p">);</code>
  <code class="n">printTransaction1</code><code class="p">(</code><code class="n">bill</code><code class="p">);</code>

  <code class="c1">// We can also create pointers to structures and use them with malloc()</code>
  <code class="k">struct</code> <code class="n">transaction</code> <code class="n">tmp</code> <code class="o">=</code> <code class="p">{</code> <code class="mf">68.91</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2020</code> <code class="p">};</code>
  <code class="k">struct</code> <code class="n">transaction</code> <code class="o">*</code><code class="n">payment</code> <code class="o">=</code> <code class="nb">NULL</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">transaction</code> <code class="o">*</code><code class="n">withdrawal</code><code class="p">;</code>
  <code class="n">payment</code> <code class="o">=</code> <code class="o">&amp;</code><code class="n">tmp</code><code class="p">;</code>
  <code class="n">withdrawal</code> <code class="o">=</code> <code class="n">malloc</code><code class="p">(</code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code> <code class="n">transaction</code><code class="p">));</code>

  <code class="c1">// With a pointer, we either have to carefully dereference it</code>
  <code class="p">(</code><code class="o">*</code><code class="n">withdrawal</code><code class="p">).</code><code class="n">amount</code> <code class="o">=</code> <code class="o">-</code><code class="mf">20.0</code><code class="p">;</code>
  <code class="c1">// Or use the arrow operator</code>
  <code class="n">withdrawal</code><code class="o">-&gt;</code><code class="n">day</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
  <code class="n">withdrawal</code><code class="o">-&gt;</code><code class="n">month</code> <code class="o">=</code> <code class="mi">8</code><code class="p">;</code>
  <code class="n">withdrawal</code><code class="o">-&gt;</code><code class="n">year</code> <code class="o">=</code> <code class="mi">2021</code><code class="p">;</code>

  <code class="c1">// And we are free to pass structure pointers to functions</code>
  <code class="n">printTransaction2</code><code class="p">(</code><code class="n">payment</code><code class="p">);</code>
  <code class="n">printTransaction2</code><code class="p">(</code><code class="n">withdrawal</code><code class="p">);</code>

  <code class="c1">// Add tax to our bill using a function and a pointer</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Our bill amount before tax: $%.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">bill</code><code class="p">.</code><code class="n">amount</code><code class="p">);</code>
  <code class="n">addTax</code><code class="p">(</code><code class="o">&amp;</code><code class="n">bill</code><code class="p">,</code> <code class="mf">0.05</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Our bill amount after tax: $%.2f</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">bill</code><code class="p">.</code><code class="n">amount</code><code class="p">);</code>

  <code class="c1">// Before we go, release the memory we allocated to withdrawal:</code>
  <code class="n">free</code><code class="p">(</code><code class="n">withdrawal</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>As with most new concepts and bits of syntax, you’ll get more comfortable
with pointers and <code>malloc()</code> as you use them more in your own programs. Creating
a program from scratch that solves a problem you are interested in always
helps cement your understanding of a new topic. I officially give you permission
to go play around with <a data-type="indexterm" data-primary="pointers" data-secondary="syntax" data-startref="pointers-syntax" id="idm45018722399128"/>pointers!</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Next Steps"><div class="sect1" id="smallerc-CHP-6-SECT-7">
<h1>Next Steps</h1>

<p>We covered some pretty advanced stuff in this chapter. We looked at where data is stored in memory as your program is running and the operators (<code>&amp;</code>, <code>*</code>, <code>.</code>, and <code>-&gt;</code>) and functions (<code>malloc()</code> and <code>free()</code>) that help you work with the addresses of that data. Many books on intermediate and advanced programming will spend multiple chapters on these concepts, so don’t be discouraged if you need to read through some of this material a few more times. As always, running the code with some of your own modifications is a great way to practice your understanding.</p>

<p>We have an impressive array of tools in our C kit now! We can start tackling
complex problems and have a good shot at solving them. But in many cases, our
problems are not actually novel. In fact, a lot of problems (or at least
a lot of the subproblems we find when we break up our real task into manageable pieces) have already been encountered and solved by other programmers. The next chapter looks at how to take advantage of those external solutions.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45018723261080"><sup><a href="ch06.xhtml#idm45018723261080-marker">1</a></sup> That convenient handling turns out to be very convenient. Kernighan and Ritchie devote an entire <a data-type="indexterm" data-primary="Ritchie, Dennis" id="idm45018723260408"/><a data-type="indexterm" data-primary="Kernighan, Brian" id="idm45018723257768"/><a data-type="indexterm" data-primary="The C Programming Language (Kernighan and Ritchie)" data-primary-sortas="C Programming Language Kernighan" id="idm45018723257096"/>chapter of <em>The C Programming Language</em> to this topic. Obviously they go into more detail than I can here, so here’s one more plug for picking up this classic.</p></div></div></section></div></body></html>