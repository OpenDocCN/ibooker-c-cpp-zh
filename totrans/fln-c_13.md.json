["```cpp\n#define MAX_SIZE 50\n#define MAX_USERS 50\n\ntypedef struct\n{\n  char name[MAX_SIZE];\n  char pwd[MAX_SIZE];\n}USER;\n\nstatic USER userList[MAX_USERS]; ![1](assets/1.png)\n```", "```cpp\n#ifndef USER_H\n#define USER_H\n\n#define MAX_SIZE 50\n\n#endif\n```", "```cpp\n#include \"user.h\"\n\n#define MAX_USERS 50\n\ntypedef struct\n{\n  char name[MAX_SIZE];\n  char pwd[MAX_SIZE];\n}USER;\n\nstatic USER userList[MAX_USERS];\n```", "```cpp\n/* Returns true if the provided username exists and\n if the provided password is correct for that user. */\nbool authenticateUser(char* username, char* pwd);\n```", "```cpp\n/* Returns true if the provided username exists and\n if the provided password is correct for that user,\n returns false otherwise. Asserts in case of invalid\n input (NULL string) */\nbool authenticateUser(char* username, char* pwd);\n```", "```cpp\nbool authenticateUser(char* username, char* pwd)\n{\n  assert(username);\n  assert(pwd);\n\n  for(int i=0; i<MAX_USERS; i++)\n  {\n    if(strcmp(username, userList[i].name) == 0 &&\n       strcmp(pwd, userList[i].pwd) == 0)\n    {\n      return true;\n    }\n  }\n  return false;\n}\n```", "```cpp\nstatic void logError(char* username)\n{\n  char logString[200];\n  sprintf(logString, \"Failed login. User:%s\\n\", username);\n  FILE* f = fopen(\"logfile\", \"a+\"); ![1](assets/1.png)\n  fwrite(logString, 1, strlen(logString), f);\n  fclose(f);\n}\n```", "```cpp\ntypedef enum{\n  USER_SUCCESSFULLY_ADDED,\n  USER_ALREADY_EXISTS,\n  USER_ADMINISTRATION_FULL\n}USER_ERROR_CODE;\n\n/* Adds a new user with the provided `username' and the provided password\n `pwd' (asserts on NULL). Returns USER_SUCCESSFULLY_ADDED on success,\n USER_ALREADY_EXISTS if a user with the provided username already exists\n and USER_ADMINISTRATION_FULL if no more users can be added. */\nUSER_ERROR_CODE addUser(char* username, char* pwd);\n```", "```cpp\nstatic bool userExists(char* username)\n{\n  for(int i=0; i<MAX_USERS; i++)\n  {\n    if(strcmp(username, userList[i].name) == 0)\n    {\n      return true;\n    }\n  }\n  return false;\n}\n```", "```cpp\nUSER_ERROR_CODE addUser(char* username, char* pwd)\n{\n  assert(username);\n  assert(pwd);\n\n  if(userExists(username))\n  {\n    return USER_ALREADY_EXISTS;\n  }\n\n  for(int i=0; i<MAX_USERS; i++)\n  {\n    if(strcmp(userList[i].name, \"\") == 0)\n    {\n      strcpy(userList[i].name, username);\n      strcpy(userList[i].pwd, pwd);\n      return USER_SUCCESSFULLY_ADDED;\n    }\n  }\n\n  return USER_ADMINISTRATION_FULL;\n}\n```", "```cpp\ntypedef struct ITERATOR* ITERATOR;\n\n/* Create an iterator instance. Returns NULL on error. */\nITERATOR createIterator();\n\n/* Retrieves the next element from an iterator instance. */\nchar* getNextElement(ITERATOR iterator);\n\n/* Destroys an iterator instance. */\nvoid destroyIterator(ITERATOR iterator);\n```", "```cpp\nstruct ITERATOR\n{\n  int currentPosition;\n  char currentElement[MAX_SIZE];\n};\n\nITERATOR createIterator()\n{\n  ITERATOR iterator = (ITERATOR) calloc(sizeof(struct ITERATOR),1);\n  return iterator;\n}\n\nchar* getNextElement(ITERATOR iterator)\n{\n  if(iterator->currentPosition < MAX_USERS)\n  {\n    strcpy(iterator->currentElement,userList[iterator->currentPosition].name);\n    iterator->currentPosition++;\n  }\n  else\n  {\n    strcpy(iterator->currentElement, \"\");\n  }\n  return iterator->currentElement;\n}\n\nvoid destroyIterator(ITERATOR iterator)\n{\n  free(iterator);\n}\n```", "```cpp\nchar* element;\naddUser(\"A\", \"pass\");\naddUser(\"B\", \"pass\");\naddUser(\"C\", \"pass\");\n\nITERATOR it = createIterator();\n\nwhile(true)\n{\n  element = getNextElement(it);\n  if(strcmp(element, \"\") == 0)\n  {\n    break;\n  }\n\n  printf(\"User: %s \", element);\n  printf(\"Authentication success? %d\\n\", authenticateUser(element, \"pass\"));\n}\n\ndestroyIterator(it);\n```"]