<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 2. The Art of Building Abstractions" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_art_of_building_abstractions">
<h1><span class="label">Chapter 2. </span>The Art of Building Abstractions</h1>
<p>Abstractions<a data-primary="abstractions" data-secondary="basic guidelines for managing" data-type="indexterm" id="idm45043121139456"/> play a vital role in software design and software architecture.
In other words, good abstractions are the key to managing complexity. Without
them, good design and proper architecture are hard to imagine. Still, building
good abstractions and using them well is surprisingly difficult. As it turns
out, building and using abstractions comes with a lot of subtleties, and
therefore feels more like an art than a science. This chapter goes into
detail about the meaning of abstractions and the art of building them.</p>
<p>In <a data-type="xref" href="#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>, we will talk about
the purpose of abstractions. We will also talk about the fact that abstractions
represent a set of requirements and expectations and why it is so important to
adhere to the expected behavior of abstractions. In that context I will introduce
another design principle, the <em>Liskov Substitution Principle</em> (LSP).</p>
<p>In <a data-type="xref" href="#understand_the_similarities_between_base_classes_and_concepts">“Guideline 7: Understand the Similarities Between 
<span class="keep-together">Base Classes and Concepts</span>”</a>, we will
compare the two most commonly used abstractions: base classes and concepts.
You will understand that from a semantic point of view both approaches are
very similar since both are able to express expected behavior.</p>
<p>In <a data-type="xref" href="#understand_the_semantic_requirements_of_overload_sets">“Guideline 8: Understand the Semantic Requirements of Overload Sets”</a>, I will extend
the discussion about semantic requirements and talk about a third kind of
abstraction: function overloading. You will understand that all functions, being
part of an overload set, also have an expected behavior and thus also have to
adhere to the LSP.</p>
<p>In <a data-type="xref" href="#pay_attention_to_the_ownership_of_abstractions">“Guideline 9: Pay Attention to the Ownership of Abstractions”</a>, I will focus on the
architectural meaning of abstractions. I will explain what an architecture is and
what we expect from the high and low levels of an architecture. I will also show
you that from an architectural point of view, it is not enough to <em>just</em> introduce
an abstraction to resolve dependencies. To explain this, I will introduce the
<em>Dependency Inversion Principle</em> (DIP), vital advice on how to build an
architecture by means of abstractions.</p>
<p>In <a data-type="xref" href="#consider_creating_an_architectural_document">“Guideline 10: Consider Creating an Architectural Document”</a>, we will talk about the benefits of an architectural document. Hopefully, this will be an incentive to create one in case this wasn’t already on your radar.</p>
<section data-pdf-bookmark="Guideline 6: Adhere to the Expected Behavior of Abstractions" data-type="sect1"><div class="sect1" id="adhere_to_the_expected_behavior_of_abstractions">
<h1>Guideline 6: Adhere to the Expected Behavior of Abstractions</h1>
<p>One<a data-primary="abstractions" data-secondary="expected behavior of" data-type="indexterm" id="ABbehav02"/> of the key aspects of decoupling software, and thus one of the key
aspects of software design, is the introduction of abstractions. For that
reason, you would expect that this is a relatively straightforward, easy
thing to do. Unfortunately, as it turns out, building abstractions is difficult.</p>
<p>To demonstrate what I mean, let’s take a look at an example.
I have selected <em>the</em> classic example for that purpose. Chances are,
you might already know this example. If so, please feel free to skip it. However, if you’re not familiar
with the example, then this may serve as an eye-opener.</p>
<section data-pdf-bookmark="An Example of Violating Expectations" data-type="sect2"><div class="sect2" id="idm45043121125952">
<h2>An Example of Violating Expectations</h2>
<p>Let’s<a data-primary="abstractions" data-secondary="expected behavior of" data-tertiary="example of violating expectations" data-type="indexterm" id="idm45043121124320"/> start with a <code>Rectangle</code> base class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">Rectangle</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Rectangle</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_1" id="code_g6_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="nf">getWidth</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_3" id="code_g6_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="nf">getHeight</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setWidth</code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_4" id="code_g6_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setHeight</code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getArea</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_5" id="code_g6_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">
</code><code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">width</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_2" id="code_g6_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">height</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p class="less_space pagebreak-before">First of all, this class is designed as a base class, since it provides
a virtual destructor
(<a class="co" href="#code_g6_1" id="para_g6_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>).
Semantically, a <code>Rectangle</code> represents an abstraction for different
kinds of rectangles. And technically, you can properly destroy an
object of derived type via a pointer to <code>Rectangle</code>.</p>
<p>Second, the <code>Rectangle</code> class comes with two data members: <code>width</code> and <code>height</code>
(<a class="co" href="#code_g6_2" id="para_g6_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>).
That is to be expected, since a rectangle has two side lengths, which are
represented by <code>width</code> and <code>height</code>. The <code>getWidth()</code> and <code>getHeight()</code> member
functions can be used to query the two side lengths
(<a class="co" href="#code_g6_3" id="para_g6_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>),
and via the <code>setWidth()</code> and <code>setHeight()</code> member functions, we can set the <code>width</code>
and <code>height</code>
(<a class="co" href="#code_g6_4" id="para_g6_4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>).
It’s important to note that I can set these two independently; i.e., I can set the
<code>width</code> without having to modify the <code>height</code>.</p>
<p>Finally, there is a <code>getArea()</code> member function
(<a class="co" href="#code_g6_5" id="para_g6_5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>).
<code>getArea()</code> computes the area of the rectangle, which is of course implemented by
returning the product of <code>width</code> and <code>height</code>.</p>
<p>Of course there may be more functionality, but the given members are the ones
that are important for this example. As it is, this seems to be a pretty
nice <code>Rectangle</code> class. Obviously, we’re off to a good start. But, of
course there’s more. For instance, there is the <code>Square</code> class:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="k">class</code><code class="w"> </code><code class="nc">Square</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Rectangle</code><code class="w">  </code><a class="co" href="#para_g6_6" id="code_g6_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="n">setWidth</code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_7" id="code_g6_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">setHeight</code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_8" id="code_g6_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="nf">getArea</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_9" id="code_g6_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="p">;</code><code class="w">
</code></pre>
<p>The <code>Square</code> class publicly inherits from the <code>Rectangle</code> class
(<a class="co" href="#code_g6_6" id="para_g6_6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>).
And that seems pretty reasonable: from a mathematical perspective, a square
appears to be a special kind of rectangle.<sup><a data-type="noteref" href="ch02.xhtml#idm45043120890480" id="idm45043120890480-marker">1</a></sup></p>
<p>A <code>Square</code> is special, in the sense that it has only one side length.
But the <code>Rectangle</code> base class comes with two lengths: <code>width</code> and <code>height</code>. For
that reason, we have to make sure that the invariants
of the <code>Square</code> are always preserved. In this given implementation
with two data members and two getter functions, we have to make sure that
both data members always have the same value. Therefore, we override the

<span class="keep-together"><code>setWidth()</code></span> member function to set both <code>width</code> and <code>height</code>
(<a class="co" href="#code_g6_7" id="para_g6_7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>).
We also override the <code>setHeight()</code> member function to set both
<code>width</code> and <code>height</code>
(<a class="co" href="#code_g6_8" id="para_g6_8"><img alt="8" height="12" src="assets/8.png" width="12"/></a>).</p>
<p>Once we have done that, a <code>Square</code> will always have equal side lengths,
and the <code>getArea()</code> function will always return the correct area of a <code>Square</code>
(<a class="co" href="#code_g6_9" id="para_g6_9"><img alt="9" height="12" src="assets/9.png" width="12"/></a>).
Nice!</p>
<p>Let’s put these two classes to good use. For instance, we could
think about a function that transforms different kinds of rectangles:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="kt">void</code><code class="w"> </code><code class="nf">transform</code><code class="p">(</code><code class="w"> </code><code class="n">Rectangle</code><code class="o">&amp;</code><code class="w"> </code><code class="n">rectangle</code><code class="w"> </code><code class="p">)</code><code class="w">  </code><a class="co" href="#para_g6_10" id="code_g6_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">rectangle</code><code class="p">.</code><code class="n">setWidth</code><code class="w"> </code><code class="p">(</code><code class="w"> </code><code class="mi">7</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_11" id="code_g6_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">rectangle</code><code class="p">.</code><code class="n">setHeight</code><code class="p">(</code><code class="w"> </code><code class="mi">4</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_12" id="code_g6_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">rectangle</code><code class="p">.</code><code class="n">getArea</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="mi">28</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_13" id="code_g6_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="c1">// ...
</code><code class="p">}</code><code class="w">
</code></pre>
<p>The <code>transform()</code> function takes any kind of <code>Rectangle</code> by means of a
reference to non-<code>const</code>
(<a class="co" href="#code_g6_10" id="para_g6_10"><img alt="10" height="12" src="assets/10.png" width="12"/></a>).
That’s reasonable, because we want to change the given rectangle. A first
possible way to change the rectangle is to set the <code>width</code> via the <code>setWidth()</code>
member function to <code>7</code>
(<a class="co" href="#code_g6_11" id="para_g6_11"><img alt="11" height="12" src="assets/11.png" width="12"/></a>).
Then we could change the <code>height</code> of the rectangle to <code>4</code> via the <code>setHeight()</code>
member function
(<a class="co" href="#code_g6_12" id="para_g6_12"><img alt="12" height="12" src="assets/12.png" width="12"/></a>).</p>
<p>At this point, I would argue that you have an implicit assumption. I am pretty
certain that you assume that the area of the rectangle is <code>28</code>, because, of
course, <code>7</code> times <code>4</code> is <code>28</code>. That is an assumption we can test via an
assertion
(<a class="co" href="#code_g6_13" id="para_g6_13"><img alt="13" height="12" src="assets/13.png" width="12"/></a>).</p>
<p>The only thing missing is to actually call the <code>transform()</code>
function. That’s what we do in the <code>main()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting">
<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">{</code><code class="w">
</code><code class="w">   </code><code class="n">Square</code><code class="w"> </code><code class="n">s</code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_14" id="code_g6_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a><code class="w">
</code><code class="w">   </code><code class="n">s</code><code class="p">.</code><code class="n">setWidth</code><code class="p">(</code><code class="w"> </code><code class="mi">6</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="n">transform</code><code class="p">(</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#para_g6_15" id="code_g6_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w">
</code><code class="p">}</code><code class="w">
</code></pre>
<p>In the <code>main()</code> function, we create a special kind of rectangle: a <code>Square</code>
(<a class="co" href="#code_g6_14" id="para_g6_14"><img alt="14" height="12" src="assets/14.png" width="12"/></a>).<sup><a data-type="noteref" href="ch02.xhtml#idm45043120674128" id="idm45043120674128-marker">2</a></sup> This square is passed to the
<code>transform()</code> function, which of course
works, since a reference to a <code>Square</code> can be implicitly converted to a
reference to a <code>Rectangle</code>
(<a class="co" href="#code_g6_15" id="para_g6_15"><img alt="15" height="12" src="assets/15.png" width="12"/></a>).</p>
<p>If I were to ask you, “What happens?” I’m pretty sure you would
answer, “The <code>assert()</code> fails!” Yes, indeed, the <code>assert()</code> will fail.
The expression passed to the <code>assert()</code> will evaluate to <code>false</code>, and <code>assert()</code>
will crash the process with a <code>SIGKILL</code> signal. Well, that’s
certainly unfortunate. So let’s do a postmortem analysis: why does the
<code>assert()</code> fail? Our expectation in the <code>transform()</code> function is that
we can change the width and height of a rectangle independently. This
expectation is explicitly expressed with the two function calls
to <code>setWidth()</code> and <code>setHeight()</code>. However, unexpectedly, this special
kind of rectangle does not allow that: to preserve its own
invariants, the <code>Square</code> class must always make sure that both side
lengths are equal. Thus, the <code>Square</code> class has to violate this
expectation. This violation of the expectation in an abstraction is
a violation of the LSP.</p>
</div></section>
<section data-pdf-bookmark="The Liskov Substitution Principle" data-type="sect2"><div class="sect2" id="idm45043121125456">
<h2>The Liskov Substitution Principle</h2>
<p>The<a data-primary="abstractions" data-secondary="expected behavior of" data-tertiary="Liskov Substitution Principle (LSP)" data-type="indexterm" id="idm45043120627264"/><a data-primary="design principles" data-secondary="Liskov Substitution Principle (LSP)" data-type="indexterm" id="DPlsp01"/><a data-primary="Liskov Substitution Principle (LSP)" data-type="indexterm" id="LSP01"/><a data-primary="behavioral subtyping" data-type="indexterm" id="idm45043120623920"/> LSP is the third of the SOLID
principles and is concerned with <em>behavioral subtyping</em>, i.e., with the expected
behavior of an abstraction. This design principle is named after
<a href="https://oreil.ly/XkNi4">Barbara Liskov</a>, who initially
introduced it in 1988 and clarified it with Jeannette
Wing in 1994:<sup><a data-type="noteref" href="ch02.xhtml#idm45043120621936" id="idm45043120621936-marker">3</a></sup></p>
<blockquote>
<p>Subtype Requirement: Let <math alttext="phi left-parenthesis x right-parenthesis">
<mrow>
<mi>φ</mi>
<mo>(</mo>
<mi>x</mi>
<mo>)</mo>
</mrow>
</math> be a property provable about
objects <math alttext="x">
<mi>x</mi>
</math> of type T. Then <math alttext="phi left-parenthesis y right-parenthesis">
<mrow>
<mi>φ</mi>
<mo>(</mo>
<mi>y</mi>
<mo>)</mo>
</mrow>
</math> should be
true for objects <math alttext="y">
<mi>y</mi>
</math> of type S where S is a subtype of T.</p></blockquote>
<p>This<a data-primary="IS-A relationship" data-type="indexterm" id="idm45043120609872"/> principle formulates what we commonly call an <a href="https://oreil.ly/isoda"><em>IS-A</em></a>
relationship. This relationship, i.e., the expectations in an abstraction, <em>must</em>
be adhered to in a subtype. That includes the following properties:</p>
<ul>
<li>
<p>Preconditions cannot be strengthened in a subtype: a subtype cannot
expect more in a function than what the super type expresses. That would
violate the expectations in the abstraction:</p>
</li>
</ul>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">X</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="c1">// Precondition: the function accepts all 'i' greater than 0</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">f</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">Y</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// Precondition: the function accepts all 'i' greater than 10.</code>
<code class="w">   </code><code class="c1">// This would strengthen the precondition; numbers between 1 and 10</code>
<code class="w">   </code><code class="c1">// would no longer be allowed. This is a LSP violation!</code>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">f</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<ul>
<li>
<p>Postconditions cannot be weakened in a subtype: a subtype cannot
promise less when leaving a function than the super type promises. Again,
that would violate the expectations in the abstraction:</p>
</li>
</ul>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">X</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="c1">// Postcondition: the function will only return values larger than 0</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">f</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">      </code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">Y</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// Postcondition: the function may return any value.</code>
<code class="w">   </code><code class="c1">// This would weaken the postcondition; negative numbers and 0 would</code>
<code class="w">   </code><code class="c1">// be allowed. This is a LSP violation!</code>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="nf">f</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">override</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<ul>
<li>
<p>Function return types in a subtype must be<a data-primary="covariance" data-type="indexterm" id="idm45043120305328"/> <em>covariant</em>: member functions
of the subtype can return a type that is itself a subtype of the return type
of the corresponding member function in the super type. This property has direct
language support in C++. However, the subtype cannot
return any super type of the return type of the corresponding function in the
super type:</p>
</li>
</ul>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">Base</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...some virtual functions, including destructor...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Base</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">X</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="n">Base</code><code class="o">*</code><code class="w"> </code><code class="nf">f</code><code class="p">();</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">Y</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">Derived</code><code class="o">*</code><code class="w"> </code><code class="nf">f</code><code class="p">()</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">  </code><code class="c1">// Covariant return type</code>
<code class="p">};</code><code class="w"/></pre>
<ul>
<li>
<p>Function parameters in a subtype must be<a data-primary="contravariance" data-type="indexterm" id="idm45043120207440"/> <em>contravariant</em>: in a member
function, the subtype can accept a super type of the function parameter
in the corresponding member function of the super type. This property does
<em>not</em> have direct language support in C++:</p>
</li>
</ul>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">Base</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...some virtual functions, including destructor...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Base</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">X</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">f</code><code class="p">(</code><code class="w"> </code><code class="n">Derived</code><code class="o">*</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">Y</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="nf">f</code><code class="p">(</code><code class="w"> </code><code class="n">Base</code><code class="o">*</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">override</code><code class="p">;</code><code class="w">  </code><code class="c1">// Contravariant function parameter; Not</code>
<code class="w">                              </code><code class="c1">// supported in C++. Therefore the function</code>
<code class="w">                              </code><code class="c1">// does not override, but fails to compile.</code>
<code class="p">};</code><code class="w"/></pre>
<ul>
<li>
<p>Invariants of the super type must be preserved in a subtype: any
expectation about the state of a super type must always be valid before
and after all calls to any member function, including the member functions
of the subtype:</p>
</li>
</ul>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">explicit</code><code class="w"> </code><code class="n">X</code><code class="p">(</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">value_</code><code class="p">(</code><code class="n">v</code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">throw</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">invalid_argument</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">X</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="nf">get</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">value_</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w"> </code><code class="k">protected</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">value_</code><code class="p">;</code><code class="w">  </code><code class="c1">// Invariant: must be within the range [1..10]</code>
<code class="p">};</code><code class="w"/>

<code class="k">struct</code><code class="w"> </code><code class="nc">Y</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">X</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="n">Y</code><code class="p">()</code><code class="w"/>
<code class="w">      </code><code class="o">:</code><code class="w"> </code><code class="n">X</code><code class="p">()</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">value_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">11</code><code class="p">;</code><code class="w">  </code><code class="c1">// Broken invariant: After the constructor, 'value_'</code>
<code class="w">                    </code><code class="c1">// is out of expected range. One good reason to</code>
<code class="w">                    </code><code class="c1">// properly encapsulate invariants and to follow</code>
<code class="w">                    </code><code class="c1">// Core Guideline C.133: Avoid protected data.</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>In our example, the expectation in a <code>Rectangle</code> is that we can change
the two side lengths independently, or, more formally, that the result
of <code>getWidth()</code> does not change after <code>setHeight()</code> is called. This
expectation is intuitive for any kind of rectangle. However, the <code>Square</code>
class itself introduces the invariant that all sides must always
be equal, or else the <code>Square</code> would not properly express our idea of a
square. But by protecting its own invariants, the <code>Square</code> unfortunately
violates the expectations in the base class. Thus, the <code>Square</code> class doesn’t fulfill the expectations in the <code>Rectangle</code> class, and the hierarchy
in this example doesn’t express an IS-A relationship. Therefore, a <code>Square</code> cannot be used in all the places a <code>Rectangle</code> is expected.</p>
<p>“But isn’t a square a rectangle?” you ask. “Isn’t that properly
expressing the geometrical relation?”<sup><a data-type="noteref" href="ch02.xhtml#idm45043119856288" id="idm45043119856288-marker">4</a></sup> Yes, there
may be a geometrical relation between squares and rectangles, but in
this example the inheritance relationship is broken. This example
demonstrates that the mathematical IS-A relationship is indeed different
from the LSP 
<span class="keep-together">IS-A</span> relationship. While in geometry a square is always a
rectangle, in computer science it really depends on the actual interface
and thus the expectations. As long as there are the two independent
<code>setWidth()</code> and <code>setHeight()</code> functions, a <code>Square</code> will always violate
the expectations. “I understand,” you say. “Nobody would claim that,
geometrically, a square is still a square after changing its width, right?”
Exactly.</p>
<p>The example also demonstrates that inheritance is not a natural or
intuitive feature, but a hard feature. As stated in the beginning, building
abstractions is hard. Whenever you use inheritance, you <em>must</em> make sure that
all expectations in the base class are fulfilled and that the derived type
behaves as expected.</p>
</div></section>
<section data-pdf-bookmark="Criticism of the Liskov Substitution Principle" data-type="sect2"><div class="sect2" id="idm45043120628464">
<h2>Criticism of the Liskov Substitution Principle</h2>
<p>Some people argue that the LSP, as explained earlier, is in fact not what is
described in the conference paper “Data Abstraction and Hierarchy”
by Barbara Liskov and that the notion of subtyping is flawed. And that is
correct: we usually do not substitute derived objects for base objects, but
we use a derived object as a base object. However, this literal and strict
interpretation of Liskov’s statements does not play any role in the kinds
of abstractions that we build on a daily basis. In their 1994 paper
“A Behavioral Notion of Subtyping,” Barbara Liskov and Jeannette Wing proposed
the term<a data-primary="behavioral subtyping" data-type="indexterm" id="idm45043119851296"/> <em>behavioral subtyping</em>, which is the common understanding of the LSP
today.</p>
<p>Other people argue that because of potential violations of the LSP, a base
class does not serve the purpose of an abstraction. The rationale is that
using code would also depend on the (mis-)behavior of derived types. This
argument unfortunately turns the world upside down. A base class <em>does</em>
represent an abstraction, because calling code can and should only and
exclusively depend on the <em>expected</em> behavior of this abstraction. It’s
that dependency that makes LSP violations programming errors.
Unfortunately, sometimes people try to fix LSP violations by introducing
special workarounds:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">class</code><code class="w"> </code><code class="nc">Base</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">Derived</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Base</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="k">class</code><code class="w"> </code><code class="nc">Special</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Base</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="c1">// ... Potentially more derived classes</code>

<code class="kt">void</code><code class="w"> </code><code class="nf">f</code><code class="p">(</code><code class="w"> </code><code class="n">Base</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">if</code><code class="p">(</code><code class="w"> </code><code class="k">dynamic_cast</code><code class="o">&lt;</code><code class="n">Special</code><code class="w"> </code><code class="k">const</code><code class="o">*&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ... do something "special," knowing that 'Special' behaves differently</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">else</code><code class="w"/>
<code class="w">   </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ... do the expected thing</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This kind of workaround will indeed introduce a dependency in the behavior of the
derived types. And a very unfortunate dependency, indeed! This should always be
considered an LSP violation and very bad practice.<sup><a data-type="noteref" href="ch02.xhtml#idm45043119792896" id="idm45043119792896-marker">5</a></sup> It doesn’t serve as a general
argument against the abstracting properties of a base class.<a data-primary="" data-startref="LSP01" data-type="indexterm" id="idm45043119756384"/><a data-primary="" data-startref="DPlsp01" data-type="indexterm" id="idm45043119755440"/></p>
</div></section>
<section data-pdf-bookmark="The Need for Good and Meaningful Abstractions" data-type="sect2"><div class="sect2" id="idm45043119754368">
<h2>The Need for Good and Meaningful Abstractions</h2>
<p>To<a data-primary="abstractions" data-secondary="expected behavior of" data-tertiary="good and meaningful abstractions" data-type="indexterm" id="idm45043119752880"/> properly decouple software entities, it is fundamentally
important that we can count on our abstractions. Without meaningful
abstractions that we, the human readers of code, <em>fully</em>
understand, we cannot write robust and reliable software. Therefore,
adherence to the LSP is essential for the purpose of software design.

<span class="keep-together">However</span>, a vital part is also the clear and unambiguous
communication of the expectations of an abstraction. In the best case,
this happens by means of software itself<a data-primary="self-documenting code" data-type="indexterm" id="idm45043119750240"/> (<em>self-documenting code</em>),
but it also entails a proper documentation of abstractions. As a
good example, I recommend the <a href="https://oreil.ly/OBpAg">iterator concepts documentation</a>
in the 
<span class="keep-together">C++</span> standard, which clearly lists the expected behavior,
including pre- and post-conditions.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043119747264">
<h5>Guideline 6: Adhere to the Expected Behavior of Abstractions</h5>
<ul>
<li>
<p>Understand that an abstraction represents a set of requirements and 
<span class="keep-together">expectations</span>.</p>
</li>
<li>
<p>Follow the Liskov Substitution Principle (LSP) to adhere to the expected behavior of abstractions.</p>
</li>
<li>
<p>Make sure that derived classes adhere to the expected behavior of their base classes.</p>
</li>
<li>
<p>Communicate the expectations of an abstraction.<a data-primary="" data-startref="ABbehav02" data-type="indexterm" id="idm45043119663056"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 7: Understand the Similarities Between &#10;Base Classes and Concepts" data-type="sect1"><div class="sect1" id="understand_the_similarities_between_base_classes_and_concepts">
<h1>Guideline 7: Understand the Similarities Between 
<span class="keep-together">Base Classes and Concepts</span></h1>
<p>In<a data-primary="abstractions" data-secondary="base classes versus concepts" data-type="indexterm" id="Abase02"/><a data-primary="base classes, versus concepts" data-type="indexterm" id="basclas02"/><a data-primary="concepts, versus base classes" data-type="indexterm" id="concepts02"/> <a data-type="xref" href="#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>, I may have created
the impression that the LSP is concerned only
with inheritance hierarchies and base classes. To make sure that this
impression doesn’t stick, allow me to explicitly state that the LSP is
<em>not</em> limited to dynamic (runtime) polymorphism and inheritance hierarchies. On
the contrary, we can apply the LSP just as well to static (compile-time)
polymorphism and templated code.</p>
<p>To make the point, let me ask you a question: what’s the difference between the
following two code snippets?</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//==== Code Snippet 1 ====</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Document</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="o">~</code><code class="n">Document</code><code class="p">()</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">default</code><code class="p">;</code><code class="w"/>

<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="k">virtual</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">ByteStream</code><code class="o">&amp;</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">};</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">useDocument</code><code class="p">(</code><code class="w"> </code><code class="n">Document</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">doc</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">doc</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/>


<code class="c1">//==== Code Snippet 2 ====</code>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">concept</code><code class="w"> </code><code class="nc">Document</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">   </code><code class="k">requires</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="n">t</code><code class="p">,</code><code class="w"> </code><code class="n">ByteStream</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">t</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">t</code><code class="p">.</code><code class="n">serialize</code><code class="p">(</code><code class="w"> </code><code class="n">b</code><code class="p">,</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="p">};</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="n">Document</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">useDocument</code><code class="p">(</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">doc</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="w">   </code><code class="n">doc</code><code class="p">.</code><code class="n">exportToJSON</code><code class="p">(</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"/></pre>
<p>I’m pretty sure your first answer is that the first code snippet shows a solution
using<a data-primary="dynamic polymorphism" data-type="indexterm" id="idm45043119650992"/> dynamic polymorphism, and the second one shows<a data-primary="static polymorphism" data-type="indexterm" id="idm45043119650256"/> static polymorphism. Yes, great!
What else? OK, yes, of course, the syntax is different, too. OK, I see, I should
ask my question a little more precisely: in which way do these two solutions differ 
<span class="keep-together"><em>semantically</em>?</span></p>
<p>Well, if you think about it, then you might find that from a
semantic point of view the two solutions are very similar indeed. In the first
code snippet, the 
<span class="keep-together"><code>useDocument()</code></span> function works only with classes derived from
the <code>Document</code> base class. Thus, we can say that the function works only with
classes adhering to the expectations of the <code>Document</code> abstraction. In the second
code snippet, the <code>use​Docu⁠ment()</code> function works only with classes that implement
the <code>Document</code> concept. In other words, the function works only with classes
adhering to the expectations of the <code>Document</code> abstraction.</p>
<p>If you now have the feeling of déjà vu, then my choice of words hopefully
struck a chord. Yes, in both code snippets, the <code>useDocument()</code> function
works only with classes adhering to the expectations of the <code>Document</code> abstraction.
So despite the fact that the first code snippet is based on a runtime
abstraction and the second function represents a compile-time abstraction,
these two functions are very similar from a semantic point of view.</p>
<p>Both the base class and the concept represent a set of requirements
(syntactic requirements, but also semantic requirements). As such, both
represent a formal description of the expected behavior and thus are the
means to express and communicate expectations for calling code. Thus, concepts
can be considered the equivalent, the static counterpart, of base classes.
And from this point of view, it makes perfect sense to also consider the
LSP for template code.</p>
<p>“I’m not buying that,” you say. “I’ve heard that C++20
concepts cannot express semantics!”<sup><a data-type="noteref" href="ch02.xhtml#idm45043119546544" id="idm45043119546544-marker">6</a></sup>
Well, to this I can only respond with a definitive yes and no. Yes, 
<span class="keep-together">C++20</span>
concepts cannot fully express semantics, that’s correct. But on the other hand,
concepts still express expected behavior. Consider, for instance, the C++20
form of the <code>std::copy()</code> algorithm:<sup><a data-type="noteref" href="ch02.xhtml#idm45043119543760" id="idm45043119543760-marker">7</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">InputIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">OutputIt</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">constexpr</code><code class="w"> </code><code class="n">OutputIt</code><code class="w"> </code><code class="n">copy</code><code class="p">(</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">OutputIt</code><code class="w"> </code><code class="n">d_first</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">while</code><code class="p">(</code><code class="w"> </code><code class="n">first</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="n">last</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="o">*</code><code class="n">d_first</code><code class="o">++</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">first</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">d_first</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>std::copy()</code> algorithm expects three arguments. The<a data-primary="input range" data-type="indexterm" id="idm45043119369824"/><a data-primary="output range" data-type="indexterm" id="idm45043119266384"/> first two arguments
represent the range of elements that need to be copied (the <em>input range</em>).
The third argument represents the first element we need to copy to (the
<em>output range</em>). A general expectation is that the <em>output range</em> is big
enough that all the elements from the <em>input range</em> can be copied to
it.</p>
<p>There are more expectations that are implicitly
expressed via the names for the iterator types: <code>InputIt</code> and
<code>OutputIt</code>. <code>InputIt</code> represents a type of<a data-primary="input iterators" data-type="indexterm" id="idm45043119261776"/> <em>input iterator</em>. The

<span class="keep-together">C++</span> standard states all the expectations of such
iterator types, such as the availability of an (in-)equality
comparison, the ability to traverse a range with a prefix and postfix
increment (<code>operator++()</code> and <code>operator++(int)</code>),
and the ability to access elements with the dereference operator (<code>operator*()</code>).
<code>OutputIt</code>, on the other hand, 
<span class="keep-together">represents</span> a type of<a data-primary="output iterators" data-type="indexterm" id="idm45043119257328"/> <em>output iterator</em>.
Here, the C++ standard also explicitly states all expected
operations.</p>
<p><code>InputIt</code> and <code>OutputIt</code> may not be C++20 concepts, but they represent the same idea: these named template parameters don’t just
give you an idea about what kind of type is required; they also express
expected behavior. For instance, we expect that subsequent
increments of <code>first</code> will eventually yield <code>last</code>. If any given
concrete iterator type does not behave this way, <code>std::copy()</code> will
not work as expected. This would be a violation of the expected behavior,
and as such, a violation of the LSP.<sup><a data-type="noteref" href="ch02.xhtml#idm45043119253776" id="idm45043119253776-marker">8</a></sup> Therefore, both <code>InputIt</code> and
<code>OutputIt</code> represent LSP abstractions.</p>
<p>Note that since concepts represent an LSP abstraction, i.e., a set of
requirements and expectations, they are subject to the <em>Interface Segregation
Principle</em> (ISP) as well (see <a data-type="xref" href="ch01.xhtml#separate_interfaces_to_avoid_artificial_coupling">“Guideline 3: Separate Interfaces to Avoid 
<span class="keep-together">Artificial Coupling</span>”</a>).
Just as you should separate concerns in the definition of requirements in the form
of base classes (say, “interface” classes), you should separate concerns when defining
a concept. The Standard Library iterators do that by building on one another, thus
allowing you to select the desired level of requirements:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">I</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">concept</code><code class="w"> </code><code class="nc">input_or_output_iterator</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">  </code><code class="cm">/* ... */</code><code class="p">;</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">I</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">concept</code><code class="w"> </code><code class="nc">input_iterator</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">input_or_output_iterator</code><code class="o">&lt;</code><code class="n">I</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* ... */</code><code class="p">;</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">I</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">concept</code><code class="w"> </code><code class="nc">forward_iterator</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">   </code><code class="n">std</code><code class="o">::</code><code class="n">input_iterator</code><code class="o">&lt;</code><code class="n">I</code><code class="o">&gt;</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"/>
<code class="w">   </code><code class="cm">/* ... */</code><code class="p">;</code><code class="w"/></pre>
<p>Since both named template parameters and C++20 concepts serve
the same purpose and since both represent LSP abstractions, from now
on, in all subsequent guidelines, I will use the term <em>concept</em> to refer
to both of them. Thus, with the term <em>concept</em>, I will refer to any way to
represent a set of requirements (in most cases for template arguments, but
sometimes even more generally). If I want to refer to either of these
two specifically, I will make it explicitly clear.</p>
<p>In summary, any kind of abstraction (dynamic and static) represents
a set of requirements with that expected behavior. These expectations
need to be fulfilled by concrete implementations. Thus, the LSP clearly
represents essential guidance for all kinds of IS-A relationships.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043119224784">
<h5>Guideline 7: Understand the Similarities Between Base Classes 
<span class="keep-together">and Concepts</span></h5>
<ul>
<li>
<p>Apply the Liskov Substitution Principle (LSP) to both dynamic and static 
<span class="keep-together">polymorphism.</span></p>
</li>
<li>
<p>Consider concepts (both the C++20 feature and pre-C++20 named template arguments) as the static equivalent of base classes.</p>
</li>
<li>
<p>Adhere to the expected behavior of concepts when using templates.</p>
</li>
<li>
<p>Communicate the expectations of a concept (in particular for pre-C++20 named template arguments).<a data-primary="" data-startref="Abase02" data-type="indexterm" id="idm45043119219088"/><a data-primary="" data-startref="basclas02" data-type="indexterm" id="idm45043119218112"/><a data-primary="" data-startref="concepts02" data-type="indexterm" id="idm45043119217168"/></p>
</li>
</ul>
</div></aside>
</div></section>
<section data-pdf-bookmark="Guideline 8: Understand the Semantic Requirements of Overload Sets" data-type="sect1"><div class="sect1" id="understand_the_semantic_requirements_of_overload_sets">
<h1>Guideline 8: Understand the Semantic Requirements of Overload Sets</h1>
<p>In<a data-primary="abstractions" data-secondary="overload sets" data-type="indexterm" id="ABover02"/><a data-primary="abstractions" data-secondary="overload sets" data-tertiary="semantic requirements of" data-type="indexterm" id="idm45043119126192"/><a data-primary="overload sets" data-secondary="semantic requirements of" data-type="indexterm" id="overset02"/> <a data-type="xref" href="#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>, I introduced you to the
LSP and hopefully made a strong argument: <em>every</em>
abstraction represents a set of semantic requirements! In other words, an abstraction
expresses expected behavior, which needs to be fulfilled. Otherwise, you (very likely) will 
<span class="keep-together">have a problem.</span> In <a data-type="xref" href="#understand_the_similarities_between_base_classes_and_concepts">“Guideline 7: Understand the Similarities Between 
<span class="keep-together">Base Classes and Concepts</span>”</a>,
I extended the LSP discussion to concepts and demonstrated that
the LSP can and <em>should</em> also be applied to static abstractions.</p>
<p>That’s not the end of the story, though. As stated before: <em>every</em> abstraction represents
a set of requirements. There is one more kind of abstraction that we have not yet taken into
account, one that’s unfortunately often overlooked, despite its power, and hence one that we
should not forget in the discussion: function overloading. “Function overloading? You mean
the fact that a class can have several functions with the same name?”
Yes, absolutely. You probably have experienced that this is indeed a pretty powerful
feature. Think, for instance, about the two overloads of the <code>begin()</code> member function inside
the <code>std::vector</code>: depending on whether you have a <code>const</code> or a non-<code>const</code> vector, the
corresponding overload is picked. Without you even noticing. Pretty powerful! But honestly,
this isn’t really much of an abstraction. While it’s convenient and helpful to overload
member functions, I have a different kind of function overloading in mind, the kind that
truly represents a form of abstraction: free functions.</p>
<section data-pdf-bookmark="The Power of Free Functions: A Compile-Time Abstraction Mechanism" data-type="sect2"><div class="sect2" id="idm45043119117792">
<h2>The Power of Free Functions: A Compile-Time Abstraction Mechanism</h2>
<p>Next<a data-primary="abstractions" data-secondary="overload sets" data-tertiary="free functions" data-type="indexterm" id="idm45043119115936"/><a data-primary="overload sets" data-secondary="free functions and" data-type="indexterm" id="idm45043119114688"/><a data-primary="free functions" data-type="indexterm" id="freefunc02"/> to concepts, function overloading by means of free functions represents a second
compile-time abstraction: based on some given types, the compiler figures out which function
to call from a set of identically named functions. This is what we call an <em>overload set</em>. This is an extremely versatile and powerful abstraction mechanism with many, many great design
characteristics. First of all, you can add a free function to any type: you can add one to
an <code>int</code>, to <code>std::string</code>, and to any other type. Nonintrusively. Try that with a member
function, and you will realize that this just does not work. Adding a member function is
intrusive. You can’t add anything to a type that cannot have a member function or to a type
that you cannot modify. Thus, a free function perfectly lives up to the spirit of the
Open-Closed Principle (OCP): you can extend the functionality by simply adding code,
without the need to modify already existing code.</p>
<p>This gives you a significant design advantage. Consider, for instance, the following code
example:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Range</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">traverseRange</code><code class="p">(</code><code class="w"> </code><code class="n">Range</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">range</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="n">pos</code><code class="o">=</code><code class="n">range</code><code class="p">.</code><code class="n">begin</code><code class="p">();</code><code class="w"> </code><code class="n">pos</code><code class="o">!=</code><code class="n">range</code><code class="p">.</code><code class="n">end</code><code class="p">();</code><code class="w"> </code><code class="o">++</code><code class="n">pos</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>traverseRange()</code> function performs a traditional, iterator-based loop over the given
<code>range</code>. To acquire iterators, it calls the <code>begin()</code> and <code>end()</code> member functions
on the <code>range</code>. While this code will work for a large number of container types, it will
not work for a built-in array:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">array</code><code class="p">[</code><code class="mi">6</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">15</code><code class="p">,</code><code class="w"> </code><code class="mi">16</code><code class="p">,</code><code class="w"> </code><code class="mi">23</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="n">traverseRange</code><code class="p">(</code><code class="w"> </code><code class="n">array</code><code class="w"> </code><code class="p">);</code><code class="w">  </code><code class="c1">// Compilation error!</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This code will not compile, as the compiler will complain about the missing <code>begin()</code> and
<code>end()</code> member functions for the given array type. “Isn’t that why we should avoid using
built-in arrays and use <code>std::array</code> instead?” I completely agree: you should use
<code>std::array</code> instead. This is also very nicely explained by <a href="https://oreil.ly/FRrfz">Core Guideline SL.con.1</a>:</p>
<blockquote>
<p>Prefer using STL <code>array</code> or <code>vector</code> instead of a C array.</p></blockquote>
<p>However, while this is good practice, let’s not lose sight of the design issues of the
<code>traverseRange()</code> function: <code>traverseRange()</code> is restricting itself by depending on the
<code>begin()</code> and <code>end()</code> member functions. Thus, it creates an artificial requirement on the
<code>Range</code> type to support a member <code>begin()</code> and a member <code>end()</code> function and, by that, limits
its own applicability. There is a simple solution, however, a simple way to make the function
much more widely applicable: build on the overload set of free <code>begin()</code> and <code>end()</code>
functions:<sup><a data-type="noteref" href="ch02.xhtml#idm45043118921264" id="idm45043118921264-marker">9</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">Range</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">traverseRange</code><code class="p">(</code><code class="w"> </code><code class="n">Range</code><code class="w"> </code><code class="k">const</code><code class="o">&amp;</code><code class="w"> </code><code class="n">range</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">begin</code><code class="p">;</code><code class="w">  </code><code class="c1">// using declarations for the purpose of calling</code>
<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">end</code><code class="p">;</code><code class="w">    </code><code class="c1">//   'begin()' and 'end()' unqualified to enable ADL</code>

<code class="w">   </code><code class="k">for</code><code class="p">(</code><code class="w"> </code><code class="k">auto</code><code class="w"> </code><code class="n">pos</code><code class="o">=</code><code class="n">begin</code><code class="p">(</code><code class="n">range</code><code class="p">);</code><code class="w"> </code><code class="n">pos</code><code class="o">!=</code><code class="n">end</code><code class="p">(</code><code class="n">range</code><code class="p">);</code><code class="w"> </code><code class="o">++</code><code class="n">pos</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="c1">// ...</code>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This function is still doing the same thing as before, but in this form it doesn’t restrict
itself by any artificial requirement. And indeed, there is no restriction: <em>any</em> type can
have a free <code>begin()</code> and <code>end()</code> function or, if it is missing, can be equipped with one.
Nonintrusively. Thus, this function works with any kind of <code>Range</code> and doesn’t have to
be modified or overloaded if some type does not meet the requirement. It is more widely
applicable. It is truly generic.<sup><a data-type="noteref" href="ch02.xhtml#idm45043118837984" id="idm45043118837984-marker">10</a></sup></p>
<p>Free functions have more advantages, though. As already discussed in
<a data-type="xref" href="ch01.xhtml#design_for_testability">“Guideline 4: Design for Testability”</a>, free functions are a very elegant technique to separate concerns,
fulfilling the Single-Responsibility Principle (SRP). By implementing an operation
outside a class, you automatically reduce the dependencies of that class to the operation.
Technically, this becomes immediately clear, since in contrast to member functions, free
functions don’t have an implicit first argument, the <code>this</code> pointer. At the same time,
this promotes the function to become a separate, isolated service, which can be used by
many other classes as well. Thus, you promote reuse and reduce duplication. This very,
very nicely adheres to the idea of the Don’t Repeat Yourself (DRY) principle.</p>
<p>The<a data-primary="Standard Template Library (STL)" data-type="indexterm" id="idm45043118834096"/><a data-primary="STL (Standard Template Library)" data-type="indexterm" id="idm45043118833392"/> beauty of this is wonderfully demonstrated in Alexander Stepanov’s brainchild, the
Standard Template Library (STL).<sup><a data-type="noteref" href="ch02.xhtml#idm45043118832496" id="idm45043118832496-marker">11</a></sup> One part of the STL philosophy is to loosely couple the
different pieces of functionality and promote reuse by separating concerns
as free functions. That’s why containers and algorithms are two
separate concepts within the STL: conceptually, containers don’t know about the algorithms,
and algorithms don’t know about containers. The abstraction between them is accomplished
via iterators that allow you to combine the two in seemingly endless ways. A truly
remarkable design. Or to say it in the words of Scott Meyers:<sup><a data-type="noteref" href="ch02.xhtml#idm45043118831152" id="idm45043118831152-marker">12</a></sup></p>
<blockquote>
<p>There was never any question that the [standard template] library represented a breakthrough
in efficient and extensible design.</p></blockquote>
<p>“But what about <code>std::string</code>? <code>std::string</code> comes with dozens of member functions,
including many algorithms.” You’re making a good point, but more in the sense of a counter
example. Today the community agrees that the design of <code>std::string</code> is not great. Its design
promotes coupling, duplication, and growth: in every new C++ standard, there are a
couple of new, additional member functions. And growth means modifications and subsequently
the risk of accidentally changing something. This is a risk that you want to avoid in your
design. However, in its defense, <code>std::string</code> was not part of the original STL. It
was not designed alongside the STL containers (<code>std::vector</code>, <code>std::list</code>, <code>std::set</code>, etc.)
and was adapted to the STL design only later. That explains why it’s different from the other
STL containers and does not completely share their beautiful design goal.</p>
</div></section>
<section data-pdf-bookmark="The Problem of Free Functions: Expectations on the Behavior" data-type="sect2"><div class="sect2" id="idm45043118792368">
<h2>The Problem of Free Functions: Expectations on the Behavior</h2>
<p>Apparently, free functions<a data-primary="abstractions" data-secondary="overload sets" data-tertiary="expectations of free functions" data-type="indexterm" id="idm45043118790800"/><a data-primary="overload sets" data-secondary="expectations of free functions" data-type="indexterm" id="idm45043118789648"/> are remarkably powerful and seriously important for generic
programming. They play a vital role in the design of the STL and the design of the
C++ Standard Library as a whole, which builds on the power of this abstraction
mechanism.<sup><a data-type="noteref" href="ch02.xhtml#idm45043118788608" id="idm45043118788608-marker">13</a></sup>
However, all of this power can only work if a set of overload functions adheres to
a set of rules and certain expectations. It can only work if it adheres to the LSP.</p>
<p>For instance, let’s imagine that you have written your own <code>Widget</code> type and want to
provide a custom <code>swap()</code> operation for it:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Widget.h&gt; ----------------</code>

<code class="k">struct</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">j</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">swap</code><code class="p">(</code><code class="w"> </code><code class="n">Widget</code><code class="o">&amp;</code><code class="w"> </code><code class="n">w1</code><code class="p">,</code><code class="w"> </code><code class="n">Widget</code><code class="o">&amp;</code><code class="w"> </code><code class="n">w2</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">swap</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">w1</code><code class="p">.</code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="n">w2</code><code class="p">.</code><code class="n">i</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Your <code>Widget</code> only needs to be a simple wrapper for <code>int</code> values, called <code>i</code> and
<code>j</code>. You provide the corresponding <code>swap()</code> function as an accompanying free function. And
you implement <code>swap()</code> by swapping only the <code>i</code> value, not the <code>j</code> value. Further imagine
that your <code>Widget</code> type is used by some other developer, maybe a kind coworker.
At some point, this coworker calls the <code>swap()</code> function:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Widget.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">Widget</code><code class="w"> </code><code class="n">w1</code><code class="p">{</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">11</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">   </code><code class="n">Widget</code><code class="w"> </code><code class="n">w2</code><code class="p">{</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">22</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">w1</code><code class="p">,</code><code class="w"> </code><code class="n">w2</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="c1">// Widget w1 contains (2,11)</code>
<code class="w">   </code><code class="c1">// Widget w2 contains (1,22)</code>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Can you imagine the surprise of your coworker when after the <code>swap()</code> operation the
content of <code>w1</code> is not <code>(2,22)</code> but <code>(2,11)</code> instead? How unexpected is it that
only part of the object is swapped? Can you imagine how frustrated your coworker must
be after an hour of debugging? And what would happen if this wasn’t a <em>kind</em> coworker?</p>
<p>Clearly, the implementation of <code>swap()</code> doesn’t fulfill the expectations of a <code>swap()</code>
function. Clearly, anyone would expect that the entire observable
state of the object is swapped. Clearly, there are behavioral expectations. Thus, if you buy
into an overload set, you’re immediately and inevitably subject to fulfill the expected
behavior of the overload set. In other words, you have to adhere to the LSP.</p>
<p>“I see the problem, I get that. I promise to adhere to the LSP,” you say. That’s great,
and this is an honorable intention. The problem is that it might not always be entirely
clear what the expected behavior is, especially for an overload set that is scattered
across a big codebase. You
might not know about all the expectations and all the details. Thus sometimes, even if
you’re aware of this problem and pay attention, you might still not do the “right”
thing. This is what several people in the community are worried about: the unrestricted ability to
add potentially LSP-violating functionality into an overload
set.<sup><a data-type="noteref" href="ch02.xhtml#idm45043118634976" id="idm45043118634976-marker">14</a></sup> And as stated before, it’s easy to do. Anyone, anywhere, can add free functions.</p>
<p>As always, every approach and every solution has advantages, and also disadvantages.
On the one hand, it is enormously beneficial to exploit the power of overload sets, but
on the other hand, it is potentially very difficult to do the right thing. These two sides
of the same coin are also expressed by <a href="https://oreil.ly/IyZwR">Core Guideline C.162</a>
and <a href="https://oreil.ly/8VWH1">Core Guideline C.163</a>:</p>
<blockquote>
<p>Overload operations that are roughly equivalent.</p>
<p data-type="attribution">Core Guideline C.162</p>
</blockquote>
<blockquote>
<p>Overload only for operations that are roughly equivalent.</p>
<p data-type="attribution">Core Guideline C.163</p>
</blockquote>
<p>Whereas C.162 expresses the advantages of having the same name for semantically equivalent
functions, C.163 expresses the problem of having the same name 
<span class="keep-together">for semantically</span> different
functions. Every C++ developer should be aware of the tension between these two
guidelines. Additionally, to adhere to the expected
behavior, every C++ developer is well advised to be aware of existing overload
sets (<code>std::swap()</code>, <code>std::begin()</code>, <code>std::cbegin()</code>, <code>std::end()</code>, <code>std::cend()</code>, <code>std::data()</code>,
<code>std::size()</code>, etc.) and to know about common naming conventions. For instance, the name
<code>find()</code> should be used only for a function that performs a linear search over a range of
elements. For any function that performs a binary search, the name <code>find()</code> would raise
the wrong expectations and would not communicate the precondition that the range needs to
be sorted. And then, of course, the names <code>begin()</code> and <code>end()</code> should always fulfill the
expectation to return a pair of iterators that can be used to traverse a range. They should
not start or end some kind of process. This task would be better performed by a <code>start()</code>
and a <code>stop()</code> function.<sup><a data-type="noteref" href="ch02.xhtml#idm45043118570624" id="idm45043118570624-marker">15</a></sup></p>
<p>“Well, I agree with all these points,” you say. “However, I’m primarily using virtual
functions, and since these cannot be implemented in terms of free functions, I can’t really
use all of this advice on overload sets, right?” It may surprise you, but this advice still
applies to you. Since the ultimate goal is to reduce dependencies, and since virtual functions
may cause quite a significant amount of coupling, one of the goals will be to “free” these,
too. In fact, in many of the subsequent guidelines, and perhaps most prominently in
<a data-type="xref" href="ch05.xhtml#use_strategy_to_isolate_how_things_are_done">“Guideline 19: Use Strategy to Isolate How Things Are Done”</a> and
<a data-type="xref" href="ch07.xhtml#use_external_polymorphism_for_non_intrusive_runtime_polymorphism">“Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism”</a>,
I will tell the story of how to extract and 
<span class="keep-together">separate virtual</span> functions in the
form of, but not limited to, free functions.</p>
<p>In summary, function overloading is a powerful compile-time abstraction mechanism
that you should not underestimate. In particular, generic programming heavily exploits this
power. However, don’t take this power too lightly: remember that just as with base classes
and concepts, an overload set represents a set of semantic requirements and thus is subject
to the LSP. The expected behavior of an overload set must be adhered to, or things will
not work well.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043118566288">
<h5>Guideline 8: Understand the Semantic Requirements of Overload Sets</h5>
<ul>
<li>
<p>Be aware that function overloading is a compile-time abstraction mechanism.</p>
</li>
<li>
<p>Keep in mind that there are expectations on the behavior of functions within an overload set.</p>
</li>
<li>
<p>Pay attention to existing names and conventions.<a data-primary="" data-startref="ABover02" data-type="indexterm" id="idm45043118562256"/><a data-primary="" data-startref="freefunc02" data-type="indexterm" id="idm45043118561280"/><a data-primary="" data-startref="overset02" data-type="indexterm" id="idm45043118560336"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 9: Pay Attention to the Ownership of Abstractions" data-type="sect1"><div class="sect1" id="pay_attention_to_the_ownership_of_abstractions">
<h1>Guideline 9: Pay Attention to the Ownership of Abstractions</h1>
<p>As<a data-primary="abstractions" data-secondary="ownership of" data-type="indexterm" id="ABown02"/> stated in <a data-type="xref" href="ch01.xhtml#design_for_change">“Guideline 2: Design for Change”</a>, change is the one constant in software
development. Your software should be prepared for change. One of the
essential ingredients for dealing with change is the introduction of
abstractions (see also <a data-type="xref" href="#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>).
Abstractions help reduce dependencies and thus make it easier to change
details in isolation. However, there is more to introducing abstractions
than just adding base classes or templates.</p>
<section data-pdf-bookmark="The Dependency Inversion Principle" data-type="sect2"><div class="sect2" id="idm45043118553728">
<h2>The Dependency Inversion Principle</h2>
<p>The<a data-primary="abstractions" data-secondary="ownership of" data-tertiary="Dependency Inversion Principle (DIP)" data-type="indexterm" id="idm45043118551152"/><a data-primary="Dependency Inversion Principle (DIP)" data-secondary="defined" data-type="indexterm" id="idm45043118549904"/><a data-primary="DIP" data-see="Dependency Inversion Principle" data-type="indexterm" id="idm45043118548992"/><a data-primary="design principles" data-secondary="Dependency Inversion Principle (DIP)" data-type="indexterm" id="DPdip02"/> need for abstractions is also expressed by Robert
Martin:<sup><a data-type="noteref" href="ch02.xhtml#idm45043118546768" id="idm45043118546768-marker">16</a></sup></p>
<blockquote>
<p>The most flexible systems are those in which source code dependencies refer only
to abstractions, not to concretions.</p></blockquote>
<p class="less_space pagebreak-before">This piece of wisdom is commonly known as the Dependency Inversion Principle
(DIP), which is the fifth of the SOLID principles. Simply stated, it advises
that for the sake of dependencies, you should depend on abstractions instead of concrete types or implementation details.
Note that this statement doesn’t say anything about inheritance hierarchies
but only mentions abstractions in general.</p>
<p>Let’s<a data-primary="Dependency Inversion Principle (DIP)" data-secondary="example" data-type="indexterm" id="DIPex02"/><a data-primary="abstractions" data-secondary="ownership of" data-tertiary="strong dependency relationships" data-type="indexterm" id="idm45043118542480"/> take a look at the situation illustrated in <a data-type="xref" href="#fig_dip_1">Figure 2-1</a>.<sup><a data-type="noteref" href="ch02.xhtml#idm45043118540336" id="idm45043118540336-marker">17</a></sup> Imagine you are implementing the logic
for an automated teller machine (ATM). An ATM provides several kinds of
operations: you can withdraw money,
deposit money, and transfer money. Since all of these operations deal
with real money, they should either run to full completion or, in case of any
kind of error, be aborted and all changes rolled back. This kind
of behavior (either 100% success or a complete rollback) is what we commonly call
a <em>transaction</em>. Consequently, we can introduce an abstraction named 
<span class="keep-together"><code>Transaction</code></span>.
All abstractions (<code>Deposit</code>, <code>Withdrawal</code>, and <code>Transfer</code>) inherit from the

<span class="keep-together"><code>Transaction</code></span> class (depicted by the UML inheritance arrow).</p>
<figure><div class="figure" id="fig_dip_1">
<img alt="A visualization of the initially strong dependency relation between several transactions and a UI" height="906" src="assets/cpsd_0201.png" width="1368"/>
<h6><span class="label">Figure 2-1. </span>Initial strong dependency relationship between several transactions and 
<span class="keep-together">a UI</span></h6>
</div></figure>
<p>All transactions are in need of input data entered by a bank customer via
the 
<span class="keep-together">user interface.</span> This user interface is provided by the <code>UI</code> class, which
provides many different functions to query for the entered data:
<code>requestDepositAmount()</code>, <code>request​WithdrawalAmount()</code>, <code>requestTransferAmount()</code>,
<code>informInsufficientFunds()</code>, and potentially more functions. All three abstractions
directly call these functions whenever they need information. This
relationship is depicted by the little solid arrow, which indicates
that the abstractions depend on the <code>UI</code> class.</p>
<p>While this setup may work for some time, your trained eye might have
already spotted a potential problem: what happens if something changes? For
instance, what happens if a new transaction is added to the system?</p>
<p>Let’s assume that we must add a <code>SpeedTransfer</code> transaction for
VIP customers. This might require us to change and extend the <code>UI</code> class with
a couple of new functions (for instance, <code>requestSpeedTransferAmount()</code> and
<code>requestVIPNumber()</code>). That, in turn, also affects all of the other
transactions, since they directly depend on the <code>UI</code> class. In the best
case, these transactions simply have to be recompiled and retested (still,
this takes time!); in the worst case, they might have to be redeployed in
case they are delivered in separate shared libraries.</p>
<p>The underlying reason for all of that extra effort is a broken architecture.
All transactions indirectly depend on one another via the concrete dependency
on the <code>UI</code> class. And that is a very unfortunate situation from an architectural
point of view: the transaction classes reside at the high level of our
architecture, while the <code>UI</code> class resides at the low level. In this
example, the high level depends on the low level. And that is just wrong:
in a proper architecture, this dependency should be inverted.<sup><a data-type="noteref" href="ch02.xhtml#idm45043118524784" id="idm45043118524784-marker">18</a></sup></p>
<p>All transactions indirectly depend on one another due
to the dependency on the <code>UI</code> class. Furthermore, the high level of our
architecture depends on the low level. This is a pretty unfortunate situation
indeed, a situation that we should resolve properly. “But that’s simple!”
you say. “We just introduce an abstraction!” That’s exactly what Robert
Martin expressed in his statement: we need to introduce an abstraction
in order not to depend on the concrete implementation in the <code>UI</code> class.</p>
<p>However, a single abstraction wouldn’t solve the problem. The three kinds
of transactions would still be indirectly coupled. No, as <a data-type="xref" href="#fig_dip_2">Figure 2-2</a>
illustrates, we need three abstractions: one for each transaction.<sup><a data-type="noteref" href="ch02.xhtml#idm45043118521184" id="idm45043118521184-marker">19</a></sup></p>
<figure><div class="figure" id="fig_dip_2">
<img alt="A visualization of the relaxed dependency relation between several transactions and a UI" height="1206" src="assets/cpsd_0202.png" width="1430"/>
<h6><span class="label">Figure 2-2. </span>The relaxed dependency relationship between several transactions and a UI</h6>
</div></figure>
<p class="less_space pagebreak-before">By<a data-primary="abstractions" data-secondary="ownership of" data-tertiary="relaxed dependency relationships" data-type="indexterm" id="idm45043118513664"/> introducing the <code>DepositUI</code>, <code>WithdrawalUI</code>, and
<code>TransferUI</code> classes, we’ve broken the dependency among the three
transactions. The three transactions are no longer dependent on the
concrete <code>UI</code> class, but on a lightweight abstraction that
represents only those operations that the relevant transaction truly
requires. If we now introduce the <code>SpeedTransfer</code> transaction,
we can also introduce the 
<span class="keep-together"><code>SpeedTransferUI</code></span> abstraction, so none
of the other transactions will be affected by the changes introduced
in the <code>UI</code> class.</p>
<p>“Oh, yes, I get it! This way we have fulfilled three design principles!”
You sound impressed. “We’ve introduced an abstraction to cut the
dependency on the implementation details of the user interface. That must be
the DIP. And we’ve followed the ISP and removed the dependencies
among the different transactions. And as a bonus, we have also nicely grouped
the things that truly belong together. That’s the SRP, right? That’s
amazing! Let’s celebrate!”</p>
<p>Wait, wait, wait…Before you go off to uncork your best bottle of
champagne to celebrate solving this dependency problem, let’s take a
closer look at the problem. So yes, you are correct, we follow the ISP
by separating the concerns of the <code>UI</code> class. By segregating it into three
client-specific interfaces, we’ve resolved the dependency situation
among the three transactions. This is indeed the ISP. Very nice!</p>
<p>Unfortunately, we haven’t resolved our architectural problem yet, so no,
we do not follow the DIP (yet). But I get the misunderstanding:
it does appear as if we have inverted the dependencies. <a data-type="xref" href="#fig_dip_3">Figure 2-3</a>
shows that we have really introduced an inversion of dependencies: instead
of depending on the concrete <code>UI</code> class, we now depend on abstractions.</p>
<figure><div class="figure" id="fig_dip_3">
<img alt="Visualization of the local inversion of dependencies by introduction of three abstract UI classes" height="1206" src="assets/cpsd_0203.png" width="1430"/>
<h6><span class="label">Figure 2-3. </span>The local inversion of dependencies by introduction of three abstract UI classes</h6>
</div></figure>
<p>However, what<a data-primary="abstractions" data-secondary="ownership of" data-tertiary="dependency diagrams" data-type="indexterm" id="ABowndia02"/> we have introduced is a <em>local</em> inversion of dependencies.
Yes, a local inversion only, not a global inversion. From an architectural
point of view, we still have a dependency from the high level (our transaction
classes) to the low level (our UI functionality). So no, it is
not enough to <em>just</em> introduce an abstraction. It’s also important to
consider <em>where</em> to introduce the abstraction. Robert Martin expressed this
with the following two points:<sup><a data-type="noteref" href="ch02.xhtml#idm45043118499872" id="idm45043118499872-marker">20</a></sup></p>
<blockquote><ol>
<li>
<p>High-level modules should not depend on low-level modules. Both should depend on abstractions.</p>
</li>
<li>
<p>Abstractions should not depend on details. Details should depend on 
<span class="keep-together">abstractions</span>.</p>
</li>
</ol></blockquote>
<p>The first point clearly expresses an essential property of an architecture: the
high level, i.e., the stable part(s) of our software, should not depend on the
low level, i.e., the implementation details. That dependency should be inverted,
meaning that the low level should depend on the high level. Luckily, the
second point gives us an idea how to achieve that: we assign the three
abstractions to the high level. <a data-type="xref" href="#fig_dip_4">Figure 2-4</a> illustrates the dependencies
when we consider abstractions part of the high level.</p>
<figure><div class="figure" id="fig_dip_4">
<img alt="Visualization of the inversion of dependencies by assigning the three abstractions to the high level" height="1206" src="assets/cpsd_0204.png" width="1430"/>
<h6><span class="label">Figure 2-4. </span>Inversion of dependencies by assigning the abstractions to the high level</h6>
</div></figure>
<p>By assigning the abstractions to the high level and by making the high level
the owner of the abstractions, we truly follow the DIP: all arrows now run from the low level to the high level. Now
we do have a proper architecture.<a data-primary="" data-startref="ABowndia02" data-type="indexterm" id="idm45043118491568"/></p>
<p>“Wait a second!” You look a little confused. “That’s it? All we need is to
perform a mental shift of the architectural boundary?” Well, it may very well
be more than just a mental shift. This may result in moving the dependent
header files for the UI classes from one module to another and
also completely rearranging the dependent include statements. It’s not just a mental shift—it is a reassignment of ownership.</p>
<p>“But now we no longer group the things that belong together,” you argue. “The
user interface functionality is now spread across both levels. Isn’t that a
violation of the SRP?” No, it isn’t. On
the contrary, only after assigning the abstractions to the high level do we
now properly follow the SRP. It’s not the <code>UI</code> classes that belong together;
it’s the transaction classes and the dependent <code>UI</code> abstractions that
should be grouped together. Only in this way can we steer the dependency in
the right direction; only in this way do we have an architecture. Thus, for a proper
dependency inversion, the abstraction <em>must</em> be owned by the high level.<a data-primary="" data-startref="DPdip02" data-type="indexterm" id="idm45043118488608"/><a data-primary="" data-startref="DIPex02" data-type="indexterm" id="idm45043118487632"/></p>
</div></section>
<section data-pdf-bookmark="Dependency Inversion in a Plug-In Architecture" data-type="sect2"><div class="sect2" id="idm45043118552816">
<h2>Dependency Inversion in a Plug-In Architecture</h2>
<p>Perhaps<a data-primary="abstractions" data-secondary="ownership of" data-tertiary="dependency inversion in plug-in architectures" data-type="indexterm" id="idm45043118485088"/><a data-primary="Dependency Inversion Principle (DIP)" data-secondary="dependency inversion in plug-in architectures" data-type="indexterm" id="DIPplugin02"/><a data-primary="plug-in architectures" data-type="indexterm" id="plugin02"/> this fact makes more sense if we consider the situation depicted in
<a data-type="xref" href="#fig_dip_5">Figure 2-5</a>. Imagine you have created the next-generation text editor. The
core of this new text editor is represented by the <code>Editor</code> class on the
lefthand side. To ensure that this text editor will be successful,
you want to make sure that the fan community can participate in the
development. Therefore, one vital ingredient for your success is the ability of
the community to add new functionality in the form of plug-ins. However,
the initial setting is pretty flawed from an architectural point of view and
will hardly satisfy your fan community: the <code>Editor</code> directly depends on the
concrete <code>VimMode​Plu⁠gin</code> class. Since the <code>Editor</code> class is part of the high level
of the architecture, which you should consider as your own realm, the <code>VimMode​Plugin</code>
is part of the low level of the architecture, which is the realm of your fan
community. Since the <code>Editor</code> directly depends on the <code>VimMode​Plu⁠gin</code>, and because
that essentially means that your community can define their interfaces as
they please, you would have to change the editor for every new plug-in. As
much as you love to work on your brainchild, there’s only so much time
you can devote to adapting to different kinds of plug-ins.
Unfortunately, your fan community will soon be disappointed and move on to
another text editor.</p>
<figure><div class="figure" id="fig_dip_5">
<img alt="Visualization of a broken plug-in architecture: the high-level +Editor+ class depends on the low-level +VimModePlugin+ class" height="487" src="assets/cpsd_0205.png" width="761"/>
<h6><span class="label">Figure 2-5. </span>Broken plug-in architecture: the high-level <code>Editor</code> class depends on the low-level <code>VimModePlugin</code> class</h6>
</div></figure>
<p>Of course, that shouldn’t happen. In the given <code>Editor</code> example, it certainly
isn’t a good idea to make the <code>Editor</code> class depend on all the concrete plug-ins.
Instead, you should reach for an abstraction, for instance, in the form of a
<code>Plugin</code> base class. The <code>Plugin</code> class now represents the abstraction for
all kinds of plug-ins. However, it doesn’t make sense to introduce the abstraction
in the low level of the architecture (see <a data-type="xref" href="#fig_dip_6">Figure 2-6</a>). Your <code>Editor</code> would
still depend on the whims of your fan 
<span class="keep-together">community</span>.</p>
<figure><div class="figure" id="fig_dip_6">
<img alt="Visualization of a broken plug-in architecture: the high-level +Editor+ class depends on the low-level +Plugin+ class" height="487" src="assets/cpsd_0206.png" width="1274"/>
<h6><span class="label">Figure 2-6. </span>Broken plug-in architecture: the high-level <code>Editor</code> class depends on the low-level <code>Plugin</code> class</h6>
</div></figure>
<p>This misdirected dependency also becomes apparent when looking at the source code:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;thirdparty/Plugin.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Plugin</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// Defines the requirements for plugins</code>


<code class="c1">//---- &lt;thirdparty/VimModePlugin.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;thirdparty/Plugin.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">VimModePlugin</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Plugin</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;yourcode/Editor.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;thirdparty/Plugin.h&gt;</code><code class="c1">  // Wrong direction of dependencies!</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Editor</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/></pre>
<p>The only way to build a proper plug-in architecture is to assign the abstraction
to the high level. The abstraction <em>must</em> belong to <em>you</em>, not to
your fan community. <a data-type="xref" href="#fig_dip_7">Figure 2-7</a> demonstrates that this resolves the architectural
dependency and frees your <code>Editor</code> class from the dependencies on plug-ins. This
resolves both the DIP, because the dependency is properly inverted, and
the SRP, because the abstraction belongs to the high level.</p>
<figure><div class="figure" id="fig_dip_7">
<img alt="Visualization of a correct plug-in architecture: the low-level +VimModePlugin+ class depends on the high-level +Plugin+ class" height="487" src="assets/cpsd_0207.png" width="1182"/>
<h6><span class="label">Figure 2-7. </span>Correct plug-in architecture: the low-level <code>VimModePlugin</code> class depends on the high-level <code>Plugin</code> class</h6>
</div></figure>
<p>A look at the source code reveals that the direction of dependencies has been
fixed: the <code>VimModePlugin</code> depends on your code, and not vice versa:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;yourcode/Plugin.h&gt; ----------------</code>

<code class="k">class</code><code class="w"> </code><code class="nc">Plugin</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// Defines the requirements for plugins</code>


<code class="c1">//---- &lt;yourcode/Editor.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;yourcode/Plugin.h&gt;</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">Editor</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/>


<code class="c1">//---- &lt;thirdparty/VimModePlugin.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;yourcode/Plugin.h&gt;</code><code class="c1">  // Correct direction of dependencies</code><code class="cp"/>

<code class="k">class</code><code class="w"> </code><code class="nc">VimModePlugin</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="k">public</code><code class="w"> </code><code class="n">Plugin</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">};</code><code class="w"/></pre>
<p>Again, to get a proper dependency inversion, the abstraction must be
owned by the high level. In this context, the <code>Plugin</code> class represents the
set of requirements that needs to be fulfilled by all plug-ins (see again
<a data-type="xref" href="#adhere_to_the_expected_behavior_of_abstractions">“Guideline 6: Adhere to the Expected Behavior of Abstractions”</a>). The <code>Editor</code> defines
and thus owns these requirements. It doesn’t depend on them. Instead, the
different plug-ins depend on the requirements. That is dependency inversion.
Hence, the DIP is not just about the introduction of an abstraction but also
about the ownership of that abstraction.<a data-primary="" data-startref="DIPplugin02" data-type="indexterm" id="idm45043118332528"/><a data-primary="" data-startref="plugin02" data-type="indexterm" id="idm45043118331584"/></p>
</div></section>
<section data-pdf-bookmark="Dependency Inversion via Templates" data-type="sect2"><div class="sect2" id="idm45043118486432">
<h2>Dependency Inversion via Templates</h2>
<p>So<a data-primary="abstractions" data-secondary="ownership of" data-tertiary="dependency inversion via templates" data-type="indexterm" id="idm45043118329136"/><a data-primary="Dependency Inversion Principle (DIP)" data-secondary="dependency inversion via templates" data-type="indexterm" id="idm45043118327888"/><a data-primary="template arguments" data-secondary="dependency inversion via" data-type="indexterm" id="idm45043118327008"/> far I might have given you the impression that the DIP is concerned with only inheritance hierarchies and base classes.
However, dependency inversion is also achieved with templates. In
that context, however, the question of ownership is resolved automatically.
As an example, let’s consider the <code>std::copy_if()</code> algorithm:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">InputIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">OutputIt</code><code class="p">,</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">UnaryPredicate</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="n">OutputIt</code><code class="w"> </code><code class="n">copy_if</code><code class="p">(</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">InputIt</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">OutputIt</code><code class="w"> </code><code class="n">d_first</code><code class="p">,</code><code class="w"/>
<code class="w">                  </code><code class="n">UnaryPredicate</code><code class="w"> </code><code class="n">pred</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>
<p>This <code>copy_if()</code> algorithm also adheres to the DIP. The dependency inversion is
achieved with the concepts <code>InputIt</code>, <code>OutputIt</code>, and <code>UnaryPredicate</code>.
These three concepts represent the requirements on the passed iterators and
predicates that need to be fulfilled by calling code. By specifying these
requirements through concepts, i.e., by owning these concepts, <code>std::copy_if()</code>
makes other code depend on itself and does not itself depend on other code. This
dependency structure is depicted in <a data-type="xref" href="#fig_dip_algorithms">Figure 2-8</a>: both containers and
predicates depend on the requirements expressed by the corresponding algorithm. Thus,
if we consider the architecture within the Standard Library, then <code>std::copy_if()</code>
is part of the high level of the architecture, and containers and predicates (function objects, lambdas, etc.) are part of the low level of the architecture.</p>
<figure><div class="figure" id="fig_dip_algorithms">
<img alt="Visualization of the dependency structure of STL algorithms" height="379" src="assets/cpsd_0208.png" width="1269"/>
<h6><span class="label">Figure 2-8. </span>Dependency structure of the STL algorithms</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Dependency Inversion via Overload Sets" data-type="sect2"><div class="sect2" id="idm45043118210592">
<h2>Dependency Inversion via Overload Sets</h2>
<p>Inheritance hierarchies<a data-primary="abstractions" data-secondary="ownership of" data-tertiary="dependency inversion via overload sets" data-type="indexterm" id="idm45043118209056"/><a data-primary="Dependency Inversion Principle (DIP)" data-secondary="dependency inversion via overload sets" data-type="indexterm" id="idm45043118207808"/><a data-primary="overload sets" data-secondary="dependency inversion via" data-type="indexterm" id="idm45043118206928"/> and concepts are not the only means to invert dependencies.
Any kind of abstraction is able to do so. Therefore, it shouldn’t come as
a surprise that overload sets also enable you to follow the DIP. As you have seen
in <a data-type="xref" href="#understand_the_semantic_requirements_of_overload_sets">“Guideline 8: Understand the Semantic Requirements of Overload Sets”</a>, overload sets
represent an abstraction and, as such, a set of semantic requirements and expectations.
In comparison to base classes and concepts, though, there is unfortunately no code
that explicitly describes the requirements. But if these requirements are owned by
a higher level in your architecture, you can achieve dependency inversion. Consider,
for instance, the following <code>Widget</code> class template:</p>
<pre data-code-language="cpp" data-type="programlisting"><code class="c1">//---- &lt;Widget.h&gt; ----------------</code>

<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;utility&gt;</code><code class="cp"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="k">struct</code><code class="w"> </code><code class="nc">Widget</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">T</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">template</code><code class="o">&lt;</code><code class="w"> </code><code class="k">typename</code><code class="w"> </code><code class="nc">T</code><code class="w"> </code><code class="o">&gt;</code><code class="w"/>
<code class="kt">void</code><code class="w"> </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">Widget</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&amp;</code><code class="w"> </code><code class="n">lhs</code><code class="p">,</code><code class="w"> </code><code class="n">Widget</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&amp;</code><code class="w"> </code><code class="n">rhs</code><code class="w"> </code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">using</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">swap</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">lhs</code><code class="p">.</code><code class="n">value</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">value</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><code>Widget</code> owns a data member of an unknown type <code>T</code>. Despite the fact that
<code>T</code> is unknown, it is possible to implement a custom <code>swap()</code> function for <code>Widget</code>
by building on the semantic expectations of the <code>swap()</code> function. This
implementation works, as long as the <code>swap()</code> function for <code>T</code> adheres to all
expectations for <code>swap()</code> and follows the LSP:<sup><a data-type="noteref" href="ch02.xhtml#idm45043118079056" id="idm45043118079056-marker">21</a></sup></p>
<pre data-code-language="cpp" data-type="programlisting"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;Widget.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;assert&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;cstdlib&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;string&gt;</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">main</code><code class="p">()</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">Widget</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="o">&gt;</code><code class="w"> </code><code class="n">w1</code><code class="p">{</code><code class="w"> </code><code class="s">"Hello"</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">   </code><code class="n">Widget</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">string</code><code class="o">&gt;</code><code class="w"> </code><code class="n">w2</code><code class="p">{</code><code class="w"> </code><code class="s">"World"</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">   </code><code class="n">swap</code><code class="p">(</code><code class="w"> </code><code class="n">w1</code><code class="p">,</code><code class="w"> </code><code class="n">w2</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">w1</code><code class="p">.</code><code class="n">value</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="s">"World"</code><code class="w"> </code><code class="p">);</code><code class="w"/>
<code class="w">   </code><code class="n">assert</code><code class="p">(</code><code class="w"> </code><code class="n">w2</code><code class="p">.</code><code class="n">value</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="s">"Hello"</code><code class="w"> </code><code class="p">);</code><code class="w"/>

<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">EXIT_SUCCESS</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In consequence, the <code>Widget</code> <code>swap()</code> function itself follows the expectations and
adds to the overload set, similar to what a derived class would do. The dependency
structure for the <code>swap()</code> overload set is shown in <a data-type="xref" href="#fig_dip_swap">Figure 2-9</a>. Since the
requirements, or the expectations, for the overload set are part of the high level
of the architecture, and since any implementation of <code>swap()</code> depends on these
expectations, the dependency runs from the low level toward the high level. The
dependency is therefore properly inverted.</p>
<figure><div class="figure" id="fig_dip_swap">
<img alt="Visualization of the dependency structure of the +swap()+ overload set" height="354" src="assets/cpsd_0209.png" width="894"/>
<h6><span class="label">Figure 2-9. </span>Dependency structure of the <code>swap()</code> overload set</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Dependency Inversion Principle Versus Single-Responsibility Principle" data-type="sect2"><div class="sect2" id="idm45043117934288">
<h2>Dependency Inversion Principle Versus Single-Responsibility Principle</h2>
<p>As<a data-primary="abstractions" data-secondary="ownership of" data-tertiary="DIP versus SRP" data-type="indexterm" id="idm45043117932992"/><a data-primary="Dependency Inversion Principle (DIP)" data-secondary="versus Single-Responsibility Principle (SRP)" data-secondary-sortas="Single-Responsibility Principle (SRP)" data-type="indexterm" id="idm45043117931712"/><a data-primary="Single-Responsibility Principle (SRP)" data-type="indexterm" id="idm45043117930592"/><a data-primary="SRP (Single-Responsibility Principle)" data-type="indexterm" id="idm45043117929952"/> we have seen, the DIP is fulfilled by properly assigning ownership and
by properly grouping the things that truly belong. From that perspective, it
sounds plausible to consider the DIP as just another special case of the
SRP (similar to the ISP). However, hopefully you see that the DIP is
more than that. As the DIP, in contrast to the SRP, is very much concerned
with the architectural point of view, I consider it a vital piece of advice to
build proper global dependency structures.</p>
<p>To summarize, in order to build a proper architecture with a proper dependency
structure, it’s essential to pay attention to the ownership of abstractions.
Since abstractions represent requirements on the implementations, they should
be part of the high level to steer all dependencies toward the
high level.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043117928672">
<h5>Guideline 9: Pay Attention to the Ownership of Abstractions</h5>
<ul>
<li>
<p>Keep in mind that in a proper architecture, low-level implementation details depend on high-level abstractions.</p>
</li>
<li>
<p>Adhere to the Dependency Inversion Principle (DIP), and assign abstractions to the high level of an architecture.</p>
</li>
<li>
<p>Make sure abstractions are <em>owned</em> by the high level, not by the low level.<a data-primary="" data-startref="ABown02" data-type="indexterm" id="idm45043117924336"/></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Guideline 10: Consider Creating an Architectural Document" data-type="sect1"><div class="sect1" id="consider_creating_an_architectural_document">
<h1>Guideline 10: Consider Creating an Architectural Document</h1>
<p>Let’s<a data-primary="abstractions" data-secondary="benefits of architectural documents" data-type="indexterm" id="ABarchdoc02"/><a data-primary="architectural documents" data-type="indexterm" id="archdoc02"/> chat a little about your architecture. Let me start with a very simple
question: do you have an architectural document? Any plan or description that
summarizes the major points and fundamental decisions of your architecture
and that shows the high levels, the low levels, and the dependencies between them?
If your answer is yes, then you’re free to skip this guideline and continue
with the next one. If your answer is no, however, then let me ask a few follow-up
questions. Do you have a <em>Continuous Integration</em> (CI) environment? Do you use
automated tests? Do you apply static code analysis tools? All yes? Good, there’s still hope. The only remaining question is: why don’t you have an
architectural document?</p>
<p>“Oh, come on, don’t turn a mosquito into an elephant. A missing architectural
document is not the end of the world! After all, we are Agile, we can change
things quickly!” Imagine my completely blank expression, followed by
a long sigh. Well, honestly, I was afraid this would be your explanation.
It’s unfortunately what I hear far too often. There may be a misunderstanding:
the ability to quickly change things is not the point of an Agile methodology.
Sadly, I also have to tell you that your answer doesn’t make any sense. You
could just as well have answered with “After all, we like chocolate!” or
“After all, we wear carrots around our necks!” To explain what I mean,
I will quickly summarize the point of the Agile methodology and then
subsequently explain why you should invest in an architectural document.</p>
<p>The expectation that Agile methods help to change things quickly is pretty
widespread. However, as several authors in the recent past have clarified, the major,
and probably only, point of the Agile methodology is to get quick feedback.<sup><a data-type="noteref" href="ch02.xhtml#idm45043117917248" id="idm45043117917248-marker">22</a></sup> In Agile methods, the
entire software development process is built around it: quick feedback due to
business practices (such as planning, small releases, and acceptance tests), quick
feedback due to team practices (e.g., collective ownership, CI, and stand-up meetings), and quick feedback due to technical practices (such as test-driven development, refactoring, and pair programming). However,
contrary to popular belief, the quick feedback does not mean that you can change
your software quickly and easily. Though quick feedback is, of course, key to quickly knowing
that something has to be done, you gain the ability to quickly change your software only with good software design and architecture. These
two save you the Herculean effort to change things; quick feedback only tells you something is broken.</p>
<p>“OK, you’re right. I get your point—it is important to pay attention to good
software design and architecture. But what’s the point of an architectural
document?” I’m glad we agree. And that is an excellent question. I see we are
making progress. To explain the purpose of an architectural document, let me give
you another definition of architecture:<sup><a data-type="noteref" href="ch02.xhtml#idm45043117913072" id="idm45043117913072-marker">23</a></sup></p>
<blockquote>
<p>In most successful software projects, the expert developers working on that project
have a shared understanding of the system design. This shared understanding is called
‘architecture.’</p>
<p data-type="attribution">Ralph Johnson</p>
</blockquote>
<p>Ralph Johnson describes <em>architecture</em> as the shared understanding of a codebase—the
global vision. Let’s assume that there is no architectural document, nothing
that summarizes the global picture—the global vision of your codebase. Let’s also
assume that you believe you have a very clear idea of the architecture of your
codebase. Then here are a few more questions: how many developers are on your team? Are
you certain that all of these developers are familiar with the architecture in your
head? Are you certain that all of them share the same vision? Are you certain that
they all help you move forward <em>in the same direction</em>?</p>
<p>If your answers are yes, then you might not have gotten the point yet. It is fairly
certain that every developer has different experiences and a slightly different
terminology. It is also fairly certain that every developer sees the code
differently and has a slightly different idea of the current architecture.
And this slightly different view of the current state of affairs may lead to
a slightly different vision for the future. While this might not be immediately
evident over a short period of time, there is a good chance that surprises will happen
in the long run. Misunderstandings. Misinterpretations. This is exactly the
point of an architectural document: one common document that unifies the
ideas, visions, and essential decisions in one place; helps maintain and
communicate the state of the architecture; and helps avoid any misunderstandings.</p>
<p>This document also preserves ideas, visions, and decisions.
Imagine that one of your leading software architects, one of the brains behind the
architecture of your codebase, leaves the organization. Without a document with
the fundamental decisions, this loss of manpower will also cause a loss of essential
information about your codebase. As a consequence, you will lose consistency in
the vision of your architecture and also, more importantly, some confidence to
adapt or change architectural decisions. No new hire will ever be able to replace
that knowledge and experience, and no one will be able to extract all that information
from the code. Thus, the code will become more rigid, more “legacy.” This promotes decisions
to rewrite large parts of the code, with questionable outcomes, as the new code
will initially lack a lot of the wisdom of the old code.<sup><a data-type="noteref" href="ch02.xhtml#idm45043117907168" id="idm45043117907168-marker">24</a></sup>
Thus, without an architectural document, your long-term success is at stake.</p>
<p class="less_space pagebreak-before">The value in such an architectural document becomes obvious if we
take a look at how seriously architecture is taken at construction sites. Construction
is not even going to start without a plan. A plan that everyone agrees to. Or let’s imagine what would happen if there was no plan: “Hey, I said the garage should
be to the left of the house!” “But I built it to the left of the house.” “Yes, but I meant my
left, not your left!”</p>
<p>This is exactly the kind of problem that can be avoided by investing
time in an architectural document. “Yes, yes, you’re right,” you admit, “but such a document is <em>soooo</em> much work. And all of this information
is in the code anyway. It adapts with the code, while the document goes out
of date <em>soooo</em> quickly!” Well, not if you’re doing it properly.
An architectural document shouldn’t go out of date quickly because it should
primarily reflect the big picture of your codebase. It shouldn’t contain the
little details that indeed can change very often; instead, it should contain the overall structure,
the connections between key players, and the major technological decisions.
All these things are not expected to change (although we all agree that
“not expected to change” doesn’t mean that they won’t change; after all,
<em>soft</em>ware is expected to change). And yes, you are correct: these details are,
of course, also part of the code. After all, the code contains all the details and
thus can be said to represent the ultimate truth. However, it doesn’t help if
the information is not easy to come by, is hidden from plain sight, and
requires an archaeological effort to extract.</p>
<p>I am also aware that, in the beginning, the endeavor to create an architectural
document does sound like a lot of work. An enormous amount of work. All I
can do is encourage you to get started somehow. Initially, you do not have to
document your architecture in all its glory, but maybe you start with only the most
fundamental structural decisions. Some tools can already use this information to
compare your assumed architectural state and its actual state.<sup><a data-type="noteref" href="ch02.xhtml#idm45043117901616" id="idm45043117901616-marker">25</a></sup>
Over time, more and more architectural information can be added, documented, and maybe
even tested by tools, which leads to more and more commonly available, established
wisdom for your entire team.</p>
<p>“But how do I keep this document up to date?” you ask. Of course, you’ll have to
maintain this document, integrate new decisions, update old decisions, etc. However,
since this document should only contain information about the aspects that do not
often change, there should be no need to constantly touch and refactor it.
It should
be enough to schedule a short meeting of the senior developers every one or two weeks
to discuss if and how the architecture has evolved. Thus, it is hard to imagine this
document becoming a bottleneck in the development process. In this regard, 
<span class="keep-together">consider</span>
this document a bank deposit safe: it is invaluable to have all of the accumulated
decisions of the past when you need them and to keep the information secure, but you
wouldn’t open it every single day.</p>
<p>In summary, the benefits of having an architectural document by far outweigh
the risks and efforts. The architectural document should be considered an
essential part of any project and an integral part of the maintenance and communication
efforts. It should be considered equally important as a CI environment or automated
tests.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45043117897648">
<h5>Guideline 10: Consider Creating an Architectural Document</h5>
<ul>
<li>
<p>Understand that an architectural document serves the purpose of maintaining and communicating the current state of the architecture.</p>
</li>
<li>
<p>Use tools to support and help you test the current state of your architecture against the expected state.<a data-primary="" data-startref="ABarchdoc02" data-type="indexterm" id="idm45043117894720"/><a data-primary="" data-startref="archdoc02" data-type="indexterm" id="idm45043117893744"/></p>
</li>
</ul>
</div></aside>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45043120890480"><sup><a href="ch02.xhtml#idm45043120890480-marker">1</a></sup> In one of my training classes several years ago, I was “gently” reminded that from a mathematical perspective, a square is not a rectangle but a rhombus. My knees still shake when I think about that lecture. Therefore, I specifically say “appears to be” instead of “is” to denote the naive impression that unaware people like me might have had.</p><p data-type="footnote" id="idm45043120674128"><sup><a href="ch02.xhtml#idm45043120674128-marker">2</a></sup> Not mathematically, but in this implementation.</p><p data-type="footnote" id="idm45043120621936"><sup><a href="ch02.xhtml#idm45043120621936-marker">3</a></sup> The LSP was first introduced by Barbara Liskov in the paper <a href="https://oreil.ly/Z9lu1">“Data Abstraction and Hierarchy”</a> in 1988. In 1994, it was reformulated in the paper <a href="https://oreil.ly/ic7N3">“A Behavioral Notion of Subtyping”</a> by Barbara Liskov and Jeannette Wing. For her work, Barbara Liskov received the Turing Award in 2008.</p><p data-type="footnote" id="idm45043119856288"><sup><a href="ch02.xhtml#idm45043119856288-marker">4</a></sup> If you have a strong opinion about a square being a rhombus, please forgive me!</p><p data-type="footnote" id="idm45043119792896"><sup><a href="ch02.xhtml#idm45043119792896-marker">5</a></sup> And yet, in a sufficiently large codebase, there’s a good chance that you’ll find at least one example of this kind of malpractice. In my experience, it’s often the result of too little time to rethink and adapt the  <span class="keep-together">abstraction</span>.</p><p data-type="footnote" id="idm45043119546544"><sup><a href="ch02.xhtml#idm45043119546544-marker">6</a></sup> This is indeed a very often discussed topic. You’ll find a very good summary of this in <a href="https://oreil.ly/HiJP9">foonathan’s blog</a>.</p><p data-type="footnote" id="idm45043119543760"><sup><a href="ch02.xhtml#idm45043119543760-marker">7</a></sup> In C++20, <code>std::copy()</code> is finally <code>constexpr</code> but does not yet use the <code>std::input_iterator</code> and <code>std::output_iterator</code> concepts. It is still based on the formal description of input and output iterators; see <a href="https://oreil.ly/9vsvC">LegacyInputIterator</a> and <a href="https://oreil.ly/ZcJeU">LegacyOutputIterator</a>.</p><p data-type="footnote" id="idm45043119253776"><sup><a href="ch02.xhtml#idm45043119253776-marker">8</a></sup> And no, it wouldn’t be a compile-time error, unfortunately.</p><p data-type="footnote" id="idm45043118921264"><sup><a href="ch02.xhtml#idm45043118921264-marker">9</a></sup> The free <code>begin()</code> and <code>end()</code> functions are an example of the <em>Adapter</em> design pattern; see <a data-type="xref" href="ch06.xhtml#use_adapters_to_standardize_interfaces">“Guideline 24: Use Adapters to Standardize Interfaces”</a> for more details.</p><p data-type="footnote" id="idm45043118837984"><sup><a href="ch02.xhtml#idm45043118837984-marker">10</a></sup> That is why range-based <code>for</code> loops build on the free <code>begin()</code> and <code>end()</code> functions.</p><p data-type="footnote" id="idm45043118832496"><sup><a href="ch02.xhtml#idm45043118832496-marker">11</a></sup> Alexander Stepanov and Meng Lee, <a href="https://oreil.ly/vgm61">“The Standard Template Library”</a>, October 1995.</p><p data-type="footnote" id="idm45043118831152"><sup><a href="ch02.xhtml#idm45043118831152-marker">12</a></sup> Scott Meyers, <em>Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library</em> (Addison-Wesley Professional, 2001).</p><p data-type="footnote" id="idm45043118788608"><sup><a href="ch02.xhtml#idm45043118788608-marker">13</a></sup> Free functions are indeed a seriously valuable design tool. To give one example of this, allow me to tell a short war story. You might know Martin Fowler’s book <em>Refactoring: Improving the Design of Existing Code</em> (Addison-Wesley), which may be considered one of <em>the</em> classics for professional software development. The first edition of the book was published in 2012 and provided programming examples in Java. The second edition of the book was released in 2018, but interestingly rewritten with JavaScript. One of the reasons for that choice was the fact that any language having a C-like syntax was considered easier to digest for a majority of readers. However, another important reason was the fact that JavaScript, unlike Java, provides free functions, which Martin Fowler considers a very important tool for decoupling and separating concerns. Without this feature, you would be limited in your flexibility to achieve the refactoring goal.</p><p data-type="footnote" id="idm45043118634976"><sup><a href="ch02.xhtml#idm45043118634976-marker">14</a></sup> A great discussion of this can be found in <a href="https://cpp.chat/83">episode 83 of <em>Cpp.Chat</em></a>, where Jon Kalb, Phil Nash, and Dave Abrahams discuss the lessons learned from C++ and how they were applied in the development of the Swift programming language.</p><p data-type="footnote" id="idm45043118570624"><sup><a href="ch02.xhtml#idm45043118570624-marker">15</a></sup> As Kate Gregory would say, “Naming Is Hard: Let’s Do Better.” This is the title of her highly recommended talk from <a href="https://oreil.ly/TLuqb">CppCon 2019</a>.</p><p data-type="footnote" id="idm45043118546768"><sup><a href="ch02.xhtml#idm45043118546768-marker">16</a></sup> Robert C. Martin, <em>Clean Architecture</em> (Addison-Wesley, 2017).</p><p data-type="footnote" id="idm45043118540336"><sup><a href="ch02.xhtml#idm45043118540336-marker">17</a></sup> This example is taken from Robert Martin’s book <em>Agile Software Development: Principles, Patterns, and Practices</em> (Prentice Hall, 2002). Martin used this example to explain the Interface Segregation Principle (ISP), and for that reason, he didn’t go into detail about the question of ownership of abstractions. I will try to fill this gap.</p><p data-type="footnote" id="idm45043118524784"><sup><a href="ch02.xhtml#idm45043118524784-marker">18</a></sup> If you argue that the <code>Transaction</code> base class could be on an even higher level, you are correct. You’ve earned yourself a bonus point! But for the remainder of the example we won’t need this extra level, and therefore I will ignore it.</p><p data-type="footnote" id="idm45043118521184"><sup><a href="ch02.xhtml#idm45043118521184-marker">19</a></sup> If you’re wondering about the two <code>informInsufficientFunds()</code> functions: yes, it is possible to implement <em>both</em> virtual functions (i.e., the one from the <code>WithdrawalUI</code> and the one from the <code>TransferUI</code>) by means of a single implementation in the <code>UI</code> class. Of course, this works well only as long as these two functions represent the same expectations and thus can be implemented as one. However, if they represent different expectations, then you’re facing a <em>Siamese Twin Problem</em> (see Item 26 in Herb Sutter’s <em>More Exceptional C++: 40 New Engineering Puzzles, Programming Problems, and Solutions</em> (Addison-Wesley). For our example, let’s assume that we can deal with these two virtual functions the easy way.</p><p data-type="footnote" id="idm45043118499872"><sup><a href="ch02.xhtml#idm45043118499872-marker">20</a></sup> Martin, <em>Clean Architecture</em>.</p><p data-type="footnote" id="idm45043118079056"><sup><a href="ch02.xhtml#idm45043118079056-marker">21</a></sup> I know what you’re thinking. However, it was just a matter of time until you encountered a “Hello World” example.</p><p data-type="footnote" id="idm45043117917248"><sup><a href="ch02.xhtml#idm45043117917248-marker">22</a></sup> The point is, for instance, made by Robert C. Martin, one of the signees of the Agile manifesto, in his book <em>Clean Agile: Back to Basics</em> (Pearson). A second good summary is given by Bertrand Meyer in <em>Agile! The Good, the Hype and the Ugly</em> (Springer). Finally, you can also consult the second edition of James Shore’s book <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/the-art-of/9781492080688/"><em>The Art of Agile Development</em></a> (O’Reilly). A good talk on the misuse of the term <em>Agile</em> is Dave Thomas’s <a href="https://oreil.ly/LJZN1">“Agile Is Dead” presentation</a> from GOTO 2015.</p><p data-type="footnote" id="idm45043117913072"><sup><a href="ch02.xhtml#idm45043117913072-marker">23</a></sup> Quoted in Martin Fowler, “Who Needs an Architect?” <em>IEEE Software</em> 20, no. 5 (2003), 11–13, <a href="https://doi.org/10.1109/MS.2003.1231144"><em class="hyperlink">https://doi.org/10.1109/MS.2003.1231144</em></a>.</p><p data-type="footnote" id="idm45043117907168"><sup><a href="ch02.xhtml#idm45043117907168-marker">24</a></sup> Joel Spolsky, whom you may know as the author of the <a href="https://www.joelonsoftware.com"><em>Joel on Software</em> blog</a>, and also as one of the creators of Stack Overflow, named the decision to rewrite a large piece of code from scratch <a href="https://oreil.ly/ndLhY">“the single worst strategic mistake that any company can make”</a>.</p><p data-type="footnote" id="idm45043117901616"><sup><a href="ch02.xhtml#idm45043117901616-marker">25</a></sup> One possible tool for this purpose is the <a href="https://oreil.ly/32kue">Axivion Suite</a>. You start by defining architectural boundaries between your modules, which can be used by the tool to check if the architectural dependencies are upheld. Another tool with such capabilities is the <a href="https://oreil.ly/1oC3Y">Sparx Systems Enterprise Architect</a>.</p></div></div></section></div></body></html>