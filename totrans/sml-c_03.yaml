- en: Chapter 3\. Flow of Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen the basic format of a statement in C, it’s time to start
    branching out…pun intended. In code, the idea of making decisions and then selecting
    a particular bit of code to run instead of some other bit of code is often referred
    to as *branching* or *conditional branching*. And repetition is often discussed
    in terms of *looping* or *iterating*. Collectively, branching and looping statements
    comprise the *flow of control* in a language.
  prefs: []
  type: TYPE_NORMAL
- en: Some problems can be solved with a simple series of linear steps. Many programs
    that automate various computer tasks work just this way, taking a tedious routine
    and reducing that to a single app you can run whenever you need it. But programs
    can do much more than just process a batch of commands. They can make decisions
    based on the values in a variable or the state of a sensor. They can repeat tasks
    like turn on every LED in a string of lights or process every line in a log file.
    And they can combine the decision-making and repetition in complex, nested ways
    that allow you as the programmer to solve just about any problem you can think
    of. In this chapter we’ll look at how C implements these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ask a question in C, you typically compare two (or more) things. C has several
    operators meant for just this task. You can check to see if two things are the
    same. You can check to see if two things are not the same. You can see if some
    value is less than or greater than some other value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you ask questions like “is x the same as y,” you get a yes or no, true
    or false answer. In computer science, these are called Boolean values, after George
    Boole, who worked to formalize a system of logical operations and outcomes. Some
    languages have an actual type for Boolean values and variables, but C mostly uses
    integers: 0 is false/no and 1 is true/yes.^([1](ch03.xhtml#idm45018734452728))'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Technically, any value in C that is not 0 is true. So 1 is true, 2 is true,
    –18 is true, etc. I’ll point out anytime I perform a check that relies on this
    fact. It can be convenient, and you will definitely see it used in the real world,
    but I’ll be concentrating on performing explicit comparisons wherever I can.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Math, of course, is not the only thing computers are good at. When we get into
    writing more complex programs, we’ll need the ability to make decisions about
    the state of our system. We’ll need to compare variables against desired values
    and safeguard against error conditions. We’ll need to detect the end of lists
    and other data structures. Happily, all of these requirements can be accommodated
    with C’s comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: C defines six operators (shown in [Table 3-1](#smallerc-CHP-3-TABLE-comparison-ops))
    that can be used to compare values. We use these operators much like we used the
    mathematical operators from [Table 2-6](ch02.xhtml#smallerc-CHP-2-TABLE-math-ops).
    You have a variable or value or expression on the left, the operator, and a variable
    or value or expression on the right. The difference here is that the result of
    using a comparison operator is always a Boolean `int`, meaning it is always a
    `1` or a `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Comparison operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Comparison |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: In C, the comparison operators work on characters, integers, and floating point
    numbers. Some languages support operators that work on more complex bits of data
    like arrays (I’ll cover these in [Chapter 4](ch04.xhtml#smallerc-CHP-4)), records,
    or objects, but C uses functions (covered in [Chapter 5](ch05.xhtml#smallerc-CHP-5))
    to do that type of work.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing two expressions of the same type, you can use the operators in
    [Table 3-1](#smallerc-CHP-3-TABLE-comparison-ops) without really thinking about
    it. If you compare expressions of different types, say a `float` variable and
    an `int` value, the same notion of implicit casting (see [Figure 2-4](ch02.xhtml#smallerc-CHP-2-FIG-promotions))
    applies and the value with the “lower” type will be promoted before being compared.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll put these comparison operators to use shortly in [“Branching”](#smallerc-CHP-3-SECT-2)
    and [“Loop Statements”](#smallerc-CHP-3-SECT-3), but we can take a quick detour
    and show the 0-or-1 results with some simple print statements. Consider [*ch03/booleans.c*](https://oreil.ly/2dSZx):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and compile that file and run it. You should see output similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that a “true” comparison results in a `1`, as I noted before.
    Conversely, “false” is a `0` behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some questions we want to ask in our code cannot be reduced to a single comparison.
    A very popular question, for example, is to ask if a variable is within a range
    of values. We need to know if the variable in question is *both* greater than
    some minimum value *and* also less than some maximum. C does not have the kinds
    of operators that create ranges or that test for membership in such ranges. But
    C does support logical operators (sometimes you’ll hear about Boolean operators)
    to help you build up logic expressions that can be quite complex.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, look at the operators in [Table 3-2](#smallerc-CHP-3-TABLE-boolean-ops).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Boolean operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Operation | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Not | Unary operator that produces the logical opposite of its operand
    |'
  prefs: []
  type: TYPE_TB
- en: '| && | And | Conjunction; both operands must be true to yield true |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Or | Disjunction; true if at least one operand is true |'
  prefs: []
  type: TYPE_TB
- en: These operators probably look a little strange and you may not be familiar with
    logical operations, so give yourself some time to play with these symbols. Don’t
    worry if they aren’t comfortable yet. Boolean algebra is not a common grade school
    topic! But you will definitely encounter these operators in code you find online,
    so let’s make sure you understand how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Calling it “logic” or “boolean algebra” is useful when discussing programming
    languages, but you probably do have experience with these concepts from human
    languages (like the English I’m using here): these operators form *conjunctions*.
    The classic “and,” “but,” and “or” from grammar lessons are roughly equivalent
    to the `&&`, `!`, and `||` in C. Putting these Boolean expressions into English
    can even help you grasp their intent. Consider “x > 0 && x < 100.” Go ahead and
    read that expression out loud: “x is greater than zero and x is less than 100.”
    If spelling these expressions out helps, it’s an easy trick to pull out when coming
    across new code.'
  prefs: []
  type: TYPE_NORMAL
- en: In logic, these operators can be described best by their outcomes. Those outcomes,
    in turn, are often shown in *truth tables* that enumerate all possible combinations
    of inputs and their results. Luckily, with only two possible values, true and
    false, the combinations are manageable. Each operator gets its own truth table.
    [Table 3-3](#smallerc-CHP-3-TABLE-boolean-op-and) lists the inputs and results
    for the `&&` operator. Let’s start there.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-3\. The `&&` (and) operator
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | a && b |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | false |'
  prefs: []
  type: TYPE_TB
- en: 'As the table illustrates, this is a fairly restrictive operator. Both inputs
    have to be true for the result to be true. Per the previous tip, it can be useful
    to think in terms of an English conjunction: “We can’t go to the party until both
    Reg *and* Kaori are ready.” If Reg isn’t ready, we have to wait. If Reg is ready,
    but Kaori isn’t, we have to wait. Of course, if neither are ready, we wait.^([2](ch03.xhtml#idm45018734265544))
    It’s only when both are good to go that we can start our trek. For the record,
    Reg and Kaori are both quite prompt individuals. Waiting is rarely an issue. ;)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-4](#smallerc-CHP-3-TABLE-boolean-op-or) shows the results when using
    `||` for the same combination of inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-4\. The `||` (or) operator
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | a &#124;&#124; b |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| true | true | true |'
  prefs: []
  type: TYPE_TB
- en: '| true | false | true |'
  prefs: []
  type: TYPE_TB
- en: '| false | true | true |'
  prefs: []
  type: TYPE_TB
- en: '| false | false | false |'
  prefs: []
  type: TYPE_TB
- en: This is a more permissive operator. Back to our party trip metaphor, perhaps
    it falls on a weeknight and we can’t expect both of our friends to drop everything
    and join. For this variation, if *either* Reg *or* Kaori can join, then we will
    have a nice time with a good dinner companion. Similar to the `&&` operator, if
    both can join, then hooray! We still have an enjoyable evening ahead.^([3](ch03.xhtml#idm45018734246248))
    If both inputs are false, though, the overall answer is still false and we’ll
    be stuck on our own.
  prefs: []
  type: TYPE_NORMAL
- en: The final operator C supports for building logic expressions is `!`. It is a
    *unary* operator, meaning it operates on only one thing rather than the two that
    go into a *binary* operation like the math or comparison operators require. That
    means its table, [Table 3-5](#smallerc-CHP-3-TABLE-boolean-op-not), is a little
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-5\. The `!` (not) operator
  prefs: []
  type: TYPE_NORMAL
- en: '| a | !a |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| true | false |'
  prefs: []
  type: TYPE_TB
- en: '| false | true |'
  prefs: []
  type: TYPE_TB
- en: 'In coding, this “not” operation is often used to guard against errors before
    continuing on. Our final party example: we will arrive at the party on time as
    long as we do *not* run into traffic. This operator creates an opposite result.
    So “traffic is bad” versus “no traffic is good.” The conversion to English is
    not quite as literal, but hopefully still illustrates the point that you can talk
    about the logic being performed.'
  prefs: []
  type: TYPE_NORMAL
- en: Branching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to translate logic questions into valid C syntax, how can
    we put those questions to use? We’ll start with the notion of conditional statements,
    or *branches*. We can ask a question and then execute some group of statements
    (or not) depending on the answer.
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest conditional statement is the `if` statement. It has three forms,
    with the simplest being a do-it-or-don’t configuration. The syntax of this statement
    is fairly straightforward. You supply the `if` keyword, a test inside parentheses,
    and then a statement or code *block* (a grouping of one or more statements inside
    curly braces) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the Boolean expression we use is true, we will execute the statement or block
    following the `if` line. If the expression is false, we will skip the statement
    or block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple program that asks the user for a numeric input. You might
    want to let the user know about uncommon inputs, in case they made a typo. For
    example, we could allow negative numbers, but maybe they aren’t the usual way
    to go. We still want the program to run, but we alert the user that they might
    get a surprising result. The program in [*ch03/warnings.c*](https://oreil.ly/sP2kJ)
    is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this with a few different inputs, you can see the effect of the `if`
    statement. Only the final run shows the warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Try entering the program and then compile and run it yourself. Try changing
    the test to look for other things like even or odd numbers, or numbers inside
    or outside a range.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `if` statements to get some more human-friendly responses from
    Boolean values. Instead of printing out simple ones and zeros, we can put the
    tests into an `if` statement and then print out any true response. Here’s our
    updated example; we’ll call it [*ch03/booleans2.c*](https://oreil.ly/neHcZ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Give this new program a try and you should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Great! Only tests that return true are printing. That is much more readable.
    This type of `if` combined with `printf()` is a common debugging trick. Anytime
    you have an interesting (or worrying) condition, print out a warning and maybe
    include the relevant variables to help you fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With a simple `if`, we can see nice output for tests that return true. But
    what if we also want to know when a test is false? That’s what the second form
    of the `if` statement is for; it includes an `else` clause. You always use an
    `else` in conjunction with an `if`. (An `else` on its own is a syntax error and
    the program won’t compile.) The `if/else` statement ends up with two branches:
    one executes if the test is true, the other executes if the test is false. Let’s
    build [*ch03/booleans3.c*](https://oreil.ly/neHcZ) and get either a thumbs-up
    or a thumbs-down answer for every test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we run this with the same inputs from before, we’ll see a gratifying
    expansion of answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Perfect. We have readable answers for every test. Now we don’t have to wonder
    if a test ran and failed or was somehow skipped altogether. We get a useful response
    every time. Try upgrading the *warnings.c* file so that you still get the warning
    if a number is “unusual,” but it also gives the user a friendly message indicating
    their input is in the expected range.
  prefs: []
  type: TYPE_NORMAL
- en: else if chains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now have some pretty powerful decision statements in our toolkit. We can
    do something or skip it. We can do one thing or an alternative. What if we need
    to decide between three statements? Or four? Or more? One possible pattern for
    this scenario is the third variation of `if`: the `if/else if/else` combination.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C allows you to “chain” `if/else` pairs together to achieve a one-of-many branch
    selection. Consider game scores that get rated with one, two, or three stars depending
    on how well you did. You could get that type of answer with this idea of `else
    if` blocks. Here is [*ch03/stars.c*](https://oreil.ly/Fe8q9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some example runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But maybe our game is special and has four star performances. (Wow!) The file
    [*ch03/stars2.c*](https://oreil.ly/uXLDr) shows how to bring one more `else if`
    clause to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And a few more examples of the output to verify that our new top score works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You could continue those chains ad infinitum. Well, within reason. You’ll eventually
    be limited by memory and beyond a handful of clauses, it becomes difficult to
    follow the flow of such chains. If it feels like you have too many `else/if` blocks
    in one chain, it might be worth spending a little time examining your algorithm
    to see if there are other ways to break down your tests.
  prefs: []
  type: TYPE_NORMAL
- en: if gotchas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of those `else/if` chains hints at a detail of C’s syntax I previously
    mentioned briefly. The `if` and `else` chunks do not require the curly braces
    if you have exactly one statement in the clause. For example, our *booleans3.c*
    could be written like this ([*ch03/booleans3_alt.c*](https://oreil.ly/FrXzk)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will definitely run across code like this online. It saves a little typing
    and can make for more compact code where the tests and the statements are simple.
    You *can* use the curly braces to create a block with a single statement just
    as we did in the original *booleans3.c* code. It works like using extra parentheses
    in mathematic operations: not necessary but useful for readability. It is mostly
    just a matter of style when you have only the one thing to do. Since doing two
    or more things always requires the curly braces, though, I’ll stick to using curly
    braces as a way to future-proof our code. (And as a matter of style, I prefer
    the consistency of seeing the braces.) If we come back later to update some example
    and need to add another print statement, say, we won’t have to remember to add
    the braces; they’ll be there ready and waiting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests you use in `if` statements can also cause problems if you aren’t
    careful. Remember the comment about C treating a zero as false and any other number
    as true? Some programmers rely on that fact to write very compact tests. Consider
    this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `if` clause will execute for any positive or negative number, as if we had
    built a real test like `x != 0` or even a fancier logical expression like `(x
    < 0 || x > 0)`. This pattern gets used as a (sometimes lazy) shortcut for asking
    “does this variable have any value at all” where a zero is assumed to be an invalid
    possibility. It’s a fairly common pattern, although I usually prefer to write
    explicit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other big quirk of C using integers as proxies for Boolean values: there
    is a very subtle typo that can cause real trouble. Take a look at this next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you’re curious, go ahead and create a program to try this gotcha. When you
    run it, you’ll see that you *always* get the “Blackjack! 21” output. What happened?
    Look closely at the test in the `if` statement. What we meant to write was `total
    == 21` using the double equal sign comparison operator. By using the single equal
    sign, we actually *assigned* the value 21 to our `total` variable right there
    inside the `if` test! Assignments in C are expressions just like our mathematic
    calculations. The value of an assignment expression is the same as the new value
    being assigned. The upshot is that this test is akin to `if (21) ...`, which will
    always be true since 21 is not 0\. It is frustratingly easy to make this mistake.
    Just watch out for `if` statements that always seem to execute no matter how you
    change your inputs. That behavior is a hint to reexamine the test you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: The switch Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I noted in [“else if chains”](#smallerc-CHP-3-SECT-2.1.2) that the `if/else
    if` chains can become difficult to follow if you have too many tests chained together.
    Sometimes, though, you really do have a bunch of specific cases you need to check,
    say, what shirts are in stock at your favorite online store based on your size.
    If those cases all involve the same variable and all use simple equality (`==`)
    as the test, then you can use the `switch` statement in C as a nice alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `switch` statement takes an expression (the control expression), typically
    a variable or simple calculation, and then systematically compares the value of
    that expression to one or more constant values using `case` labels. If the control
    expression value matches a case, the code following that value starts executing
    and continues until the end of the `switch` statement (which is always a curly
    brace block) or the program hits a `break` command. The [*ch03/medals.c*](https://oreil.ly/LVkuZ)
    file contains a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and run the program a few times with the three possible inputs,
    you should see results like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Neat! Exactly what we expected. But what if we comment out those `break` lines?
    Let’s try that now because this illustrates a critical quirk with `switch` that
    can trip up new programmers. Here is our altered program, [*ch03/medals2.c*](https://oreil.ly/MluI4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the new output using the same series of inputs we used the first
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Huh. That’s really strange. Once it gets started, the program just keeps executing
    statements in the `switch` even if they are part of separate cases. While that
    might seem like a bad idea, it is meant to be a feature of `switch`, not a bug.
    This design allows you to perform the same action for several values. Consider
    the following snippet that describes any number between 1 and 10 in terms of even,
    odd, and prime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can arrange cases in such a way that the `switch` feature of flowing until
    a `break` gives us exactly the right output. While this feature is most often
    used to collect a related series of distinct values (such as our even numbers)
    and then give them the same block to execute, the flow of printing the “prime”
    qualifier and then continuing on to add the “odd” designation is valid and can
    be handy sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one other feature in `switch` that is similar to the `else` clause
    that can be used with `if` statements. Sometimes you want your `switch` statement
    to handle every possible input. But listing out a few thousand integers or even
    just every letter in the alphabet can be very tedious, to say the least. And usually,
    you don’t have unique actions for all those thousands of options. In these situations,
    you can use the `default` label as your final “case” and it will execute regardless
    of the control expression value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Technically, `default` can appear anywhere in the list of cases, not just as
    the final option. However, since the `default` case *always* runs when encountered,
    it doesn’t make sense to include subsequent, specific cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with our *medals.c* program, what about contestants that didn’t
    make the podium? Try running it again with some number larger than three. What
    do you get? Nothing. No error, no output, nada. Let’s write [*ch03/medals3.c*](https://oreil.ly/l1AHK)
    and use the `default` option to print a message and at least prove we saw the
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run this new program and try some values larger than three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lovely! No matter what number greater than three we give, we get some feedback
    to show that we have processed that input. Exactly what we wanted. And we can
    use `default` even with `switch` statements that include the multiple-cases-per-block
    arrangement. Let’s add a “Top 10” level to our medal description program, [*ch03/medals4.c*](https://oreil.ly/lS1tv):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'One more compile and then run it with a few inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Great. Here’s a quick homework assignment for you. Modify *medals4.c* so that
    if you get 4th or 5th place, you get labeled a “runner up.” Places 6 through 10
    should still be listed as top 10\. (It’s a small change. You can check your answer
    against mine in [*ch03/medals5.c*](https://oreil.ly/W7uci).)
  prefs: []
  type: TYPE_NORMAL
- en: The Ternary Operator and Conditional Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One last conditional topic that gets a lot of use in lean code is the notion
    of conditional assignment. C includes a ternary operator, `?:`, that takes three
    operands. It allows you to use one of two values in a very compact syntax. The
    result of this ternary expression is indeed a value like any other expression
    in C, so you can use `?:` anywhere a value is legal.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of `?:` uses a Boolean expression as the first operand, then the
    question mark, then an expression to evaluate if the boolean is true, then the
    colon, and finally an alternate expression to evaluate if the boolean is false.
  prefs: []
  type: TYPE_NORMAL
- en: A great example of using the ternary operator is grabbing the smaller of two
    values. Consider a simple program processing two bids for some graphic design
    work. Budget is sadly the driving factor, so you need to accept the lowest bid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Very dense! It takes a little practice even just to read these ternary expressions,
    but once you have the hang of it, I think you’ll find it a very handy operator.
    The alternative is a somewhat drawn out `if/else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Certainly not an awful alternative, but it is definitely more verbose. Plus
    there are times where the ternary approach really simplifies things. Remember
    the first program on Boolean expressions, *booleans.c*, in [“Comparison Operators”](#smallerc-CHP-3-SECT-1.1)?
    We had to live with interpreting a 1 as “true” and a 0 as “false.” We eventually
    printed nice statements in *booleans3.c*, but we had to use that fairly verbose
    `if/else` pattern. With `?:`, however, we can make human-friendly output directly
    in the `printf()` statements. Try [*ch03/booleans4.c*](https://oreil.ly/Hnumr)
    and see what you think:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is our updated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Much better.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It was a bit of a pain wrapping each of those print calls in an `if/else` block
    in *booleans3.c*. Not just annoying, the shared parts in the printed text can
    get out of sync if you make any changes. If you found a typo at the beginning
    of a line, for example, you would have to make sure you fixed the beginning of
    both the `if` clause `printf()` and again in the `else` clause. It is all too
    easy to forget one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you can avoid such duplicated code by using a different conditional
    statement or operator, it’s worth considering. But don’t be overzealous; if your
    `if/else` chain feels readable and produces the right output, that is still a
    fine option.
  prefs: []
  type: TYPE_NORMAL
- en: Loop Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can solve some interesting problems with just variables and the input, output,
    and branching statements we have covered so far. But one of the spots where computers
    really shine is when you need to repeat a test or batch of statements. To perform
    repetitions, you can use one of C’s *loop* statements. Your program will execute
    all of the (optional) statements, and at the end of those statements, “loop” back
    to the start and execute them all again. Usually you don’t want that loop to run
    forever, so each loop statement has a condition to check and see when the loop
    should stop.
  prefs: []
  type: TYPE_NORMAL
- en: The for Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One type of repetition that crops up in programming is repeating a block for
    a specific number of times. For example, doing something for each day of the week,
    or processing the first 5 lines of input, or even just counting to 10\. In fact,
    let’s see the `for` loop that counts to 10, shown in [Figure 3-1](#smallerc-CHP-3-FIG-for-loop-annotated)
    where I have marked the parts of the loop. (Feel free to type this in or open
    up the [*ch03/ten.c*](https://oreil.ly/qqDiQ) file.) It can look a little messy
    at first, but over time it’ll become familiar.
  prefs: []
  type: TYPE_NORMAL
- en: '![smac 0301](Images/smac_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. An annotated `for` loop
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Before we look at the details of the loop, here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![1](Images/1.png)'
  prefs: []
  type: TYPE_IMG
- en: (`int i = 1`) This is our loop variable. We use the same declaration and initialization
    syntax as we do for normal variables. This portion of the loop is always executed
    first, and is only executed once when the loop starts.
  prefs: []
  type: TYPE_NORMAL
- en: '![2](Images/2.png)'
  prefs: []
  type: TYPE_IMG
- en: (`i <= 10`) Here is the test to see when the loop should stop. The loop will
    run as long as this test returns true. If this condition is false—even the first
    time it is checked—the loop will end.
  prefs: []
  type: TYPE_NORMAL
- en: '![3](Images/3.png)'
  prefs: []
  type: TYPE_IMG
- en: The body of the loop is executed next, assuming the test in ![2](Images/2.png)
    returned true.
  prefs: []
  type: TYPE_NORMAL
- en: '![4](Images/4.png)'
  prefs: []
  type: TYPE_IMG
- en: (`i = i + 1`) After completing the body, this adjustment expression is evaluated.
    This expression typically increments or decrements our loop variable by one. After
    this step, control jumps back to ![2](Images/2.png) to see if the loop should
    continue.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization, the check for when to end, and the adjustment are all quite
    flexible. You can use whatever name you like and can count up or down by any amount.
    You can even use the `char` type for a variable if you want sequential characters
    for any reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a few more simple `for` loops to practice its syntax and its flow.
    We’ll initialize our loop variable, check to make sure we should start the loop,
    execute the statements in the body, perform the adjustment, and then check to
    see if we should continue. Lather. Rinse. Repeat.^([4](ch03.xhtml#idm45018732222664))
    We’ll try some loops with different adjustments including a decrement that can
    be used to count backward, [*ch03/more_for.c*](https://oreil.ly/jzGZe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Try tweaking some of the values in the loops and recompile. Can you count backward
    by twos? Can you count to 100? Can you count from 1 to 1,024 by doubling?
  prefs: []
  type: TYPE_NORMAL
- en: Increment shortcuts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Incrementing or decrementing a variable like we do in those adjustment expressions
    is such a common task (even outside of loops) that C supports a number of shortcuts
    for that type of change. Consider statements of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'where `var` is some variable and `op` is one of the arithmetic operators from
    [Table 2-6](ch02.xhtml#smallerc-CHP-2-TABLE-math-ops). If you are using that pattern
    in your code, you can use a compound assignment instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Going further, any time you are adding or subtracting 1 from a variable, you
    can use an even more succinct variation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may see a “prefix” version of the increment and decrement shortcuts, i.e.,
    `++i` or `--total`. These variations are legal and have a subtle distinction that
    does not come into play when used in `for` loops like we’re doing.^([5](ch03.xhtml#idm45018732082600))
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to use these compact options, but they are popular and you will
    certainly encounter them on coding sites like Stack Overflow or in Arduino examples.
  prefs: []
  type: TYPE_NORMAL
- en: for gotchas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we tackle the other loop options in C, I want to point out a few details
    about `for` loops that can trip you up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most important element of the `for` loop syntax is the condition
    in the middle of the loop’s setup. You need to make sure that the condition allows
    the loop to *start* as well as the more obviously necessary ability to make the
    loop stop. Consider this loop snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The ostensible intent of the loop is to count to 10—by stopping when `x` is
    equal to 11\. But the condition must evaluate to true for the loop to run, so
    you can’t just watch for the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to make sure your condition and adjustment expressions are in
    sync. One of my favorite mistakes is to create a loop meant to count down or count
    backward, but I forget to use the decrement operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: I obviously should say `countdown--` in the last segment of this setup, but
    incrementing is so common, it’s almost muscle memory. Take a look at this loop.
    Can you see what is going to happen? Instead of moving toward the stop condition,
    this loop will head away and keep going for quite some time. Sadly, the compiler
    can’t really help us here because this syntax is entirely legal. The error is
    a logic error, so it falls to you as the programmer to catch it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other big mistake that can be easy to make has to do with the syntax of
    the `for` loop setup. Notice that the expressions are separated by semicolons,
    not commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That detail is easy to miss and you’ll probably make that mistake at least
    once. Here, the compiler will catch you, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Easy to fix, of course, but something to be mindful of as you are learning.
    These types of errors are something you encounter (and then fix!) more often when
    typing up code directly rather than cutting and pasting it from an online source.
    I really do recommend entering some of the program listings in this book by hand
    for just this reason.
  prefs: []
  type: TYPE_NORMAL
- en: The while Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performing a specific number of iterations is certainly a popular task in computer
    programming. But looping until some more generic condition is met is easily just
    as common. In C, that more generic loop is the `while` loop. It has a simple condition
    as its only real syntactic element. If the condition is true, the body of the
    loop is executed. Jump back up and check the condition…and repeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of loop is perfect for input where you cannot predict how many pieces
    of information you will need to scan. Let’s try a simple program to calculate
    the average of some numbers. Critically, we will allow the user to enter as many
    (or as few) numbers as they wish. We’ll ask them to enter a *sentinel* value to
    indicate they are done giving us new numbers. A sentinel can be any value that
    stands out from expected values. We use it in our condition so we know when to
    stop. For example, let’s ask the user for numbers between 1 and 100\. We can then
    use 0 as a sentinel. Here is [*ch03/average.c*](https://oreil.ly/KmxH4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two sample runs with different inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We get things going by asking the user for the first number. We then use that
    response in our `while` statement. If they enter a 0 the first time, we’re done.
    Unlike `for` loops, it is not uncommon for a `while` loop to never execute. There
    are reasonable circumstances where you might need to iterate over an optional
    task, say, turning off all the lights in a smart home. But being optional, sometimes
    that means you don’t do it at all; if the lights are already off, there’s nothing
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming they give us a valid number, though, we start the loop. We add their
    input to a separate variable where we keep the running `total`. (In programming,
    this is sometimes referred to as an *accumulator*.) We also increment a third
    variable, `count`, to keep track of how many numbers the user gives us.
  prefs: []
  type: TYPE_NORMAL
- en: We prompt the user for the next number (or a 0 to quit). We get their input,
    and again that value will be used in the `while` loop’s condition. If the most
    recent grade is valid, add it to the total and repeat.
  prefs: []
  type: TYPE_NORMAL
- en: Once we complete the loop, we print the results. We use an `if/else` statement
    to wrap that final result in a nice, human-friendly sentence. If they entered
    a 0 at the beginning, we note that there is no average to print. Otherwise (`else`)
    we print the average with two decimal places of precision.
  prefs: []
  type: TYPE_NORMAL
- en: The do/while Variation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last of the loop statements in C is the `do/while` (sometimes referred
    to as just a `do` loop). As you might guess from the name, it is similar to the
    `while` loop, but with one big difference. A `do` loop automatically guarantees
    at least one execution of the loop body. It does this by checking the loop condition
    *after* the body has executed instead of before. This is great where you know
    you need at least one pass. Our grade averaging program is actually a perfect
    example. We have to ask the user for a grade at least once. If they give us a
    0 right away, we’re done and that’s fine. If they give us a valid number, we accumulate
    our total and ask again. Using a `do` loop and a small adjustment to our count
    at the end, we can avoid the duplicate `scanf()` calls in [*ch03/average2.c*](https://oreil.ly/ILhdW):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output is essentially the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Not much of a difference—indeed no difference in the results—but any time you
    can remove lines of code without harming functionality, you’re reducing the chances
    of bugs cropping up. That’s always a good thing!
  prefs: []
  type: TYPE_NORMAL
- en: Nesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding loops and conditional statements to your repertoire greatly expands
    the problems you can tackle. But it gets even better: you can nest `if` statements
    inside loops to watch for error conditions, put a `while` inside an `if` to wait
    on a sensor, or use a `for` loop inside another `for` loop to traverse tabular
    data. Remember that all these control statements are still just statements and
    they can be used anywhere other, simpler statements are allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use this nesting ability to improve our averaging program further. We
    know zero is the “done” value, but we said we wanted values between 1 and 100\.
    What happens if the user gives us a negative number? Or a number greater than
    100? If you look closely at the code in *average2.c*, you’ll see we don’t do much
    about it. We don’t exit or throw it out. We can do better if we use an `if/else`
    statement inside our loop as in [*ch03/average3.c*](https://oreil.ly/alYI8):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Cool. We even fixed the little hiccup with our `count` variable in *average2.c*
    where we had to decrement `count` by 1 since we executed the entire body of the
    `do/while` loop even if the first entry was 0\. Very nice upgrade!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this program with some simple inputs so we can verify that bad values
    were not included in the average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the math: 82 + 43 + 14 + 97 = 236\. 236 ÷ 4 = 59\. That matches
    our result, so our nested `if/else` is working. Hooray!'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you build more complicated programs with nested control statements, you may
    bump into situations where you need to get out of a loop before it would normally
    finish. Happily, the `break` command you saw in the discussion of the `switch`
    statement can be used to immediately exit a loop. Some programmers try to avoid
    this “cheat,” but sometimes I think it actually makes code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: A common use case is encountering an error from user input in the middle of
    a loop. Rather than try to add extra logic to your loop condition, you can test
    for the error with an `if` statement and if you did get the error, just `break`.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Loops and Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s try another example. I mentioned using nested `for` loops for tabular
    data. We can use this idea to produce the classic multiplication table from grade
    school in [*ch03/multiplication.c*](https://oreil.ly/mQQbs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s pretty small. This is the type of repetitive task that programs can
    solve very efficiently. And the resulting table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Very gratifying! And you aren’t limited to just two loops. You could process
    three-dimensional data with three loops, as in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There is (almost) no end to the complexity you can wrap up in your code to solve
    even the thorniest problems.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important thing to remember about nesting statements in C is that the language
    enforces *variable scope* in its blocks. If you create a variable to use with
    a `for` loop, for example, that variable cannot be used *after* the loop has completed.
    This is true of any variable declared inside a block (e.g., inside a pair of curly
    braces) or in the setup of a `for` loop. Once the block ends, the variable is
    no longer accessible. (Sometimes you’ll hear programmers talk about a variable’s
    *visibility*, which is the same idea.)
  prefs: []
  type: TYPE_NORMAL
- en: Most times you don’t have to think much about this topic, as you’ll naturally
    tend to use your variables where you declare them and that’s great. But in complex
    code structures, you can lose track of where a variable was declared and that
    can cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s upgrade our multiplication table program to ask the user what size of
    table (within reason!) they’d like to produce. We’ll allow any table size from
    1 to 20\. We’ll store the user’s response in a variable that can be used by both
    loops. Try the following program ([*ch03/multiplication2.c*](https://oreil.ly/0z424))
    and pay attention to the comments that highlight some potential problem areas
    where a variable is not visible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_flow_of_control_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that our `tableSize` variable is visible in both loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_flow_of_control_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the `row` variable is visible inside the loop drive by the `col` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_flow_of_control_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: But once that inner `for` loop finishes printing the values for a given row,
    the `col` variable goes “out of scope” and cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens if you try to access something that has gone out of scope?
    Well happily, the compiler will usually catch you. For example, if we try printing
    the final value of `col` where we currently print the newline character to end
    the row, we’ll get an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Making these mistakes is never fatal. You just have to read the error message
    and figure out which bit of code is causing the problem. If you *do* need to use
    a particular variable after a loop or block concludes, you must define that variable
    before the block. For example, we could declare both of our loop variables, `row`
    and `col`, in the same spot where we declare `tableSize` to make all three of
    them visible everywhere inside our `main()` function. Our initialization step
    in our `for` loops won’t declare those variables with their `int` type, but rather
    just assign the starting value, like in [*ch03/multiplication3.c*](https://oreil.ly/yTDBc):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our new version with a width of 5, then, here’s our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: So we can see the final values of `row` and `col` that caused the loops to stop.
    Kind of neat, but also kind of prone to causing problems. Using variables with
    a broad or global scope is frowned on because of those potential problems. If
    you have a good reason and need to use a particular variable in different blocks,
    that’s fine, just make sure you declare such variables deliberately and not simply
    to make the program compile.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen the structure of several different flow of control statements in
    this chapter. Hopefully, you’ve been trying and tweaking the examples as you’ve
    been reading. But nothing helps you get comfortable with a new language or a new
    statement like using it. Over and over. And over. :) To that end, here are some
    exercises to try if you like before reading on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print out a triangle pattern. You can hardcode the size or ask the user, like
    we did with our multiplication table. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out a pyramid pattern where the rows of stars are centered, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add row and column labels to our multiplication table, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a number guessing game. For now, just pick a number yourself and store
    it in a variable like `secret`. (We’ll take a look at letting the computer pick
    a random number for us in [Chapter 7](ch07.xhtml#smallerc-CHP-7).) Tell the user
    what the bounds of the range are and as they guess, give them clues about whether
    their guess is lower or higher than the secret. Playing your game might look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try implementing Euclid’s algorithm for finding the greatest common divisor
    shared by two numbers. In *pseudocode* (English statements arranged like code
    and occasionally using operators like “=”; it’s meant to be a way of describing
    the steps of some program without requiring real code), the algorithm goes like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can just set the two values in your program or ask the user to input them.
    To check your program, the greatest common divisor of 3,456 and 1,234 is 2 and
    the greatest common divisor of 432 and 729 is 27.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see how I solved these problems, you can look at the various
    answers in the [*ch03/exercises*](https://oreil.ly/BDw5K) folder. But I encourage
    you to try and solve them yourself before looking at my solutions. There are many,
    many ways to solve each of the exercises, and comparing your own approach to mine
    can help reinforce the syntax and purpose of the statements we’ve covered.
  prefs: []
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The branching and repetition statements we covered in this chapter are the core
    of a computer program’s ability to solve problems. They make it possible to take
    real-world algorithms and convert them into code. Knowing C’s control statements
    comes with the added benefit of preparing you for other programming languages
    that often borrow some of C’s syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is more of that syntax to cover, though. In the next chapter, we’ll look
    at how C handles one of the most popular tools for storing big lists of things:
    the array. With an eye on our goal of writing C code for more limited microcontrollers,
    we’ll also see how C can be used to manipulate the smallest thing in a computer:
    the bit.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45018734452728-marker)) C99 introduced a new type, `_Bool`,
    but we won’t be using this in our lean code. If you find yourself working with
    Boolean logic in your own coding, though, be sure to check out the *stdbool.h*
    header. You can find more details on just about everything C in Prinz and Crawford’s
    [*C in a Nutshell*](https://www.oreilly.com/library/view/c-in-a/0596006977/) (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.xhtml#idm45018734265544-marker)) Many languages, including C, are
    clever enough to realize that if Reg is not ready, we don’t even have to bother
    checking on Kaori. This behavior is often referred to as “short circuit evaluation.”
    Short circuit comparisons can be very useful when the tests involved are computationally
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.xhtml#idm45018734246248-marker)) And like the `&&` operator, the
    C compiler optimizes the case where Reg can join by not asking Kaori at all.
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch03.xhtml#idm45018732222664-marker)) Did you know many shampoo bottles
    come with an algorithm for washing your hair? But don’t follow the algorithm too
    closely: many times the instructions really are as simple as “lather, rinse, repeat,”
    which is an infinite loop! There is no check as to when you have repeated enough.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch03.xhtml#idm45018732082600-marker)) A quick nerdy detail, if you’re
    curious. *Prefix* operators come before the value or expression they are meant
    to operate on. The `i--` expression contains an example of a *postfix* operator—one
    that comes after the value or expression. In C, all of the binary operators like
    + or * or == are *infix* operators, coming “in between” the operands.
  prefs: []
  type: TYPE_NORMAL
