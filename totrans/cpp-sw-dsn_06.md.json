["```cpp\nclass JSONExportable\n{\n public:\n   // ...\n   virtual ~JSONExportable() = default;\n\n   virtual void exportToJSON( /*...*/ ) const = 0;\n   // ...\n};\n\nclass Serializable\n{\n public:\n   // ...\n   virtual ~Serializable() = default;\n\n   virtual void serialize( ByteStream& bs, /*...*/ ) const = 0;\n   // ...\n};\n\nclass Document\n   : public JSONExportable\n   , public Serializable\n{\n public:\n   // ...\n};\n```", "```cpp\nclass OpenPages\n{\n public:\n   // ...\n   void convertToBytes( /*...*/ );\n};\n\nvoid exportToJSONFormat( OpenPages const& pages, /*...*/ );\n```", "```cpp\nclass Pages : public Document\n{\n public:\n   // ...\n   void exportToJSON( /*...*/ ) const override\n   {\n      exportToJSONFormat(pages, /*...*/);  ![1](assets/1.png)\n   }\n\n   void serialize( ByteStream& bs, /*...*/ ) const override\n   {\n      pages.convertToBytes(/*...*/);  ![2](assets/2.png)\n   }\n   // ... \n private:\n   OpenPages pages;  // Example of an object adapter };\n\n```", "```cpp\nclass Pages : public Document\n            , private OpenPages  // Example of a class adapter ![3](assets/3.png)\n{\n public:\n   // ...\n   void exportToJSON( /*...*/ ) const override\n   {\n      exportToJSONFormat(*this, /*...*/);\n   }\n\n   void serialize( ByteStream& bs, /*...*/ ) const override\n   {\n      this->convertToBytes(/*...*/);\n   }\n   // ... };\n\n```", "```cpp\n//---- <Stack.h> ---------------- \ntemplate< typename T >\nclass Stack\n{\n public:\n   virtual ~Stack() = default;\n   virtual T& top() = 0;  ![4](assets/4.png)\n   virtual bool empty() const = 0;  ![5](assets/5.png)\n   virtual size_t size() const = 0;  ![6](assets/6.png)\n   virtual void push( T const& value ) = 0;  ![7](assets/7.png)\n   virtual void pop() = 0;  ![8](assets/8.png)\n};\n\n```", "```cpp\n//---- <VectorStack.h> ----------------\n\n#include <Stack.h>\n\ntemplate< typename T >\nclass VectorStack : public Stack<T>\n{\n public:\n   T& top() override { return vec_.back(); }\n   bool empty() const override { return vec_.empty(); }\n   size_t size() const override { return vec_.size(); }\n   void push( T const& value ) override { vec_.push_back(value); }\n   void pop() override { vec_.pop_back(); }\n\n private:\n   std::vector<T> vec_;\n};\n```", "```cpp\ntemplate< typename T\n        , typename Container = std::deque<T> >\nclass stack;\n\ntemplate< typename T\n        , typename Container = std::deque<T> >\nclass queue;\n\ntemplate< typename T\n        , typename Container = std::vector<T>\n        , typename Compare = std::less<typename Container::value_type> >\nclass priority_queue;\n```", "```cpp\ntemplate< typename Range >\nvoid traverseRange( Range const& range )\n{\n   for( auto&& element : range ) {\n      // ...\n   }\n}\n```", "```cpp\ntemplate< typename Range >\nvoid traverseRange( Range const& range )\n{\n   {\n      using std::begin;\n      using std::end;\n\n      auto first( begin(range) );\n      auto last ( end(range) );\n      for( ; first!=last; ++first ) {\n         auto&& element = *first;\n         // ...\n      }\n   }\n}\n```", "```cpp\n//---- <Duck.h> ----------------\n\nclass Duck\n{\n public:\n   virtual ~Duck() = default;\n   virtual void quack() = 0;\n   virtual void fly() = 0;\n};\n\n//---- <MallardDuck.h> ----------------\n\n#include <Duck.h>\n\nclass MallardDuck : public Duck\n{\n public:\n   void quack() override { /*...*/ }\n   void fly() override { /*...*/ }\n};\n```", "```cpp\n//---- <Turkey.h> ----------------\n\nclass Turkey\n{\n public:\n   virtual ~Turkey() = default;\n   virtual void gobble() = 0;  // Turkeys don't quack, they gobble!\n   virtual void fly() = 0;     // Turkeys can fly (a short distance)\n};\n\n//---- <WildTurkey.h> ----------------\n\nclass WildTurkey : public Turkey\n{\n public:\n   void gobble() override { /*...*/ }\n   void fly() override { /*...*/ }\n};\n```", "```cpp\n//---- <TurkeyAdapter.h> ----------------\n\n#include <memory>\n\nclass TurkeyAdapter : public Duck\n{\n public:\n   explicit TurkeyAdapter( std::unique_ptr<Turkey> turkey )\n      : turkey_{ std::move(turkey) }\n   {}\n\n   void quack() override { turkey_->gobble(); }\n   void fly() override { turkey_->fly(); }\n\n private:\n   std::unique_ptr<Turkey> turkey_;  // This is an example for an object adapter\n};\n```", "```cpp\n#include <MallardDuck.h>\n#include <WildTurkey.h>\n#include <TurkeyAdapter.h>\n#include <memory>\n#include <vector>\n\nusing DuckChoir = std::vector<std::unique_ptr<Duck>>;\n\nvoid give_concert( DuckChoir const& duck_choir )\n{\n   for( auto const& duck : duck_choir ) {\n      duck->quack();\n   }\n}\n\nint main()\n{\n   DuckChoir duck_choir{};\n\n   // Let's hire the world's best ducks for the choir\n   duck_choir.push_back( std::make_unique<MallardDuck>() );\n   duck_choir.push_back( std::make_unique<MallardDuck>() );\n   duck_choir.push_back( std::make_unique<MallardDuck>() );\n\n   // Unfortunately we also hire a turkey in disguise\n   auto turkey = std::make_unique<WildTurkey>();\n   auto turkey_in_disguise = std::make_unique<TurkeyAdapter>( std::move(turkey) );\n   duck_choir.push_back( std::move(turkey_in_disguise) );\n\n   // The concert is going to be a musical disaster...\n   give_concert( duck_choir );\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <Observer.h> ---------------- \nclass Observer\n{\n public:\n   virtual ~Observer() = default;\n\n   virtual void update( /*...*/ ) = 0;  ![1](assets/1.png)\n};\n\n```", "```cpp\nclass Observer\n{\n public:\n   // ...\n   virtual void update1( /*arguments representing the updated state*/ ) = 0;\n   virtual void update2( /*arguments representing the updated state*/ ) = 0;\n   // ...\n};\n```", "```cpp\nclass Observer1\n{\n public:\n   // ...\n   virtual void update1( /*arguments representing the updated state*/ ) = 0;\n   // ...\n};\n\nclass Observer2\n{\n public:\n   // ...\n   virtual void update2( /*arguments representing the updated state*/ ) = 0;\n   // ...\n};\n```", "```cpp\nclass Observer\n{\n public:\n   // ...\n   virtual void update( Subject const& subject ) = 0;\n   // ...\n};\n```", "```cpp\n//---- <Observer.h> ----------------\n\nclass Observer\n{\n public:\n   virtual ~Observer() = default;\n\n   virtual void update( Subject const& subject\n                      , /*Subject-specific type*/ property ) = 0;\n};\n```", "```cpp\n//---- <Observer.h> ---------------- \ntemplate< typename Subject, typename StateTag >  ![2](assets/2.png)\nclass Observer\n{\n public:\n   virtual ~Observer() = default;\n\n   virtual void update( Subject const& subject, StateTag property ) = 0;\n};\n\n```", "```cpp\n//---- <Person.h> ---------------- \n#include <Observer.h>\n#include <string>\n#include <set>\n\nclass Person\n{\n public:\n   enum StateChange\n   {\n      forenameChanged,\n      surnameChanged,\n      addressChanged\n   };\n\n   using PersonObserver = Observer<Person,StateChange>;  ![5](assets/5.png)\n\n   explicit Person( std::string forename, std::string surname )\n      : forename_{ std::move(forename) }\n      , surname_{ std::move(surname) }\n   {}\n\n   bool attach( PersonObserver* observer );  ![6](assets/6.png)\n   bool detach( PersonObserver* observer );  ![7](assets/7.png)\n\n   void notify( StateChange property );  ![8](assets/8.png)\n\n   void forename( std::string newForename );  ![9](assets/9.png)\n   void surname ( std::string newSurname );\n   void address ( std::string newAddress );\n\n   std::string const& forename() const { return forename_; }\n   std::string const& surname () const { return surname_; }\n   std::string const& address () const { return address_; }\n\n private:\n   std::string forename_;  ![3](assets/3.png)\n   std::string surname_;\n   std::string address_;\n\n   std::set<PersonObserver*> observers_;  ![4](assets/4.png)\n};\n\n```", "```cpp\nbool Person::attach( PersonObserver* observer )\n{\n   auto [pos,success] = observers_.insert( observer );\n   return success;\n}\n\nbool Person::detach( PersonObserver* observer )\n{\n   return ( observers_.erase( observer ) > 0U );\n}\n```", "```cpp\nvoid Person::notify( StateChange property )\n{\n   for( auto iter=begin(observers_); iter!=end(observers_); )\n   {\n      auto const pos = iter++;\n      (*pos)->update(*this,property);\n   }\n}\n```", "```cpp\nvoid Person::forename( std::string newForename )\n{\n   forename_ = std::move(newForename);\n   notify( forenameChanged );\n}\n\nvoid Person::surname( std::string newSurname )\n{\n   surname_ = std::move(newSurname);\n   notify( surnameChanged );\n}\n\nvoid Person::address( std::string newAddress )\n{\n   address_ = std::move(newAddress);\n   notify( addressChanged );\n}\n```", "```cpp\n//---- <NameObserver.h> ----------------\n\n#include <Observer.h>\n#include <Person.h>\n\nclass NameObserver : public Observer<Person,Person::StateChange>\n{\n public:\n   void update( Person const& person, Person::StateChange property ) override;\n};\n\n//---- <NameObserver.cpp> ----------------\n\n#include <NameObserver.h>\n\nvoid NameObserver::update( Person const& person, Person::StateChange property )\n{\n   if( property == Person::forenameChanged ||\n       property == Person::surnameChanged )\n   {\n      // ... Respond to changed name\n   }\n}\n\n//---- <AddressObserver.h> ----------------\n\n#include <Observer.h>\n#include <Person.h>\n\nclass AddressObserver : public Observer<Person,Person::StateChange>\n{\n public:\n   void update( Person const& person, Person::StateChange property ) override;\n};\n\n//---- <AddressObserver.cpp> ----------------\n\n#include <AddressObserver.h>\n\nvoid AddressObserver::update( Person const& person, Person::StateChange property )\n{\n   if( property == Person::addressChanged ) {\n      // ... Respond to changed address\n   }\n}\n```", "```cpp\n#include <AddressObserver.h>\n#include <NameObserver.h>\n#include <Person.h>\n#include <cstdlib>\n\nint main()\n{\n   NameObserver nameObserver;\n   AddressObserver addressObserver;\n\n   Person homer( \"Homer\"     , \"Simpson\" );\n   Person marge( \"Marge\"     , \"Simpson\" );\n   Person monty( \"Montgomery\", \"Burns\"   );\n\n   // Attaching observers\n   homer.attach( &nameObserver );\n   marge.attach( &addressObserver );\n   monty.attach( &addressObserver );\n\n   // Updating information on Homer Simpson\n   homer.forename( \"Homer Jay\" );  // Adding his middle name\n\n   // Updating information on Marge Simpson\n   marge.address( \"712 Red Bark Lane, Henderson, Clark County, Nevada 89011\" );\n\n   // Updating information on Montgomery Burns\n   monty.address( \"Springfield Nuclear Power Plant\" );\n\n   // Detaching observers\n   homer.detach( &nameObserver );\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <Observer.h> ---------------- \n#include <functional>\n\ntemplate< typename Subject, typename StateTag >\nclass Observer\n{\n public:\n   using OnUpdate = std::function<void(Subject const&,StateTag)>;  ![10](assets/10.png)\n\n   // No virtual destructor necessary \n   explicit Observer( OnUpdate onUpdate )  ![11](assets/11.png)\n      : onUpdate_{ std::move(onUpdate) }\n   {\n      // Possibly respond on an invalid/empty std::function instance\n   }\n\n   // Non-virtual update function\n   void update( Subject const& subject, StateTag property )\n   {\n      onUpdate_( subject, property );  ![13](assets/13.png)\n   }\n\n private:\n   OnUpdate onUpdate_;  ![12](assets/12.png)\n};\n\n```", "```cpp\n#include <Observer.h>\n#include <Person.h>\n#include <cstdlib>\n\nvoid propertyChanged( Person const& person, Person::StateChange property )\n{\n   if( property == Person::forenameChanged ||\n       property == Person::surnameChanged )\n   {\n      // ... Respond to changed name\n   }\n}\n\nint main()\n{\n   using PersonObserver = Observer<Person,Person::StateChange>;\n\n   PersonObserver nameObserver( propertyChanged );\n\n   PersonObserver addressObserver(\n      [/*captured state*/]( Person const& person, Person::StateChange property ){\n         if( property == Person::addressChanged )\n         {\n            // ... Respond to changed address\n         }\n      } );\n\n   Person homer( \"Homer\"     , \"Simpson\" );\n   Person marge( \"Marge\"     , \"Simpson\" );\n   Person monty( \"Montgomery\", \"Burns\"   );\n\n   // Attaching observers\n   homer.attach( &nameObserver );\n   marge.attach( &addressObserver );\n   monty.attach( &addressObserver );\n\n   // ...\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <DynamicVector.h> ---------------- \n#include <numeric>\n#include <iosfwd>\n#include <iterator>\n#include <vector>\n// ... \ntemplate< typename T >\nclass DynamicVector\n{\n public:\n   using value_type     = T;  ![2](assets/2.png)\n   using iterator       = typename std::vector<T>::iterator;\n   using const_iterator = typename std::vector<T>::const_iterator;\n\n   // ... Constructors and special member functions \n   size_t size() const;  ![3](assets/3.png)\n\n   T&       operator[]( size_t index );  ![4](assets/4.png)\n   T const& operator[]( size_t index ) const;\n\n   iterator       begin();  ![5](assets/5.png)\n   const_iterator begin() const;\n   iterator       end();\n   const_iterator end() const;\n\n   // ... Many numeric functions \n private:\n   std::vector<T> values_;  ![1](assets/1.png)\n   // ... };\n\ntemplate< typename T >\nstd::ostream& operator<<( std::ostream& os, DynamicVector const<T>& vector )  ![6](assets/6.png)\n{\n   os << \"(\";\n   for( auto const& element : vector ) {\n      os << \" \" << element;\n   }\n   os << \" )\";\n\n   return os;\n}\n\ntemplate< typename T >\nauto l2norm( DynamicVector const<T>& vector )  ![7](assets/7.png)\n{\n   using std::begin, std::end;\n   return std::sqrt( std::inner_product( begin(vector), end(vector)\n                                       , begin(vector), T{} ) );\n}\n\n// ... Many more \n```", "```cpp\n//---- <StaticVector.h> ---------------- \n#include <array>\n#include <numeric>\n#include <iosfwd>\n#include <iterator>\n// ... \ntemplate< typename T, size_t Size >\nclass StaticVector\n{\n public:\n   using value_type     = T;  ![8](assets/8.png)\n   using iterator       = typename std::array<T,Size>::iterator;\n   using const_iterator = typename std::array<T,Size>::const_iterator;\n\n   // ... Constructors and special member functions \n   size_t size() const;  ![9](assets/9.png)\n\n   T&       operator[]( size_t index );  ![10](assets/10.png)\n   T const& operator[]( size_t index ) const;\n\n   iterator       begin();  ![11](assets/11.png)\n   const_iterator begin() const;\n   iterator       end();\n   const_iterator end() const;\n\n   // ... Many numeric functions \n private:\n   std::array<T,Size> values_;  ![14](assets/14.png)\n   // ... };\n\ntemplate< typename T, size_t Size >\nstd::ostream& operator<<( std::ostream& os,    ![12](assets/12.png)\n                          StaticVector<T,Size> const& vector )\n{\n   os << \"(\";\n   for( auto const& element : vector ) {\n      os << \" \" << element;\n   }\n   os << \" )\";\n\n   return os;\n}\n\ntemplate< typename T, size_t Size >\nauto l2norm( StaticVector<T,Size> const& vector )  ![13](assets/13.png)\n{\n   using std::begin, std::end;\n   return std::sqrt( std::inner_product( begin(vector), end(vector)\n                                       , begin(vector), T{} ) );\n}\n\n```", "```cpp\ntemplate< typename DenseVector >\nstd::ostream& operator<<( std::ostream& os, DenseVector const& vector )\n{\n   // ... as before\n}\n```", "```cpp\ntemplate< typename T >  // Type of the elements\nclass DenseVector\n{\n public:\n   virtual ~DenseVector() = default;\n\n   virtual size_t size() const = 0;\n\n   virtual T&       operator[]( size_t index ) = 0;\n   virtual T const& operator[]( size_t index ) const = 0;\n\n   // ...\n};\n\ntemplate< typename T >\nstd::ostream& operator<<( std::ostream& os, DenseVector<T> const& vector )\n{\n   // ... as before\n}\n```", "```cpp\n//---- <DenseVector.h> ---------------- \ntemplate< typename Derived >  ![15](assets/15.png)\nstruct DenseVector\n{\n   // ...\n   size_t size() const { return static_cast<Derived const&>(*this).size(); }  ![17](assets/17.png)\n   // ... };\n\n//---- <DynamicVector.h> ---------------- \ntemplate< typename T >\nclass DynamicVector : public DenseVector<DynamicVector<T>>  ![16](assets/16.png)\n{\n public:\n   // ...\n   size_t size() const;  ![18](assets/18.png)\n   // ... };\n\n```", "```cpp\n//---- <DenseVector.h> ---------------- \ntemplate< typename Derived >\nstruct DenseVector\n{\n protected:\n   ~DenseVector() = default;  ![19](assets/19.png)\n\n public:\n   Derived&       derived()       { return static_cast<Derived&>( *this ); }  ![20](assets/20.png)\n   Derived const& derived() const { return static_cast<Derived const&>( *this ); }\n\n   size_t size() const { return derived().size(); }\n\n   // ... };\n\n```", "```cpp\ntemplate< typename Derived >\nstruct DenseVector\n{\n   // ...\n\n   ??? operator[]( size_t index )       { return derived()[index]; }\n   ??? operator[]( size_t index ) const { return derived()[index]; }\n\n   ??? begin()       { return derived().begin(); }\n   ??? begin() const { return derived().begin(); }\n   ??? end()         { return derived().end(); }\n   ??? end()   const { return derived().end(); }\n\n   // ...\n};\n```", "```cpp\ntemplate< typename Derived >\nstruct DenseVector\n{\n   // ... \n   using value_type     = typename Derived::value_type;  ![21](assets/21.png)\n   using iterator       = typename Derived::iterator;\n   using const_iterator = typename Derived::const_iterator;\n\n   value_type&       operator[]( size_t index )       { return derived()[index]; }\n   value_type const& operator[]( size_t index ) const { return derived()[index]; }\n\n   iterator       begin()       { return derived().begin(); }\n   const_iterator begin() const { return derived().begin(); }\n   iterator       end()         { return derived().end(); }\n   const_iterator end()   const { return derived().end(); }\n\n   // ... };\n\n```", "```cpp\nCRTP.cpp:29:41: error: no type named 'value_type' in 'DynamicVector<int>'\nusing value_type = typename Derived::value_type;\n                      ~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n```", "```cpp\nCRTP.cpp:29:10: error: invalid use of incomplete type 'class DynamicVector<int>'\n   29 |    using value_type = typename Derived::value_type;\n      |          ^~~~~~~~~~\n```", "```cpp\ntemplate< typename T >\nclass DynamicVector : public DenseVector<DynamicVector<T>>\n// ...\n```", "```cpp\ntemplate< typename Derived >\nstruct DenseVector\n{\n   // ...\n\n   decltype(auto) operator[]( size_t index )       { return derived()[index]; }\n   decltype(auto) operator[]( size_t index ) const { return derived()[index]; }\n\n   decltype(auto) begin()       { return derived().begin(); }\n   decltype(auto) begin() const { return derived().begin(); }\n   decltype(auto) end()         { return derived().end(); }\n   decltype(auto) end()   const { return derived().end(); }\n};\n```", "```cpp\ntemplate< typename Derived >\nstruct DenseVector\n{\n   // ... Note: this doesn't always work, whereas decltype(auto) always works\n\n   auto&       operator[]( size_t index )       { return derived()[index]; }\n   auto const& operator[]( size_t index ) const { return derived()[index]; }\n\n   auto begin()       { return derived().begin(); }\n   auto begin() const { return derived().begin(); }\n   auto end()         { return derived().end(); }\n   auto end()   const { return derived().end(); }\n};\n```", "```cpp\ntemplate< typename Derived >\nstd::ostream& operator<<( std::ostream& os, DenseVector<Derived> const& vector );\n\ntemplate< typename Derived >\nauto l2norm( DenseVector<Derived> const& vector );\n```", "```cpp\ntemplate< typename T >\nconcept DenseVector =\n   requires ( T t, size_t index ) {\n      t.size();\n      t[index];\n      { t.begin() } -> std::same_as<typename T::iterator>;\n      { t.end() } -> std::same_as<typename T::iterator>;\n   } &&\n   requires ( T const t, size_t index ) {\n      t[index];\n      { t.begin() } -> std::same_as<typename T::const_iterator>;\n      { t.end() } -> std::same_as<typename T::const_iterator>;\n   };\n\ntemplate< DenseVector VectorT >\nstd::ostream& operator<<( std::ostream& os, VectorT const& vector )\n{\n   // ... as before\n}\n```", "```cpp\nstruct DenseVectorTag {};  ![22](assets/22.png)\n\ntemplate< typename T >\nconcept DenseVector =\n   // ... Definition of all requirements on a dense vector (as before)\n   && std::is_base_of_v<DenseVectorTag,T>;\n\ntemplate< typename T >\nclass DynamicVector : private DenseVectorTag  ![23](assets/23.png)\n{\n   // ... };\n\n```", "```cpp\nstruct DenseVectorTag {};\n\ntemplate< typename T >\nstruct IsDenseVector  ![24](assets/24.png)\n   : public std::is_base_of<DenseVectorTag,T>\n{};\n\ntemplate< typename T >\nconstexpr bool IsDenseVector_v = IsDenseVector<T>::value;  ![25](assets/25.png)\n\ntemplate< typename T >\nconcept DenseVector =\n   // ... Definition of all requirements on a dense vector (as before)\n   && IsDenseVector_v<T>;  ![26](assets/26.png)\n\ntemplate< typename T >\nclass DynamicVector : private DenseVectorTag  ![27](assets/27.png)\n{\n   // ... };\n\ntemplate< typename T, size_t Size >\nclass StaticVector\n{\n   // ... };\n\ntemplate< typename T, size_t Size >\nstruct IsDenseVector< StaticVector<T,Size> >  ![28](assets/28.png)\n   : public std::true_type\n{};\n\n```", "```cpp\n//---- <StrongType.h> ----------------\n\n#include <utility>\n\ntemplate< typename T, typename Tag >\nstruct StrongType\n{\n public:\n   using value_type = T;\n\n   explicit StrongType( T const& value ) : value_( value ) {}\n\n   T&       get()       { return value_; }\n   T const& get() const { return value_; }\n\n private:\n   T value_;\n};\n```", "```cpp\n//---- <Distances.h> ----------------\n\n#include <StrongType.h>\n\ntemplate< typename T >\nusing Meter = StrongType<T,struct MeterTag>;\n\ntemplate< typename T >\nusing Kilometer = StrongType<T,struct KilometerTag>;\n\n// ...\n\n//---- <Person.h> ----------------\n\n#include <StrongType.h>\n\nusing Surname = StrongType<std::string,struct SurnameTag>;\n\n// ...\n```", "```cpp\n//---- <Main.cpp> ---------------- \n#include <Distances.h>\n#include <cstdlib>\n\nint main()\n{\n   auto const m1 = Meter<long>{ 120L };\n   auto const m2 = Meter<long>{  50L };\n   auto const km = Kilometer<long>{ 30L };\n   auto const surname1 = Surname{ \"Stroustrup\" };\n   auto const surname2 = Surname{ \"Iglberger\" };\n   // ... \n   m1 + km;              // Correctly does not compile! ![1](assets/1.png)\n   surname1 + surname2;  // Also correctly does not compile! ![2](assets/2.png)\n   m1 + m2;              // Inconveniently this does not compile either. ![3](assets/3.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\ntemplate< typename T, typename Tag >\nStrongType<T,Tag>\n   operator+( StrongType<T,Tag> const& a, StrongType<T,Tag> const& b )\n{\n   return StrongType<T,Tag>( a.get() + b.get() );\n}\n```", "```cpp\n//---- <Addable.h> ---------------- \ntemplate< typename Derived >\nstruct Addable\n{\n   friend Derived& operator+=( Derived& lhs, Derived const& rhs ) {  ![4](assets/4.png)\n      lhs.get() += rhs.get();\n      return lhs;\n   }\n\n   friend Derived operator+( Derived const& lhs, Derived const& rhs ) {  ![5](assets/5.png)\n      return Derived{ lhs.get() + rhs.get() };\n   }\n};\n\n```", "```cpp\n//---- <StrongType.h> ----------------\n\n#include <stdlib>\n#include <utility>\n\ntemplate< typename T, typename Tag >\nstruct StrongType : private Addable< StrongType<T,Tag> >\n{ /* ... */ };\n\n//---- <Distances.h> ----------------\n\n#include <StrongType.h>\n\ntemplate< typename T >\nusing Meter = StrongType<T,struct MeterTag>;\n\n// ...\n\n//---- <Main.cpp> ----------------\n\n#include <Distances.h>\n#include <cstdlib>\n\nint main()\n{\n   auto const m1 = Meter<long>{ 100 };\n   auto const m2 = Meter<long>{  50 };\n\n   auto const m3 = m1 + m2;  // Compiles and results in 150 meters\n   // ...\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <StrongType.h> ---------------- \n#include <utility>\n\ntemplate< typename T, typename Tag, template<typename> class... Skills >\nstruct StrongType\n   : private Skills< StrongType<T,Tag,Skills...> >...  ![9](assets/9.png)\n{ /* ... */ };\n\n```", "```cpp\n//---- <Printable.h> ----------------\n\ntemplate< typename Derived >\nstruct Printable\n{\n   friend std::ostream& operator<<( std::ostream& os, const Derived& d )\n   {\n      os << d.get();\n      return os;\n   }\n};\n\n//---- <Swappable.h> ----------------\n\ntemplate< typename Derived >\nstruct Swappable\n{\n   friend void swap( Derived& lhs, Derived& rhs )\n   {\n      using std::swap;  // Enable ADL\n      swap( lhs.get(), rhs.get() );\n   }\n};\n```", "```cpp\n//---- <Distances.h> ---------------- \n#include <StrongType.h>\n\ntemplate< typename T >\nusing Meter =\n   StrongType<T,struct MeterTag,Addable,Printable,Swappable>;  ![6](assets/6.png)\n\ntemplate< typename T >\nusing Kilometer =\n   StrongType<T,struct KilometerTag,Addable,Printable,Swappable>;  ![7](assets/7.png)\n\n// ... \n\n//---- <Person.h> ---------------- \n#include <StrongType.h>\n#include <string>\n\nusing Surname =\n   StrongType<std::string,struct SurnameTag,Printable,Swappable>;  ![8](assets/8.png)\n\n// ... \n```"]