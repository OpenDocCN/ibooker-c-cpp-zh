["```cpp\n#include <stdio.h>\n\nint main() {\n  int answer = 42;\n  double pi = 3.1415926;\n  printf(\"answer's value: %d\\n\", answer);\n  printf(\"answer's address: %p\\n\", &answer);\n  printf(\"pi's value: %0.4f\\n\", pi);\n  printf(\"pi's address: %p\\n\", &pi);\n}\n```", "```cpp\nch06$ gcc address.c\nch06$ ./a.out\nanswer's value: 42\nanswer's address: 0x7fff2970ee0c\npi's value: 3.1416\npi's address: 0x7fff2970ee10\n```", "```cpp\n#include <stdio.h>\n\nint main() {\n  int answer = 42;\n  double pi = 3.1415926;\n  int extra = 1234;\n  printf(\"answer's value: %d\\n\", answer);\n  printf(\"answer's address: %p\\n\", &answer);\n  printf(\"pi's value: %0.4f\\n\", pi);\n  printf(\"pi's address: %p\\n\", &pi);\n  printf(\"extra's value: %d\\n\", extra);\n  printf(\"extra's address: %p\\n\", &extra);\n}\n```", "```cpp\nch06$ gcc address2.c\nch06$ ./a.out\nanswer's value: 42\nanswer's address: 0x7fff9c827498\npi's value: 3.1416\npi's address: 0x7fff9c8274a0\nextra's value: 1234\nextra's address: 0x7fff9c82749c\n```", "```cpp\ndouble pi = 0.0;\ndouble *pi_ptr = NULL;\n// ...\npi = 3.14156;\npi_ptr = &pi;\n```", "```cpp\ndouble messyAreaCalculator(double radius, double *pi_ptr) {\n  if (pi_ptr == NULL) {\n    printf(\"Could not calculate area with a reference to pi!\\n\");\n    return 0.0;\n  }\n  return radius * radius * (*pi_ptr);\n}\n```", "```cpp\nSegmentation fault (core dumped)\n```", "```cpp\n#include <stdio.h>\n\nint main() {\n  char title[30] = \"Address Example 3\";\n  int page_counts[5] = { 14, 78, 49, 18, 50 };\n  printf(\"title's value: %s\\n\", title);\n  printf(\"title's address: %p\\n\", &title);\n  printf(\"title's size: %lu\\n\", sizeof(title));\n  printf(\"page_counts' value: {\");\n  for (int p = 0; p < 5; p++) {\n    printf(\" %d\", page_counts[p]);\n  }\n  printf(\" }\\n\");\n  printf(\"page_counts's address: %p\\n\", &page_counts);\n  printf(\"page_counts's size: %lu\\n\", sizeof(page_counts));\n}\n```", "```cpp\ntitle's value: Address Example 3\ntitle's address: 0x7ffe971a5dc0\ntitle's size: 30\npage_counts' value: { 14 78 49 18 50 }\npage_counts's address: 0x7ffe971a5da0\npage_counts's size: 20\n```", "```cpp\n#include <stdio.h>\n\nvoid do_stuff() {\n  int local = 12;\n  printf(\"Our local variable has a value of %d\\n\", local);\n  printf(\"local's address: %p\\n\", &local);\n}\n\nint main() {\n  int count = 1;\n  printf(\"Starting count at %d\\n\", count);\n  printf(\"count's address: %p\\n\", &count);\n  do_stuff();\n}\n```", "```cpp\nch06$ gcc do_stuff.c\nch06$ ./a.out\nStarting count at 1\ncount's address: 0x7fff30f1b644\nOur local variable has a value of 12\nlocal's address: 0x7fff30f1b624\n```", "```cpp\nfloat average(float a, float b) {\n  float sum = a + b;\n  if (sum < 0) {\n    for (int i = 0; i < 5; i++) {\n      printf(\"Warning!\\n\");\n    }\n    printf(\"Negative average. Be careful!\\n\");\n  }\n  return sum / 2;\n}\n```", "```cpp\n#include <stdio.h>\n\nint main() {\n  double total = 500.0;                ![1](Images/1.png)\n  int count = 34;\n  double average = total / count;\n  printf(\"The average of %d units totaling %.1f is %.2f\\n\",\n     count, total, average);\n\n  // Now let's reproduce some of that work with pointers\n  double *total_ptr = &total;          ![2](Images/2.png)\n  int *count_ptr = &count;\n  printf(\"total_ptr is the same as the address of total:\\n\");\n  printf(\" total_ptr %p == %p &total\\n\", total_ptr, &total);\n\n  // We can manipulate the value at the end of a pointer\n  // with the '*' prefix (dereferencing)\n  printf(\"The current total is: %.1f\\n\", *total_ptr);\n  // Let's pretend we forgot two units and correct our count:\n  *count_ptr += 2;                     ![3](Images/3.png)\n  average = *total_ptr / *count_ptr;\n  printf(\"The corrected average of %d units totaling %.1f is %.2f\\n\",\n     count, total, average);           ![4](Images/4.png)\n}\n```", "```cpp\nch06$ gcc pointer.c\nch06$ ./a.out\nThe average of 34 units totaling 500.0 is 14.71\ntotal_ptr is the same as the address of total:\n  total_ptr 0x7ffdfdc079c8 == 0x7ffdfdc079c8 &total\nThe current total is: 500.0\nThe corrected average of 36 units totaling 500.0 is 13.89\n```", "```cpp\n#include <stdio.h>\n\nint main() {\n  char name[] = \"a.c. Programmer\";             ![1](Images/1.png)\n  printf(\"Before manipulation: %s\\n\", name);\n  *name = 'A';                                 ![2](Images/2.png)\n  *(name + 2) = 'C';                           ![3](Images/3.png)\n  printf(\"After manipulation: %s\\n\", name);    ![4](Images/4.png)\n}\n```", "```cpp\nch06$ gcc direct_edit.c\nch06$ ./a.out\nBefore manipulation: a.c. Programmer\nAfter manipulation: A.C. Programmer\n```", "```cpp\nvoid increment_me(int me, int amount) {\n  // increment \"me\" by the \"amount\"\n  me += amount;\n  printf(\"  Inside increment_me: %d\\n\", me);\n}\n\nvoid increment_me_too(int *me, int amount) {\n  // increment the variable pointed to by \"me\" by the \"amount\"\n  *me += amount;\n  printf(\"  Inside increment_me_too: %d\\n\", *me);\n}\n```", "```cpp\nint main() {\n  int count = 1;\n  printf(\"Initial count: %d\\n\", count);\n  increment_me(count, 5);\n  printf(\"Count after increment_me: %d\\n\", count);\n  increment_me_too(&count, 5);\n  printf(\"Count after increment_me_too: %d\\n\", count);\n}\n```", "```cpp\nch06$ gcc increment.c\nch06$ ./a.out\nInitial count: 1\n  Inside increment_me: 6\nCount after increment_me: 1\n  Inside increment_me_too: 6\nCount after increment_me_too: 6\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n\n// ...\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n\nint result_code = 404;\nchar result_msg[20] = \"File Not Found\";\n\nint main() {\n  char temp[20] = \"Loading ...\";\n  int success = 200;\n\n  char *buffer = (char *)malloc(20 * sizeof (char));\n\n  // We won't do anything with these various variables,\n  // but we can print out their addresses\n  printf(\"Address of result_code:   %p\\n\", &result_code);\n  printf(\"Address of result_msg:    %p\\n\", &result_msg);\n  printf(\"Address of temp:          %p\\n\", &temp);\n  printf(\"Address of success:       %p\\n\", &success);\n  printf(\"Address of buffer (heap): %p\\n\", buffer);\n}\n```", "```cpp\nch06$ gcc memory.c\nch06$ ./a.out\nAddress of result_code:   0x55c4f49c8010\nAddress of result_msg:    0x55c4f49c8020\nAddress of temp:          0x7fffc84f1840\nAddress of success:       0x7fffc84f1834\nAddress of buffer (heap): 0x55c4f542e2a0\n```", "```cpp\n  free(buffer);\n```", "```cpp\nstruct transaction {\n  double amount;\n  int day, month, year;\n};\n```", "```cpp\nint main() {\n  int count;\n  char message[] = \"Your money is safe with us!\";\n  struct transaction bill, deposit;\n  // ...\n}\n```", "```cpp\n  struct transaction deposit = { 200.00, 6, 20, 2021 };\n```", "```cpp\n  bill.day = 15;\n  bill.month = 7;\n  bill.year = 2021;\n  bill.amount = 56.75;\n```", "```cpp\n  printf(\"Your deposit of $%0.2f was accepted.\\n\", deposit.amount);\n  printf(\"Your bill is due on %d/%02d\\n\", bill.month, bill.day);\n```", "```cpp\n  deposit.amount = 200.00;\n  bill.amount = 56.75;\n```", "```cpp\n  bill.amount = bill.amount + bill.amount * 0.05;\n\n  printf(\"Our final bill: $%0.2f\\n\", bill.amount); // $59.59\n  printf(\"Our deposit: $%0.2f\\n\", )                // $200.00\n```", "```cpp\nstruct transaction tmp = { 68.91, 8, 1, 2020 };\nstruct transaction *payment;\nstruct transaction *withdrawal;\n\npayment = &tmp;\nwithdrawal = malloc(sizeof(struct transaction));\n\n```", "```cpp\n// With dereferencing:\n(*withdrawal).amount = -20.0;\n\n// With the arrow operator:\nwithdrawal->day = 3;\nwithdrawal->month = 8;\nwithdrawal->year = 2021;\n```", "```cpp\nvoid printTransaction1(struct transaction tx) {\n  printf(\"%2d/%02d/%4d: %10.2f\\n\", tx.month, tx.day, tx.year, tx.amount);\n}\n// ...\nprintTransaction1(bill);\nprintTransaction1(deposit);\n```", "```cpp\nvoid printTransaction2(struct transaction *ptr) {\n  printf(\"%2d/%02d/%4d: %10.2f\\n\",\n      ptr->month, ptr->day, ptr->year, ptr->amount);\n}\n// ...\nprintTransaction2(&tmp);\nprintTransaction2(payment)\nprintTransaction2(withdrawal);\n```", "```cpp\nvoid addTax(struct transaction *ptr, double rate) {\n  double tax = ptr->amount * rate;\n  ptr->amount += tax;\n}\n\n// ... back in main\n  printf(\"Our bill amount before tax: $%.2f\\n\", bill.amount);\n  addTax(&bill, 0.05);\n  printf(\"Our bill amount after tax: $%.2f\\n\", bill.amount);\n// ...\n```", "```cpp\nOur bill amount before tax: $56.75\nOur bill amount after tax: $59.59\n```", "```cpp\n// Include the usual stdio, but also stdlib for access\n// to the malloc() and free() functions, and NULL\n#include <stdio.h>\n#include <stdlib.h>\n\n// We can use the struct keyword to define new, composite types\nstruct transaction {\n  double amount;\n  int month, day, year;\n};\n\n// That new type can be used with function parameters\nvoid printTransaction1(struct transaction tx) {\n  printf(\"%2d/%02d/%4d: %10.2f\\n\", tx.month, tx.day, tx.year, tx.amount);\n}\n\n// We can also use a pointer to that type with parameters\nvoid printTransaction2(struct transaction *ptr) {\n  // Check to make sure our pointer isn't empty\n  if (ptr == NULL) {\n    printf(\"Invalid transaction.\\n\");\n  } else {\n    // Yay! We have a transaction, print out its details with ->\n    printf(\"%2d/%02d/%4d: %10.2f\\n\", ptr->month, ptr->day, ptr->year,\n        ptr->amount);\n  }\n}\n\n// Passing a structure pointer to a function means we can alter\n// the contents of the structure if necessary\nvoid addTax(struct transaction *ptr, double rate) {\n  double tax = ptr->amount * rate;\n  ptr->amount += tax;\n}\n\nint main() {\n  // We can declare local (or global) variables with our new type\n  struct transaction bill;\n\n  // We can assign initial values inside curly braces\n  struct transaction deposit = { 200.00, 6, 20, 2021 };\n\n  // Or we can assign values at any time after with the dot operator\n  bill.amount = 56.75;\n  bill.month = 7;\n  bill.day = 15;\n  bill.year = 2021;\n\n  // We can pass structure variables to functions just like other variables\n  printTransaction1(deposit);\n  printTransaction1(bill);\n\n  // We can also create pointers to structures and use them with malloc()\n  struct transaction tmp = { 68.91, 8, 1, 2020 };\n  struct transaction *payment = NULL;\n  struct transaction *withdrawal;\n  payment = &tmp;\n  withdrawal = malloc(sizeof(struct transaction));\n\n  // With a pointer, we either have to carefully dereference it\n  (*withdrawal).amount = -20.0;\n  // Or use the arrow operator\n  withdrawal->day = 3;\n  withdrawal->month = 8;\n  withdrawal->year = 2021;\n\n  // And we are free to pass structure pointers to functions\n  printTransaction2(payment);\n  printTransaction2(withdrawal);\n\n  // Add tax to our bill using a function and a pointer\n  printf(\"Our bill amount before tax: $%.2f\\n\", bill.amount);\n  addTax(&bill, 0.05);\n  printf(\"Our bill amount after tax: $%.2f\\n\", bill.amount);\n\n  // Before we go, release the memory we allocated to withdrawal:\n  free(withdrawal);\n}\n```"]