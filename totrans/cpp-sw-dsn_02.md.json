["```cpp\nclass Rectangle\n{\n public:\n   // ...\n   virtual ~Rectangle() = default;  ![1](assets/1.png)\n\n   int getWidth() const;  ![3](assets/3.png)\n   int getHeight() const;\n\n   virtual void setWidth(int);  ![4](assets/4.png)\n   virtual void setHeight(int);\n\n   virtual int getArea() const;  ![5](assets/5.png)\n   // ... \n private:\n   int width;  ![2](assets/2.png)\n   int height;\n};\n\n```", "```cpp\nclass Square : public Rectangle  ![6](assets/6.png)\n{\n public:\n   // ...\n   void setWidth(int) override;  ![7](assets/7.png)\n   void setHeight(int) override;  ![8](assets/8.png)\n\n   int getArea() const override;  ![9](assets/9.png)\n   // ... };\n\n```", "```cpp\nvoid transform( Rectangle& rectangle )  ![10](assets/10.png)\n{\n   rectangle.setWidth ( 7 );  ![11](assets/11.png)\n   rectangle.setHeight( 4 );  ![12](assets/12.png)\n\n   assert( rectangle.getArea() == 28 );  ![13](assets/13.png)\n\n   // ... }\n\n```", "```cpp\nint main()\n{\n   Square s{};  ![14](assets/14.png)\n   s.setWidth( 6 );\n\n   transform( s );  ![15](assets/15.png)\n\n   return EXIT_SUCCESS;\n}\n\n```", "```cpp\nstruct X\n{\n   virtual ~X() = default;\n\n   // Precondition: the function accepts all 'i' greater than 0\n   virtual void f( int i ) const\n   {\n      assert( i > 0 );\n      // ...\n   }\n};\n\nstruct Y : public X\n{\n   // Precondition: the function accepts all 'i' greater than 10.\n   // This would strengthen the precondition; numbers between 1 and 10\n   // would no longer be allowed. This is a LSP violation!\n   void f( int i ) const override\n   {\n      assert( i > 10 );\n      // ...\n   }\n};\n```", "```cpp\nstruct X\n{\n   virtual ~X() = default;\n\n   // Postcondition: the function will only return values larger than 0\n   virtual int f() const\n   {\n      int i;\n      // ...\n      assert( i > 0 );\n      return i;\n   }\n};\n\nstruct Y : public X\n{\n   // Postcondition: the function may return any value.\n   // This would weaken the postcondition; negative numbers and 0 would\n   // be allowed. This is a LSP violation!\n   int f( int i ) const override\n   {\n      int i;\n      // ...\n      return i;\n   }\n};\n```", "```cpp\nstruct Base { /*...some virtual functions, including destructor...*/ };\nstruct Derived : public Base { /*...*/ };\n\nstruct X\n{\n   virtual ~X() = default;\n   virtual Base* f();\n};\n\nstruct Y : public X\n{\n   Derived* f() override;  // Covariant return type\n};\n```", "```cpp\nstruct Base { /*...some virtual functions, including destructor...*/ };\nstruct Derived : public Base { /*...*/ };\n\nstruct X\n{\n   virtual ~X() = default;\n   virtual void f( Derived* );\n};\n\nstruct Y : public X\n{\n   void f( Base* ) override;  // Contravariant function parameter; Not\n                              // supported in C++. Therefore the function\n                              // does not override, but fails to compile.\n};\n```", "```cpp\nstruct X\n{\n   explicit X( int v = 1 )\n      : value_(v)\n   {\n      if( v < 1 || v > 10 ) throw std::invalid_argument( /*...*/ );\n   }\n\n   virtual ~X() = default;\n\n   int get() const { return value_; }\n\n protected:\n   int value_;  // Invariant: must be within the range [1..10]\n};\n\nstruct Y : public X\n{\n public:\n   Y()\n      : X()\n   {\n      value_ = 11;  // Broken invariant: After the constructor, 'value_'\n                    // is out of expected range. One good reason to\n                    // properly encapsulate invariants and to follow\n                    // Core Guideline C.133: Avoid protected data.\n   }\n};\n```", "```cpp\nclass Base { /*...*/ };\nclass Derived : public Base { /*...*/ };\nclass Special : public Base { /*...*/ };\n// ... Potentially more derived classes\n\nvoid f( Base const& b )\n{\n   if( dynamic_cast<Special const*>(&b) )\n   {\n      // ... do something \"special,\" knowing that 'Special' behaves differently\n   }\n   else\n   {\n      // ... do the expected thing\n   }\n}\n```", "```cpp\n//==== Code Snippet 1 ====\n\nclass Document\n{\n public:\n   // ...\n   virtual ~Document() = default;\n\n   virtual void exportToJSON( /*...*/ ) const = 0;\n   virtual void serialize( ByteStream&, /*...*/ ) const = 0;\n   // ...\n};\n\nvoid useDocument( Document const& doc )\n{\n   // ...\n   doc.exportToJSON( /*...*/ );\n   // ...\n}\n\n//==== Code Snippet 2 ====\n\ntemplate< typename T >\nconcept Document =\n   requires( T t, ByteStream b ) {\n      t.exportToJSON( /*...*/ );\n      t.serialize( b, /*...*/ );\n   };\n\ntemplate< Document T >\nvoid useDocument( T const& doc )\n{\n   // ...\n   doc.exportToJSON( /*...*/ );\n   // ...\n}\n```", "```cpp\ntemplate< typename InputIt, typename OutputIt >\nconstexpr OutputIt copy( InputIt first, InputIt last, OutputIt d_first )\n{\n   while( first != last ) {\n      *d_first++ = *first++;\n   }\n   return d_first;\n}\n```", "```cpp\ntemplate< typename I >\nconcept input_or_output_iterator =\n  /* ... */;\n\ntemplate< typename I >\nconcept input_iterator =\n   std::input_or_output_iterator<I> &&\n   /* ... */;\n\ntemplate< typename I >\nconcept forward_iterator =\n   std::input_iterator<I> &&\n   /* ... */;\n```", "```cpp\ntemplate< typename Range >\nvoid traverseRange( Range const& range )\n{\n   for( auto pos=range.begin(); pos!=range.end(); ++pos ) {\n      // ...\n   }\n}\n```", "```cpp\n#include <cstdlib>\n\nint main()\n{\n   int array[6] = { 4, 8, 15, 16, 23, 42 };\n\n   traverseRange( array );  // Compilation error!\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\ntemplate< typename Range >\nvoid traverseRange( Range const& range )\n{\n   using std::begin;  // using declarations for the purpose of calling\n   using std::end;    //   'begin()' and 'end()' unqualified to enable ADL\n\n   for( auto pos=begin(range); pos!=end(range); ++pos ) {\n      // ...\n   }\n}\n```", "```cpp\n//---- <Widget.h> ----------------\n\nstruct Widget\n{\n   int i;\n   int j;\n};\n\nvoid swap( Widget& w1, Widget& w2 )\n{\n   using std::swap;\n   swap( w1.i, w2.i );\n}\n```", "```cpp\n#include <Widget.h>\n#include <cstdlib>\n\nint main()\n{\n   Widget w1{ 1, 11 };\n   Widget w2{ 2, 22 };\n\n   swap( w1, w2 );\n\n   // Widget w1 contains (2,11)\n   // Widget w2 contains (1,22)\n\n   return EXIT_SUCCESS;\n}\n```", "```cpp\n//---- <thirdparty/Plugin.h> ----------------\n\nclass Plugin { /*...*/ };  // Defines the requirements for plugins\n\n//---- <thirdparty/VimModePlugin.h> ----------------\n\n#include <thirdparty/Plugin.h>\n\nclass VimModePlugin : public Plugin { /*...*/ };\n\n//---- <yourcode/Editor.h> ----------------\n\n#include <thirdparty/Plugin.h> // Wrong direction of dependencies!\n\nclass Editor { /*...*/ };\n```", "```cpp\n//---- <yourcode/Plugin.h> ----------------\n\nclass Plugin { /*...*/ };  // Defines the requirements for plugins\n\n//---- <yourcode/Editor.h> ----------------\n\n#include <yourcode/Plugin.h>\n\nclass Editor { /*...*/ };\n\n//---- <thirdparty/VimModePlugin.h> ----------------\n\n#include <yourcode/Plugin.h> // Correct direction of dependencies\n\nclass VimModePlugin : public Plugin { /*...*/ };\n```", "```cpp\ntemplate< typename InputIt, typename OutputIt, typename UnaryPredicate >\nOutputIt copy_if( InputIt first, InputIt last, OutputIt d_first,\n                  UnaryPredicate pred );\n```", "```cpp\n//---- <Widget.h> ----------------\n\n#include <utility>\n\ntemplate< typename T >\nstruct Widget\n{\n   T value;\n};\n\ntemplate< typename T >\nvoid swap( Widget<T>& lhs, Widget<T>& rhs )\n{\n   using std::swap;\n   swap( lhs.value, rhs.value );\n}\n```", "```cpp\n#include <Widget.h>\n#include <assert>\n#include <cstdlib>\n#include <string>\n\nint main()\n{\n   Widget<std::string> w1{ \"Hello\" };\n   Widget<std::string> w2{ \"World\" };\n\n   swap( w1, w2 );\n\n   assert( w1.value == \"World\" );\n   assert( w2.value == \"Hello\" );\n\n   return EXIT_SUCCESS;\n}\n```"]