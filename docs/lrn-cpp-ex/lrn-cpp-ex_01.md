# 1 再次欢迎，C++

本章涵盖

+   为什么 C++ 仍然相关

+   C++ 何时有用

+   在阅读本书之前你需要知道什么

+   这本书将如何帮助你启动 C++ 知识

+   你将在本书中学到什么

C++ 是一种古老但不断发展的语言。在编程中，你可以用它来做几乎所有的事情，你会在许多地方找到它的应用。实际上，C++ 的发明者 Bjarne Stroustrup 将其描述为“一切的无形基础”。有时，C++ 可能深深地存在于另一种语言的库中，因为它可以用于性能关键路径。此外，它可以在小型嵌入式系统中运行，或者为视频游戏供电。甚至你的浏览器可能也在使用这种语言。C++ 几乎无处不在。

这种语言是编译的，针对特定的架构，如 PC、大型机、嵌入式设备、定制硬件，或任何你能想到的东西。如果你需要你的代码在不同的机器上运行，你需要重新编译它。这既有优点也有缺点。不同的配置给你带来更多的维护工作，但针对特定架构的编译可以使你深入到底层，从而获得速度优势。无论你针对哪个平台，你都需要一个编译器。你还需要一个编辑器或集成开发环境（IDE）来编写 C++ 代码。

C++ 源于 C，它具有类似的优点但是一种更低级的语言。如果你认识到 `++` 是增量运算符，你就会意识到语言的名称本身暗示它是 C 的继承者。你可以通过编写高级代码来避免 C++ 中指针和内存分配的深度，你同样可以在 C++ 代码中下降到 C 或甚至汇编语言。尽管 C++ 从未打算接管世界或甚至取代 C，但它确实提供了许多新的编程方法。例如，你可以在编译时做许多令人惊讶的事情，使用类型安全特性而不是 C 中常用的预处理器宏。

这种语言支撑着各种技术，包括其他语言的编译器或解释器，甚至 C++ 编译器本身。你可以为其他语言开发库，编写游戏，定价金融工具，以及做更多的事情。如果你曾在提示符中输入过 `make`，你很可能在不自知的情况下使用了 C++。如果你以数字形式阅读这本书，C++ 可能正在为你的浏览器或电子阅读器供电，或者它可能被用来编写你机器的设备驱动程序。

这本书将为你打下 C++语言和库特性的坚实基础。每一章都通过一个小型、自包含的项目进行讲解，专注于一个领域。除了每一章的主要特性外，还会涵盖语言的其他部分。例如，如果你填充了一个容器，比如向量或数组，你可能还希望有一种方式来显示和操作其内容。因此，下一章将专注于向量，同时也介绍了范围和 lambda 表达式，以及使用`format`来显示输出。通过逐渐积累你的知识库，你将获得信心，这将使你能够重新发现 C++的乐趣。本书将重点关注几个基本部分，展示语言现在比过去更容易的各种方式。你将获得坚实的基础，准备好使用和学习更多的 C++。

## 1.1 为什么 C++很重要？

C++是由一个委员会设计的。有些语言是由公司或个人引入和开发的。C++不是。最初由 Bjarne Stroustrup 发明，国际标准化组织（ISO）的工作组 21（WG21）现在负责其新版本。你可以在[`isocpp.org/std`](https://isocpp.org/std)找到更多详细信息。自 2011 年以来，每三年就会有一个新的标准被批准，每次都会添加新特性，有时还会简化做事的方式。这意味着有很多东西要学习。一些文档和描述听起来就像是用法律术语写的，可能会让人感到压倒。本书将使用一些精确的定义来帮助你理解这些解释。委员会成员提出建议，撰写论文来解释他们的想法，并展示如何实现新特性或小的改进，这导致了影响其他编程语言的创新。例如，如果没有 C++引入模板，Java 和 C#可能就不会有泛型。思想是双向流动的。C++也吸收了其他语言的想法，包括函数式编程习惯，如 lambda 表达式。

这些最近的标准为 C++注入了新的活力，引起了极大的兴奋。那些多年来一直在使用 C++的公司可能之前依赖于内部库来支持现在已成为核心语言特性的功能。升级到较新标准可能是一项艰巨的工作，但这意味着更多的人将能够在不花费时间熟悉特定实现的情况下参与代码库的开发。除了企业技术栈的变化之外，现在还有几个专注于 C++的会议，以及播客和博客，因为新一代的人开始参与其中。C++以其非常核心而闻名，极客们争论着困难的问题，对新手（以及彼此）都很刻薄。这部分是不公平的，但 IncludeCpp 小组([`www.includecpp.org/`](https://www.includecpp.org/))试图包容和欢迎。他们有一个 Discord 群组，并在 C++会议上设有摊位，所以如果你一个人去，可以直接去找他们打招呼。最近的变化使得 C++的几个部分更容易解释和使用，但同时也引入了更多的边缘情况和复杂性。这本书将倾向于坚持那些使你的生活更轻松的常用特性，但了解一些新特性是有价值的，尽管这些特性支持度不高。

如果你是在 C++11 之前了解 C++的，你可能会被这些变化吓到。实际上，如果你花时间追赶并眨眼，你仍然错过了很多东西。不必担心。尽管 C++可能类似于骑自行车（如果你摔倒了会受伤），但 C++不必痛苦。这本书将阻止你掉进兔子洞。你可以享受乐趣，并学习许多方法和范式，从面向对象编程到函数式方法。C++的基础知识也会使其他语言和方法更容易理解。此外，C++如此普遍，它永远不会消失，所以了解一点是有用的。你永远不可能知道所有内容。甚至 Bjarne 本人据称也说过，他在 C++知识方面的评分是七分。所以不必担心。要成为一名优秀的程序员，你不必知道语言的每一个细节。在了解足够的基础上学习更多是很重要的。如果你现在就建立你的理解，你也会发现跟上进度更容易。

C++ 随着时间的推移而发展壮大。最初，C++ 是在 C 的基础上增加了类，引入了关键字 `new`（以及 `delete` 和 `class`）以及构造函数和析构函数的概念。这些函数在对象创建时以及对象超出作用域或被删除时自动运行。与垃圾回收语言（如 C# 和 Java）不同，你控制着对象的整个生命周期。垃圾回收语言的拥护者有时会贬低 C++，声称它很容易导致内存泄漏。现在，你不需要使用 `new` 和 `delete`，C++ 有智能指针来帮助进行内存管理。该语言随着时间的推移而发展，增加了各种新特性。尽管它从开始到现在已经有所增长，但它仍然相对紧凑。就像所有其他语言一样，它取决于你如何使用它。你可以在任何语言中编写糟糕的代码。你同样也可以在任何语言中编写优美的代码，但你需要学会如何做。通过在阅读这本书的过程中尝试代码，你将最终得到一些可以玩耍的小程序。它们将涵盖语言的各个方面，为你打下坚实的基础。你将看到 C++ 可以有多么出色。

尽管有许多 C++ 的竞争对手，但 C++ 仍然具有持久力。它始终位居 TIOBE 指数（https://www.tiobe.com/tiobe-index/#2022）的榜首，并在 2022 年排名前三。你可以使用 C，但你将看到星星（指针用 `*` 字符表示）。如果你想使用比数组更复杂的数据结构，你必须自己实现。你可以使用高性能 Fortran 进行极快的计算。英国气象办公室使用 Fortran 进行他们的天气预报，因为他们需要在非常短的时间内处理大量数据。Fortran 还在许多学术机构中存在，所以如果你是学者或学生，你可能见过或使用过它。然而，它是一个相对较小的领域。你在更广阔的世界中更有可能遇到一些 C++ 代码。

已经发明了各种新的语言，旨在处理 C++ 的缺陷或烦恼。D 语言由于类似 C 的语法和高层结构，感觉与 C++ 类似，它是为了处理创作者不喜欢的 C++ 方面而发明的。同时，C++ 仍在不断发展，但它始终旨在保持向后兼容性，因此受到历史决策的限制。新语言没有遗留问题，因此有更多的自由。Go、Objective C、Swift、Rust 以及最近出现的 Carbon 在某些领域也挑战了 C++。这很好，学习几种语言并思考什么可能使程序员的职业生涯更轻松是件好事。很多时候，最新 C++ 标准中引入的新想法都是基于其他语言的洞察。随着新语言的引入，C++ 仍然非常流行，并且经常接受它们提出的任何挑战。C++ 在不久的将来不会消失。如果你愿意，你也可以参与其中，提交错误报告或建议。委员会由志愿者组成，他们努力改进该语言。ISOCpp 提供了如何参与的详细信息 ([`isocpp.org/std/meetings-and-participation`](https://isocpp.org/std/meetings-and-participation))。

如果你学习了 C++，你将为其他语言打下坚实的基础。与其他语言的相似性可以帮助你快速掌握如何使用它们。你将熟悉一些数据结构和算法，以及从函数式编程到面向对象代码的各种范式。即使你最终没有加入标准委员会或发明自己的编程语言，你也将处于继续终身学习之旅并理解底层发生的事情的有利位置。

## 1.2 你应该在什么时候使用 C++？

你可以用 C++ 做任何事情，但有些用例比其他用例更有意义。为了原型设计一些机器学习或运行统计计算，可能最快的方法是从 Python 开始，并使用现有的库。当然，这些库可能包含一些 C++ 代码。如果你足够自信，可以查看库的源代码来找出为什么出现错误，你将比其他程序员有先发优势。如果有人需要一个具有前端（无论是网站还是具有图形用户界面 (GUI) 的本地程序），你可以用 C++ 构建整个系统，但可能更容易将其拆分。与 C# 等语言不同，C++ 核心语言不支持 GUI，因此前端将需要一个外部库，例如跨平台的 C++ 库 Qt ([`www.qt.io/`](https://www.qt.io/))。你也可以用完全不同的东西编写前端，并将 C++ 代码作为服务或库调用。所以，考虑到你可能从另一种语言开始尝试一个想法，或在另一个工具链中构建应用程序的一部分，你什么时候应该使用 C++？

如果你想要一款第一人称射击风格的电子游戏，你可以尝试用 JavaScript 编写，但使用编译到硬件的语言更合理。解释型语言会比编译型语言慢。因此，C++经常被用来编写游戏引擎、渲染图形、处理物理、检测碰撞，并为机器人提供声音和人工智能。脚本语言可能会调用这个引擎，但引擎的强大和速度通常来自 C++，从高端显卡或其他昂贵的游戏设备中榨取每一寸性能。这也使 C++适合高性能计算（HPC）、金融应用、嵌入式设备和机器人技术。

因为 C++让你接近底层硬件，你可以破坏东西。如果你不小心，可能会 brick 一个嵌入式设备，使机器无法使用。如果你编写一个在笔记本电脑或计算机上运行的程序，你不太可能做到这一点。它可能会崩溃，自豪地宣布在退出时出现段错误或类似错误。没有操作系统的嵌入式设备是不同的。如果它只运行一个程序而没有操作系统，并且出了问题，可能会发生糟糕的事情。这也是可以接受的。Bjarne Stroustrup 曾经说，“如果你从未失败，那么你努力的程度还不够”([`www.stroustrup.com/quotes.html`](https://www.stroustrup.com/quotes.html))。尽管这种语言允许你使用原始指针，并可能超出内存边界或调用未定义的行为，但本书将引导你远离危险。只需记住，人们常说，权力越大，责任越大。有了足够坚实的基础，你可以负责任地编程，学到很多东西，并享受乐趣。

尽管 C++原生不支持几件事情，例如单元测试、GUI 编码，甚至网络（几乎进入 C++23，可能在未来标准中实现），但你可以使用合适的第三方库来做这些事情。核心 C++语言提供的是一个大而周到的标准库。如果你使用 C，并需要一个正态分布的随机数，你需要翻阅一本数学书或阅读 Donald Knuth 关于这个问题的看法。如果你需要一个查找表，你可以使用 C++的标准 map。在 C 中，你必须自己编写。事实上，你从 C++中得到堆栈、队列、堆，以及几乎所有你能想到的数据结构，还有大量的算法。这意味着学习 C++为理解其他语言提供了坚实的基础。

如果你需要快速进行大量数值计算，C++ 是一个很好的选择。现代语言版本也支持各种随机数分布，正如你将在本书中看到的那样，这使得设置各种复杂的模拟相对容易。即使不使用语言中最新和最优秀的部分，你也能用 C++ 构建一些严肃的应用程序。例如，英国帝国理工学院附属的 MRC 中心全球传染病分析中心开源了他们的 COVID-19 模拟模型 ([`github.com/mrc-ide/covid-sim`](https://github.com/mrc-ide/covid-sim))。这些模型在英国疫情期间被用于决定公共政策。C++ 承担了繁重的工作，并提供了一些用 R 编写的脚本以显示结果。

C++ 通常被描述为一种多范式语言。它支持面向对象编程，但你也允许编写自由函数。如果你想写低级过程式代码，你也可以使用泛型（即模板）和函数式编程风格。你甚至可以进行模板元编程（TMP），让编译器为你进行计算。这其实是一个意外发现，由 Erwin Unruh 在 1994 年的一次 C++ 委员会会议上提出。他展示了一个无法编译但会打印出编译器错误信息中的素数的程序。玩转 TMP 可以很有趣，探索并推向极致，但简单的案例可以提供更快的运行时间，以及类型安全的、编译器评估的常量。如果你学会了如何使用一些 C++，你将为许多其他语言打下稳定的基石，并了解各种不同的编程范式。

## 1.3 为什么阅读这本书？

随着语言的发展，人们为每个新的标准和更通用的风格指南编写书籍。如果你不了解新特性，风格指南将毫无意义，而新特性建立在之前的变化之上，所以全部细节可能会让人感到压倒性。面对不断变化的目标，你从哪里开始？从你所在的地方开始。你需要一种方法来自我启动学习。这本书将通过一些小型项目带你了解一些核心变化，这样你就有东西可以实验。通过使用一些新特性，你将更好地识别现代 C++ 代码正在做什么，并知道在哪里关注进一步的变更和发展。

与其阅读可能错过的所有更改列表，ISOCpp 网站有一个常见问题解答部分 ([`isocpp.org/wiki/faq`](https://isocpp.org/wiki/faq))，它概述了一些最近的更改和宏观问题。该网站由标准 C++ 基金会运营，这是一个非营利组织，其目的是支持 C++ 软件开发社区并推广对现代标准 C++ 的理解和应用。该网站甚至有一个针对有其他语言背景且想学习 C++ 的人的板块。它没有针对“如果你之前已经知道 C++ 有一段时间了，如何学习 C++”的板块。这本书填补了这一空白。你不需要一个包含多年来引入的所有功能的冗长列表。你需要的是足够的，以恢复你的信心。

你可以关注网上众多优秀的资源，以保持对语言中已经发生和正在发生的变化的了解。ISOCpp 将帮助你做到这一点。然而，你需要停下来尝试一些事情来学习。花时间进行实验将会有回报，这本书将引导你通过一些有用的实验。以小块的形式尝试功能将帮助你使思想和概念具体化。你将不时看到替代方法。通过看到将项目放入 `vector` 的两种方式，你将学习一个新特性（`emplace` 方法）并回忆起一个旧特性（`push_back`）。这将帮助你阅读他人的代码，不会被不熟悉的方法所困惑。你将学习如何考虑替代方案，意识到来自不同地方的建议，有时这些建议是相互冲突的。这本书将采取实用主义的方法，同时鼓励你考虑替代方案。

## 1.4 这本书是如何教授 C++ 的？

本书涵盖了从 C++11 开始引入的 C++ 特性的子集。在撰写本书时，C++23 正处于特性冻结阶段，使其准备好推出新的标准。每一章都专注于一个主要特性，尽管它也介绍了并使用了其他现代特性和惯用法。有些人以前对 C++ 很熟悉，但被需要学习的新事物数量所吓倒，而初学者往往很快就会感到害怕。这不必如此困难。现在跟上进度将使跟踪 C++ 继续变化和发展的过程变得更加容易。如果你已经有一段时间没有使用 C++，并且看到其他书籍列出了所有新的特性和惯用法，但你不知道从哪里开始或如何使用它们，这本书将帮助你专注于一些重要的部分，使你能够在其他地方深入探讨复杂边缘情况和详细解释。

这本书专注于使用 C++ 的各个部分进行独立项目。你将在旅途中尝试一些想法，并学习语言特性，而不是通过一行行的示例来逐个分析语言的语法和标准库。如果你已经生疏了，这本书将给你一个练习和重新发现使用 C++ 欢乐的机会。正如你可能意识到的，编写一个完整的程序比玩弄一两行代码能提供更多的实践机会。因此，这本书将帮助你自学。

### 1.4.1 这本书面向的对象

这本书的目标读者是那些曾经使用过一些，甚至很多，这种语言但失去了对最近变化跟踪的人。如果你认识这种语法并想尝试学习更多，你将从这本书中获得一些收获。如果你知道 `int x = 5;` `int &y = x;` 的作用，之前使用过 `std::vector<int>`，并认识 `std::cout << x`，你将能够理解。如果你之前见过 `int x{1};`，你已经走了一半的路。如果没有，不要慌张。花括号是初始化几乎所有内容的新方法，你很快就会习惯的。如果你以前知道所有复杂的边缘情况，并能引用之前标准的章节和段落，这本书将帮助你专注于一些新特性，让你重新回到驾驶座。一旦你读完这本书，你将知道如何获取最新的编译器以及如何关注即将到来的变化，你将能够阅读和编写现代 C++。现在让我们看看一些代码，以了解一些编写语言的新方法。

### 1.4.2 再次，C++！

通常，人们会从“Hello, World!”程序开始学习一门语言，所以我们就这样做。以下代码会在屏幕上打印一条问候信息。

列表 1.1 Hello, World

```
#include <iostream>                    ❶

auto main() -> int {                   ❷
    std::cout << "Hello, world!\n";    ❸
}
```

❶ 包含一个头文件

❷ 后置返回类型

❸ 运算符 :: 和 <<

如果你将这个程序保存为名为 `hello_world.cpp` 的文件，你可以编译它。例如，使用 GNU 编译器集合（gcc；见 [`gcc.gnu.org/`](https://gcc.gnu.org/)），使用支持 C++11 的 g++：

```
g++ hello_world.cpp -o ./hello.out
```

本书假设你认识 `include` 语句、作用域解析 `operator::` 和流插入 `operator` `<<`。代码在 `main` 函数中向标准（std）`cout` 插入问候语，这是可执行代码的常规入口点。然而，你可能不熟悉函数名称末尾的 *尾随返回类型* `->`，以及行首的关键字 *auto*。你可以在这里写 `int main()`，就像你以前一直做的那样，但自从 C++11 引入这个特性后，许多人开始为了保持一致性而到处使用它。当你想要推断函数返回的类型时，这很有用。我们的 hello 程序不需要尾随返回。此外，`main` 函数是特殊的，因为它默认返回 0，所以即使它返回 `int` 类型，也不需要返回语句。没有尾随返回类型，一些模板函数可能很难指定。让我们考虑一个使用模板函数的例子。

你可以使用 + 运算符轻松地添加数字。例如，`auto x = 1 + 1.23.`。我们的朋友 `auto` 又出现了。我们试图将一个整数（1）和一个双精度浮点数（1.23）相加，所以结果是双精度浮点数，这是由于 *整数* *提升*。如果你想有一个通用加法函数，你可以尝试为每一对可能的参数编写重载，或者更合理地，编写一个模板函数。甚至更好，你可以使用已经为你编写好的一个。`functional` 头文件包含 `plus` 的定义。事实上，这个头文件包含两个定义，其中一个将两个相同类型的参数相加，我们通过说 `std::plus<int>` 来添加两个整数。自 C++14 以来，引入了一个可以推断模板参数类型的版本。使用 `std::plus<>` 选择新的特化，它会为我们计算出类型。如果你尝试第一个版本，1.23 会被转换为 `int`，所以你会得到 1 + 1，这可能会让一些编译器发出警告，而第二个版本将 `int` 1 和 `double` 1.23 相加得到 2.23。试试看！

列表 1.2 添加两个数字

```
#include <iostream>
#include <functional>

auto main() -> int {
    std::cout << std::plus<int>{}(1, 1.23) << '\n';     ❶
    std::cout << std::plus<>{}(1, 1.23) << '\n';        ❷
}
```

❶ 强制两个整数的和，因此返回 2

❷ 确定不同的类型

你习惯于函数以返回类型开头，然后是名称和参数，例如 `int main()`。返回类型是首先给出的。为了指定返回类型，`plus` 需要表达两个函数参数的加法操作。这使用参数名称来做要容易得多，但那些名称对于通常的返回类型是不可见的。尾随返回类型使得使用参数名称来指定返回类型成为可能。你需要在开头说 `auto`，并在尾随 `->` 后面指出返回的类型。

让我们看看 `plus<>` 特化版本的 `operator()` 的简化版本。记住，我们想要声明一个函数，它接受两个参数并返回它们的和。我们将使用一个模板，包含两个类型名，允许相加两种不同的类型。加法本身是简单的部分，只需简单地使用 `+` 操作符。声明从 `auto` 开始，以类型结束。

列表 1.3 添加两种不同类型的功能

```
template<typename T, typename U>
auto simple_plus(T lhs, U rhs) -> decltype(lhs + rhs)
{
    return lhs + rhs;
}
```

操作符函数是一个模板，使用两种不同的类型 `T` 和 `U` 分别表示二元运算的左侧 (`lhs`) 和右侧 (`rhs`)。返回类型使用 `decltype` 指示符和表达式 `lhs + rhs` 声明。如果你眯起眼睛看，你会发现这与我们之前看到的 `main` 函数的语法相似。将它们并排放置，看看：

```
auto main() -> int
auto simple_plus(T& lhs, U& rhs ) -> decltype(lhs + rhs)
```

你可以看到在两种情况下都跟随 `auto`、函数名和参数，然后是箭头和尾随返回类型。当我们添加 1 和 1.23 时，参数类型被推断为整数和双精度浮点数。尾随返回类型使用表达式 (1 + 1.23) 来获取双精度浮点数的返回类型。

如果你已经认识这些新特性，那太好了。还有很多新事物要学习。如果你以前从未见过这些，请专注于这里的主要观点，这是你在尝试“Hello, World!”时看到的：尾随返回类型。你已经学到了一些东西。

### 1.4.3 从阅读本书中你将学到什么

你将学习如何使用语言的一些新元素，从范围到随机数，并在旅途中学习几种其他更简单的方法来做事情。这本书从向量开始，并在此基础上构建。向量是一个很好的复习和学习新特性的方法，包括范围、视图、函数式对象和 lambda 表达式。一旦你熟悉了使用范围和算法填充、显示、查询和操作向量，你就可以准备使用标准库的其他部分，包括时间（`chrono`）、随机数，最后是协程。

C++11 中引入的基于范围的 `for` 循环使语言变得更简单。你可以使用它们遍历容器，而无需首先深入迭代器。随着时间的推移，完整的范围也已成为标准，提供了便利，避免了直接使用迭代器，同时提供了更统一的查找和额外的安全性。以前，可以将一个容器的开始传递给算法，并将另一个容器的结束传递给算法，而不会意识到这个问题，直到运行时发生可怕的事情。范围避免了这个问题。你将熟悉使用范围来查看和复制容器的内容。

通过使用构造函数和操作符的 `default` 关键字，你会发现为什么在类中不需要那么多样板代码。你将学习如何使用新的随机数分布。如果你习惯于调用 C 的 `rand` 函数，新的方法一开始可能看起来很复杂，但它很强大，并且当正确使用时，可以帮助你避免人们常犯的错误，例如在模拟掷骰子或洗牌时。

通过在每个章节中使用自包含的项目，你将有机会使用各种新功能和旧功能。你将达到理解新功能的地步，知道何时以及如何以惯用的方式使用它们。有时关于做事的最佳方式有不同的观点。你早些时候看到了尾随返回类型：`auto` `main()` `->` `int`。有些人非常喜欢它并在任何地方使用它，但有些人则不喜欢。语言的演变使我们超越了争论括号放置（如果你不喜欢我的方法，请提前原谅）并给了我们更多可以争论的东西。这本书将提供替代方案，在讨论此类问题时坚定地站在中间，这样你就可以专注于尝试编写一些代码并尝试用新的方式表达自己。

## 1.5 一些专业技巧

在学习过程中可能会感到迷茫或不知所措，尤其是当你试图处理一个大主题时。如果你记住以下几点，你将能够找到自己的路。

首先，许多新特性都是 *语法糖*，其次，许多代码元素使用标点符号，这很难查找。如果你想知道之前给出的主函数中 `->` 符号的作用，你会从哪里开始？一个非常有用的工具是 Andreas Fertig 的 C++ Insights ([`cppinsights.io/`](https://cppinsights.io/)) 网站。C++ Insights 将代码转换为显示一些较新 C++ 功能背后的细节。它基于 Clang ([`clang.llvm.org/`](https://clang.llvm.org/)) 和 Andreas 对 C++ 的理解 ([`cppinsights.io/about.html`](https://cppinsights.io/about.html))。如果你输入我们在列表 1.2 中查看的 `plus` 代码，C++ Insights 将为你转换代码。

列表 1.4 C++ Insights 输出

```
#include <iostream>
#include <functional>

int main()                     ❶
{
  std::operator<<
    (
        std::cout.operator<<
        (
        std::plus<int>{{}}.operator()(1, static_cast<const int>(1.23))
        ),
        '\n'
    );                         ❷
  std::operator<<
    (
        std::cout.operator<<
        (
        std::plus<void>{}.operator()(1, 1.23)
        ),
        '\n'
    );                         ❸
  return 0;                    ❹
}
```

❶ 追加返回值已被重写。

❷ 明确写出 << 和 () 是操作符，并将 1.23 转换为 int 类型。

❸ 明确写出 << 和 () 是操作符。

❹ 我们没有明确返回 0，但它对我们来说发生了。

直接尝试一下 ([`cppinsights.io/s/508b2063`](https://cppinsights.io/s/508b2063))。洞察力可能会显示很多细节，生成的代码基于 Clang，所以它可能不总是适用于其他编译器，但列表 1.4 显示了转换后的尾随返回符号 `->`，以及使用的 `std::plus<int>` 和 `std::plus<void>` 结构。如果你不能理解你遇到的一个函数，尝试使用 C++ Insights 获取线索。

需要记住的是，并非所有编译器都支持所有新特性，因此你可能需要多个编译器。至少，你可能需要在 Visual Studio 中使用`/std:c++latest`选项或在 g++中使用`--std=c++20`。如果你不想设置另一个工具，你总是可以通过 Matt Godbolt 的编译器探索器([`godbolt.org/`](https://godbolt.org/))在线尝试各种编译器中的 C++代码。它支持大量的不同编译器，让你可以看到每个编译器的行为。这本书会尽量遵循常见的部分，但如果你想要探索更多，这是一个很好的资源，与 C++ Insights 一起使用。每个资源都有一个链接到另一个资源，所以为什么不两者都使用呢？在花费时间设置工具链之前，CppReference 有一个列表，列出了每个新特性的编译器支持([`en.cppreference.com/w/cpp/compiler_support`](https://en.cppreference.com/w/cpp/compiler_support))，以帮助你决定你需要哪个版本。这是检查函数签名或简单地找到你需要包含以使用某个特性的标准头文件的一个很好的资源。

最后，如果你遇到了困难，不要慌张。编译器可能会因为你在某个模板代码中忘记分号而给出几个错误。不过，较新的编译器可能会指出实际的问题，而不是给出需要翻阅的页面错误。大多数现代编译器确实会尝试提供一些帮助，所以如果你之前遇到过困难并放弃了，现在可能会更容易一些。然而，你有时还是会遇到难以理解的错误。如果你无法解决它们，可以寻求帮助，或者尝试从第一个错误开始。如果这也不行，尝试从最后一个错误开始，或者至少找到一个指向你的代码的错误，而不是库代码。如果这也不行，可以全部注释掉，然后慢慢将你的代码添加回去。或者，更好的是，考虑使用版本控制并回滚到之前工作过的版本。这本书不会带你详细了解如何设置一个合理的开发环境，但会指出一些有用的工具和需要考虑的事项。

## 摘要

+   C++无处不在，几乎可以用于任何事情。

+   C++正在不断发展，每三年就会有一个新的标准，由 ISO 的 WG21 决定。

+   C++是一种多范式语言。

+   你需要一个支持你选择平台的编译器。

+   其他类似的语言也都有，但 C++能为你打下各种技术和习惯用法坚实的基础。

+   目前没有任何单个编译器支持该语言最新版本的每个特性，但你可以使用 Godbolt 和 C++ Insights 来尝试短小的代码片段，以检查它们是否可以编译。

+   编写整个程序是学习的好方法，你将在本书的其余部分中这样做。
