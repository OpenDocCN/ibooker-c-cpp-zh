## Takeaways

| **A** C 和 C++不同：不要混淆它们，也不要将它们混淆。 |  |
| --- | --- |
| **B** 不要慌张。 |  |
| **1.1** C 是一种命令式编程语言。 |  |
| **1.2** C 是一种编译型编程语言。 |  |
| **1.3** 正确的 C 程序可以在不同的平台上移植。 |  |
| **1.4** 一个 C 程序应该无警告地干净编译。 |  |
| **2.1** 标点符号可以有多种不同的含义。 |  |
| **2.2** 程序中的所有标识符都必须声明。 |  |
| **2.3** 标识符可以有多个一致的声明。 |  |
| **2.4** 声明绑定到它们出现的范围。 |  |
| **2.5** 声明指定标识符，而定义指定对象。 |  |
| **2.6** 对象在初始化的同时被定义。 |  |
| **2.7** 初始化器中缺失的元素默认为 0。 |  |
| **2.8** 对于具有 n 个元素的数组，第一个元素的索引为 0，最后一个元素的索引为 n-1。 |  |
| **2.9** 每个对象或函数必须有一个确切的定义。 |  |
| **2.10** 应使用**for**语句编写域迭代。 |  |
| **2.11** 循环变量应在**for**语句的初始部分定义。 |  |
| **3.1** 值 0 表示逻辑假。 |  |
| **3.2** 任何非 0 值表示逻辑真。 |  |
| **3.3** 不要与 0、**false**或**true**进行比较。 |  |
| **3.4** 所有标量都有一个真值。 |  |
| **3.5** **case**值必须是整数常量表达式。 |  |
| **3.6** **case**标签不得跳过变量定义。 |  |
| **4.1** 类型**size_t**表示的范围是[0, **SIZE_MAX**]。 |  |
| **4.2** 无符号算术始终有定义。 |  |
| **4.3** 对于**size_t**上的+、-和*运算，如果结果可以表示为**size_t**，则提供数学上正确的结果。 |  |
| **4.4** 对于无符号值，a == (a/b)*b + (a%b)。 |  |
| **4.5** 无符号除法和取模运算仅在第二个操作数不为 0 时定义良好。 |  |
| **4.6** 对 **size_t** 的算术运算隐式执行计算 %(**SIZE_MAX**+1)。 |  |
| **4.7** 在溢出情况下，无符号算术会进行环绕。 |  |
| **4.8** 无符号除法和取模运算的结果总是小于操作数。 |  |
| **4.9** 无符号除法和取模运算不会溢出。 |  |
| **4.10** 运算符的所有字符必须直接相连。 |  |
| **4.11** 值表达式中的副作用是邪恶的。 |  |
| **4.12** 在一个语句中不要修改超过一个对象。 |  |
| **4.13** 比较运算符返回值 **false** 或 **true**。 |  |
| **4.14** 逻辑运算符返回值 **false** 或 **true**。 |  |
| **4.15** &&, | | , ?: 和 , 首先评估它们的第一操作数。 |  |
| **4.16** 不要使用逗号运算符。 |  |
| **4.17** 大多数运算符不会对其操作数进行排序。 |  |
| **4.18** 函数调用不会对其参数表达式进行排序。 |  |
| **4.19** 在表达式内部调用的函数不应有副作用。 |  |
| **5.1** C 程序主要处理值而不是它们的表示。 |  |
| **5.2** 所有值都是数字或者可以转换为数字。 |  |
| **5.3** 所有值都有一个静态确定的类型。 |  |
| **5.4** 值上可能进行的操作由其类型决定。 |  |
| **5.5** 值的类型决定了所有操作的结果。 |  |
| **5.6** 类型的二进制表示决定了所有操作的结果。 |  |
| **5.7** 类型二进制表示是可观察的。 |  |
| **5.8 (as-if)** 程序执行 **as if** 遵循抽象状态机。 |  |
| **5.9** 类型决定了优化机会。 |  |
| **5.10** 在算术运算之前，窄整数类型会被提升为 **signed int**。 |  |
| **5.11** 四种基本类型类中的每一个都有三个不同的未提升类型。 |  |
| **5.12** 使用 **size_t** 表示大小、基数或序数。 |  |
| **5.13** 对于不能为负的小量，使用**unsigned**。 |  |
| **5.14** 对于带有符号的小量，使用**signed**。 |  |
| **5.15** 对于带有符号的大差异，使用**ptrdiff_t**。 |  |
| **5.16** 对于浮点计算，使用**double**。 |  |
| **5.17** 对于复杂数学计算，使用**double** **complex**。 |  |
| **5.18** 连续的字符串字面量会被连接。 |  |
| **5.19** 数值字面量从不为负。 |  |
| **5.20** 十进制整数常量是有符号的。 |  |
| **5.21** 十进制整数常量具有适合它的三个有符号类型中的第一个。 |  |
| **5.22** 同一个值可以有不同的类型。 |  |
| **5.23** 不要使用八进制或十六进制常量来表示负值。 |  |
| **5.24** 使用十进制常量来表示负值。 |  |
| **5.25** 不同的字面量可以具有相同的值。 |  |
| **5.26** 十进制浮点常量的有效值可能与其字面值不同。 |  |
| **5.27** 字面量具有值、类型和二进制表示。 |  |
| **5.28** I 保留用于虚数单位。 |  |
| **5.29** 一元减号（-）和加号（+）具有提升后的参数的类型。 |  |
| **5.30** 避免缩窄转换。 |  |
| **5.31** 在算术中不要使用窄类型。 |  |
| **5.32** 避免具有不同符号的运算数。 |  |
| **5.33** 在可能的情况下，使用无符号类型。 |  |
| **5.34** 选择算术类型，以确保隐式转换无害。 |  |
| **5.35** 所有变量都应该初始化。 |  |
| **5.36** 为所有聚合数据类型使用指定初始化器。 |  |
| **5.37** {0}是所有非变长数组（VLA）对象类型的有效初始化器。 |  |
| **5.38** 所有具有特定含义的常量都必须命名。 |  |
| **5.39** 所有具有不同含义的常量都必须区分开来。 |  |
| **5.40** **const**-限定类型的对象是只读的。 |  |
| **5.41** 字符串字面量是只读的。 |  |
| **5.42** 枚举常量具有显式或位置值。 |  |
| **5.43** 枚举常量是 **signed int** 类型。 |  |
| **5.44** 整数常量表达式不评估任何对象。 |  |
| **5.45** 宏名称全部为大写。 |  |
| **5.46** 复合字面量定义了一个对象。 |  |
| **5.47** 不要在宏内部隐藏终止的分号。 |  |
| **5.48** 将宏的缩进续行符右缩进到同一列。 |  |
| **5.49** 相同的值可能有不同的二进制表示。 |  |
| **5.50** 无符号算术可以很好地回绕。 |  |
| **5.51** 任何整数类型的最大值形式为 2^p – 1。 |  |
| **5.52** 无符号整数类型的算术由其精度决定。 |  |
| **5.53** 移位操作的第二操作数必须小于精度。 |  |
| **5.54** 正值独立于符号表示。 |  |
| **5.55** 一旦抽象状态机达到未定义状态，就无法再对执行的后续进行任何假设。 |  |
| **5.56** 避免所有操作未定义行为是你的责任。 |  |
| **5.57** 有符号算术可能会产生严重错误。 |  |
| **5.58** 在二进制补码表示中，**INT_MIN** < -**INT_MAX**。 |  |
| **5.59** 对于有符号算术，取反可能会溢出。 |  |
| **5.60** 对于位操作，使用无符号类型。 |  |
| **5.61** 如果提供了 uintN_t 类型，它是一个具有精确 *N* 位宽度和精度的无符号整数类型。 |  |
| **5.62** 如果提供了 intN_t 类型，它是有符号的，采用二进制补码表示，具有精确 *N* 位的宽度和 *N* – 1 的精度。 |  |
| **5.63** 如果存在具有所需属性的 *N* = 8, 16, 32, 和 64 的值类型，则必须提供 uintN_t 和 intN_t 类型，分别对应无符号和有符号整数类型。 |  |
| **5.64** 对于提供的任何固定宽度类型，还提供了 **_MIN**（仅限有符号）、最大 **_MAX** 和字面量 **_C** 宏。 |  |
| **5.65** 浮点运算既不是*结合律*，也不是*交换律*，也不是*分配律*。 |  |
| **5.66** 永远不要比较浮点值是否相等。 |  |
| **6.1** 数组不是指针。 |  |
| **6.2** 在条件中评估数组为**true**。 |  |
| **6.3** 存在数组对象，但没有数组值。 |  |
| **6.4** 数组不能进行比较。 |  |
| **6.5** 数组不能被赋值。 |  |
| **6.6** 可变长度数组（VLA）不能有初始化器。 |  |
| **6.7** 可变长度数组（VLA）不能在函数外部声明。 |  |
| **6.8** 可变长度数组（FLA）的长度由整数常量表达式（ICE）或初始化器确定。 |  |
| **6.9** 数组长度规范必须是严格正数。 |  |
| **6.10** 长度不是整数常量表达式的数组是可变长度数组（VLA）。 |  |
| **6.11** 数组 A 的长度是（**sizeof** A）/（**sizeof** A[0]）。 |  |
| **6.12** 函数数组参数的最内层维度丢失。 |  |
| **6.13** 不要在数组参数上使用**sizeof**运算符。 |  |
| **6.14** 数组参数的行为*就像*数组是通过引用传递的。 |  |
| **6.15** 字符串是一个以 0 结尾的**char**数组。 |  |
| **6.16** 使用非字符串的字符串函数会有未定义行为。 |  |
| **6.17** 指针是不透明对象。 |  |
| **6.18** 指针是有效的、空的或不确定的。 |  |
| **6.19** 使用 0 进行初始化或赋值会使指针变为空。 |  |
| **6.20** 在逻辑表达式中，如果指针为空，则其评估结果为**false**。 |  |
| **6.21** 不确定指针会导致未定义行为。 |  |
| **6.22** 总是初始化指针。 |  |
| **6.23** 省略的结构体初始化器将相应的成员强制设置为 0。 |  |
| **6.24** 结构体初始化器必须初始化至少一个成员。 |  |
| **6.25** 结构体参数是通过值传递的。 |  |
| **6.26** 结构体可以用=赋值，但不能用==或!=比较。 |  |
| **6.27** 结构布局是一个重要的设计决策。 |  |
| **6.28** 在嵌套声明中的所有 **struct** 声明具有相同的可见作用域。 |  |
| **6.29** 在 **typedef** 中使用与标签名相同的标识符来提前声明一个 **struct**。 |  |
| **6.30** **typedef** 只创建一个类型的别名，但永远不会创建一个新类型。 |  |
| **6.31** 以 **_t** 结尾的标识符名称是保留的。 |  |
| **7.1** 所有函数都必须有原型。 |  |
| **7.2** 函数只有一个入口，但可以有多个 **return** 语句。 |  |
| **7.3** 函数的 **return** 必须与其类型一致。 |  |
| **7.4** 到达函数的 `{}` 块的末尾等同于没有表达式的 **return** 语句。 |  |
| **7.5** 只有对于 **void** 函数，才允许到达函数的 `{}` 块的末尾。 |  |
| **7.6** 将 **EXIT_SUCCESS** 和 **EXIT_FAILURE** 作为 **main** 的返回值。 |  |
| **7.7** 到达 **main** 的末尾等同于带有值 **EXIT_SUCCESS** 的 **return** 语句。 |  |
| **7.8** 调用 **exit**(s) 等同于在 **main** 中评估 **return** 语句。 |  |
| **7.9** **exit** 从不失败，并且从不返回给其调用者。 |  |
| **7.10** 所有命令行参数都作为字符串传递。 |  |
| **7.11** 对于 **main** 的参数，`argv[0]` 包含程序调用的名称。 |  |
| **7.12** 对于 **main** 的参数，`argv[argc]` 是 0。 |  |
| **7.13** 使一个函数的所有先决条件都明确。 |  |
| **7.14** 在递归函数中，首先检查终止条件。 |  |
| **7.15** 确保包装函数中递归函数的先决条件。 |  |
| **7.16** 多重递归可能导致指数级的计算时间。 |  |
| **7.17** 一个糟糕的算法永远不会导致性能良好的实现。 |  |
| **7.18** 改进算法可以显著提高性能。 |  |
| **8.1** 失败始终是一个选项。 |  |
| **8.2** 检查库函数的返回值以查找错误。 |  |
| **8.3** 快速失败，尽早失败，频繁失败。 |  |
| **8.4** 以 _s 结尾的标识符名称是保留的。 |  |
| **8.5** 忽略执行平台的先决条件必须中止编译。 |  |
| **8.6** 仅在预处理器条件中评估宏和整数文字。 |  |
| **8.7** 在预处理器条件中，未知标识符评估为 0。 |  |
| **8.8** 不透明类型通过功能接口指定。 |  |
| **8.9** 不要依赖于不透明类型的实现细节。 |  |
| **8.10** `puts` 和 `fputs` 在换行符处理上有所不同。 |  |
| **8.11** 文本输入和输出转换数据。 |  |
| **8.12** 有三种常用的转换用于编码换行符。 |  |
| **8.13** 文本行不应包含尾随空白。 |  |
| **8.14** **printf** 的参数必须与格式说明符完全对应。 |  |
| **8.15** 使用 "%d" 和 "%u" 格式来打印整数值。 |  |
| **8.16** 使用 "%x" 格式来打印位模式。 |  |
| **8.17** 使用 "%g" 格式来打印浮点值。 |  |
| **8.18** 使用不适当的格式说明符或修饰符会使行为未定义。 |  |
| **8.19** 对于以后需要读取的转换，使用 "%+d", "%#X", 和 "%a"。 |  |
| **8.20** 不要使用 **gets**。 |  |
| **8.21** `fgetc` 返回 `int` 以能够编码一个特殊错误状态，**EOF**，以及所有有效字符。 |  |
| **8.22** 文件结束只能在使用失败的读取后检测到。 |  |
| **8.23** 数值编码字符的解释取决于执行字符集。 |  |
| **8.24** 正常程序终止应使用从 **main** 的 **return**。 |  |
| **8.25** 从可能终止常规控制流的函数中使用 **exit**。 |  |
| **8.26** 不要使用除 **exit** 之外的其他函数来终止程序，除非您必须抑制库清理的执行。 |  |
| **8.27** 尽可能多地使用 **assert** 来确认运行时属性。 |  |
| **8.28** 在生产编译中，使用 **NDEBUG** 来关闭所有 **assert**。 |  |
| **C** 所有 C 语言代码都必须易于阅读。 |  |
| **9.1** 短时记忆和视野范围都很小。 |  |
| **9.2** 编码风格不是品味问题，而是文化问题。 |  |
| **9.3** 当你加入一个成熟的项目时，你就进入了一个新的文化空间。 |  |
| **9.4** 选择一致的策略来处理空白和其他文本格式。 |  |
| **9.5** 让你的文本编辑器自动格式化你的代码。 |  |
| **9.6** 为所有标识符选择一致的命名策略。 |  |
| **9.7** 在头文件中可见的任何标识符都必须符合规范。 |  |
| **9.8** 不要污染标识符的全局空间。 |  |
| **9.9** 名称必须易于识别且易于区分。 |  |
| **9.10** 命名是一种创造性行为。 |  |
| **9.11** 文件作用域的标识符必须全面。 |  |
| **9.12** 类型名称标识一个概念。 |  |
| **9.13** 全局常量标识一个工件。 |  |
| **9.14** 全局变量标识状态。 |  |
| **9.15** 函数或功能宏标识一个动作。 |  |
| **10.1 (what)** 函数接口描述了*做什么*。 |  |
| **10.2 (what for)** 接口注释记录了函数的目的。 |  |
| **10.3 (how)** 函数代码说明了函数是如何组织的。 |  |
| **10.4 (in which manner)** 代码注释解释了函数细节是如何实现的。 |  |
| **10.5** 分离接口和实现。 |  |
| **10.6** 记录接口——解释实现。 |  |
| **10.7** 详尽地记录接口。 |  |
| **10.8** 以具有强语义连接的单元结构化代码。 |  |
| **10.9** 逐字实现。 |  |
| **10.10** 控制流必须明显。 |  |
| **10.11** 宏不应以令人惊讶的方式改变控制流。 |  |
| **10.12** 函数宏在语法上应像函数调用一样表现。 |  |
| **10.13** 函数参数按值传递。 |  |
| **10.14** 全局变量不受欢迎。 |  |
| **10.15** 在可能的情况下，将小任务表示为纯函数。 |  |
| **11.1** 使用 * 与不确定或空指针一起使用将产生未定义行为。 |  |
| **11.2** 一个有效的指针指向引用类型数组的第一个元素。 |  |
| **11.3** 无法从指针重建数组对象的长度。 |  |
| **11.4** 指针不是数组。 |  |
| **11.5** 只从数组对象的元素中减去指针。 |  |
| **11.6** 所有指针差都具有类型 **ptrdiff_t**。 |  |
| **11.7** 使用 **ptrdiff_t** 来编码位置或大小的有符号差。 |  |
| **11.8** 对于打印，将指针值转换为 **void***，并使用格式 %p。 |  |
| **11.9** 指针有真值。 |  |
| **11.10** 一旦可能，就将指针变量设置为 0。 |  |
| **11.11** 访问具有其类型陷阱表示的对象将产生未定义行为。 |  |
| **11.12** 解引用时，指向的对象必须是指定的类型。 |  |
| **11.13** 指针必须指向一个有效的对象或一个有效对象之后的对象或为空。 |  |
| **11.14** 不要使用 **NULL**。 |  |
| **11.15** 不要在 **typedef** 中隐藏指针。 |  |
| **11.16** 两个表达式 A[i] 和 *(A+i) 是等价的。 |  |
| **11.17 (数组衰减)** 数组 A 的评估返回 &A[0]。 |  |
| **11.18** 在函数声明中，任何数组参数都会重写为指针。 |  |
| **11.19** 只重写数组参数的最内层维度。 |  |
| **11.20** 在数组参数之前声明长度参数。 |  |
| **11.21** 函数的数组参数的有效性必须由程序员保证。 |  |
| **11.22 (函数衰减)** 没有后续开括号的函数 *f* 会衰减为其起始位置的指针。 |  |
| **11.23** 函数指针必须使用其确切类型。 |  |
| **11.24** 函数调用运算符 (...) 适用于函数指针。 |  |
| **12.1** 具有不同基类型的指针类型是不同的。 |  |
| **12.2** 根据定义，sizeof(char) 是 1。 |  |
| **12.3** 每个对象 A 都可以看作是 **unsigned char**[**sizeof(A**)]。 |  |
| **12.4** 字符类型指针是特殊的。 |  |
| **12.5** 使用类型 **char** 用于字符和字符串数据。 |  |
| **12.6** 使用类型 **unsigned char** 作为所有对象类型的原子。 |  |
| **12.7** **sizeof** 运算符可以应用于对象和对象类型。 |  |
| **12.8** 类型 T 的所有对象的尺寸由 **sizeof(T**) 给出。 |  |
| **12.9** 算术类型表示数字的内存顺序是实现定义的。 |  |
| **12.10** 在大多数架构上，**CHAR_BIT** 是 8，**UCHAR_MAX** 是 255。 |  |
| **12.11 (Aliasing)** 除了字符类型外，只有相同基类型的指针可以别名。 |  |
| **12.12** 避免使用 & 运算符。 |  |
| **12.13** 任何对象指针都可以转换为 **void** 并从 **void** 转换回来。 |  |
| **12.14** 对象具有存储、类型和值。 |  |
| **12.15** 将对象指针转换为 **void** 并再转换回相同类型是恒等操作。 |  |
| **12.16 (a***void*²***)** A*void* **void***。 |  |
| **12.17** 不要使用类型转换。 |  |
| **12.18 (Effective Type)** 对象必须通过其有效类型或通过指向字符类型的指针来访问。 |  |
| **12.19** 如果字节表示相当于访问类型的有效值，则可以随时访问具有有效 **union** 类型的对象的任何成员。 |  |
| **12.20** 变量或复合字面量的有效类型是其声明类型。 |  |
| **12.21** 变量和复合字面量必须通过其声明类型或通过指向字符类型的指针来访问。 |  |
| **13.1** 不要对 **malloc** 和其相关函数的返回值进行类型转换。 |  |
| **13.2** 通过**malloc**分配的存储空间未初始化且没有类型。 |  |
| **13.3** **malloc**通过返回空指针值来指示失败。 |  |
| **13.4** 对于每个分配，必须有相应的**free**。 |  |
| **13.5** 对于每个**free**，必须有相应的**malloc**、**calloc**、**aligned_alloc**或**realloc**。 |  |
| **13.6** 只用指针调用**free**，这些指针由**malloc**、**calloc**、**aligned_alloc**或**realloc**返回。 |  |
| **13.7** 标识符只在它们的声明作用域内可见，从它们的声明开始。 |  |
| **13.8** 标识符的可见性可能被从属作用域中具有相同名称的标识符所遮蔽。 |  |
| **13.9** 每个变量的定义都会创建一个新的、不同的对象。 |  |
| **13.10** 只读对象字面量可以重叠。 |  |
| **13.11** 对象有一个生命周期，在此生命周期之外它们无法被访问。 |  |
| **13.12** 在对象的生命周期之外引用对象具有未定义的行为。 |  |
| **13.13** 静态存储持续时间的对象总是初始化的。 |  |
| **13.14** 除非是 VLA 或临时对象，否则自动对象的生存期与它们的定义块的执行相对应。 |  |
| **13.15** 每次递归调用都会创建一个自动对象的新的局部实例。 |  |
| **13.16** 对于声明为**register**的变量，不允许使用&运算符。 |  |
| **13.17** 声明为**register**的变量不能有别名。 |  |
| **13.18** 在性能关键代码中将非数组局部变量声明为**register**。 |  |
| **13.19** 存储类为**register**的数组是无用的。 |  |
| **13.20** 临时生命周期的对象是只读的。 |  |
| **13.21** 临时生命周期的结束是在包含表达式的末尾。 |  |
| **13.22** 对于不是 VLA 的对象，其生命周期从进入定义的作用域开始，并在离开该作用域时结束。 |  |
| **13.23** 自动变量和复合字面量的初始化器在每次遇到定义时都会被评估。 |  |
| **13.24** 对于 VLA，生命周期从遇到定义开始，到离开可见作用域结束。 |  |
| **13.25** 静态或线程存储持续期的对象默认初始化。 |  |
| **13.26** 自动或分配存储持续期的对象必须显式初始化。 |  |
| **13.27** 为你的每个数据类型系统地提供一个初始化函数。 |  |
| **14.1** 字符串 strto... 转换函数不是 **const**-安全的。 |  |
| **14.2** **memchr** 和 **strchr** 搜索函数不是 **const**-安全的。 |  |
| **14.3** **strspn** 和 **strcspn** 搜索函数是 **const**-安全的。 |  |
| **14.4** **sprintf** 没有提供防止缓冲区溢出的措施。 |  |
| **14.5** 在格式化未知长度的输出时使用 **snprintf**。 |  |
| **14.6** 多字节字符不包含空字节。 |  |
| **14.7** 多字节字符串以空字符结尾。 |  |
| **14.8** 在二进制模式下使用 **fread** 或 **fwrite** 的打开流。 |  |
| **14.9** 以二进制模式写入的文件在不同平台之间不可移植。 |  |
| **14.10** **fseek** 和 **ftell** 不适合非常大的文件偏移量。 |  |
| **14.11** **goto** 标签在包含它们的整个函数中可见。 |  |
| **14.12** **goto** 只能跳转到同一函数内的标签。 |  |
| **14.13** **goto** 不应跳过变量初始化。 |  |
| **D** 过早优化是万恶之源。 |  |
| **15.1** 不要为了性能而牺牲安全。 |  |
| **15.2** 优化器足够聪明，可以消除未使用的初始化。 |  |
| **15.3** 函数指针参数的不同表示方式导致相同的二进制代码。 |  |
| **15.4** 不取局部变量的地址有助于优化器，因为它抑制了别名。 |  |
| **15.5** 内联可以打开许多优化机会。 |  |
| **15.6** 添加一个兼容的声明而不使用 **inline** 关键字确保在当前 TU 中发出函数符号。 |  |
| **15.7** 内联函数的定义在所有 TUs 中都是可见的。 |  |
| **15.8** 内联的定义放在头文件中。 |  |
| **15.9** 没有使用**inline**的额外*声明*将放在恰好一个 TUs 中。 |  |
| **15.10** 只有在你认为它们是稳定的时，才将函数暴露为**inline**。 |  |
| **15.11** 所有属于内联函数本地的标识符都应该通过方便的命名约定来保护。 |  |
| **15.12** 内联函数不能访问静态函数的*标识符*。 |  |
| **15.13** 内联函数不能定义或访问可修改的静态对象的*标识符*。 |  |
| **15.14** 带有**restrict**限定符的指针必须提供独占访问。 |  |
| **15.15** 当你考虑它们是稳定的时，才将函数暴露为**inline**。 |  |
| **E** 不要推测代码的性能；要严格验证。 |  |
| **15.16** 算法复杂度评估需要证明。 |  |
| **15.17** 代码的性能评估需要测量。 |  |
| **15.18** 所有测量都会引入偏差。 |  |
| **15.19** 仪器更改会改变编译时和运行时属性。 |  |
| **15.20** 运行时间的相对标准偏差必须在低百分比范围内。 |  |
| **15.21** 收集测量值的高阶矩以计算方差和偏斜是简单且经济的。 |  |
| **15.22** 运行时测量必须通过统计方法来强化。 |  |
| **16.1** 在可能的情况下，优先选择内联函数而不是功能宏。 |  |
| **16.2** 功能宏应提供一个简单的接口来执行复杂任务。 |  |
| **16.3** 宏替换是在早期翻译阶段完成的，在给程序组成的标记赋予任何其他解释之前。 |  |
| **16.4 (macro retention)** 如果一个功能宏后面没有跟括号（()），则它不会被展开。 |  |
| **16.5** **__LINE__**中的行号可能无法放入一个**int**中。 |  |
| **16.6** 使用**__LINE__**固有的很危险。 |  |
| **16.7** 使用操作符**#**进行字符串化不会展开其参数中的宏。 |  |
| **16.8** 当传递给可变参数时，所有算术类型都按算术运算的方式转换，除了 **float** 参数，它们被转换为 **double**。 |  |
| **16.9** 可变参数函数必须接收有关可变列表中每个参数类型的有效信息。 |  |
| **16.10** 除非每个参数都强制转换为特定类型，否则使用可变参数函数是不可移植的。 |  |
| **16.11** 避免在新的接口中使用可变参数函数。 |  |
| **16.12** **va_arg** 机制不提供对 **va_list** 长度的访问。 |  |
| **16.13** 可变参数函数需要一个特定的约定来指定列表的长度。 |  |
| **16.14** **_Generic** 表达式的结果类型是所选表达式的类型。 |  |
| **16.15** 使用 **_Generic** 与 **inline** 函数一起使用可以增加优化机会。 |  |
| **16.16** **_Generic** 表达式中的类型表达式应该是无修饰的类型：没有数组类型，也没有函数类型。 |  |
| **16.17** **_Generic** 表达式中的类型表达式必须引用相互不兼容的类型。 |  |
| **16.18** 在一个 **_Generic** 表达式中的类型表达式不能是一个指向 VLA 的指针。 |  |
| **16.19** 在 **_Generic** 中的所有选择 *expression1* ... *expressionN* 必须是有效的。 |  |
| **17.1** 函数中的副作用可能导致不确定的结果。 |  |
| **17.2** 任何运算符的具体操作都排在所有操作数评估之后。 |  |
| **17.3** 使用任何赋值、增量或减量运算符更新对象的效果都排在它的操作数评估之后。 |  |
| **17.4** 函数调用相对于调用者的所有评估是有序的。 |  |
| **17.5** 数组或结构类型初始化列表的表达式是有序不确定的。 |  |
| **17.6** 每次迭代定义了一个局部对象的新实例。 |  |
| **17.7** **goto** 应仅用于控制流中的异常变化。 |  |
| **17.8** 每个函数调用定义了一个局部对象的新实例。 |  |
| **17.9** **longjmp** 从不返回到调用者。 |  |
| **17.10** 当通过正常控制流到达时，对 **setjmp** 的调用将标记调用位置为跳转目标，并返回 0。 |  |
| **17.11** 离开对 **setjmp** 的调用范围会使跳转目标无效。 |  |
| **17.12** 对 **longjmp** 的调用将直接转移到由 **setjmp** 设置的位置，就像它返回了条件参数一样。 |  |
| **17.13** 将 0 作为 **longjmp** 的条件参数时，会被替换为 1。 |  |
| **17.14** **setjmp** 只能在条件表达式的简单比较中使用。 |  |
| **17.15** 优化与对 **setjmp** 的调用交互不良。 |  |
| **17.16** 在 **longjmp** 跨越时修改的对象必须是 **volatile**。 |  |
| **17.17** **volatile** 对象在每次访问时都会从内存中重新加载。 |  |
| **17.18** **volatile** 对象在每次修改时都会存储到内存中。 |  |
| **17.19** **jmp_buf** 的 **typedef** 隐藏了一个数组类型。 |  |
| **17.20** C 的信号处理接口是最基本的，并且仅应用于基本情况。 |  |
| **17.21** 信号处理程序可以在执行的任何点介入。 |  |
| **17.22** 从信号处理程序返回后，执行将从被中断的地方继续。 |  |
| **17.23** 一个 C 语句可能对应于多个处理器指令。 |  |
| **17.24** 信号处理程序需要具有不可中断操作的类型。 |  |
| **17.25** **sig_atomic_t** 类型的对象不应用作计数器。 |  |
| **17.26** 除非另有指定，否则 C 库函数不是异步信号安全的。 |  |
| **18.1** 如果线程 *T*[0] 写入一个同时被另一个线程 *T*[1] 读取或写入的非原子对象，则执行行为将变为未定义。 |  |
| **18.2** 考虑到不同线程的执行，原子对象的常规操作是不可分割的且可线性化的。 |  |
| **18.3** 使用 **_Atomic(**T**) 语法指定符进行原子声明。 |  |
| **18.4** 没有原子数组类型。 |  |
| **18.5** 原子对象是强制消除竞争条件的特权工具。 |  |
| **18.6** 正确初始化的 **FILE*** 可以被多个线程安全地使用。 |  |
| **18.7** 并发写操作应一次打印整行。 |  |
| **18.8** 销毁和分配共享动态对象需要很多注意。 |  |
| **18.9** 通过函数参数传递线程特定的数据。 |  |
| **18.10** 将线程特定的状态保存在局部变量中。 |  |
| **18.11** **thread_local** 变量为每个线程都有一个单独的实例。 |  |
| **18.12** 如果初始化可以在编译时确定，请使用 **thread_local**。 |  |
| **18.13** 互斥锁操作提供线性化。 |  |
| **18.14** 每个互斥锁都必须使用 **mtx_init** 进行初始化。 |  |
| **18.15** 持有非递归互斥锁的线程不得调用其互斥锁锁定函数。 |  |
| **18.16** 递归互斥锁只有在持有线程对 **mtx_unlock** 的调用次数与其获取的锁次数相同时才会释放。 |  |
| **18.17** 在线程终止之前必须释放已锁定的互斥锁。 |  |
| **18.18** 线程必须只在对它持有的互斥锁上调用 **mtx_unlock**。 |  |
| **18.19** 每次成功的互斥锁锁定对应于对 **mtx_unlock** 的精确一次调用。 |  |
| **18.20** 互斥锁必须在生命周期结束时被销毁。 |  |
| **18.21** 从 **cnd_t** 等待返回后，必须再次检查表达式。 |  |
| **18.22** 条件变量只能与一个互斥锁同时使用。 |  |
| **18.23** **cnd_t** 必须动态初始化。 |  |
| **18.24** **cnd_t** 必须在其生命周期结束时被销毁。 |  |
| **18.25** 从 **main** 函数返回或调用 **exit** 会终止所有线程。 |  |
| **18.26** 在阻塞于 **mtx_t** 或 **cnd_t** 时，线程会释放处理资源。 |  |
| **19.1** 每次评估都有一个效果。 |  |
| **19.2** 如果 *F* 在 *E* 之前顺序，则 *F → E*。 |  |
| **19.3** 原子对象 X 的修改集以与处理 X 的任何线程的顺序关系一致的顺序执行。 |  |
| **19.4** 在线程 *T[E]* 中的获取操作 *E* 与释放操作 *F* 同步，如果另一个线程 *T[F]* 中 *E* 读取了 *F* 写入的值。 |  |
| **19.5** 如果 *F* 与 *E* 同步，所有在 *E* 之后发生的评估 G 中必须可见的所有在 *F* 之前发生的效果 *X*。 |  |
| **19.6** 只有在我们有一个将它们连接起来的同步序列链时，我们才能得出一个评估发生在另一个评估之前的结论。 |  |
| **19.7** 如果评估 *F* 发生在 *E* 之前，所有已知在 *F* 之前发生的效果也都是在 *E* 之前发生的。 |  |
| **19.8** 由相同互斥锁保护的关键区是顺序发生的。 |  |
| **19.9** 在由互斥锁 mut 保护的关键区中，所有由 mut 保护的前关键区的影响都是可见的。 |  |
| **19.10** **cnd_wait** 和 **cnd_timedwait** 对互斥锁具有释放-获取语义。 |  |
| **19.11** 对 **cnd_signal** 和 **cnd_broadcast** 的调用通过互斥锁进行同步。 |  |
| **19.12** 对 **cnd_signal** 和 **cnd_broadcast** 的调用应发生在由等待者相同的互斥锁保护的临界区中。 |  |
| **19.13** 所有具有顺序一致性的原子操作都发生在全局修改顺序中，无论它们应用于哪个原子对象。 |  |
| **19.14** 所有原子上的操作符和未指定其他情况的函数式接口都具有顺序一致性。 |  |
| **19.15** 原子对象的同步功能接口有一个形式，其中附加了 **_ 显式**，这允许我们指定它们的一致性模型。 |  |
