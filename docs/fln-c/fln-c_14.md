# 第十二章 结论

# 你学到了什么

阅读本书后，你现在熟悉了几个高级 C 编程概念。当查看更大的代码示例时，你现在知道为什么代码看起来是这个样子的。你现在了解了在那些代码中做出的设计决策的理由。例如，在本书的前言中呈现的以太网驱动程序示例代码中，你现在理解为什么有一个显式的`driverCreate`方法以及为什么有一个`DRIVER_HANDLE`来保存状态信息。第一部分的模式指导了在这个示例及本书讨论的许多其他示例中做出的决策。

第二部分中的模式故事展示了应用本书中的模式的好处以及如何通过逐步应用模式来逐步增强代码。当面对下一个 C 编程问题时，查阅模式的问题部分，看看是否有一个匹配你的问题。如果是这样，你非常幸运，因为那么你可以从模式提供的指导中受益。

# 进一步阅读

这本书帮助 C 编程新手成为高级 C 程序员。以下是一些特别帮助我提高 C 编程技能的其他书籍：

+   *Clean Code: A Handbook of Agile Software Craftsmanship* by Robert C. Martin (Prentice Hall, 2008) 讨论了实现持久高质量代码的基本原则。对于任何程序员来说，它都是一本必读之作，涵盖了测试、文档、代码风格等主题。

+   *Test-Driven Development for Embedded C* by James W. Grenning (Pragmatic Bookshelf, 2011) 通过一个运行示例解释如何在硬件接近的程序环境中使用 C 实现单元测试。

+   *Expert C Programming* by Peter van der Linden (Prentice Hall, 1994) 是一本早期的关于高级 C 编程指导的书籍。它详细描述了 C 语法的工作原理以及如何避免常见陷阱。它还讨论了诸如 C 内存管理的概念，并告诉你链接器的工作原理。

+   与我的书密切相关的是 *Patterns in C* by Adam Tornhill (Leanpub, 2014)。它也展示了模式，并专注于如何在 C 中实现四人帮设计模式。

# 结语

与刚从学校毕业的 C 程序员相比，你现在具备了高级的知识，知道如何编写更大规模和工业级别的 C 代码。现在你可以：

+   执行错误处理，即使你没有像异常这样的机制

+   管理你的内存，即使你没有垃圾回收器和析构函数来清理内存

+   实现灵活的接口，即使你没有本地的抽象机制

+   组织文件和代码，即使你没有类或包的机制

现在你能够使用 C 进行工作，尽管它缺少现代编程语言的某些便利性。
