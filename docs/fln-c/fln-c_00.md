# 前言

你拿起这本书是为了提升你的编程技能。这是好事，因为你肯定会从本书提供的实际知识中受益。如果您在 C 编程方面有丰富的经验，您将了解良好设计决策的细节及其利弊。如果您对 C 编程相对较新，您将找到有关设计决策的指导，并看到这些决策如何逐步应用于运行代码示例以构建规模较大的程序。

本书回答了如何结构化一个 C 程序、如何处理错误处理或如何设计灵活接口等问题。随着您对 C 编程的了解加深，通常会出现以下问题：

+   我应该返回任何错误信息吗？

+   我应该使用全局变量`errno`来做到这一点吗？

+   我应该选择少数带有许多参数的函数还是反之？

+   我如何构建一个灵活的接口？

+   我如何构建基本的事物，比如一个迭代器？

对于面向对象的语言，这些问题的大部分在《设计模式：可重用面向对象软件的元素》（Erich Gamma，Richard Helm，Ralph Johnson 和 John Vlissides 著，Prentice Hall 出版，1997 年）中得到了很大程度上的回答。设计模式为程序员提供了关于对象如何互动以及哪个对象拥有其他类型对象的最佳实践。此外，设计模式展示了如何将这些对象组合在一起。

然而，对于像 C 这样的过程式编程语言，大部分这些设计模式无法像《四人帮》描述的那样实现。在 C 中没有本地的面向对象机制。在 C 编程语言中可以模拟继承或多态性，但这可能不是第一选择，因为这种模拟使得习惯于 C 编程而不习惯使用类似 C++这样的面向对象语言及其继承和多态性概念的程序员感到陌生。这样的程序员可能希望坚持他们习惯的本地 C 编程风格。然而，使用本地 C 编程风格，不是所有面向对象设计模式的指导都可用，或者至少没有提供非面向对象编程语言的具体实现的想法。

这就是我们的立场：我们希望在 C 中编程，但我们不能直接使用设计模式文档中记录的大多数知识。本书展示了如何弥补这一差距，并为 C 编程语言实施实际设计知识。

# 为什么我写这本书

让我告诉你为什么我收集在这本书中的知识对我来说非常重要，以及为什么这样的知识很难找到。

在学校里，我把 C 编程作为我的第一门编程语言。就像每个新的 C 程序员一样，我想知道为什么数组从索引 0 开始，我首先随机尝试如何放置操作符`*`和`&`，最终让 C 指针魔法起作用。

在大学里，我学习了 C 语法的实际工作原理，以及它如何在硬件上转换成位和字节。有了这些知识，我能够编写非常有效的小程序。然而，我仍然很难理解为什么更长的代码看起来像这样，而且我肯定不会想出以下的解决方案：

```cpp
typedef struct INTERNAL_DRIVER_STRUCT* DRIVER_HANDLE;
typedef void (*DriverSend_FP)(char byte);
typedef char (*DriverReceive_FP)();
typedef void (*DriverIOCTL_FP)(int ioctl, void* context);

struct DriverFunctions
{
  DriverSend_FP fpSend;
  DriverReceive_FP fpReceive;
  DriverIOCTL_FP fpIOCTL;
};

DRIVER_HANDLE driverCreate(void* initArg, struct DriverFunctions f);
void driverDestroy(DRIVER_HANDLE h);
void sendByte(DRIVER_HANDLE h, char byte);
char receiveByte(DRIVER_HANDLE h);
void driverIOCTL(DRIVER_HANDLE h, int ioctl, void* context);
```

查看这样的代码引发了许多问题：

+   为什么在`struct`中需要函数指针？

+   函数为什么需要那个`DRIVER_HANDLE`？

+   IOCTL 是什么，为什么我不能使用单独的函数来代替？

+   为什么需要显式的创建和销毁函数？

当我开始编写工业应用程序时，这些问题就出现了。我经常遇到这样的情况：我意识到我不具备如何在函数中实现迭代器或如何处理错误的 C 编程知识。我意识到，虽然我了解 C 语法，但我不知道如何应用它。我试图做些事情，但只是以笨拙的方式或根本不行。我需要的是关于如何用 C 编程语言实现特定任务的最佳实践。例如，我需要知道以下内容：

+   如何以简单的方式获取和释放资源？

+   对于错误处理，使用`goto`是个好主意吗？

+   我应该设计我的界面以便灵活应对，还是应该在需要时直接更改？

+   我应该使用`assert`语句，还是应该返回错误代码？

+   在 C 语言中，迭代器是如何实现的？

有趣的是，我意识到，虽然我的经验丰富的同事对这些问题有许多不同的答案，但没有人能指引我找到关于这些设计决策及其利弊的文件。

所以我转向互联网，再次感到惊讶：尽管 C 编程语言已经存在了几十年，但很难找到这些问题的正确答案。我发现，虽然有很多关于 C 编程语言基础和语法的文献，但在高级 C 编程主题或如何编写适合工业应用的优美 C 代码方面的内容并不多。

这本书就是起作用的地方。它教会你如何从编写基本的 C 程序进阶到编写考虑错误处理并对需求和设计变化灵活的大规模 C 程序。这本书使用设计模式的概念逐步为你提供设计决策及其利弊。这些设计模式应用于运行代码示例，教你类似之前示例代码如何演化，以及为何最终呈现如此形式。

展示的模式可以应用于任何 C 编程领域。由于我来自嵌入式编程多线程实时环境的领域，一些模式偏向于该领域。不过，你会看到这些模式的一般思想可以应用于其他 C 编程领域，甚至超出 C 编程的范围。

# 模式基础

本书提供的设计指导以模式的形式呈现。将知识和最佳实践以模式形式呈现的想法源自建筑师 Christopher Alexander 的作品*The Timeless Way of Building*（Oxford University Press，1979）。他使用经过验证的小片段解决他领域中的重大问题：如何设计和建造城市。这种应用模式的方法被软件开发领域采纳，其中模式会议如 Pattern Languages of Programs（PLoP）会议旨在扩展模式知识体系。特别是 Gang of Four 的书籍*Design Patterns: Elements of Reusable Object-Oriented Software*（Prentice Hall，1997）产生了重大影响，并使设计模式的概念为软件开发人员所熟知。

但是模式究竟是什么？有很多定义，如果你对此深感兴趣，那么 Frank Buschmann 等人的书籍*Pattern-Oriented Software Architecture: On Patterns and Pattern Languages*（Wiley，2007）可以为你提供准确的描述和细节。对于本书的目的而言，模式为实际问题提供了经过验证的解决方案。本书展示的模式具有表 P-1 所示的结构。

Table P-1\. 本书中模式的分解方式

| 模式部分 | 描述 |
| --- | --- |
| 名称 | 这是模式的名称，应易于记忆。目标是程序员在日常语言中使用这些名称（就像 Gang of Four 模式那样，程序员会说：“抽象工厂创建对象”）。本书中的模式名称均大写。 |
| 上下文 | 上下文部分为模式设定背景，告诉你在什么情况下可以应用该模式。 |
| 问题 | 问题部分提供了关于你想解决的问题的信息。它以粗体字体类型开始主要的问题陈述，然后添加关于为什么这个问题难以解决的详细信息。（在其他模式格式中，这些详细信息会放入一个名为“forces”的单独部分。） |
| 解决方案 | 本节提供了如何解决问题的指导。它以粗体字体类型陈述解决方案的主要思想，并继续详细说明解决方案。它还提供了一个代码示例，以便提供非常具体的指导。 |
| 后果 | 本节列出了应用所描述解决方案的利弊。在应用一个模式时，你应该确认由此产生的后果是否可以接受。 |
| 已知用途 | 已知用途为你提供了提议的解决方案是好的并且在实际应用中有效的证据。它们还向你展示了具体的例子，帮助你理解如何应用这个模式。 |

将设计指导以模式的形式呈现的一个主要好处是，这些模式可以依次应用。如果你有一个庞大的设计问题，很难找到一个能够解决这个问题的指导文件和一个解决方案。相反，你可以将你的庞大和非常具体的问题看作许多较小和更通用问题的总和，并且可以通过依次应用一个又一个模式逐步解决这些问题。你只需检查模式的问题描述，并应用适合你的问题并且你可以接受其后果的模式。这些后果可能会导致另一个问题，然后你可以通过应用另一个模式来解决它。这样，你就可以逐步设计你的代码，而不是在甚至写下第一行代码之前就想出一个完整的前期设计。

# 如何阅读本书

你应该已经了解 C 编程的基础知识。你应该知道 C 的语法及其工作原理——例如，这本书不会教你什么是指针或者如何使用它。本书提供了关于高级主题的提示和指导。

本书的各章节都是独立的。你可以按任意顺序阅读它们，可以简单地挑选你感兴趣的主题。你将在下一节找到所有模式的概述，然后可以跳转到你感兴趣的模式。因此，如果你确切地知道你在寻找什么，你可以从那里开始。

如果你不是在寻找一个特定的模式，而是想要了解可能的 C 设计选项的概述，请阅读本书的第一部分。那里的每一章都专注于特定主题，从错误处理和内存管理等基础主题开始，然后转向更高级和具体的主题，如接口设计或跨平台代码。每章节都介绍了与该主题相关的模式，并提供了一个运行的代码示例，逐步展示这些模式如何应用。

本书的 第二部分 展示了两个应用了 第一部分 中许多模式的较大运行示例。在这里，您可以学习如何通过模式的应用逐步构建一些较大的软件部件。

# 模式概览

你将在本书中介绍的所有模式概览都可以在表 P-2 到 P-10 中找到。这些表显示了模式的简短形式，仅包含核心问题的简要描述，后跟关键字“因此”，再后跟核心解决方案。

表 P-2\. 错误处理模式

| 模式名称 | 摘要 |
| --- | --- |
| “函数分割” | 函数具有多个责任，这使得函数难以阅读和维护。因此，将其拆分。将看似有用的函数部分单独提取出来，创建一个新函数，并调用该函数。 |
| “守卫条款” | 函数由于将前置条件检查与函数的主要程序逻辑混合在一起而难以阅读和维护。因此，检查是否具有强制性的前置条件，如果这些前置条件不满足，则立即从函数中返回。 |
| “武士原则” | 在返回错误信息时，您假设调用者会检查此信息。然而，调用者可以简单地忽略此检查，错误可能会被忽略。因此，要么从函数中胜利返回，要么干脆不返回。如果有一种情况，您知道无法处理错误，则中止程序。 |
| “Goto 错误处理” | 如果函数在不同位置获取和清理多个资源，则代码变得难以阅读和维护。因此，将所有资源清理和错误处理放在函数末尾。如果无法获取资源，则使用 `goto` 语句跳转到资源清理代码。 |
| “清理记录” | 如果代码获取并清理多个资源，特别是这些资源彼此依赖，那么要使代码易于阅读和维护是很困难的。因此，只要成功，调用资源获取函数，并存储哪些函数需要清理。根据这些存储的值调用清理函数。 |
| “基于对象的错误处理” | 一个函数具有多个责任，如资源获取、资源清理和资源使用，使得该代码难以实现、阅读、维护和测试。因此，将初始化和清理放入单独的函数中，类似于面向对象编程中构造函数和析构函数的概念。 |

表 P-3\. 返回错误信息的模式

| 模式名称 | 摘要 |
| --- | --- |
| “返回状态码” | 你需要一个机制来向调用者返回状态信息，以便调用者能够做出反应。你希望这个机制简单易用，并且调用者能够清楚地区分可能发生的不同错误情况。因此，使用函数的返回值来返回状态信息。返回一个代表特定状态的值。你和调用者必须对这个值的含义有共同的理解。 |
| “返回相关错误” | 一方面，调用者应该能够对错误做出反应；另一方面，你返回的错误信息越多，你和调用者的代码处理错误的负担就越重，这会使代码变得更长。长代码更难阅读和维护，并带来额外错误的风险。因此，只有当信息对调用者是相关的时，才向调用者返回错误信息。错误信息只有在调用者能够对其做出反应时才是相关的。 |
| “特殊返回值” | 你希望返回错误信息，但显式返回状态码并不是一个选项，因为这意味着你不能使用函数的返回值来返回其他数据。你必须通过输出参数返回这些数据，这会使调用函数更加困难。因此，使用函数的返回值来返回函数计算的数据。预留一个或多个特殊值在发生错误时返回。 |
| “记录错误” | 你希望在发生错误时能够轻松找出其原因。然而，你不希望因此使你的错误处理代码变得复杂。因此，使用不同的渠道提供对调用代码和开发者相关的错误信息。例如，将调试错误信息写入日志文件，而不将详细的调试错误信息返回给调用者。 |

表格 P-4\. 内存管理模式

| 模式名称 | 摘要 |
| --- | --- |
| “栈优先” | 决定变量的存储类别和内存部分（栈、堆等）是每个程序员经常要做的决定。如果每个变量都要详细考虑所有可能的替代方案的利弊，这将是很费力的。因此，默认情况下将变量放在栈上，以便从栈变量的自动清理中获益。 |
| “永久内存” | 持有大量数据并在函数调用之间传输数据很困难，因为必须确保数据的内存足够大且其生命周期跨越函数调用。因此，将数据放入整个程序生命周期都可用的内存中。 |
| “延迟清理” | 如果需要大量内存或者不知道所需大小的内存，则需要动态内存。然而，处理动态内存的清理是一件麻烦事，并且是许多编程错误的来源。因此，分配动态内存，并在程序结束时让操作系统处理释放。 |
| “专用所有权” | 使用动态内存的巨大力量伴随着要正确清理内存的重大责任。在较大的程序中，确保所有动态内存正确清理变得困难。因此，在实现内存分配时，清晰地定义和记录将要进行清理的位置及执行清理的对象。 |
| “分配包装器” | 每次动态内存分配可能会失败，因此应在代码中检查分配并做出相应反应。这很麻烦，因为您的代码中有许多这样的检查位置。因此，包装分配和释放调用，并在这些包装函数中实现错误处理或额外的内存管理组织。 |
| “指针检查” | 导致访问无效指针的编程错误会引发程序的不受控行为，此类错误难以调试。然而，因为您的代码频繁使用指针，存在引入此类编程错误的风险。因此，明确地使未初始化或已释放的指针无效，并始终在访问之前检查指针的有效性。 |
| “内存池” | 频繁地从堆中分配和释放对象会导致内存碎片化。因此，持有整个程序生命周期中的大块内存。在运行时，从该内存池中检索固定大小的块，而不是直接从堆中分配新内存。 |

表 P-5\. 从 C 函数返回数据的模式

| 模式名称 | 摘要 |
| --- | --- |
| “返回值” | 你希望分离的函数部分彼此不独立。与面向过程编程一样，一些部分产生的结果需要其他部分使用。你希望分离的函数部分需要共享一些数据。因此，简单地使用 C 语言机制来检索函数调用结果的信息：返回值。C 语言中返回数据的机制会复制函数结果，并提供调用者访问此副本的方式。 |
| “输出参数” | C 只支持从函数调用返回单一类型，这使得返回多个信息变得复杂。因此，通过使用指针模拟按引用参数传递的方式，在单个函数调用中返回所有数据。 |
| “聚合实例” | C 只支持从函数调用返回单一类型，这使得返回多个信息变得复杂。因此，将所有相关数据放入一个新定义的类型中。定义这个聚合实例来包含你想要分享的所有相关数据。在你组件的接口中定义它，让调用者直接访问实例中存储的所有数据。 |
| “不可变实例” | 你希望从组件向调用者提供大块不可变数据中包含的信息。因此，有一个实例（例如一个`struct`），包含要在静态内存中共享的数据。将这些数据提供给希望访问它的用户，并确保他们无法修改它。 |
| “调用者拥有的缓冲区” | 你希望向调用者提供复杂或大型数据（其大小已知），并且该数据不是不可变的（它在运行时会改变）。因此，要求调用者向返回大型复杂数据的函数提供缓冲区及其大小。在函数实现中，如果缓冲区大小足够大，将所需数据复制到缓冲区中。 |
| “被调用者分配” | 你希望向调用者提供复杂或大小未知的数据，并且该数据不是不可变的（它在运行时会改变）。因此，在提供大型复杂数据的函数内部分配一个具有所需大小的缓冲区。将所需数据复制到缓冲区中，并返回指向该缓冲区的指针。 |

Table P-6\. 数据生命周期和所有权的模式

| 模式名称 | 摘要 |
| --- | --- |
| “无状态软件模块” | 你希望向调用者提供逻辑相关的功能，并尽可能地简化调用者使用该功能。因此，保持函数简单，在实现中不要建立状态信息。将所有相关函数放入一个头文件中，并向调用者提供你软件模块的接口。 |
| “带全局状态的软件模块” | 您希望结构化逻辑相关代码，这些代码需要共享状态信息，并使调用者尽可能轻松地使用该功能。因此，使用一个全局实例让相关函数共享公共资源。将所有操作此实例的函数放入一个头文件中，并向调用者提供这个软件模块的接口。 |
| “调用者拥有实例” | 您希望提供多个调用者或线程访问依赖于彼此的功能，调用者与您的函数交互会构建状态信息。因此，要求调用者传递一个实例，用于存储资源和状态信息，并传递给您的函数。提供明确的函数来创建和销毁这些实例，以便调用者可以确定它们的生命周期。 |
| “共享实例” | 您希望提供多个调用者或线程访问依赖于彼此的功能，调用者与您的函数交互会构建状态信息，而调用者希望共享这些信息。因此，要求调用者传递一个实例，用于存储资源和状态信息，并传递给您的函数。在多个调用者之间使用相同的实例，并在您的软件模块中保持该实例的所有权。 |

表格 P-7\. 灵活 API 的模式

| 模式名称 | 摘要 |
| --- | --- |
| “头文件” | 您希望您实现的功能可以被其他实现文件中的代码访问，但希望隐藏调用者不应看到的实现细节。因此，在您的 API 中提供函数声明，为您希望向用户提供的任何功能提供接口。将任何内部函数、内部数据和函数定义（实现）隐藏在实现文件中，并不将此实现文件提供给用户。 |
| “句柄” | 您需要在函数实现中共享状态信息或操作共享资源，但不希望调用者看到或甚至访问所有这些状态信息和共享资源。因此，提供一个函数来创建调用者操作的上下文，并返回该上下文内部数据的抽象指针。要求调用者将该指针传递给所有您的函数，然后这些函数可以使用内部数据来存储状态信息和资源。 |
| “动态接口” | 应该能够调用具有略有不同行为的实现，但不应该需要复制任何代码，甚至是控制逻辑实现和接口声明。因此，在你的 API 中为这些有差异的功能定义一个通用接口，并要求调用者提供一个回调函数，然后在你的函数实现中调用这个回调函数。 |
| “函数控制” | 你希望调用具有略有不同行为的实现，但不想重复任何代码，甚至是控制逻辑实现或接口声明。因此，在你的函数中添加一个参数，传递关于函数调用的元信息，并指定要执行的实际功能。 |

表 P-8\. 灵活迭代器接口的模式

| 模式名称 | 概要 |
| --- | --- |
| “索引访问” | 你希望让用户以便捷的方式迭代你的数据结构中的元素，并且可以在内部更改数据结构而不需要更改用户代码。因此，提供一个函数，接受一个索引来访问底层数据结构中的元素，并返回此元素的内容。用户在循环中调用此函数来迭代所有元素。 |
| “游标迭代器” | 你希望为用户提供一个迭代接口，即使在迭代过程中元素发生变化也能保持稳健，并且在稍后可以更改底层数据结构而无需更改用户代码。因此，创建一个迭代器实例，指向底层数据结构中的一个元素。一个迭代函数以此迭代器实例作为参数，检索迭代器当前指向的元素，并修改迭代实例以指向下一个元素。然后用户迭代调用此函数以逐个检索元素。 |
| “回调迭代器” | 你希望提供一个稳健的迭代接口，用户不需要在代码中实现循环来迭代所有元素，并且在稍后可以更改底层数据结构而无需更改用户代码。因此，使用你现有的数据结构特定操作来在你的实现内部迭代所有元素，并在此迭代过程中调用一些提供的用户函数处理每个元素。这个用户函数以元素内容作为参数，然后可以对这个元素执行操作。用户只需调用一个函数来触发迭代，整个迭代过程在你的实现内部完成。 |

表 P-9\. 模块化程序中文件组织的模式

| 模式名称 | 摘要 |
| --- | --- |
| “包含保护” | 多次包含同一个头文件很容易，但如果其中包含类型或某些宏，则在编译时会导致重定义错误。因此，保护您的头文件内容免受多次包含的影响，以便使用头文件的开发人员不必关心它是否多次包含。使用交叉锁定的 `#ifdef` 语句或 `#pragma once` 语句来实现这一点。 |
| “软件模块目录” | 将代码分割为不同的文件会增加代码库中的文件数量。将所有文件放在一个目录中会使得在大型代码库中特别难以保持对所有文件的概览。因此，将属于紧密耦合功能的头文件和实现文件放入一个目录中。将该目录命名为通过头文件提供的功能的名称。 |
| “全局包含目录” | 要包含来自其他软件模块的文件，必须使用诸如 *../othersoftwaremodule/file.h* 的相对路径。您必须知道其他头文件的确切位置。因此，在代码库中有一个全局目录，其中包含所有软件模块的 API。将此目录添加到工具链中的全局包含路径中。 |
| “自包含组件” | 从目录结构中不可能看到代码的依赖关系。任何软件模块都可以简单地包含来自任何其他软件模块的头文件，因此无法通过编译器检查代码的依赖关系。因此，识别包含类似功能的软件模块，并应将这些软件模块放入一个共同的目录中，并为调用者相关的头文件指定一个指定的子目录。 |
| “API 复制” | 您希望独立开发、版本化和部署代码库的各个部分。但是，为了实现这一目标，您需要明确定义代码部分之间的接口，并能够将该代码分隔到不同的存储库中。因此，为了使用另一个组件的功能，复制其 API。分别构建该其他组件并复制构建产物及其公共头文件。将这些文件放入您的组件内的一个目录，并配置该目录为全局包含路径。 |

表 P-10\. 逃离 `#ifdef` 地狱的模式

| 模式名称 | 摘要 |
| --- | --- |
| “避免变体” | 在每个平台上使用不同的函数使得代码更难阅读和编写。程序员需要最初理解、正确使用和测试这些多个函数，以实现跨多个平台的单一功能。因此，请使用在所有平台上都可用的标准化函数。如果没有标准化函数，则考虑不实现该功能。 |
| “隔离原语” | 使用`#ifdef`语句组织的代码变体使得代码难以阅读。很难跟踪程序流程，因为为多个平台实现了多次。因此，请隔离您的代码变体。在实现文件中，将处理变体的代码放入单独的函数中，并从主程序逻辑中调用这些函数，这样主程序只包含平台无关的代码。 |
| “原子原语” | 包含变体并由主程序调用的函数仍然很难理解，因为所有复杂的`#ifdef`代码只是为了在主程序中摆脱它。因此，请使您的原语是原子的。每个函数仅处理一种变体。如果处理多种变体，例如操作系统变体和硬件变体，则为其使用单独的函数。 |
| “抽象层” | 您希望在代码库的多个位置使用处理平台变体的功能，但不希望复制该功能的代码。因此，请为每个需要平台特定代码的功能提供一个 API。在头文件中仅定义平台无关的函数，并将所有平台特定的`#ifdef`代码放入实现文件中。函数的调用者仅需包含您的头文件，而不必包含任何平台特定文件。 |
| “拆分变体实现” | 平台特定的实现仍然包含`#ifdef`语句，用于区分代码变体。这使得很难看到并选择应该为哪个平台构建哪部分代码。因此，将每个变体实现放入单独的实现文件中，并根据需要选择为哪个平台编译。 |

# 本书中使用的约定

本书使用以下排版约定：

*斜体*

表示新术语、网址、电子邮件地址、文件名和文件扩展名。

**粗体**

用于突出每种模式的问题和解决方案。

`等宽字体`

用于程序清单，以及段落中引用程序元素如变量或函数名、数据库、数据类型、环境变量、语句和关键字。

###### 注意

此元素表示一般注释。

###### 警告

此元素指示警告或注意事项。

# 使用代码示例

本书中的代码示例展示了重点在于展示模式及其应用的核心思想的短代码片段。这些代码片段本身不会编译，因为为了简化，省略了几个部分（例如，包含文件）。如果您有兴趣获取完全可编译的完整代码，可以从 GitHub 上下载，网址为[*https://github.com/christopher-preschern/fluent-c*](https://github.com/christopher-preschern/fluent-c)。

如果您在使用代码示例时有技术问题或疑问，请发送电子邮件至*bookquestions@oreilly.com*。

本书旨在帮助您完成工作。一般来说，如果本书提供了示例代码，您可以在您的程序和文档中使用它。除非您复制了大量代码，否则您无需联系我们请求许可。例如，编写一个使用本书中多个代码片段的程序不需要许可。销售或分发 O'Reilly 书籍中的示例代码需要许可。引用本书并引用示例代码回答问题不需要许可。将本书中大量示例代码整合到产品文档中需要许可。

我们感谢您的使用，但通常不需要署名。署名通常包括标题、作者、出版商和 ISBN。例如：“*Fluent C* by Christopher Preschern (O’Reilly). Copyright 2023 Christopher Preschern, 978-1-492-09733-4.”

如果您觉得您对代码示例的使用超出了合理使用范围或以上给出的许可，请随时与我们联系，电子邮件地址为*permissions@oreilly.com*。

本书中的模式均展示了应用这些模式的现有代码示例。以下列表显示了这些代码示例的引用：

+   [游戏 NetHack](https://oreil.ly/nzO5W)

+   [OpenWrt 项目](https://oreil.ly/qeppo)

+   [OpenSSL 库](https://oreil.ly/zzsMO)

+   [Wireshark 网络嗅探器](https://oreil.ly/M55B5)

+   [波特兰模式库](https://oreil.ly/wkZzb)

+   [Git 版本控制系统](https://oreil.ly/7F9Oz)

+   [Apache 可移植运行时](https://oreil.ly/ysaM6)

+   [Apache Web 服务器](https://oreil.ly/W6SMn)

+   B&R Automation Runtime 操作系统（B&R 工业自动化有限责任公司的专有和保密代码）

+   B&R Visual Components 自动化系统可视化编辑器（B&R 工业自动化有限责任公司的专有和保密代码）

+   [NetDRMS 数据管理系统](https://oreil.ly/eR0EV)

+   [MATLAB 编程和数值计算平台](https://oreil.ly/UpvJK)

+   [GLib 库](https://oreil.ly/QoUwT)

+   [GoAccess 实时 Web 分析器](https://oreil.ly/L1Eij)

+   [Cloudy 物理计算软件](https://oreil.ly/phLBb)

+   [GNU 编译器集合（GCC）](https://oreil.ly/KK4jY)

+   [MySQL 数据库系统](https://oreil.ly/YKXxs)

+   [Android ION 内存管理器](https://oreil.ly/2JV7h)

+   [Windows API](https://oreil.ly/nnzyX)

+   [Apple Cocoa API](https://oreil.ly/sQuaI)

+   [VxWorks 实时操作系统](https://oreil.ly/UMUaj)

+   [sam 文本编辑器](https://oreil.ly/k3SQI)

+   [C 标准库函数：glibc 实现](https://oreil.ly/9Qr95)

+   [Subversion 项目](https://oreil.ly/sg9sz)

+   [Netdata 实时性能监控和可视化系统](https://oreil.ly/1sDZz)

+   [Nmap 网络工具](https://oreil.ly/8Yz5R)

+   [OpenZFS 文件系统](https://oreil.ly/VWeQL)

+   [RIOT 操作系统](https://oreil.ly/LhZM4)

+   [Radare 逆向工程框架](https://oreil.ly/TUYfh)

+   [Education First 数字学习产品](https://www.ef.com)

+   [VIM 文本编辑器](https://github.com/vim/vim)

+   [GNUplot 绘图实用工具](https://oreil.ly/PlQPj)

+   [SQLite 数据库引擎](https://oreil.ly/5Knfz)

+   [gzip 数据压缩程序](https://oreil.ly/it40Z)

+   [lighttpd web 服务器](https://github.com/lighttpd)

+   [U-Boot 启动加载程序](https://oreil.ly/IKVYV)

+   [Smpl 离散事件模拟系统](https://oreil.ly/NJnCH)

+   [Nokia Maemo 平台](https://oreil.ly/RwDtt)

# O’Reilly 在线学习

###### 注意

超过 40 年来，[*O’Reilly Media*](https://oreilly.com)为企业的成功提供技术和业务培训、知识和见解。

我们独特的专家和创新者网络通过书籍、文章和我们的在线学习平台分享他们的知识和专长。O’Reilly 的在线学习平台为您提供按需访问的实时培训课程、深入学习路径、交互式编码环境以及来自 O’Reilly 和其他 200 多家出版商的大量文本和视频。欲了解更多信息，请访问[*https://oreilly.com*](https://oreilly.com)。

# 如何联系我们

请将有关本书的评论和问题发送至出版商：

+   O’Reilly Media, Inc.

+   1005 Gravenstein Highway North

+   Sebastopol, CA 95472

+   800-998-9938（美国或加拿大）

+   707-829-0515（国际或当地电话）

+   707-829-0104（传真）

我们有一个关于本书的网页，上面列出勘误、示例和任何额外信息。您可以访问[*https://oreil.ly/fluent-c*](https://oreil.ly/fluent-c)。

发送电子邮件至*bookquestions@oreilly.com*以评论或询问有关本书的技术问题。

欲了解有关我们图书和课程的新闻和信息，请访问[*https://oreilly.com*](https://oreilly.com)。

在 LinkedIn 上找到我们：[*https://linkedin.com/company/oreilly-media*](https://linkedin.com/company/oreilly-media)

在 Twitter 上关注我们：[*https://twitter.com/oreillymedia*](https://twitter.com/oreillymedia)

在 YouTube 上关注我们：[*https://www.youtube.com/oreillymedia*](https://www.youtube.com/oreillymedia)

# 致谢

我要感谢我的妻子 Silke，她现在甚至知道什么是模式 :-) 我也要感谢我的女儿 Ylvi。她们两个让我的生活更加幸福，也确保我不会整天坐在电脑前工作，而是享受生活。

这本书得益于许多模式爱好者的帮助而得以问世。我要感谢所有参与欧洲程序模式语言会议作家工作坊的参与者，他们为我的模式提供了反馈。特别感谢以下人员，在会议的指导过程中提供了非常有帮助的反馈：Jari Rauhamäki, Tobias Rauter, Andrea Höller, James Coplien, Uwe Zdun, Thomas Raser, Eden Burton, Claudius Link, Valentino Vranić, 和 Sumit Kalra。特别感谢我的工作同事，尤其是 Thomas Havlovec，他确保我在模式中正确理解了 C 编程的细节。Robert Hanmer, Michael Weiss, David Griffiths, 和 Thomas Krug 花了很多时间审查这本书，并为我提供了改进的额外想法——非常感谢！同时也感谢 O'Reilly 团队的所有成员，在这本书的问世过程中给予了我很多帮助。特别要感谢我的开发编辑 Corbin Collins 和制作编辑 Jonathon Owen。

本书的内容基于以下论文，这些论文在欧洲程序模式语言会议上被接受并由 ACM 出版。这些论文可以在网站[*http://www.preschern.com*](http://www.preschern.com)上免费获取。

+   “一个关于 C 编程的模式故事”，EuroPLoP ’21：程序模式语言欧洲会议第 26 届，2015 年 7 月，文章编号 53，1–10，[*https://dl.acm.org/doi/10.1145/3489449.3489978*](https://dl.acm.org/doi/10.1145/3489449.3489978)。

+   “模块化 C 程序中的文件组织模式”，EuroPLoP ’20：程序模式语言欧洲会议论文集，2020 年 7 月，文章编号 1，1–15，[*https://dl.acm.org/doi/10.1145/3424771.3424772*](https://dl.acm.org/doi/10.1145/3424771.3424772)。

+   “摆脱#ifdef 地狱的模式”，EuroPLoP ’19：程序模式语言欧洲会议第 24 届论文集，2019 年 7 月，文章编号 2，1–12，[*https://dl.acm.org/doi/10.1145/3361149.3361151*](https://dl.acm.org/doi/10.1145/3361149.3361151)。

+   “在 C 中返回错误信息的模式”，EuroPLoP ’19：程序模式语言欧洲会议第 24 届论文集，2019 年 7 月，文章编号 3，1–14，[*https://dl.acm.org/doi/10.1145/3361149.3361152*](https://dl.acm.org/doi/10.1145/3361149.3361152)。

+   “从 C 函数返回数据的模式”，EuroPLoP ’19：程序模式语言欧洲会议第 24 届论文集，2019 年 7 月，文章编号 37，1–13，[*https://dl.acm.org/doi/10.1145/3361149.3361188*](https://dl.acm.org/doi/10.1145/3361149.3361188)。

+   “C 中关于数据生命周期和所有权的模式”，EuroPLoP ’19：《程序模式的第 24 届欧洲会议论文集》，2019 年 7 月，文章编号 36，1–13，[*https://dl.acm.org/doi/10.1145/3361149.3361187*](https://dl.acm.org/doi/10.1145/3361149.3361187)。

+   “C 迭代器接口的模式”，EuroPLoP ’17：《程序模式的第 22 届欧洲会议论文集》，2017 年 7 月，文章编号 8，1–14，[*https://dl.acm.org/doi/10.1145/3147704.3147714*](https://dl.acm.org/doi/10.1145/3147704.3147714)。

+   “C 中的 API 模式”，EuroPlop ’16：《程序模式的第 21 届欧洲会议论文集》，2016 年 7 月，文章编号 7，1–11，[*https://dl.acm.org/doi/10.1145/3011784.3011791*](https://dl.acm.org/doi/10.1145/3011784.3011791)。

+   “C 中的错误处理惯用语”，EuroPLoP ’15：《程序模式的第 20 届欧洲会议论文集》，2015 年 7 月，文章编号 53，1–10，[*https://dl.acm.org/doi/10.1145/2855321.2855377*](https://dl.acm.org/doi/10.1145/2855321.2855377)。
